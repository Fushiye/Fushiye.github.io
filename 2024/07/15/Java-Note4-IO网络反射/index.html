<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_apple-touch-icon-human.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_human_32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_human_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fushiye.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism-darcula","dark":"prism-darcula"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"giscus","storage":true,"lazyload":false,"nav":null,"activeClass":"giscus"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":3,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="java流操作、网络编程和反射机制学习过程中记录的笔记，仅供参考，如有错漏，敬请指正!">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-Note4-IO网络反射">
<meta property="og:url" content="https://fushiye.github.io/2024/07/15/Java-Note4-IO%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%B0%84/index.html">
<meta property="og:site_name" content="星海拾贝">
<meta property="og:description" content="java流操作、网络编程和反射机制学习过程中记录的笔记，仅供参考，如有错漏，敬请指正!">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719224715.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719224617.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719173502.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719231301.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240721113125.png">
<meta property="og:image" content="https://fushiye.github.io/images/image-20220415013546074.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240721225138.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240721230428.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240722151909.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240722160449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240722160706.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240722161041.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727173149.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727184143.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185259.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185358.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185434.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185543.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185608.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240728172455.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240728173753.png">
<meta property="article:published_time" content="2024-07-15T02:46:04.000Z">
<meta property="article:modified_time" content="2025-03-02T09:28:18.706Z">
<meta property="article:author" content="Shearington">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719224715.png">


<link rel="canonical" href="https://fushiye.github.io/2024/07/15/Java-Note4-IO%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%B0%84/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://fushiye.github.io/2024/07/15/Java-Note4-IO%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%B0%84/","path":"2024/07/15/Java-Note4-IO网络反射/","title":"Java-Note4-IO网络反射"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java-Note4-IO网络反射 | 星海拾贝</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">星海拾贝</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探索永无止境</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#file%E7%B1%BB%E5%92%8Cio%E6%B5%81-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6-jdk8-17%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">file类和io流 网络编程 反射机制 jdk8-17新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC15%E7%AB%A0-File%E7%B1%BB%E4%B8%8EIO%E6%B5%81"><span class="nav-number">1.1.</span> <span class="nav-text">第15章_File类与IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.1.</span> <span class="nav-text">File类的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.2.</span> <span class="nav-text">IO流概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81-Reader-Writer"><span class="nav-number">1.1.3.</span> <span class="nav-text">字符输入输出流 Reader &amp;&amp; Writer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileReader"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">FileReader</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileWriter"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">FileWriter</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81-InputStream-OutputStream"><span class="nav-number">1.1.4.</span> <span class="nav-text">字节输入输出流 InputStream &amp; OutputStream</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileInputStream"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">FileInputStream</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#FileOutputStream"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">FileOutputStream</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%B5%81"><span class="nav-number">1.1.5.</span> <span class="nav-text">处理流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">缓冲流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">转换流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">对象流（重点）和数据流（了解）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%EF%BC%9ADataOutputStream%E3%80%81DataInputStream"><span class="nav-number">1.1.5.3.1.</span> <span class="nav-text">数据流：DataOutputStream、DataInputStream</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81%EF%BC%9AObjectOutputStream%E3%80%81ObjectInputStream"><span class="nav-number">1.1.5.3.2.</span> <span class="nav-text">对象流：ObjectOutputStream、ObjectInputStream</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.1.5.3.3.</span> <span class="nav-text">序列化和反序列化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%B5%81"><span class="nav-number">1.1.6.</span> <span class="nav-text">其他流</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">1.1.6.0.1.</span> <span class="nav-text">标准输入、输出流</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">打印流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Scanner%E7%B1%BB"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">Scanner类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#apache-common%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">apache-common包的使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC16%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">第16章_网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#InetAddress"><span class="nav-number">1.2.1.</span> <span class="nav-text">InetAddress</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89TCP-Socket-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">（重点）TCP Socket 网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ServerSocket%E7%B1%BB"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">ServerSocket类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#socket%E7%B1%BB"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">socket类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">通信示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89UDP-Socket-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">（了解）UDP Socket 网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#DatagramSocket%E7%B1%BB"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">DatagramSocket类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#DatagramPacket%E7%B1%BB"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">DatagramPacket类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B-1"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">通信示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89URL"><span class="nav-number">1.2.4.</span> <span class="nav-text">（重点）URL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#URLConnection%E7%B1%BB"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">URLConnection类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E8%80%85%E6%80%BB%E7%BB%93"><span class="nav-number">1.2.5.</span> <span class="nav-text">三者总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC17%E7%AB%A0-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">第17章_反射机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E6%BA%90%E5%A4%B4-Class%E7%B1%BB"><span class="nav-number">1.3.1.</span> <span class="nav-text">反射的源头-Class类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">类的加载器和加载过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.3.3.</span> <span class="nav-text">反射的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A81%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">应用1：创建运行时类的对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-%E5%BA%94%E7%94%A82%EF%BC%9A%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">(了解)应用2：获取运行时类的完整结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%8C%E6%8F%A1-%E5%BA%94%E7%94%A83%EF%BC%9A%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">(掌握)应用3：调用运行时类的指定结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-%E5%BA%94%E7%94%A84-%E8%AF%BB%E5%8F%96%E6%B3%A8%E8%A7%A3%E4%BF%A1%E6%81%AF"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">(了解)应用4 读取注解信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E8%A6%81-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">(重要)反射的动态性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%AF%BB%E5%8F%96%E7%AE%80%E4%BB%8B"><span class="nav-number">1.3.3.6.</span> <span class="nav-text">配置文件的设置和读取简介</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC18%E7%AB%A0-JDK8-17%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.4.</span> <span class="nav-text">第18章_JDK8-17新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Jdk8-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">Jdk8:Lambda表达式和方法引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Lambda表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E3%80%81%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8%E3%80%81%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">方法引用、构造器引用、数组引用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk8-Stream-API-%E7%94%A8%E4%BA%8E%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.2.</span> <span class="nav-text">jdk8: Stream API(用于集合操作)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-Stream-%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">创建 Stream 的三种方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Stream%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">Stream中间操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Stream%E7%BB%88%E6%AD%A2%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">Stream终止操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk9-17-%E8%AF%AD%E6%B3%95%E6%96%B0%E7%BB%93%E6%9E%84"><span class="nav-number">1.4.3.</span> <span class="nav-text">jdk9-17 语法新结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK9%EF%BC%9AJava%E7%9A%84REPL%E5%B7%A5%E5%85%B7%EF%BC%9A-jShell%E5%91%BD%E4%BB%A4"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">JDK9：Java的REPL工具： jShell命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk7-jdk9-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">jdk7 &amp; jdk9 异常处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk10-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD-var%E7%B1%BB%E5%9E%8B%E5%90%8D"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">jdk10 局部变量类型推断 var类型名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk14-16-instanceof%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">jdk14(16) instanceof的模式匹配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk-12-13-14-17-switch%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">jdk 12,13,14 17 switch表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk13-14-15-%E6%96%87%E6%9C%AC%E5%9D%97"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">jdk13,14,15 文本块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk14-15-16-record%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.4.3.7.</span> <span class="nav-text">jdk14,15,16 record数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk15-16-17-%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="nav-number">1.4.3.8.</span> <span class="nav-text">jdk15,16,17 密封类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk9-17-API"><span class="nav-number">1.4.4.</span> <span class="nav-text">jdk9-17 API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk8-Optional%E7%B1%BB"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">jdk8 Optional类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk9-%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89String%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%92%8CAPI%E5%8F%98%E6%9B%B4"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">jdk9+（了解）String存储结构和API变更</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK17-%E6%A0%87%E8%AE%B0%E5%88%A0%E9%99%A4Applet-API"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">JDK17 标记删除Applet API</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E5%AE%83%E7%BB%93%E6%9E%84%E5%8F%98%E5%8C%96"><span class="nav-number">1.4.5.</span> <span class="nav-text">其它结构变化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK9%EF%BC%9AUnderScore-%E4%B8%8B%E5%88%92%E7%BA%BF-%E4%BD%BF%E7%94%A8%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">JDK9：UnderScore(下划线)使用的限制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK11%EF%BC%9A%E6%9B%B4%E7%AE%80%E5%8C%96%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">JDK11：更简化的编译运行程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GC%E6%96%B9%E9%9D%A2%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.4.5.3.</span> <span class="nav-text">GC方面新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#G1-GC"><span class="nav-number">1.4.5.3.1.</span> <span class="nav-text">G1 GC</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Shenandoah-GC"><span class="nav-number">1.4.5.3.2.</span> <span class="nav-text">Shenandoah GC</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%9D%A9%E5%91%BD%E6%80%A7%E7%9A%84-ZGC"><span class="nav-number">1.4.5.3.3.</span> <span class="nav-text">革命性的 ZGC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B"><span class="nav-number">1.4.6.</span> <span class="nav-text">小结与展望</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shearington"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Shearington</p>
  <div class="site-description" itemprop="description">诗酒趁年华</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Fushiye/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Fushiye&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shearington@foxmail.com" title="E-Mail → mailto:shearington@foxmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fushiye.github.io/2024/07/15/Java-Note4-IO%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Shearington">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星海拾贝">
      <meta itemprop="description" content="诗酒趁年华">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java-Note4-IO网络反射 | 星海拾贝">
      <meta itemprop="description" content="java流操作、网络编程和反射机制学习过程中记录的笔记，仅供参考，如有错漏，敬请指正!">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java-Note4-IO网络反射
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-15 10:46:04" itemprop="dateCreated datePublished" datetime="2024-07-15T10:46:04+08:00">2024-07-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-02 17:28:18" itemprop="dateModified" datetime="2025-03-02T17:28:18+08:00">2025-03-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>28k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:33</span>
    </span>
</div>

            <div class="post-description">java流操作、网络编程和反射机制学习过程中记录的笔记，仅供参考，如有错漏，敬请指正!</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>file类和io流 网络编程 反射机制 jdk8-17新特性</p>
<span id="more"></span>

<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1PY411e7J6/?p=15&spm_id_from=pageDriver&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-java基础教程</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-tutorial.html">菜鸟教程-java</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/index.html">Java API 参考文档</a><br>参考书籍:《java核心技术》《Effective Java》 《java编程思想》</p>
<hr>
<h2 id="file类和io流-网络编程-反射机制-jdk8-17新特性"><a href="#file类和io流-网络编程-反射机制-jdk8-17新特性" class="headerlink" title="file类和io流 网络编程 反射机制 jdk8-17新特性"></a>file类和io流 网络编程 反射机制 jdk8-17新特性</h2><h3 id="第15章-File类与IO流"><a href="#第15章-File类与IO流" class="headerlink" title="第15章_File类与IO流"></a>第15章_File类与IO流</h3><p>本章中涉及的相关流均在java.io包下</p>
<h4 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a>File类的使用</h4><ul>
<li>一个File对象代表硬盘或网络中可能存在的一个文件或者文件目录（俗称文件夹），与平台无关。（体会万事万物皆对象）</li>
<li>File 能新建、删除、重命名文件和目录，但 File <strong>不能访问文件内容本身</strong>。如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。</li>
<li>File对象可以作为参数传递给流的构造器。</li>
<li>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</li>
</ul>
<p><strong>构造器</strong></p>
<ul>
<li><code>public File(String pathname) </code> ：以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。</li>
<li><code>public File(String parent, String child) </code> ：以parent为父路径，child为子路径创建File对象。</li>
<li><code>public File(File parent, String child)</code> ：根据一个父File对象和子文件路径创建File对象</li>
</ul>
<p>关于路径：</p>
<ul>
<li><strong>绝对路径：</strong>从盘符开始的路径，这是一个完整的路径。</li>
<li><strong>相对路径：</strong>相对于<code>项目目录</code>的路径，这是一个便捷的路径，开发中经常使用。<ul>
<li>IDEA中，main中的文件的相对路径，是相对于”<code>当前工程</code>“</li>
<li>IDEA中，单元测试方法中的文件的相对路径，是相对于”<code>当前module</code>“</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器1</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test&quot;</span>); <span class="comment">// 文件目录对象，采用相对路径</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/test\\a.txt&quot;</span>); <span class="comment">//有后缀名，为文件，绝对路径</span></span><br><span class="line"><span class="comment">// 构造器2</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/test&quot;</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/test&quot;</span>,<span class="string">&quot;a.txt&quot;</span>);<span class="comment">//第一个参数必须是文件目录，第二个可以是文件目录或文件</span></span><br><span class="line"><span class="comment">// 构造器3</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file,<span class="string">&quot;a.txt&quot;</span>);<span class="comment">//第一个参数必须是文件目录，第二个可以是文件目录或文件</span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>无论该路径下是否存在文件或者目录，都不影响File对象的创建。</li>
<li>window的路径分隔符使用“\”，而Java程序中的“\”表示转义字符，所以在Windows中表示路径，需要用“\”。或者直接使用“&#x2F;”也可以，Java程序支持将“&#x2F;”当成平台无关的<code>路径分隔符</code>。或者直接使用File.separator常量值表示。比如：<br>File file2 &#x3D; new File(“d:” + File.separator + “atguigu” + File.separator + “info.txt”);</li>
<li>当构造路径是绝对路径时，那么getPath和getAbsolutePath结果一样<br>当构造路径是相对路径时，那么getAbsolutePath的路径 &#x3D; user.dir的路径 + 构造路径</li>
</ol>
<p><strong>常用方法</strong></p>
<ol>
<li>获取文件和目录基本信息<ul>
<li>public String getName() ：获取名称</li>
<li>public String getPath() ：获取路径</li>
<li><code>public String getAbsolutePath()</code>：获取绝对路径</li>
<li>public File getAbsoluteFile()：获取绝对路径表示的文件</li>
<li><code>public String getParent()</code>：获取上层文件目录路径。若无，返回null</li>
<li>public long length() ：获取文件长度（即：字节数）。<em>不能获取目录的长度</em>。</li>
<li>public long lastModified() ：获取最后一次的修改时间，毫秒值</li>
</ul>
</li>
<li>列出目录的下一级<ul>
<li>public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。</li>
<li>public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。</li>
</ul>
</li>
<li>File类的重命名功能<ul>
<li>public boolean renameTo(File dest):把文件重命名为指定的文件路径。<br>调用的File对象对应文件必须存在且重命名的文件路径不存在文件</li>
</ul>
</li>
<li>判断功能的方法<ul>
<li><code>public boolean exists()</code> ：此File表示的文件或目录是否实际存在。</li>
<li><code>public boolean isDirectory()</code> ：此File表示的是否为目录。</li>
<li><code>public boolean isFile()</code> ：此File表示的是否为文件。</li>
<li>public boolean canRead() ：判断是否可读</li>
<li>public boolean canWrite() ：判断是否可写</li>
<li>public boolean isHidden() ：判断是否隐藏</li>
</ul>
</li>
<li>创建、删除功能<ul>
<li><code>public boolean createNewFile()</code> ：创建文件。若文件存在，则不创建，返回false。</li>
<li><code>public boolean mkdir()</code> ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</li>
<li><code>public boolean mkdirs()</code> ：创建文件目录。如果上层文件目录不存在，一并创建。</li>
<li><code>public boolean delete()</code> ：删除文件或者文件夹<br>删除注意事项：① Java中的删除不走回收站。② 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。</li>
</ul>
</li>
</ol>
<h4 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h4><p>Java程序中，对于数据的输入&#x2F;输出操作以“<code>流(stream)</code>” 的方式进行，可以看做是一种数据的流动。<br>I&#x2F;O流中的I&#x2F;O是<code>Input/Output</code>的缩写， I&#x2F;O技术是非常实用的技术，用于处理设备之间的数据传输。如读&#x2F;写文件，网络通讯等。</p>
<ul>
<li><code>输入input</code>：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li>
<li><code>输出output</code>：将程序（内存）数据输出到磁盘、光盘等存储设备中。</li>
</ul>
<p><strong>流的分类</strong><br><code>java.io</code>包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过<code>标准的方法</code>输入或输出数据。</p>
<ul>
<li>按数据的流向不同分为：<strong>输入流</strong>和<strong>输出流</strong>。<ul>
<li><strong>输入流</strong> ：把数据从<code>其他设备</code>上读取到<code>内存</code>中的流。 <ul>
<li>以InputStream、Reader结尾</li>
</ul>
</li>
<li><strong>输出流</strong> ：把数据从<code>内存</code> 中写出到<code>其他设备</code>上的流。<ul>
<li>以OutputStream、Writer结尾</li>
</ul>
</li>
</ul>
</li>
<li>按操作数据单位的不同分为：<strong>字节流（8bit）</strong>和<strong>字符流（16bit）</strong>。<ul>
<li><strong>字节流</strong> ：以字节为单位，读写数据的流。<ul>
<li>以InputStream、OutputStream结尾</li>
</ul>
</li>
<li><strong>字符流</strong> ：以字符为单位，读写数据的流。<ul>
<li>以Reader、Writer结尾</li>
</ul>
</li>
</ul>
</li>
<li>根据IO流的角色不同分为：<strong>节点流</strong>和<strong>处理流</strong>。<ul>
<li><strong>节点流</strong>：直接从数据源或目的地读写数据<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719224715.png" alt="节点流"></li>
<li><strong>处理流</strong>：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719224617.png" alt="处理流"></li>
</ul>
</li>
</ul>
<p><strong>流的API</strong></p>
<ul>
<li>Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。<table>
<thead>
<tr>
<th>（抽象基类）</th>
<th>输入流</th>
<th>输出流</th>
</tr>
</thead>
<tbody><tr>
<td>字节流</td>
<td>InputStream</td>
<td>OutputStream</td>
</tr>
<tr>
<td>字符流</td>
<td>Reader</td>
<td>Writer</td>
</tr>
</tbody></table>
</li>
<li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719173502.png" alt="IO流"></li>
</ul>
<p><strong>常用的节点流：</strong> 　</p>
<ul>
<li>文件流： FileInputStream、FileOutputStrean、FileReader、FileWriter </li>
<li>字节&#x2F;字符数组流： ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter <ul>
<li>对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。</li>
</ul>
</li>
</ul>
<p><strong>常用处理流：</strong></p>
<ul>
<li>缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter<ul>
<li>作用：增加缓冲功能，避免频繁读写硬盘，进而提升读写效率。</li>
</ul>
</li>
<li>转换流：InputStreamReader、OutputStreamReader<ul>
<li>作用：实现字节流和字符流之间的转换。</li>
</ul>
</li>
<li>对象流：ObjectInputStream、ObjectOutputStream<ul>
<li>作用：提供直接读写Java对象功能</li>
</ul>
</li>
</ul>
<h4 id="字符输入输出流-Reader-Writer"><a href="#字符输入输出流-Reader-Writer" class="headerlink" title="字符输入输出流 Reader &amp;&amp; Writer"></a>字符输入输出流 Reader &amp;&amp; Writer</h4><p>Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。不能操作图片，视频等非文本文件。<br>常见的文本文件有如下的格式：.txt、.java、.c、.cpp、.py等<br>注意：.doc、.xls、.ppt这些都不是文本文件。</p>
<p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的父类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<p><strong>Reader方法</strong></p>
<ul>
<li><code>public int read()</code>： 从输入流读取一个字符。 虽然读取了一个字符，但是会自动提升为int类型。返回该字符的Unicode编码值。如果已经到达流末尾了，则返回-1。</li>
<li><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。每次最多读取cbuf.length个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回-1。 </li>
<li><code>public int read(char[] cbuf,int off,int len)</code>：从输入流中读取一些字符，并将它们存储到字符数组 cbuf中，从cbuf[off]开始的位置存储。每次最多读取len个字符。返回实际读取的字符个数。如果已经到达流末尾，没有数据可读，则返回-1。 </li>
<li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。<br> 注意：当完成流的操作时，必须调用close()方法，释放系统资源，否则会造成内存泄漏。</li>
</ul>
<p><code>java.io.Writer </code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<p><strong>Writer方法</strong></p>
<ul>
<li><code>public void write(int c)</code> ：写出单个字符。</li>
<li><code>public void write(char[] cbuf) </code>：写出字符数组。 </li>
<li><code>public void write(char[] cbuf, int off, int len) </code>：写出字符数组的某一部分。off：数组的开始索引；len：写出的字符个数。 </li>
<li><code>public void write(String str) </code>：写出字符串。 </li>
<li><code>public void write(String str, int off, int len)</code> ：写出字符串的某一部分。off：字符串的开始索引；len：写出的字符个数。</li>
<li><code>public void flush() </code>：刷新该流的缓冲。  </li>
<li><code>public void close()</code> ：关闭此流。<br> 注意：当完成流的操作时，必须调用close()方法，释放系统资源，否则会造成内存泄漏。</li>
</ul>
<p>因为内置缓冲区的原因，如果FileWriter不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush()</code> 方法了。</p>
<ul>
<li><code>flush()</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close() </code>：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。<br>注意：即便是flush()方法写出了数据，操作的最后还是要调用close方法，释放系统资源。<blockquote>
<p>在向文件写入数据时，如果不调用 flush()，数据可能会暂时留在内存中的缓冲区里，直到缓冲区满了或者流被关闭时才真正写入文件。这在某些需要即时写入数据的场景下是不可接受的，因此可以通过调用 flush() 方法来强制将缓冲区中的数据写出。</p>
</blockquote>
</li>
</ul>
<h5 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h5><p><code>java.io.FileReader </code>类用于读取字符文件，构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<p><strong>构造器</strong></p>
<ul>
<li><code>FileReader(File file)</code>： 创建一个新的 FileReader ，给定要读取的File对象。   </li>
<li><code>FileReader(String fileName)</code>： 创建一个新的 FileReader ，给定要读取的文件的名称。</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fileReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建File类对象，对应文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\test\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2 创建输入型字符流，用于读取数据</span></span><br><span class="line">        fileReader = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="comment">//3 读取数据，显示在控制台</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fileReader.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>)data);</span><br><span class="line">            data= fileReader.read();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等价</span></span><br><span class="line">        <span class="comment">// int data;</span></span><br><span class="line">        <span class="comment">// while(data  = fileReader.read() != -1)&#123;</span></span><br><span class="line">        <span class="comment">//     System.out.println((char)data);</span></span><br><span class="line">        <span class="comment">//     data= fileReader.read();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 使用read(char[] cbuf) 加快速度</span></span><br><span class="line">        <span class="comment">// char[] cbuffer = new char[5];</span></span><br><span class="line">        <span class="comment">// int len</span></span><br><span class="line">        <span class="comment">// while((len = fr.read(cbuffer))!=-1)&#123;</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;len;i++&#123;System.out.println(cbuffer[i]);&#125;)</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fileReader!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//4 流资源的关闭！！必须关闭，否则可能导致内存泄漏</span></span><br><span class="line">                fileReader.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h5><p><code>java.io.FileWriter </code>类用于写出字符到文件，构造时使用系统默认的字符编码和默认字节缓冲区。</p>
<p><strong>构造器</strong></p>
<ul>
<li><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。   </li>
<li><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。  </li>
<li><code>FileWriter(File file,boolean append)</code>： 创建一个新的 FileWriter，指明是否在现有文件末尾追加内容。</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建File类对象，对应文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\test\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2 创建输出型字符流，用于输出数据，覆盖写入</span></span><br><span class="line">        <span class="comment">//fileWriter = new FileWriter(file);</span></span><br><span class="line">        <span class="comment">//追加写入</span></span><br><span class="line">        fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 输出数据</span></span><br><span class="line">        fileWriter.write(<span class="string">&quot;I an Tom&quot;</span>);</span><br><span class="line">        fileWriter.write(<span class="string">&quot;我是汤姆猫&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fileWriter!=<span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//4 流资源的关闭！！必须关闭，否则可能导致内存泄漏</span></span><br><span class="line">                fileWriter.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong> </p>
<ol>
<li>因为出现流资源的调用，为了避免内存泄漏，需要使用try-catch-finally处理异常</li>
<li><ul>
<li>对于输入流来说，File类的对象必须在物理磁盘上存在，否则执行就会报FileNotFoundException。如果传入的是一个目录，则会报IOException异常。</li>
<li>对于输出流来说，File类的对象是可以不存在的。<blockquote>
<p>如果File类的对象不存在，则可以在输出的过程中，自动创建File类的对象<br>如果File类的对象存在，<br>如果调用FileWriter(File file)或FileWriter(File file,false)，输出时会新建File文件覆盖已有的文件<br>如果调用FileWriter(File file,true)构造器，则在现有的文件末尾追加写出内容。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="字节输入输出流-InputStream-OutputStream"><a href="#字节输入输出流-InputStream-OutputStream" class="headerlink" title="字节输入输出流 InputStream &amp; OutputStream"></a>字节输入输出流 InputStream &amp; OutputStream</h4><p>读取或写出的数据是非文本文件，必须使用字节流;字节流也可以处理文本文件<br>exp: .doc .xls .jpg .pdf .mp3 .mp4 .avi</p>
<p><strong>字节输入流：InputStream</strong><br><code>java.io.InputStream </code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<ul>
<li><code>public int read()</code>： 从输入流读取一个字节。返回读取的字节值。虽然读取了一个字节，但是会自动提升为int类型。如果已经到达流末尾，没有数据可读，则返回-1。 </li>
<li><code>public int read(byte[] b)</code>： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。每次最多读取b.length个字节。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回-1。 </li>
<li><code>public int read(byte[] b,int off,int len)</code>：从输入流中读取一些字节数，并将它们存储到字节数组 b中，从b[off]开始存储，每次最多读取len个字节 。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回-1。 </li>
<li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。<br> 说明：close()方法，当完成流的操作时，必须调用此方法，释放系统资源。</li>
</ul>
<p><strong>字节输出流：OutputStream</strong><br><code>java.io.OutputStream </code>抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<ul>
<li><code>public void write(int b)</code> ：将指定的字节输出流。虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。</li>
<li><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。  </li>
<li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  </li>
<li><code>public void flush() </code> ：刷新此输出流并强制任何缓冲的输出字节被写出。  </li>
<li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。<br> 说明：close()方法，当完成流的操作时，必须调用此方法，释放系统资源。</li>
</ul>
<p>因为内置缓冲区的原因，如果FileWriter不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要<code>flush()</code> 方法了。</p>
<ul>
<li><code>flush()</code> ：刷新缓冲区，流对象可以继续使用。</li>
<li><code>close() </code>：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。<br>注意：即便是flush()方法写出了数据，操作的最后还是要调用close方法，释放系统资源。<blockquote>
<p>在向文件写入数据时，如果不调用 flush()，数据可能会暂时留在内存中的缓冲区里，直到缓冲区满了或者流被关闭时才真正写入文件。这在某些需要即时写入数据的场景下是不可接受的，因此可以通过调用 flush() 方法来强制将缓冲区中的数据写出。</p>
</blockquote>
</li>
</ul>
<h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><p><code>java.io.FileInputStream </code>类是文件输入流，从文件中读取字节。</p>
<ul>
<li><code>FileInputStream(File file)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 </li>
<li><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</li>
</ul>
<h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><p><code>java.io.FileOutputStream </code>类是文件输出流，用于将数据写出到文件。</p>
<ul>
<li><code>public FileOutputStream(File file)</code>：创建文件输出流，写出由指定的 File对象表示的文件。 </li>
<li><code>public FileOutputStream(String name)</code>： 创建文件输出流，指定的名称为写出文件。</li>
<li><code>public FileOutputStream(File file, boolean append)</code>：  创建文件输出流，指明是否在现有文件末尾追加内容。</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建相关的File类对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\1 (1).jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">desFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\1.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 创建相关的字节流</span></span><br><span class="line">        fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(desFile, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 数据的读写</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fileInputStream.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fileOutputStream.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4 关闭流资源</span></span><br><span class="line">            fileInputStream.close();</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ol>
<li>同Reader和Writer的注意点</li>
<li>字符流只能用于处理文本文件，不能处理非文本文件<br>字节流通常用于处理非文本文件，但若涉及文本文件的复制操作也可以使用字节流，但建议使用字符流</li>
</ol>
<h4 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h4><p><strong>！！使用处理流时必须在有节点流的基础上！！</strong></p>
<h5 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h5><p><code>为了提高数据读写的速度</code>，Java API提供了带缓冲功能的流类：缓冲流。</p>
<p>缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：</p>
<ul>
<li><strong>字节缓冲流</strong>：<code>BufferedInputStream</code>，<code>BufferedOutputStream</code> </li>
<li><strong>字符缓冲流</strong>：<code>BufferedReader</code>，<code>BufferedWriter</code><br>缓冲流的基本原理：在创建流对象时，内部会创建一个缓冲区数组（缺省使用<code>8192个字节(8Kb)</code>的缓冲区），通过缓冲区读写，减少系统IO次数，从而提高读写的效率。</li>
</ul>
<p><strong>字符缓冲流</strong></p>
<p><strong>构造器</strong></p>
<ul>
<li><code>public BufferedInputStream(InputStream in)</code> ：创建一个 新的字节型的缓冲输入流。 </li>
<li><code>public BufferedOutputStream(OutputStream out)</code>： 创建一个新的字节型的缓冲输出流。</li>
</ul>
<p><strong>特有方法</strong><br>字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。</p>
<ul>
<li>BufferedReader：<code>public String readLine()</code>: 读一行文字，不包括换行符，若返回null表示结束。 </li>
<li>BufferedWriter：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。</li>
</ul>
<p><strong>字节缓冲流</strong></p>
<p><strong>构造器</strong></p>
<ul>
<li><code>public BufferedReader(Reader in)</code> ：创建一个新的字符型的缓冲输入流。 </li>
<li><code>public BufferedWriter(Writer out)</code>： 创建一个新的字符型的缓冲输出流。</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bIS</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bOS</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1 创建相关的File类对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\1 (1).jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">desFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\1-1.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 创建相应的字节流、处理流</span></span><br><span class="line">        fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(desFile, <span class="literal">true</span>);</span><br><span class="line">        bIS = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fileInputStream);</span><br><span class="line">        bOS = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fileOutputStream);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 数据的读写-使用处理流而非节点流读写</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];<span class="comment">// 选择适当大小的缓冲区可以减少内存读写耗时</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bIS.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bOS.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//4 关闭流资源 先关外层后关内层，但关闭外层流可以自动关闭内层流，故</span></span><br><span class="line">            bIS.close();</span><br><span class="line">            bOS.close();</span><br><span class="line">            <span class="comment">//fileInputStream.close();省略</span></span><br><span class="line">            <span class="comment">//fileOutputStream.close();省略</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h5><p><strong>作用：转换流是字节与字符间的桥梁！</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719231301.png" alt="转换流的作用"></p>
<p>InputStreamReader：将一个输入型的字节流转为字符流<br>OutputStreamWriter：将一个输出型的字节流转为字符流</p>
<p><strong>InputStreamReader</strong> </p>
<p>转换流<code>java.io.InputStreamReader</code>，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<p><strong>构造器</strong></p>
<ul>
<li><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p><strong>OutputStreamWriter</strong></p>
<p>转换流<code>java.io.OutputStreamWriter</code> ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 </p>
<p><strong>构造器</strong></p>
<ul>
<li><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 </li>
<li><code>OutputStreamWriter(OutputStream in,String charsetName)</code>: 创建一个指定字符集的字符流。</li>
</ul>
<p><strong>字符集</strong></p>
<p>一个char占两个字节，是指在内存中占2个字节，采用的是Unicode字符集<br>gbk中一个汉字占2字节，utf-8中一个汉字占3字节，指的是文件存储中<br>因为char中无论用多少位表示的字符（汉字，英文字母）都占2字节，gbk等字符集中占用的字节数不一定（英文字母1B）</p>
<h5 id="对象流（重点）和数据流（了解）"><a href="#对象流（重点）和数据流（了解）" class="headerlink" title="对象流（重点）和数据流（了解）"></a>对象流（重点）和数据流（了解）</h5><p>Java提供了数据流和对象流来将内存中定义的变量（包括基本数据类型或引用数据类型）保存在文件中</p>
<hr>
<h6 id="数据流：DataOutputStream、DataInputStream"><a href="#数据流：DataOutputStream、DataInputStream" class="headerlink" title="数据流：DataOutputStream、DataInputStream"></a>数据流：DataOutputStream、DataInputStream</h6><ul>
<li>DataOutputStream：允许应用程序将基本数据类型、String类型的变量写入输出流中</li>
<li>DataInputStream：允许应用程序以与机器无关的方式从底层输入流中读取基本数据类型、String类型的变量。</li>
<li>数据流的弊端：只支持Java基本数据类型和字符串的读写，而不支持其它Java对象的类型。而ObjectOutputStream和ObjectInputStream既支持Java基本数据类型的数据读写，又支持Java对象的读写，所以重点介绍对象流ObjectOutputStream和ObjectInputStream</li>
</ul>
<p><strong>数据流中的方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="title function_">readByte</span><span class="params">()</span>                <span class="type">short</span> <span class="title function_">readShort</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span>                  <span class="type">long</span> <span class="title function_">readLong</span><span class="params">()</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">readFloat</span><span class="params">()</span>              <span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">readChar</span><span class="params">()</span>				 <span class="type">boolean</span> <span class="title function_">readBoolean</span><span class="params">()</span>					</span><br><span class="line">String <span class="title function_">readUTF</span><span class="params">()</span>               <span class="keyword">void</span> <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span>[] b)</span></span><br></pre></td></tr></table></figure>
<p>数据流DataOutputStream中的方法：将上述的方法的read改为相应的write即可。</p>
<hr>
<h6 id="对象流：ObjectOutputStream、ObjectInputStream"><a href="#对象流：ObjectOutputStream、ObjectInputStream" class="headerlink" title="对象流：ObjectOutputStream、ObjectInputStream"></a>对象流：ObjectOutputStream、ObjectInputStream</h6><ul>
<li>ObjectOutputStream：将 Java 基本数据类型和对象写入字节输出流中。通过在流中使用文件可以实现Java各种基本数据类型的数据以及对象的持久存储。</li>
<li>ObjectInputStream：ObjectInputStream 对以前使用 ObjectOutputStream 写出的基本数据类型的数据和对象进行读入操作，保存在内存中。</li>
<li>对象流的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li>
</ul>
<p><strong>ObjectOutputStream中的构造器：</strong></p>
<p><code>public ObjectOutputStream(OutputStream out) </code>： 创建一个指定的ObjectOutputStream。</p>
<p><strong>ObjectOutputStream中的方法：</strong></p>
<ul>
<li>public void writeBoolean(boolean val)：写出一个 boolean 值。</li>
<li>public void writeByte(int val)：写出一个8位字节</li>
<li>public void writeShort(int val)：写出一个16位的 short 值</li>
<li>public void writeChar(int val)：写出一个16位的 char 值</li>
<li>public void writeInt(int val)：写出一个32位的 int 值</li>
<li>public void writeLong(long val)：写出一个64位的 long 值</li>
<li>public void writeFloat(float val)：写出一个32位的 float 值。</li>
<li>public void writeDouble(double val)：写出一个64位的 double 值</li>
<li>public void writeUTF(String str)：将表示长度信息的两个字节写入输出流，后跟字符串 s 中每个字符的 UTF-8 修改版表示形式。根据字符的值，将字符串 s 中每个字符转换成一个字节、两个字节或三个字节的字节组。注意，将 String 作为基本数据写入流中与将它作为 Object 写入流中明显不同。 如果 s 为 null，则抛出 NullPointerException。</li>
<li><code>public void writeObject(Object obj)</code>：写出一个obj对象</li>
<li>public void close() ：关闭此输出流并释放与此流相关联的任何系统资源</li>
</ul>
<p><strong>ObjectInputStream中的构造器：</strong></p>
<p><code>public ObjectInputStream(InputStream in) </code>： 创建一个指定的ObjectInputStream。</p>
<p><strong>ObjectInputStream中的方法：</strong></p>
<ul>
<li>public boolean readBoolean()：读取一个 boolean 值</li>
<li>public byte readByte()：读取一个 8 位的字节</li>
<li>public short readShort()：读取一个 16 位的 short 值</li>
<li>public char readChar()：读取一个 16 位的 char 值</li>
<li>public int readInt()：读取一个 32 位的 int 值</li>
<li>public long readLong()：读取一个 64 位的 long 值</li>
<li>public float readFloat()：读取一个 32 位的 float 值</li>
<li>public double readDouble()：读取一个 64 位的 double 值</li>
<li>public String readUTF()：读取 UTF-8 修改版格式的 String</li>
<li><code>public void readObject(Object obj)</code>：读入一个obj对象</li>
<li>public void close() ：关闭此输入流并释放与此流相关联的任何系统资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\test\\b.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化，将内存中的Java对象转换位文件中的数据或网络传输的数据</span></span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写出数据即为序列化过程</span></span><br><span class="line">    <span class="comment">// String对象</span></span><br><span class="line">    oos.writeUTF(<span class="string">&quot;江山如此多娇&quot;</span>);</span><br><span class="line">    oos.flush();</span><br><span class="line">    </span><br><span class="line">    oos.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化，将文件中的数据或网络传输的数据还原为内存中的Java对象</span></span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取文件中对象即反序列化过程</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> ois.readUTF();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    ois.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h6><p><strong>1、何为对象序列化机制？</strong></p>
<p><code>对象序列化机制</code>允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</p>
<ul>
<li>序列化过程：用一个字节序列可以表示一个对象，该字节序列包含该<code>对象的类型</code>和<code>对象中存储的属性</code>等信息。字节序列写出到文件之后，相当于文件中<code>持久保存</code>了一个对象的信息。 </li>
<li>反序列化过程：该字节序列还可以从文件中读取回来，重构对象，对它进行<code>反序列化</code>。<code>对象的数据</code>、<code>对象的类型</code>和<code>对象中存储的数据</code>信息，都可以用来在内存中创建对象。</li>
</ul>
<p><strong>2、序列化机制的重要性</strong></p>
<p>序列化是 RMI（Remote Method Invoke、远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础。因此序列化机制是 JavaEE 平台的基础。<br>序列化的好处，在于可将任何实现了Serializable接口的对象转化为<strong>字节数据</strong>，使其在保存和传输时可被还原。</p>
<p><strong>3、实现原理</strong></p>
<ul>
<li>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制。方法为：<ul>
<li><code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</li>
</ul>
</li>
<li>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制。方法为：<ul>
<li><code>public final Object readObject ()</code> : 读取一个对象。</li>
</ul>
</li>
</ul>
<p><strong>类实现序列化的要求</strong></p>
<ol>
<li>需要实现Serializable接口<br>&#x3D;&#x3D;》否则序列化或反序列化会抛出<code>NotSerializableException</code></li>
<li>需要声明一个全局常量：<code>static final long serialVersionUID = 42234234L;</code>（数字自由自定，不可重复）<br>原本会自动生成，但为使类被修改(如网络传输后对方修改此类)后仍能唯一标识此类。（注1）<br>&#x3D;&#x3D;》否则当JVM反序列化对象时,报<code>InvalidClassException</code>,该类的序列版本号与从流中读取的类描述符的版本号不匹配 </li>
<li>自定义类的各个属性都必须是可序列化的<ul>
<li>基本数据类型的属性默认可以序列化</li>
<li>引用类型的属性需要实现Serializable接口。</li>
<li>不需要可序列化的属性必须注明是瞬态的，使用<code>transient</code> 关键字修饰。</li>
<li><code>静态（static）变量</code>的值不会序列化。因为静态变量的值不属于某个对象。<br>&#x3D;&#x3D;》否则当JVM反序列化对象时,报<code>InvalidClassException</code>,该类包含未知数据类型</li>
</ul>
</li>
</ol>
<p><strong>注意</strong>：</p>
<blockquote>
<ol>
<li><code>Serializable</code> 接口给需要序列化的类，提供了一个序列版本号：<code>serialVersionUID</code> 。凡是实现 Serializable接口的类都应该有一个表示序列化版本标识符的静态变量。serialVersionUID用来表明类的不同版本间的兼容性。简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)。如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节<code>自动生成</code>的。若类的实例变量做了修改，serialVersionUID <code>可能发生变化</code>。因此，建议显式声明。如果声明了serialVersionUID，即使在序列化完成之后修改了类导致类重新编译，则原来的数据也能正常反序列化，只是新增的字段值是默认值而已。</li>
<li>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code> 异常。</li>
</ol>
</blockquote>
<h4 id="其他流"><a href="#其他流" class="headerlink" title="其他流"></a>其他流</h4><h6 id="标准输入、输出流"><a href="#标准输入、输出流" class="headerlink" title="标准输入、输出流"></a>标准输入、输出流</h6><p>System.in和System.out分别代表了系统标准的输入和输出设备，默认输入设备是：键盘，输出设备是：显示器</p>
<ul>
<li>System.in的类型是InputStream</li>
<li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream 的子类</li>
</ul>
<p>重定向：通过System类的setIn，setOut方法对默认设备进行改变。</p>
<ul>
<li>public static void setIn(InputStream in)</li>
<li>public static void setOut(PrintStream out)</li>
</ul>
<p><strong>拓展：</strong></p>
<p>System类中有三个常量对象：System.out、System.in、System.err<br>查看System类中这三个常量对象的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">PrintStream</span> <span class="variable">err</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>奇怪的是，</p>
<ul>
<li>这三个常量对象有final声明，但是却初始化为null。final声明的常量一旦赋值就不能修改，那么null不会空指针异常吗？</li>
<li>这三个常量对象为什么要小写？final声明的常量按照命名规范不是应该大写吗？</li>
<li>这三个常量的对象有set方法？final声明的常量不是不能修改值吗？set方法是如何修改它们的值的？</li>
</ul>
<p>final声明的常量，表示在Java的语法体系中它们的值是不能修改的，而这三个常量对象的值是由C&#x2F;C++等系统函数进行初始化和修改值的，所以它们故意没有用大写，也有set方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Declare and initialize the string</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the string from the keyboard</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        string = br.readLine();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        System.out.println(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the string obtained from the keyboard</span></span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h5><p>实现将基本数据类型的数据格式转化为字符串输出。<br>打印流：<code>PrintStream</code>和<code>PrintWriter</code></p>
<ul>
<li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li>
<li>PrintStream和PrintWriter的输出不会抛出IOException异常</li>
<li>PrintStream和PrintWriter有自动flush功能</li>
<li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类。</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
<p><strong>构造器</strong></p>
<ul>
<li>PrintStream(File file) ：创建具有指定文件且不带自动行刷新的新打印流。 </li>
<li>PrintStream(File file, String csn)：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。 </li>
<li>PrintStream(OutputStream out) ：创建新的打印流。 </li>
<li>PrintStream(OutputStream out, boolean autoFlush)：创建新的打印流。 autoFlush如果为 true，则每当写入 byte 数组、调用其中一个 println 方法或写入换行符或字节 (‘\n’) 时都会刷新输出缓冲区。</li>
<li>PrintStream(OutputStream out, boolean autoFlush, String encoding) ：创建新的打印流。 </li>
<li>PrintStream(String fileName)：创建具有指定文件名称且不带自动行刷新的新打印流。 </li>
<li>PrintStream(String fileName, String csn) ：创建具有指定文件名称和字符集且不带自动行刷新的新打印流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;io.txt&quot;</span>);</span><br><span class="line">    ps.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    ps.println(<span class="number">1</span>);</span><br><span class="line">    ps.println(<span class="number">1.5</span>);</span><br><span class="line">    ps.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个重要应用：向文件输出，记录日志</p>
<h5 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h5><p><strong>构造方法</strong></p>
<ul>
<li>Scanner(File source) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。 </li>
<li>Scanner(File source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定文件扫描的。 </li>
<li>Scanner(InputStream source) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。 </li>
<li>Scanner(InputStream source, String charsetName) ：构造一个新的 Scanner，它生成的值是从指定的输入流扫描的。</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li>boolean hasNextXxx()： 如果通过使用nextXxx()方法，此扫描器输入信息中的下一个标记可以解释为默认基数中的一个 Xxx 值，则返回 true。</li>
<li>Xxx nextXxx()： 将输入信息的下一个标记扫描为一个Xxx</li>
</ul>
<h5 id="apache-common包的使用"><a href="#apache-common包的使用" class="headerlink" title="apache-common包的使用"></a>apache-common包的使用</h5><p>IO技术开发中，代码量很大，而且代码的重复率较高，为此Apache软件基金会，开发了IO技术的工具类<code>commonsIO</code>，大大简化了IO开发。Apahce软件基金会属于第三方，（Oracle公司第一方，我们自己第二方，其他都是第三方）我们要使用第三方开发好的工具，需要添加jar包。</p>
<p><strong>导包及举例</strong></p>
<ul>
<li>在导入commons-io-2.5.jar包之后，内部的API都可以使用。</li>
<li>IOUtils类的使用</li>
<li>FileUtils类的使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 静态方法：IOUtils.copy(InputStream in,OutputStream out)传递字节流，实现文件复制。</span><br><span class="line">- 静态方法：IOUtils.closeQuietly(任意流对象)悄悄的释放资源，自动处理close()方法抛出的异常。</span><br><span class="line">- 静态方法：<span class="keyword">void</span> <span class="title function_">copyDirectoryToDirectory</span><span class="params">(File src,File dest)</span>：整个目录的复制，自动进行递归遍历</span><br><span class="line">          参数:</span><br><span class="line">          src:要复制的文件夹路径</span><br><span class="line">          dest:要将文件夹粘贴到哪里去         </span><br><span class="line">- 静态方法：<span class="keyword">void</span> <span class="title function_">writeStringToFile</span><span class="params">(File file,String content)</span>：将内容content写入到file中</span><br><span class="line">- 静态方法：String <span class="title function_">readFileToString</span><span class="params">(File file)</span>：读取文件内容，并返回一个String</span><br><span class="line">- 静态方法：<span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(File srcFile,File destFile)</span>：文件复制</span><br></pre></td></tr></table></figure>


<h3 id="第16章-网络编程"><a href="#第16章-网络编程" class="headerlink" title="第16章_网络编程"></a>第16章_网络编程</h3><p>Java是 Internet 上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序。<br>Java提供的网络类库，可以实现无痛的网络连接，联网的底层细节被隐藏在 Java 的本机安装系统里，由 JVM 进行控制。并且 Java 实现了一个跨平台的网络库，<code>程序员面对的是一个统一的网络编程环境</code>。</p>
<p><strong>软件架构</strong></p>
<ul>
<li><strong>C&#x2F;S架构</strong> ：全称为Client&#x2F;Server结构，是指客户端和服务器结构。常见程序有QQ、美团app、360安全卫士等软件。</li>
<li><strong>B&#x2F;S架构</strong> ：全称为Browser&#x2F;Server结构，是指浏览器和服务器结构。常见浏览器有IE、谷歌、火狐等。</li>
</ul>
<p>两种架构各有优势，但是无论哪种架构，都离不开网络的支持。<strong>网络编程</strong>，就是在一定的协议下，实现两台计算机的通信的程序。</p>
<p><strong>网络编程三要素</strong></p>
<ol>
<li>IP地址和域名</li>
<li>端口号</li>
<li>网络通信协议</li>
</ol>
<h4 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h4><p><strong>InetAddress类的使用</strong></p>
<p>InetAddress类主要表示IP地址，两个子类：Inet4Address、Inet6Address。<br>InetAddress 类没有提供公共的构造器，而是提供 了 如下几个 静态方法来获取InetAddress 实例</p>
<ul>
<li>public static InetAddress <code>getLocalHost()</code></li>
<li>public static InetAddress <code>getByName(String host)</code></li>
<li>public static InetAddress getByAddress(byte[] addr)</li>
</ul>
<p>InetAddress 提供了如下几个常用的方法</p>
<ul>
<li>public String getHostAddress() ：返回 IP 地址字符串（以文本表现形式）</li>
<li>public String getHostName() ：获取此 IP 地址的主机名</li>
<li>public boolean isReachable(int timeout)：测试是否可以达到该地址</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 常用实例化方式</span></span><br><span class="line">        <span class="comment">//获取指定IP/域名对应的InetAddress的实例，如是域名会进行解析</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.23.31&quot;</span>);</span><br><span class="line">        <span class="comment">// /192.168.23.31</span></span><br><span class="line">        System.out.println(inet1);</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">        <span class="comment">// www.baidu.com/183.2.172.42</span></span><br><span class="line">        System.out.println(inet2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取本地IP对应的InetAddress的实例</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet3</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="comment">// shiyefu-computer1/192.168.110.96</span></span><br><span class="line">        System.out.println(inet3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 常用方法</span></span><br><span class="line">        <span class="comment">//获取域名/IP地址（没有域名时）</span></span><br><span class="line">        <span class="comment">//www.baidu.com</span></span><br><span class="line">        System.out.println(inet2.getHostName());</span><br><span class="line">        <span class="comment">//183.2.172.42</span></span><br><span class="line">        System.out.println(inet2.getHostAddress());</span><br><span class="line">        <span class="comment">//192.168.23.31</span></span><br><span class="line">        System.out.println(inet1.getHostName());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="（重点）TCP-Socket-网络编程"><a href="#（重点）TCP-Socket-网络编程" class="headerlink" title="（重点）TCP Socket 网络编程"></a>（重点）TCP Socket 网络编程</h4><p>网络上具有唯一标识的<strong>IP地址和端口号组合</strong>在一起构成唯一能识别的标识符套接字（Socket）。<br>利用套接字(Socket)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。网络通信其实就是Socket间的通信。<br>通信的两端都要有Socket，是两台机器间通信的端点。一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输。</p>
<p><strong>Socket分类：</strong></p>
<ul>
<li>流套接字（stream socket）：使用TCP提供可依赖的字节流服务</li>
<li>ServerSocket：此类实现TCP服务器套接字。服务器套接字等待请求通过网络传入。</li>
<li>Socket：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点。</li>
<li>数据报套接字（datagram socket）：使用UDP提供“尽力而为”的数据报服务</li>
<li>DatagramSocket：此类表示用来发送和接收UDP数据报包的套接字。</li>
</ul>
<p><strong>通信模型</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240721113125.png" alt="基于TCP的Socket通信"></p>
<h5 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h5><p><strong>ServerSocket类的构造方法：</strong></p>
<ul>
<li>ServerSocket(int port) ：创建绑定到特定端口的服务器套接字。</li>
</ul>
<p><strong>ServerSocket类的常用方法：</strong></p>
<ul>
<li>Socket accept()：侦听并接受到此套接字的连接。</li>
</ul>
<h5 id="socket类"><a href="#socket类" class="headerlink" title="socket类"></a>socket类</h5><p><strong>Socket类的常用构造方法</strong>：</p>
<ul>
<li>public Socket(InetAddress address,int port)：创建一个流套接字并将其连接到指定 IP 地址的指定端口号。</li>
<li>public Socket(String host,int port)：创建一个流套接字并将其连接到指定主机上的指定端口号。</li>
</ul>
<p><strong>Socket类的常用方法</strong>：</p>
<ul>
<li>public InputStream getInputStream()：返回此套接字的输入流，可以用于接收消息</li>
<li>public OutputStream getOutputStream()：返回此套接字的输出流，可以用于发送消息</li>
<li>public InetAddress getInetAddress()：此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null。</li>
<li>public InetAddress getLocalAddress()：获取套接字绑定的本地地址。</li>
<li>public int getPort()：此套接字连接到的远程端口号；如果尚未连接套接字，则返回 0。</li>
<li>public int getLocalPort()：返回此套接字绑定到的本地端口。如果尚未绑定套接字，则返回 -1。</li>
<li>public void close()：关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。 关闭此套接字也将会关闭该套接字的 InputStream 和 OutputStream。 </li>
<li>public void shutdownInput()：如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）。 即不能在从此套接字的输入流中接收任何数据。</li>
<li>public void shutdownOutput()：禁用此套接字的输出流。对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列。 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException。 即不能通过此套接字的输出流发送任何数据。</li>
</ul>
<p><strong>注意：</strong>先后调用Socket的shutdownInput()和shutdownOutput()方法，仅仅关闭了输入流和输出流，并不等于调用Socket的close()方法。在通信结束后，仍然要调用Socket的close()方法，因为只有该方法才会释放Socket占用的资源，比如占用的本地端口号等。</p>
<h5 id="通信示例"><a href="#通信示例" class="headerlink" title="通信示例"></a>通信示例</h5><p>文件传输通信</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTransmissTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;        </span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8989</span>; <span class="comment">// 声明对方端口号</span></span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;192.168.83.1&quot;</span>, port);</span><br><span class="line"></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\1.jpg&quot;</span>);</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">// 发送数据</span></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件传输完成&quot;</span>);</span><br><span class="line">            <span class="comment">// 说明本次数据传输完成</span></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] buffer1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len1;</span><br><span class="line">            <span class="keyword">while</span>((len1 = inputStream.read(buffer1))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buffer1,<span class="number">0</span>,len1);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (baos!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (inputStream!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (os!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fis!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (socket!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8989</span>;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;服务端开启&quot;</span>);</span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;收到来自&quot;</span>+socket.getInetAddress().getHostAddress()+<span class="string">&quot;的连接&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workinenglish\\1-1.jpg&quot;</span>);</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file);</span><br><span class="line"></span><br><span class="line">            inputStream = socket.getInputStream();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = inputStream.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件接收完毕&quot;</span>);</span><br><span class="line"></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;服务器成功接收文件&quot;</span>.getBytes());</span><br><span class="line">            <span class="comment">// 说明本次数据传输完成</span></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (baos!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (inputStream!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (os!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fos!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (socket!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="（了解）UDP-Socket-网络编程"><a href="#（了解）UDP-Socket-网络编程" class="headerlink" title="（了解）UDP Socket 网络编程"></a>（了解）UDP Socket 网络编程</h4><h5 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a>DatagramSocket类</h5><p><strong>DatagramSocket 类的常用方法：</strong></p>
<ul>
<li>public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字将被绑定到通配符地址，IP 地址由内核来选择。</li>
<li>public DatagramSocket(int port,InetAddress laddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在 0 到 65535 之间（包括两者）。如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择。 </li>
<li>public void close()关闭此数据报套接字。 </li>
<li>public void send(DatagramPacket p)从此套接字发送数据报包。DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号。 </li>
<li>public void receive(DatagramPacket p)从此套接字接收数据报包。当此方法返回时，DatagramPacket 的缓冲区填充了接收的数据。数据报包也包含发送方的 IP 地址和发送方机器上的端口号。 此方法在接收到数据报前一直阻塞。数据报包对象的 length 字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短。 </li>
<li>public InetAddress getLocalAddress()获取套接字绑定的本地地址。</li>
<li>public int getLocalPort()返回此套接字绑定的本地主机上的端口号。 </li>
<li>public InetAddress getInetAddress()返回此套接字连接的地址。如果套接字未连接，则返回 null。</li>
<li>public int getPort()返回此套接字的端口。如果套接字未连接，则返回 -1。</li>
</ul>
<h5 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a>DatagramPacket类</h5><p><strong>DatagramPacket类的常用方法：</strong></p>
<ul>
<li>public DatagramPacket(byte[] buf,int length)构造 DatagramPacket，用来接收长度为 length 的数据包。 length 参数必须小于等于 buf.length。</li>
<li>public DatagramPacket(byte[] buf,int length,InetAddress address,int port)构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。length 参数必须小于等于 buf.length。</li>
<li>public InetAddress getAddress()返回某台机器的 IP 地址，此数据报将要发往该机器或者是从该机器接收到的。</li>
<li>public int getPort()返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的。</li>
<li><code>public byte[] getData()</code>返回数据缓冲区。接收到的或将要发送的数据从缓冲区中的偏移量 offset 处开始，持续 length 长度。</li>
<li><code>public int getLength()</code>返回将要发送或接收到的数据的长度。</li>
</ul>
<h5 id="通信示例-1"><a href="#通信示例-1" class="headerlink" title="通信示例"></a>通信示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sender</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ds = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8989</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="string">&quot;我是发送端&quot;</span>.getBytes(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">// 创建数据包，包含数据，起始字节，结束字节，套接字；</span></span><br><span class="line">            <span class="comment">// 若大于64kb，应当分为多个数据包，前一个数据包的结束字节为当前数据包开始字节</span></span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length,inetAddress,port);</span><br><span class="line">            ds.send(packet);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ds != <span class="literal">null</span>) &#123;</span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiver</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">8989</span>;</span><br><span class="line">            ds = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(port);</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>*<span class="number">64</span>];</span><br><span class="line">            <span class="comment">// 创建数据包，包含数据，起始字节，结束字节</span></span><br><span class="line">            <span class="comment">// 若大于64kb，应当分为多个数据包，前一个数据包的结束字节为当前数据包开始字节</span></span><br><span class="line">            <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line">            ds.receive(packet);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>, packet.getLength());</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ds != <span class="literal">null</span>) &#123;</span><br><span class="line">                ds.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（重点）URL"><a href="#（重点）URL" class="headerlink" title="（重点）URL"></a>（重点）URL</h4><p>URL(Uniform Resource Locator)：统一资源定位符，它表示 Internet 上某一资源的地址。通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点。浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源。 </p>
<p>URL的基本结构由5部分组成：<code>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表</code></p>
<ul>
<li>片段名：即锚点，例如看小说，直接定位到章节</li>
<li>参数列表格式：参数名&#x3D;参数值&amp;参数名&#x3D;参数值….</li>
</ul>
<p>为了表示URL，java.net 中实现了类 URL。我们可以通过下面的构造器来初始化一个 URL 对象：</p>
<ul>
<li>public URL (String spec)：通过一个表示URL地址的字符串可以构造一个URL对象。</li>
<li>public URL(URL context, String spec)：通过基 URL 和相对 URL 构造一个 URL 对象。</li>
<li>public URL(String protocol, String host, String file);</li>
<li>public URL(String protocol, String host, int port, String file);</li>
</ul>
<p>URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 try-catch 语句进行捕获。</p>
<p><img src="/images/image-20220415013546074.png" alt="image-20220415013546074"></p>
<p><strong>常用方法</strong></p>
<p>一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性：</p>
<ul>
<li>public String getProtocol( )   获取该URL的协议名</li>
<li>public String getHost( )      获取该URL的主机名</li>
<li>public String getPort( )      获取该URL的端口号</li>
<li>public String getPath( )      获取该URL的文件路径</li>
<li>public String getFile( )       获取该URL的文件名</li>
<li>public String getQuery(  )    获取该URL的查询名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/myTest.txt&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;getProtocol() :&quot;</span>+url.getProtocol());</span><br><span class="line">System.out.println(<span class="string">&quot;getHost() :&quot;</span>+url.getHost());</span><br><span class="line">System.out.println(<span class="string">&quot;getPort() :&quot;</span>+url.getPort());</span><br><span class="line">System.out.println(<span class="string">&quot;getPath() :&quot;</span>+url.getPath());</span><br><span class="line">System.out.println(<span class="string">&quot;getFile() :&quot;</span>+url.getFile());</span><br><span class="line">System.out.println(<span class="string">&quot;getQuery() :&quot;</span>+url.getQuery());</span><br></pre></td></tr></table></figure>

<h5 id="URLConnection类"><a href="#URLConnection类" class="headerlink" title="URLConnection类"></a>URLConnection类</h5><p>URL的方法 openStream()：能从网络上读取数据<br>若希望输出数据，例如向服务器端的 CGI （公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一些数据，则必须先与URL建立连接，然后才能对其进行读写，此时需要使用 URLConnection 。</p>
<p>URLConnection：表示到URL所引用的远程对象的连接。当与一个URL建立连接时，首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象。如果连接过程失败，将产生IOException. </p>
<ul>
<li>URL netchinaren &#x3D; new URL (“<a target="_blank" rel="noopener" href="http://www.atguigu.com/index.shtml">http://www.atguigu.com/index.shtml</a>“); </li>
<li>URLConnectonn u &#x3D; netchinaren.openConnection( );</li>
</ul>
<p>通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI程序进行交互。</p>
<ul>
<li><p>public Object getContent( ) throws IOException</p>
</li>
<li><p>public int getContentLength( )</p>
</li>
<li><p>public String getContentType( )</p>
</li>
<li><p>public long getDate( )</p>
</li>
<li><p>public long getLastModified( )</p>
</li>
<li><p><strong>public InputStream getInputStream ( ) throws IOException</strong></p>
</li>
<li><p>public OutputSteram getOutputStream( )throws IOException</p>
</li>
</ul>
<h4 id="三者总结"><a href="#三者总结" class="headerlink" title="三者总结"></a>三者总结</h4><p>TCP和UDP协议的区别</p>
<ol>
<li>需建立连接（三次握手），可靠，大数据量，需要释放已有连接（四次挥手），效率低，</li>
<li>不需要建立连接，不可靠，64K，无需释放资源，开销小，通信效率高，适用于音视频和普通数据传输</li>
</ol>
<p>TCP通信编程</p>
<ol>
<li>三次握手四次挥手均不需要自己编程，自动完成</li>
</ol>
<p>位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。</p>
<p>客户端－服务器是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。端口号是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。套接字用于连接客户端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实现面向连接的会话。</p>
<p>Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP 地址，该对象里有两个字段：主机名(String) 和 IP 地址(int)。</p>
<ul>
<li>类 Socket 和 ServerSocket 实现了基于TCP协议的客户端－服务器程序。Socket是客户端和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络拥挤等问题，它保证数据可靠的传送。</li>
<li>类 URL 和 URLConnection 提供了最高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去。</li>
</ul>
<h3 id="第17章-反射机制"><a href="#第17章-反射机制" class="headerlink" title="第17章_反射机制"></a>第17章_反射机制</h3><p>（多态） Java程序中，所有的对象都有两种类型：<code>编译时类型</code>和<code>运行时类型</code>，而很多时候对象的编译时类型和运行时类型<code>不一致</code>。<br>例如：某些变量或形参的声明类型是Object类型，但是程序却需要调用该对象运行时类型的方法，该方法不是Object中的方法，那么如何解决呢？<code>Object obj = new String(&quot;hello&quot;);    obj.getClass()</code></p>
<p>解决这个问题，有两种方案：</p>
<ol>
<li>在编译和运行时都完全知道类型的具体信息，在这种情况下，我们可以直接先使用<code>instanceof</code>运算符进行判断，再利用强制类型转换符将其转换成运行时类型的变量即可。</li>
<li>编译时根本无法预知该对象和类的真实信息，程序只能依靠<code>运行时信息</code>来发现该对象和类的真实信息，这就必须使用反射。</li>
</ol>
<p><strong>反射的概述</strong></p>
<p>Reflection（反射）是被视为<code>动态语言</code>的关键，反射机制允许程序在<code>运行期间</code>借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。<br>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。<code>这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</code><br>在日常的</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240721225138.png" alt="反射"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240721230428.png" alt="内存角度反射理解"></p>
<p><strong>Java反射机制提供的功能：</strong></p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法，包括私有变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
<p><strong>反射相关的主要API</strong></p>
<p><code>java.lang.Class</code>：代表一个类<br>java.lang.reflect.Method：代表类的方法<br>java.lang.reflect.Field：代表类的成员变量<br>java.lang.reflect.Constructor：代表类的构造器</p>
<p><strong>反射的优缺点</strong></p>
<p><strong>优点：</strong></p>
<ul>
<li>提高了Java程序的灵活性和扩展性，<code>降低了耦合性</code>，提高<code>自适应</code>能力</li>
<li>允许程序创建和控制任何类的对象，无需提前<code>硬编码</code>目标类</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>反射的<code>性能较低</code>。<ul>
<li>反射机制主要应用在对灵活性和扩展性要求很高的系统框架上</li>
</ul>
</li>
<li>反射会<code>模糊</code>程序内部逻辑，<code>可读性较差</code>。</li>
</ul>
<p><strong>总结</strong></p>
<ol>
<li>反射的使用场景：<ul>
<li>我们的业务代码开发过程中，相关的对象和方法的调用都是确定的，因此一般不使用反射</li>
<li>因为反射体现了动态性，因此在设计框架时常常大量使用反射，理解框架需要学习反射机制<br>框架 &#x3D; 反射 + 注解 + 设计模式</li>
</ul>
</li>
<li>通过反射可以创建单例模式中类的多个对象，即使构造器已经私有化</li>
<li>反射和封装性<ul>
<li>封装性主要体现的是是否建议为欧盟调用内部的api的问题</li>
<li>反射体现的是我们能否调用的问题，因为在运行时类的完整结构都被加载在内存中，所以我们可以调用</li>
</ul>
</li>
</ol>
<h4 id="反射的源头-Class类"><a href="#反射的源头-Class类" class="headerlink" title="反射的源头-Class类"></a>反射的源头-Class类</h4><p><strong>Class类的理解</strong><br>针对编写好的.java源文件进行编译(使用javac.exe)会生成一个或多个.class字节码文件，然后使用<code>java.exe</code>命令对指定的.class文件进行解释运行。在解释运行的过程中，需要使用类的加载器将.class字节码文件加载到内存中的方法区，加载到内存中的.class文件对应的结构即为Class类的一个实例。某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构(class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F;primitive type&#x2F;void&#x2F;[])的有关信息。 运行时类在内存中会缓存起来，在整个执行期间都只加载一次（不严谨）</p>
<ul>
<li>Class本身也是一个类</li>
<li><strong>Class 对象只能由系统建立对象</strong></li>
<li><strong>一个加载的类在 JVM 中只会有一个Class实例</strong> </li>
<li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li>
<li>每个类的实例都会记得自己是由哪个 Class 实例所生成</li>
<li>通过Class可以完整地得到一个类中的所有被加载的结构 </li>
<li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li>
</ul>
<p>说明：下图中字符串常量池在JDK6中存储在方法区；JDK7及以后，存储在堆空间。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240722151909.png" alt="内存结构示意图"><br>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Person.class<span class="comment">//运行时类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">class2</span> <span class="operator">=</span> String.<span class="keyword">class</span></span><br><span class="line"><span class="title class_">Class</span> class3 = Comparable.class</span><br></pre></td></tr></table></figure>


<p><strong>获取Class类的实例</strong></p>
<ol>
<li>要求编译期间已知类型<br>若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高<br><code>Class clazz = String.class;</code></li>
<li>获取对象的运行时类型<br>已知某个类的实例，调用该实例(对象)的getClass()方法获取Class对象，以下示例中person是Person类的一个对象<br><code>Class clazz = person.getClass();</code></li>
<li>可以获取编译期间未知的类型<br>已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException<br><code>Class clazz = Class.forName(&quot;java.lang.String&quot;);</code></li>
<li>其他方式(不做要求)，使用场景和3一样，不需要掌握<br>可以用系统类加载对象或自定义加载器对象加载指定路径下的类型<br><code>ClassLoader cl = this.getClass().getClassLoader();</code><br><code>Class clazz4 = cl.loadClass(&quot;类的全类名&quot;);</code></li>
</ol>
<p><strong>Class的实例可以指向哪些结构</strong>（所有java类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Object.class; <span class="comment">//1 class:外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Comparable.class; <span class="comment">//2 interface：接口</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> String[].class;  <span class="comment">//3 []:数组</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="type">int</span>[][].class;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> ElementType.class; <span class="comment">//4 enum:枚举</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c6</span> <span class="operator">=</span> Override.class; <span class="comment">//5 annotation:注解@interface</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c7</span> <span class="operator">=</span> <span class="type">int</span>.class;  <span class="comment">//6 primitive type：基本数据类型</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c8</span> <span class="operator">=</span> <span class="keyword">void</span>.class; <span class="comment">//7 void</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">c9</span> <span class="operator">=</span> Class.class;</span><br><span class="line"><span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line"><span class="type">Class</span> <span class="variable">c10</span> <span class="operator">=</span> a.getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c11</span> <span class="operator">=</span> b.getClass();</span><br><span class="line"><span class="comment">// 只要元素类型与维度一样，就是同一个Class</span></span><br><span class="line">System.out.println(c10 == c11);</span><br></pre></td></tr></table></figure>


<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>功能说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>static  Class forName(String  name)</td>
<td>返回指定类名  name  的  Class  对象</td>
</tr>
<tr>
<td>Object  newInstance()</td>
<td>调用缺省构造函数，返回该Class对象的一个实例</td>
</tr>
<tr>
<td>getName()</td>
<td>返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称</td>
</tr>
<tr>
<td>Class  getSuperClass()</td>
<td>返回当前Class对象的父类的Class对象</td>
</tr>
<tr>
<td>Class  [] getInterfaces()</td>
<td>获取当前Class对象的接口</td>
</tr>
<tr>
<td>ClassLoader  getClassLoader()</td>
<td>返回该类的类加载器</td>
</tr>
<tr>
<td>Class  getSuperclass()</td>
<td>返回表示此Class所表示的实体的超类的Class</td>
</tr>
<tr>
<td>Constructor[]  getConstructors()</td>
<td>返回一个包含某些Constructor对象的数组</td>
</tr>
<tr>
<td>Field[]  getDeclaredFields()</td>
<td>返回Field对象的一个数组</td>
</tr>
<tr>
<td>Method  getMethod(String  name,Class … paramTypes)</td>
<td>返回一个Method对象，此对象的形参类型为paramType</td>
</tr>
</tbody></table>
<h4 id="类的加载器和加载过程"><a href="#类的加载器和加载过程" class="headerlink" title="类的加载器和加载过程"></a>类的加载器和加载过程</h4><p><strong>类的加载过程</strong></p>
<p>类在内存中完整的生命周期：加载–&gt;使用–&gt;卸载。其中加载过程又分为：装载、链接、初始化三个阶段。当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、链接、初始化三个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载。<br>类的加载又分为三个阶段：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240722160449.png" alt="类的加载"></p>
<ol>
<li>装载（Loading）<br>将类的class文件读入内存，并为之创建一个java.lang.Class对象。此过程由类加载器完成</li>
<li>链接（Linking）<br>①验证Verify：确保加载的类信息符合JVM规范，例如：以cafebabe开头，没有安全方面的问题。<br>②准备Prepare：正式为类变量（static）分配内存并<code>设置类变量默认初始值</code>的阶段，这些内存都将在方法区中进行分配。<br>③解析Resolve：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li>
<li>初始化（Initialization）<ul>
<li>执行<code>类构造器&lt;clinit&gt;()方法</code>的过程。<code>类构造器&lt;clinit&gt;()方法</code>是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>虚拟机会保证一个<code>类的&lt;clinit&gt;()方法</code>在多线程环境中被正确加锁和同步。</li>
</ul>
</li>
</ol>
<p><strong>类的加载器</strong></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240722160706.png" alt="类的加载器"></p>
<p><strong>作用</strong><br>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。<br>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象。</p>
<p><strong>分类</strong></p>
<p>JVM（以jdk8为例）支持两种类型的类加载器，分别为<code>(启动)引导类加载器（Bootstrap ClassLoader）</code>和<code>自定义类加载器（User-Defined ClassLoader）</code>。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240722161041.png" alt="类加载器"></p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p>
<ol>
<li><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong><ul>
<li>这个类加载使用<code>C/C++语言</code>实现的，嵌套在JVM内部。获取它的对象时往往返回null</li>
<li>它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</li>
<li>并不继承自java.lang.ClassLoader，没有父加载器。</li>
<li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
</ul>
</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong><ul>
<li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</li>
<li>继承于ClassLoader类</li>
<li>父类加载器为启动类加载器</li>
<li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
</li>
<li><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong><ul>
<li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>继承于ClassLoader类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库 </li>
<li>应用程序中的类加载器默认是系统类加载器。</li>
<li>它是用户自定义类加载器的默认父加载器</li>
<li>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</li>
</ul>
</li>
<li><strong>用户自定义类加载器（了解）</strong><ul>
<li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
<li>体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</li>
<li>同时，自定义加载器能够实现<code>应用隔离</code>，例如 Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C++程序要好太多，想不修改C&#x2F;C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li>
<li>自定义类加载器通常需要继承于ClassLoader。</li>
</ul>
</li>
</ol>
<p><strong>查看某个类的类加载器对象</strong></p>
<p>（1）获取默认的系统类加载器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classloader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure>

<p>（2）查看某个类是哪个类加载器加载的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">classloader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;exer2.ClassloaderDemo&quot;</span>).getClassLoader();</span><br><span class="line"><span class="comment">//如果是根加载器加载的类，则会得到null</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classloader1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br></pre></td></tr></table></figure>

<p>（3）获取某个类加载器的父加载器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassLoader</span> <span class="variable">parentClassloader</span> <span class="operator">=</span> classloader.getParent();</span><br></pre></td></tr></table></figure>


<p><strong>(重要)使用ClassLoader获取流</strong></p>
<p>关于类加载器的一个主要方法：getResourceAsStream(String str):获取类路径下的指定文件的输入流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">in = <span class="built_in">this</span>.getClass().getClassLoader().getResourceAsStream(<span class="string">&quot;exer2\\test.properties&quot;</span>);</span><br><span class="line">System.out.println(in);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要掌握如下的代码</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//方式1：此时默认的相对路径是当前的module</span></span><br><span class="line"><span class="comment">//        FileInputStream is = new FileInputStream(&quot;info.properties&quot;);</span></span><br><span class="line"><span class="comment">//        FileInputStream is = new FileInputStream(&quot;src//info1.properties&quot;);</span></span><br><span class="line">        <span class="comment">//方式2：使用类的加载器</span></span><br><span class="line">        <span class="comment">//此时默认的相对路径是当前module的src目录</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;info1.properties&quot;</span>);</span><br><span class="line">        pros.load(is);</span><br><span class="line">        <span class="comment">//获取配置文件中的信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h4 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a>反射的应用</h4><h5 id="应用1：创建运行时类的对象"><a href="#应用1：创建运行时类的对象" class="headerlink" title="应用1：创建运行时类的对象"></a>应用1：创建运行时类的对象</h5><p>这是反射机制应用最多的地方。创建运行时类的对象有两种方式：<br><strong>方式1：直接调用Class对象的newInstance()方法</strong><br>步骤：<br>1）获取该类型的Class对象  2）调用Class对象的newInstance()方法创建对象<br>要求： 1）类<em>必须有一个无参数的构造器</em>(javaBean必须有无参构造器原因之一)。2）类的构造器的访问权限需要足够。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Person类的实例</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) class1.newInstance();<span class="comment">// 过时方法</span></span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方式2：通过获取构造器对象来进行实例化</strong></p>
<p>步骤：<br>1）通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型的构造器<br>2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。<br>3）通过Constructor实例化对象。</p>
<blockquote>
<p>如果构造器的权限修饰符修饰的范围不可见，也可以调用setAccessible(true)</p>
</blockquote>
<h5 id="了解-应用2：获取运行时类的完整结构"><a href="#了解-应用2：获取运行时类的完整结构" class="headerlink" title="(了解)应用2：获取运行时类的完整结构"></a>(了解)应用2：获取运行时类的完整结构</h5><p>可以获取：包、修饰符、类型名、父类（包括泛型父类）、父接口（包括泛型父接口）、成员（属性、构造器、方法）、注解（类上的、方法上的、属性上的）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.实现的全部接口</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getInterfaces()   </span><br><span class="line"><span class="comment">//确定此对象所表示的类或接口实现的接口。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.所继承的父类</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;? Super T&gt; getSuperclass()</span><br><span class="line"><span class="comment">//返回表示此 Class 所表示的实体（类、接口、基本类型）的父类的 Class。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.全部的构造器</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt;[] getConstructors()</span><br><span class="line"><span class="comment">//返回此 Class 对象所表示的类的所有public构造方法。</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt;[] getDeclaredConstructors()</span><br><span class="line"><span class="comment">//返回此 Class 对象表示的类声明的所有构造方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Constructor类中：</span></span><br><span class="line"><span class="comment">//取得修饰符: </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//取得方法名称: </span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//取得参数的类型：</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.全部的方法</span></span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods()</span><br><span class="line"><span class="comment">//返回此Class对象所表示的类或接口的全部方法</span></span><br><span class="line"><span class="keyword">public</span> Method[] getMethods()  </span><br><span class="line"><span class="comment">//返回此Class对象所表示的类或接口的public的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Method类中：</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getReturnType()</span><br><span class="line"><span class="comment">//取得全部的返回值</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getParameterTypes()</span><br><span class="line"><span class="comment">//取得全部的参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span></span><br><span class="line"><span class="comment">//取得修饰符</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getExceptionTypes()</span><br><span class="line"><span class="comment">//取得异常信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.全部的Field</span></span><br><span class="line"><span class="keyword">public</span> Field[] getFields() </span><br><span class="line"><span class="comment">//返回此Class对象所表示的类或接口的public的Field。</span></span><br><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields() </span><br><span class="line"><span class="comment">//返回此Class对象所表示的类或接口的全部Field。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Field方法中：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getModifiers</span><span class="params">()</span></span><br><span class="line"><span class="comment">//以整数形式返回此Field的修饰符</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getType()  </span><br><span class="line"><span class="comment">//得到Field的属性类型</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>  </span><br><span class="line"><span class="comment">//返回Field的名称。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6. Annotation相关</span></span><br><span class="line">get <span class="title function_">Annotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span> </span><br><span class="line">getDeclaredAnnotations() </span><br><span class="line"></span><br><span class="line"><span class="comment">//7.泛型相关</span></span><br><span class="line"><span class="comment">//获取父类泛型类型：</span></span><br><span class="line">Type <span class="title function_">getGenericSuperclass</span><span class="params">()</span></span><br><span class="line"><span class="comment">//泛型类型：ParameterizedType</span></span><br><span class="line"><span class="comment">//获取实际的泛型类型参数数组：</span></span><br><span class="line">getActualTypeArguments()</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.类所在的包</span></span><br><span class="line">Package <span class="title function_">getPackage</span><span class="params">()</span> </span><br></pre></td></tr></table></figure>


<h5 id="掌握-应用3：调用运行时类的指定结构"><a href="#掌握-应用3：调用运行时类的指定结构" class="headerlink" title="(掌握)应用3：调用运行时类的指定结构"></a>(掌握)应用3：调用运行时类的指定结构</h5><p><strong>调用指定的属性</strong></p>
<p>在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作。<br>（1）获取该类型的Class对象<br><code>Class clazz = Class.forName(&quot;包.类名&quot;);</code><br>（2）获取属性对象<br><code>Field field = clazz.getDeclaredField(&quot;属性名&quot;);</code><br>（3）如果属性的权限修饰符不是public，那么需要设置属性可访问<br><code>field.setAccessible(true);</code><br>（4）创建实例对象：如果操作的是非静态属性，需要创建实例对象<br><code>Object obj = clazz.newInstance();</code> &#x2F;&#x2F;有公共的无参构造<br><code>Object obj = 构造器对象.newInstance(实参...);</code>&#x2F;&#x2F;通过特定构造器对象创建实例对象<br>（5）设置指定对象obj上此Field的属性内容<br><code>field.set(obj,&quot;属性值&quot;);</code>&#x2F;&#x2F; 如果操作静态变量，那么实例对象可以省略，用null表示<br>（6）取得指定对象obj上此Field的属性内容<br><code>Object value = field.get(obj);</code> &#x2F;&#x2F;如果操作静态变量，那么实例对象可以省略，用null表示</p>
<p><strong>关于setAccessible方法的使用：</strong></p>
<ul>
<li>Method和Field、Constructor对象都有setAccessible()方法。</li>
<li>setAccessible启动和禁用访问安全检查的开关。</li>
<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。<ul>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true。</li>
<li>使得原本无法访问的私有成员也可以访问</li>
</ul>
</li>
<li>参数值为false则指示反射的对象应该实施Java语言访问检查。</li>
</ul>
<p><strong>步骤</strong></p>
<ol>
<li>通过Class实例调用<code>.getDeclaredField(&quot;属性名&quot;);</code>,获取运行时类指定名的属性</li>
<li>setAccessible(true):确保此属性是可以访问的</li>
<li>通过Field类的实例调用get(Object obj)(获取的操作)或set(Object obj,Object value)（设置的操作）进行操作</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) class1.newInstance();</span><br><span class="line"><span class="type">Field</span> <span class="variable">nameFiled</span> <span class="operator">=</span> class1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">nameFiled.setAccessible(<span class="literal">true</span>);</span><br><span class="line">nameFiled.set(per,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"><span class="comment">// 在类变量中设置静态属性(类变量)可以set(null,&quot;value&quot;)</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">class2</span> <span class="operator">=</span> Peron.class;</span><br><span class="line"><span class="type">Field</span> <span class="variable">nameFiled</span> <span class="operator">=</span> class1.getDeclaredField(<span class="string">&quot;info&quot;</span>);</span><br><span class="line">nameFiled.setAccessible(<span class="literal">true</span>);</span><br><span class="line">nameFiled.set(<span class="literal">null</span>,<span class="string">&quot;value&quot;</span>);</span><br></pre></td></tr></table></figure>


<p><br><br></p>
<p><strong>调用指定的方法和构造器</strong></p>
<p>（1）获取该类型的Class对象<br><code>Class clazz = Class.forName(&quot;包.类名&quot;);</code><br>（2）获取方法对象<br><code>Method method = clazz.getDeclaredMethod(&quot;方法名&quot;,方法的形参类型列表);</code><br>（3）创建实例对象<br><code>Object obj = clazz.newInstance();</code><br>（4）调用方法<br><code>Object result = method.invoke(obj, 方法的实参值列表);</code></p>
<blockquote>
<p>如果方法的权限修饰符修饰的范围不可见，也可以调用setAccessible(true)<br>如果方法是静态方法，实例对象也可以省略，用null代替<br>（5）获取构造器对象<br><code>Constructor constructor= clazz.getDeclaredConstructor(形参类型列表);</code></p>
</blockquote>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Person.class;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) class1.newInstance();</span><br><span class="line">    <span class="comment">// 使用此方法必须是Person类有空参构造器，否则使用以下等价方法</span></span><br><span class="line">    <span class="comment">// Constructor constructor = class1.getDeclaredConstructor(Class args...);</span></span><br><span class="line">    <span class="comment">// constructor.setAccessible(true);</span></span><br><span class="line">    <span class="comment">// Person per = (Person) constructor.newInstance(&quot;Tom&quot;,12);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1 通过Class实例调用getDeclareMethod(methodName,Class args...)，获取指定方法</span></span><br><span class="line">    <span class="comment">// Class args指的是形参数据类型对应的Class实例</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">showNationMethod</span> <span class="operator">=</span> class1.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="comment">// 2 setAccessible(true),确保此方法可以访问</span></span><br><span class="line">    showNationMethod.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//3 通过Method实例调用invoke(Object obj,Object ..objs),即对Method对应方法的调用，其返回值即为</span></span><br><span class="line">    <span class="comment">// 对应方法的返回值，若对应方法返回值为void，则invoke()返回值为null</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> showNationMethod.invoke(per,<span class="string">&quot;CHN&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    System.out.println(returnValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h5 id="了解-应用4-读取注解信息"><a href="#了解-应用4-读取注解信息" class="headerlink" title="(了解)应用4 读取注解信息"></a>(了解)应用4 读取注解信息</h5><p><strong>注解的语法参考SuppressWarnings</strong><br>一个完整的注解应该包含三个部分：<br>（1）声明<br>（2）使用<br>（3）读取<br>声明和使用的语法参见Java-note-2 &#x3D;&gt; 常用类</p>
<p><strong>读取和处理自定义注解</strong></p>
<p>自定义注解必须配上注解的信息处理流程才有意义。<br>我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    String <span class="title function_">columnName</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">columnType</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(&#123;TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</span><br><span class="line">    String <span class="title function_">tableName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Table(tableName = &quot;Customer&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span> &#123;</span><br><span class="line">    <span class="meta">@Column(columnName = &quot;cust_name&quot;,columnType = &quot;varchar&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Column(columnName = &quot;cust_Age&quot;,columnType = &quot;int&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span> <span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Customer.class;</span><br><span class="line">        <span class="comment">// 获取类声明的注解</span></span><br><span class="line">        <span class="type">Table</span> <span class="variable">annotation</span> <span class="operator">=</span> (Table) class1.getDeclaredAnnotation(Table.class);</span><br><span class="line">        System.out.println(annotation.tableName());</span><br><span class="line">        <span class="comment">// 获取属性声明的注解</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> class1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">Column</span> <span class="variable">column</span> <span class="operator">=</span> nameField.getDeclaredAnnotation(Column.class);</span><br><span class="line">        System.out.println(column.columnName());</span><br><span class="line">        System.out.println(column.columnType());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<h5 id="重要-反射的动态性"><a href="#重要-反射的动态性" class="headerlink" title="(重要)反射的动态性"></a>(重要)反射的动态性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射的动态性1：动态的创建给定字符串对应的类的对象</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(String className)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (T) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射的动态性2：动态的创建指定字符串对应类的对象，并调用指定的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object  <span class="title function_">invoke</span><span class="params">(String className,String methodName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//动态的创建指定字符串对应类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(methodName);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 在实际开发中类名，方法名可能是写在配置文件或通过浏览器发送来的</span></span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="string">&quot;全类名&quot;</span>;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> getInstance(className);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> (String) invoke(<span class="string">&quot;全类名&quot;</span>, <span class="string">&quot;方法名&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回值为：&quot;</span> + info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>反射动态性-&gt;配置文件确定执行方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionTest</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.加载配置文件，并获取指定的fruitName值</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().getResourceAsStream(<span class="string">&quot;config.properties&quot;</span>);</span><br><span class="line">        pros.load(is);</span><br><span class="line">        <span class="type">String</span> <span class="variable">fruitStr</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;fruitName&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建指定全类名对应类的实例</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(fruitStr);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> (Fruit) constructor.newInstance();</span><br><span class="line">        <span class="comment">//3. 调用相关方法，进行测试</span></span><br><span class="line">        <span class="type">Juicer</span> <span class="variable">juicer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Juicer</span>();</span><br><span class="line">        juicer.run(fruit);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">squeeze</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">squeeze</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;榨出一杯苹果汁儿&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Orange</span> <span class="keyword">implements</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">squeeze</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;榨出一杯桔子汁儿&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Juicer</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Fruit f)</span> &#123;</span><br><span class="line">		f.squeeze();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h5 id="配置文件的设置和读取简介"><a href="#配置文件的设置和读取简介" class="headerlink" title="配置文件的设置和读取简介"></a>配置文件的设置和读取简介</h5><p>配置文件应当建立在当前Module的Src目录下，以properties为文件后缀<br>示例<br>读取user.properties文件中的数据，通过反射完成User类对象的创建及对应方法的调用。</p>
<p>配置文件user.properties内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">className:com.atguigu.bean.User</span><br><span class="line">methodName:show</span><br></pre></td></tr></table></figure>

<p>User.java文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个脉脉平台的用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReflectTest.java文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.创建Properties对象</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.加载配置文件，转换为一个集合</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;user.properties&quot;</span>);</span><br><span class="line">        pro.load(is);</span><br><span class="line">        <span class="comment">//3.获取配置文件中定义的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">//4.加载该类进内存</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        <span class="comment">//5.创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="comment">//6.获取方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">showMethod</span> <span class="operator">=</span> clazz.getMethod(methodName);</span><br><span class="line">        <span class="comment">//7.执行方法</span></span><br><span class="line">        showMethod.invoke(instance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第18章-JDK8-17新特性"><a href="#第18章-JDK8-17新特性" class="headerlink" title="第18章_JDK8-17新特性"></a>第18章_JDK8-17新特性</h3><p><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk9/">JDK9新特性</a><br><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/10/">JDK10新特性</a><br><a target="_blank" rel="noopener" href="https://openjdk.java.net/projects/jdk/17/">JDK17新特性</a><br>重要版本更新：1996 jdk1.0  2004 jdk5.0  2014 jdk8.0  2017 jdk9.0<br>长期支持版本jad8,jdk11,jdk17</p>
<ul>
<li>语法层面：<ul>
<li>比如JDK5中的自动拆箱、自动装箱、enum、泛型</li>
<li>比如JDK8中的lambda表达式、接口中的默认方法、静态方法</li>
<li>比如JDK10中局部变量的类型推断</li>
<li>比如JDK12中的switch</li>
<li>比如JDK13中的文本块</li>
</ul>
</li>
<li>API层面：<ul>
<li>比如JDK8中的Stream、Optional、新的日期时间、HashMap的底层结构</li>
<li>比如JDK9中String的底层结构</li>
<li>新的 &#x2F; 过时的 API</li>
</ul>
</li>
<li>底层优化<ul>
<li>比如JDK8中永久代被元空间替代、新的JS执行引擎</li>
<li>比如新的垃圾回收器、GC参数、JVM的优化</li>
</ul>
</li>
</ul>
<h4 id="Jdk8-Lambda表达式和方法引用"><a href="#Jdk8-Lambda表达式和方法引用" class="headerlink" title="Jdk8:Lambda表达式和方法引用"></a>Jdk8:Lambda表达式和方法引用</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727173149.png" alt="JDK8新特性"></p>
<ul>
<li>速度更快</li>
<li>代码更少(增加了新的语法：<strong>Lambda</strong> <strong>表达式</strong>)</li>
<li>强大的 <strong>Stream API</strong></li>
<li>便于并行<ul>
<li><strong>并行流</strong>就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</li>
<li>Java 8 中将并行进行了优化，我们可以很容易的对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换。</li>
</ul>
</li>
<li>最大化减少空指针异常：Optional</li>
<li>Nashorn引擎，允许在JVM上运行JS应用<ul>
<li>发音“nass-horn”，是德国二战时一个坦克的命名</li>
<li>javascript运行在jvm已经不是新鲜事了，Rhino早在jdk6的时候已经存在。现在替代Rhino，官方的解释是Rhino相比其他JavaScript引擎（比如google的V8）实在太慢了，改造Rhino还不如重写。所以Nashorn的性能也是其一个亮点。</li>
<li>Nashorn 项目在 JDK 9 中得到改进；在JDK11 中<code>Deprecated</code>，后续JDK15版本中<code>remove</code>。在JDK11中取以代之的是GraalVM。（GraalVM是一个运行时平台，它支持Java和其他基于Java字节码的语言，但也支持其他语言，如JavaScript，Ruby，Python或LLVM。性能是Nashorn的2倍以上。）</li>
</ul>
</li>
</ul>
<h5 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h5><p>Lambda表达式作为接口的实现类的对象，是一个匿名函数</p>
<p><strong>函数式接口</strong></p>
<ul>
<li>当接口中只声明了一个抽象方法(待重写的方法)，那么此接口就称为函数接口，可以使用<code>注解FunctionInterface</code>标注，有多个抽象方法的接口不得使用此注解！</li>
<li>只有给函数式接口提供实现类的对象时，才可以使用lambda表达式</li>
<li>api中的函数式接口都声明在<code>java.util.function</code>包下（jdk8中）<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727184143.png" alt="四大函数式接口"></li>
</ul>
<p><strong>Lambda表达式格式说明</strong></p>
<ol>
<li><code>-&gt;</code>是lambda操作符或箭头操作符</li>
<li><code>-&gt;</code>符号左侧为lambda形参列表，对应着要重写的接口中的抽象方法的形参列表</li>
<li><code>-&gt;</code>符号右侧为lambda体，对应着接口的实现类要重写的方法的方法体</li>
<li><code>lambda形参列表 -&gt; lambda体</code></li>
</ol>
<p><strong>Lambda表达式的写法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 语法格式一：无参，无返回值</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我爱北京天安门&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// lambda表达式</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> ()-&gt;&#123;System.out.println(<span class="string">&quot;我爱北京天安门&quot;</span>);&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式二：Lambda 需要一个参数，但是没有返回值。</span></span><br><span class="line">    Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Lambda表达式</span></span><br><span class="line"></span><br><span class="line">    Consumer&lt;String&gt; con1 = (String s)-&gt;&#123;System.out.println(s);&#125;;</span><br><span class="line">    <span class="comment">// 方法引用写法：Consumer&lt;String&gt; con1 = System.out::println;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class="line">    <span class="comment">// s类型可以推断出来的,因此上述写法进一步简化</span></span><br><span class="line">    Consumer&lt;String&gt; con2 = (s)-&gt;&#123;System.out.println(s);&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</span></span><br><span class="line">    Consumer&lt;String&gt; con3 = s-&gt;&#123;System.out.println(s);&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class="line">    Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(o2);</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，可以一并省略</span></span><br><span class="line">    Comparator&lt;Integer&gt; com3 = (o1,o2) -&gt; o1.compareTo(o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>其他常用函数式接口</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185259.png" alt="消费型接口"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185358.png" alt="供给型接口"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185434.png" alt="函数型接口1"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185543.png" alt="函数型接口2"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240727185608.png" alt="判断型接口"></p>
<p><strong>Lambda表达式语法总结</strong></p>
<ol>
<li>lambda形参列表：参数类型都可以省略，如果形参只有一个，则<code>()</code>也可以省略</li>
<li>lambda体：如果方法体只有一行执行语句，则一对<code>&#123;&#125;</code>可以省略；省略<code>&#123;&#125;</code>时若有return关键字，则必须一并省略</li>
</ol>
<h5 id="方法引用、构造器引用、数组引用"><a href="#方法引用、构造器引用、数组引用" class="headerlink" title="方法引用、构造器引用、数组引用"></a>方法引用、构造器引用、数组引用</h5><p>Lambda表达式是可以简化函数式接口的变量或形参赋值的语法。<br>方法引用和构造器引用是为了简化Lambda表达式的。</p>
<p>方法引用作为了函数式接口的实例</p>
<p><strong>方法引用的格式：类(对象) :: 类名</strong></p>
<p><strong>情况一：对象 :: 实例方法</strong><br>函数式接口中的抽象方法a与其内部实现时调用的对象的某个方法b的形参列表和返回值类型都相同或一致(满足多态或自动装箱)时,可以考虑使用方法b实现对方法a的替换、覆盖，此替换或覆盖即为方法引用</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Consumer中的void accept(T t)</span></span><br><span class="line"><span class="comment">//PrintStream中的void println(T t)</span></span><br><span class="line">Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Lambda表达式</span></span><br><span class="line">Consumer&lt;String&gt; con1 = (String s)-&gt;&#123;System.out.println(s);&#125;;</span><br><span class="line"><span class="comment">// 方法引用</span></span><br><span class="line">Consumer&lt;String&gt; con2 = System.out::println;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Supplier中的T get()</span></span><br><span class="line"><span class="comment">//Employee中的String getName()</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;tom&quot;</span>,<span class="number">10</span>);</span><br><span class="line">Supplier&lt;String&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> emp.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// lambda</span></span><br><span class="line">Supplier&lt;String&gt; sup1 = ()-&gt;emp.getName();</span><br><span class="line"><span class="comment">// 方法引用 对象emp :: 方法名 getName</span></span><br><span class="line">Supplier&lt;String&gt; sup2 = emp::getName;</span><br></pre></td></tr></table></figure>

<p><strong>情况二：类 :: 静态方法</strong><br>函数式接口中的抽象方法a与其内部实现时调用的类的某个静态方法b的形参列表和返回值类型都相同或一致(满足多态或自动装箱)时,可以考虑使用方法b实现对方法a的替换、覆盖，此替换或覆盖即为方法引用</p>
<p>注意：此时的方法b是静态方法，需要通过类调用<br>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Comparator中的int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment">//Integer中的int compare(T t1,T t2)</span></span><br><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// lambda</span></span><br><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1,o2);</span><br><span class="line"><span class="comment">// 方法引用</span></span><br><span class="line">Comparator&lt;Integer&gt; com3 = Integer :: compare;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line"><span class="comment">//Math中的Long round(Double d)</span></span><br><span class="line">Function&lt;Double,Long&gt; fun1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double aDouble)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.round(aDouble);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Function&lt;Double,Long&gt; fun2 = aDouble -&gt; Math.round(aDouble);</span><br><span class="line">Function&lt;Double,Long&gt; fun3 = Math::round;</span><br></pre></td></tr></table></figure>

<p><strong>情况三：类 :: 实例方法</strong><br>函数式接口中的抽象方法a与其内部实现时调用的类的某个方法b的返回值类型相同，同时抽象方法a中有n个参数而方法b中有除a中第一个参数外的n-1个参数时，可以考虑使用方法b实现对方法a的替换、覆盖，此替换或覆盖即为方法引用</p>
<p>注意：此方法b是非静态的方法，需要通过对象调用，但形式上写成对象a所属类调用<br>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Comparator中的int comapre(T t1,T t2)</span></span><br><span class="line"><span class="comment">// String中的int t1.compareTo(t2)</span></span><br><span class="line">Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line">Comparator&lt;Integer&gt; com3 = Integer::compareTo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line"><span class="comment">//String中的boolean t1.equals(t2)</span></span><br><span class="line">BiPredicate&lt;String,String&gt; bip1 = <span class="keyword">new</span> <span class="title class_">BiPredicate</span>&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.equals(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">BiPredicate&lt;String,String&gt; bip2 = (s,s2) -&gt; s.equals(s2);</span><br><span class="line">BiPredicate&lt;String,String&gt; bip3 = String::equals;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的T get()</span></span><br><span class="line"><span class="comment">//Employee中的String getName()</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;tom&quot;</span>,<span class="number">10</span>);</span><br><span class="line">Function&lt;Employee,String&gt; fun1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Employee,String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">apply</span><span class="params">(Employee emp)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> emp.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// lambda</span></span><br><span class="line">Function&lt;Employee,String&gt; fun2 = emp -&gt;emp.getName();</span><br><span class="line"><span class="comment">// 方法引用 类名 :: 方法名 getName</span></span><br><span class="line">Function&lt;Employee,String&gt; fun3 = Employee::getName;</span><br></pre></td></tr></table></figure>


<p><strong>构造器引用和数组引用</strong></p>
<p>格式：<code>类名::new</code><br>调用了类名对应类中的某一个确定的构造器，具体取决于函数式接口的抽象方法的形参列表（顺序个数类型）<br>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Supplier中的T get()</span></span><br><span class="line">Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用的是空参构造器</span></span><br><span class="line">Supplier&lt;Employee&gt; sup1 = Employee::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">Function&lt;Integer, Employee&gt; fun1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Employee&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">apply</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用的是构造器Employee(id)</span></span><br><span class="line">Function&lt;Integer, Employee&gt; fun2 = Employee::<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BiFunction中的R apply(T t,U u)</span></span><br><span class="line">BiFunction&lt;String, Integer, Employee&gt; bif = <span class="keyword">new</span> <span class="title class_">BiFunction</span>&lt;String, Integer, Employee&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">apply</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用的是构造器Employee(name,age)</span></span><br><span class="line">BiFunction&lt;String, Integer, Employee&gt; bif2 = Employee::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>


<p><strong>数组引用</strong><br>格式：<code>数组名[]::new</code></p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">Function&lt;Integer, Employee[]&gt; fun1 = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Integer, Employee[]&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Employee[] apply(Integer length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Function&lt;Integer, Employee[]&gt; fun2 = Employee[]::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>


<h4 id="jdk8-Stream-API-用于集合操作"><a href="#jdk8-Stream-API-用于集合操作" class="headerlink" title="jdk8: Stream API(用于集合操作)"></a>jdk8: Stream API(用于集合操作)</h4><p>关注多个数据的计算（排序、查找、过滤、映射、遍历等），面向CPU，用于集合操作</p>
<p><strong>Stream的执行流程</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240728172455.png" alt="Stream的执行流程"></p>
<ol>
<li>创建 Stream<br>一个数据源（如：集合、数组），获取一个流</li>
<li>中间操作<br>每次处理都会返回一个持有结果的新Stream，即中间操作的方法返回值仍然是Stream类型的对象。因此中间操作可以是个<code>操作链</code>，可对数据源的数据进行n次处理，但是在终结操作前，并不会真正执行。</li>
<li>终止操作(终端操作)<br>终止操作的方法返回值类型就不再是Stream了，因此一旦执行终止操作，就结束整个Stream操作了。一旦执行终止操作，就执行中间操作链，最终产生结果并结束Stream。</li>
</ol>
<p><strong>使用说明</strong></p>
<ol>
<li>Stream自己不会储存数据</li>
<li>Stream不会改变源对象，会返回一个持有结果的新Stream</li>
<li>Stream操作是延迟执行的，会等到需要结果时才执行，即一旦执行终止操作，就执行中间操作链并产生结果</li>
<li>Stream一旦执行终止操作，就不能再调用其他中间或终止操作</li>
</ol>
<h5 id="创建-Stream-的三种方法"><a href="#创建-Stream-的三种方法" class="headerlink" title="创建 Stream 的三种方法"></a>创建 Stream 的三种方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Stream方式一：通过集合</span></span><br><span class="line">List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line"><span class="comment">// default Stream&lt;E&gt; stream() : 返回一个顺序流</span></span><br><span class="line">Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line"><span class="comment">// default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span></span><br><span class="line">Stream&lt;Employee&gt; stream1 = list.parallelStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 Stream方式二：通过数组</span></span><br><span class="line">Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Arrays.stream(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建 Stream方式三：通过Stream的of()</span></span><br><span class="line">Stream&lt;String&gt; stream3 = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;vv&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br></pre></td></tr></table></figure>


<h5 id="Stream中间操作"><a href="#Stream中间操作" class="headerlink" title="Stream中间操作"></a>Stream中间操作</h5><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240728173753.png" alt="常用操作"></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter(Predicate p)——接收 Lambda ， 从流中排除某些元素。</span></span><br><span class="line"><span class="comment">//练习：查询员工表中薪资大于7000的员工信息</span></span><br><span class="line">List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">Stream&lt;Employee&gt; stream = list.stream();</span><br><span class="line">stream.filter(employee -&gt; employee.getSalary() &gt; <span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//limit(n)——截断流，使其元素不超过给定数量。</span></span><br><span class="line"><span class="comment">// 错误：stream.limit(2).forEach(System.out::println); 流已经执行终止操作</span></span><br><span class="line">list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</span></span><br><span class="line">list.stream().skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">//distinct()——筛选(去重)，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class="line">list.stream().distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//练习：获取员工姓名长度大于3的员工的姓名。   </span></span><br><span class="line">list.stream().map(Employee::getName).filter(name -&gt; name.length() &gt; <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sorted(Comparator com)——定制排序</span></span><br><span class="line"><span class="comment">//Comparator的抽象方法compare</span></span><br><span class="line">List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">list.stream().sorted((e1,e2)-&gt;e1.getAge()-e2.getAge()).forEach(System.out::println);</span><br></pre></td></tr></table></figure>


<h5 id="Stream终止操作"><a href="#Stream终止操作" class="headerlink" title="Stream终止操作"></a>Stream终止操作</h5><ul>
<li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。</li>
<li>流进行了终止操作后，不能再次使用。</li>
</ul>
<p>下列方法未标明返回值时默认返回Optional类对象，可以进一步调用get()方法恢复到原类对象<br>1-匹配与查找</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>allMatch(Predicate  p)</strong></td>
<td>检查是否匹配所有元素 True or False</td>
</tr>
<tr>
<td><strong>anyMatch(Predicate  p)</strong></td>
<td>检查是否至少匹配一个元素 True or False</td>
</tr>
<tr>
<td><strong>noneMatch(Predicate</strong>  <strong>p)</strong></td>
<td>检查是否没有匹配所有元素  True or False</td>
</tr>
<tr>
<td><strong>findFirst()</strong></td>
<td>返回第一个元素</td>
</tr>
<tr>
<td><strong>findAny()</strong></td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td><strong>count()</strong></td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td><strong>max(Comparator c)</strong></td>
<td>返回流中最大值</td>
</tr>
<tr>
<td><strong>min(Comparator c)</strong></td>
<td>返回流中最小值</td>
</tr>
<tr>
<td><strong>forEach(Consumer c)</strong></td>
<td>内部迭代(使用  Collection  接口需要用户去做迭代，称为外部迭代。<br>相反，Stream  API 使用内部迭代——它帮你把迭代做了)</td>
</tr>
</tbody></table>
<p>2-归约</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>reduce(T  identity, BinaryOperator b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回  T</td>
</tr>
<tr>
<td><strong>reduce(BinaryOperator  b)</strong></td>
<td>可以将流中元素反复结合起来，得到一个值。返回 Optional<T></td>
</tr>
</tbody></table>
<p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(list.stream().map(Employee::getSalary).reduce(Double::sum));<span class="comment">//计算员工工资</span></span><br></pre></td></tr></table></figure>

<p>3-收集</p>
<table>
<thead>
<tr>
<th><strong>方   法</strong></th>
<th><strong>描   述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>collect(Collector  c)</strong></td>
<td>将流转换为其他形式。接收一个  Collector接口的实现，<br>用于给Stream中元素做汇总的方法</td>
</tr>
</tbody></table>
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。<br>另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，具体方法与实例如下表：</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>返回类型</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>toList</strong></td>
<td>Collector&lt;T, ?, List<T>&gt;</td>
<td>把流中元素收集到List</td>
</tr>
<tr>
<td><strong>toSet</strong></td>
<td>Collector&lt;T, ?, Set<T>&gt;</td>
<td>把流中元素收集到Set</td>
</tr>
<tr>
<td><strong>toCollection</strong></td>
<td>Collector&lt;T, ?, C&gt;</td>
<td>把流中元素收集到创建的集合</td>
</tr>
<tr>
<td><strong>counting</strong></td>
<td>Collector&lt;T, ?, Long&gt;</td>
<td>计算流中元素的个数</td>
</tr>
<tr>
<td><strong>summingInt</strong></td>
<td>Collector&lt;T, ?, Integer&gt;</td>
<td>对流中元素的整数属性求和</td>
</tr>
<tr>
<td><strong>averagingInt</strong></td>
<td>Collector&lt;T, ?, Double&gt;</td>
<td>计算流中元素Integer属性的平均值</td>
</tr>
<tr>
<td><strong>summarizingInt</strong></td>
<td>Collector&lt;T, ?, IntSummaryStatistics&gt;</td>
<td>收集流中Integer属性的统计值。如：平均值</td>
</tr>
<tr>
<td><strong>joining</strong></td>
<td>Collector&lt;CharSequence, ?, String&gt;</td>
<td>连接流中每个字符串</td>
</tr>
<tr>
<td><strong>maxBy</strong></td>
<td>Collector&lt;T, ?, Optional<T>&gt;</td>
<td>根据比较器选择最大值</td>
</tr>
<tr>
<td><strong>minBy</strong></td>
<td>Collector&lt;T, ?, Optional<T>&gt;</td>
<td>根据比较器选择最小值</td>
</tr>
<tr>
<td><strong>reducing</strong></td>
<td>Collector&lt;T, ?, Optional<T>&gt;</td>
<td>从一个作为累加器的初始值开始，利用BinaryOperator与流中元素逐个结合，从而归约成单个值</td>
</tr>
<tr>
<td><strong>collectingAndThen</strong></td>
<td>Collector&lt;T,A,RR&gt;</td>
<td>包裹另一个收集器，对其结果转换函数</td>
</tr>
<tr>
<td><strong>groupingBy</strong></td>
<td>Collector&lt;T, ?, Map&lt;K, List<T>&gt;&gt;</td>
<td>根据某属性值对流分组，属性为K，结果为V</td>
</tr>
<tr>
<td><strong>partitioningBy</strong></td>
<td>Collector&lt;T, ?, Map&lt;Boolean, List<T>&gt;&gt;</td>
<td>根据true或false进行分区</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; emps= list.stream().collect(Collectors.toList());</span><br><span class="line">Set&lt;Employee&gt; emps= list.stream().collect(Collectors.toSet());</span><br><span class="line">Collection&lt;Employee&gt; emps =list.stream().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().collect(Collectors.counting());</span><br><span class="line"><span class="type">int</span> total=list.stream().collect(Collectors.summingInt(Employee::getSalary));</span><br><span class="line"><span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> list.stream().collect(Collectors.averagingInt(Employee::getSalary));</span><br><span class="line"><span class="type">int</span> SummaryStatisticsiss= list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</span><br><span class="line">String str= list.stream().map(Employee::getName).collect(Collectors.joining());</span><br><span class="line">Optional&lt;Emp&gt;max= list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</span><br><span class="line">Optional&lt;Emp&gt; min = list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</span><br><span class="line"><span class="type">int</span> total=list.stream().collect(Collectors.reducing(<span class="number">0</span>, Employee::getSalar, Integer::sum));</span><br><span class="line"><span class="type">int</span> how= list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</span><br><span class="line">Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map= list.stream().collect(Collectors.groupingBy(Employee::getStatus));</span><br><span class="line">Map&lt;Boolean,List&lt;Emp&gt;&gt; vd = list.stream().collect(Collectors.partitioningBy(Employee::getManage));</span><br></pre></td></tr></table></figure>


<h4 id="jdk9-17-语法新结构"><a href="#jdk9-17-语法新结构" class="headerlink" title="jdk9-17 语法新结构"></a>jdk9-17 语法新结构</h4><h5 id="JDK9：Java的REPL工具：-jShell命令"><a href="#JDK9：Java的REPL工具：-jShell命令" class="headerlink" title="JDK9：Java的REPL工具： jShell命令"></a>JDK9：Java的REPL工具： jShell命令</h5><p>Java 终于拥有了像Python 和 Scala 之类语言的REPL工具（交互式编程环境，read - evaluate - print - loop）：<code>jShell</code>。以交互式的方式对语句和表达式进行求值。<code>即写即得</code>、<code>快速运行</code>。<br>利用jShell在没有创建类的情况下，在命令行里直接声明变量，计算表达式，执行语句。无需跟人解释”public static void main(String[] args)”这句”废话”。</p>
<p>使用示例：<br>Powershell输入jshell，进入jshell，输入\help即可查看可执行操作</p>
<h5 id="jdk7-jdk9-异常处理"><a href="#jdk7-jdk9-异常处理" class="headerlink" title="jdk7 &amp; jdk9 异常处理"></a>jdk7 &amp; jdk9 异常处理</h5><p><strong>JDK7的新特性</strong></p>
<p>在try的后面可以增加一个()，在括号中可以声明流对象并初始化。try中的代码执行完毕，会自动把流对象释放，就不用写finally了。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例1</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (</span><br><span class="line">        <span class="comment">// 资源对象的声明和初始化</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;d:/1.txt&quot;</span>);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line">    ) &#123;</span><br><span class="line">        bw.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：<br>1、在try()中声明的资源，无论是否发生异常，无论是否处理异常，都会自动关闭资源对象，不用手动关闭了。<br>2、这些资源实现类必须实现AutoCloseable或Closeable接口，实现其中的close()方法。Closeable是AutoCloseable的子接口。Java7几乎把所有的“资源类”（包括文件IO的各种类、JDBC编程的Connection、Statement等接口…）都进行了改写，改写后资源类都实现了AutoCloseable或Closeable接口，并实现了close()方法。<br>3、写到try()中的资源类的变量默认是final声明的，不能修改。</p>
<p><strong>JDK9的新特性</strong>try-catch外定义流对象，()内只写名称</p>
<p>try的前面可以定义流对象，try后面的()中可以直接引用流对象的名称。在try代码执行完毕后，流对象也可以释放掉，也不用写finally了。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out);</span><br><span class="line">    <span class="keyword">try</span> (reader; writer) &#123;</span><br><span class="line">        <span class="comment">//reader是final的，不可再被赋值</span></span><br><span class="line">        <span class="comment">//   reader = null;</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="jdk10-局部变量类型推断-var类型名"><a href="#jdk10-局部变量类型推断-var类型名" class="headerlink" title="jdk10 局部变量类型推断 var类型名"></a>jdk10 局部变量类型推断 var类型名</h5><p><strong>JDK 10的新特性</strong></p>
<p>局部变量的显示类型声明，常常被认为是不必须的，给一个好听的名字反而可以很清楚的表达出下面应该怎样继续。本新特性允许开发人员省略通常不必要的局部变量类型声明，以增强Java语言的体验性、可读性。</p>
<ul>
<li><p>使用举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.局部变量的实例化</span></span><br><span class="line"><span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.增强for循环中的索引</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> v : list) &#123;</span><br><span class="line">    System.out.println(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.传统for循环中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 返回值类型含复杂泛型结构</span></span><br><span class="line"><span class="type">var</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line"><span class="comment">//Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator();</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>不适用场景</p>
<ul>
<li>声明一个成员变量</li>
<li>声明一个数组变量，并为数组静态初始化（省略new的情况下）</li>
<li>方法的返回值类型</li>
<li>方法的参数类型</li>
<li>没有初始化的方法内的局部变量声明</li>
<li>作为catch块中异常类型</li>
<li>Lambda表达式中函数式接口的类型</li>
<li>方法引用中函数式接口的类型</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>var不是一个关键字，而是一个类型名，将它作为变量的类型。不能使用var作为类名。</li>
<li>这不是JavaScript。var并不会改变 Java是一门静态类型语言的事实。编译器负责推断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。</li>
</ul>
<h5 id="jdk14-16-instanceof的模式匹配"><a href="#jdk14-16-instanceof的模式匹配" class="headerlink" title="jdk14(16) instanceof的模式匹配"></a>jdk14(16) instanceof的模式匹配</h5><p><strong>JDK14引入,JDK16正式可用特性：</strong></p>
<p>instanceof 模式匹配通过提供更为简便的语法，来提高生产力。有了该功能，可以<strong>减少Java程序中显式强制转换</strong>的数量，实现更精确、简洁的类型安全的代码。</p>
<p>Java 14之前旧写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj; <span class="comment">//需要强转</span></span><br><span class="line">    .. str.contains(..)..</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 14新特性写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String str)&#123;</span><br><span class="line">    .. str.contains(..)..</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="jdk-12-13-14-17-switch表达式"><a href="#jdk-12-13-14-17-switch表达式" class="headerlink" title="jdk 12,13,14 17 switch表达式"></a>jdk 12,13,14 17 switch表达式</h5><p>传统switch声明语句的弊端：</p>
<ul>
<li>匹配是自上而下的，如果忘记写break，后面的case语句不论匹配与否都会执行； —&gt;case穿透</li>
<li>所有的case语句共用一个块范围，在不同的case语句定义的变量名不能重复；</li>
<li>不能在一个case里写多个执行结果一致的条件；</li>
<li>整个switch不能作为表达式返回值；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见错误实现</span></span><br><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>|<span class="number">4</span>|<span class="number">5</span>:<span class="comment">//3|4|5 用了位运算符，11 | 100 | 101结果是 111是7</span></span><br><span class="line">        System.out.println(<span class="string">&quot;春季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>:<span class="comment">//6|7|8用了位运算符，110 | 111 | 1000结果是1111是15</span></span><br><span class="line">        System.out.println(<span class="string">&quot;夏季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>|<span class="number">10</span>|<span class="number">11</span>:<span class="comment">//9|10|11用了位运算符，1001 | 1010 | 1011结果是1011是11</span></span><br><span class="line">        System.out.println(<span class="string">&quot;秋季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>|<span class="number">1</span>|<span class="number">2</span>:<span class="comment">//12|1|2 用了位运算符，1100 | 1 | 10 结果是1111，是15</span></span><br><span class="line">        System.out.println(<span class="string">&quot;冬季&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;输入有误&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK12中预览特性：</strong></p>
<p>传统switch-case的弊端：</p>
<ol>
<li>匹配自上而下，若忘记写break，则后续case语句无论是否匹配均会执行–&gt;case穿透</li>
<li>所有的case语句共用一个块范围，不同case语句中间不可以定义同名变量</li>
<li>不能在一个case语句里写多个执行结果一致的条件</li>
<li>整个switch不能作为表达式返回值</li>
</ol>
<p>Java 12将会对switch声明语句进行扩展</p>
<ul>
<li>使用<code>case L -&gt;</code>来替代以前的<code>break;</code>，省去了 break 语句，避免了因少写 break 而出错。</li>
<li>同时将多个 case 合并到一行，显得简洁、清晰，也更加优雅的表达逻辑分支。</li>
<li>为了保持兼容性，case 条件语句中依然可以使用字符<code> :</code> ，但是同一个 switch 结构里不能混用<code> -&gt;</code> 和<code> :</code> ，否则编译错误。</li>
<li>可以返回switch整体的结果，但只适用于只有返回语句的情况，如同一case条件下还需执行其他语句，必须使用yield关键字</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> Fruit.GRAPE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numberOfLetters</span> <span class="operator">=</span> <span class="keyword">switch</span>(fruit)&#123;</span><br><span class="line">        <span class="keyword">case</span> PEAR -&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> APPLE,MANGO,GRAPE -&gt; <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> ORANGE,PAPAYA -&gt; <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Such Fruit:&quot;</span> + fruit);</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(numberOfLetters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK13进一步拓展yield</strong></p>
<p>关键字yield用于返回指定数据，结束switch结构，当switch表达式(有返回值)应该使用yield，不返回值使用break；其与return的区别在于return会直接退出当前方法，yield只会结束switch块</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> Fruit.GRAPE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numberOfLetters</span> <span class="operator">=</span> <span class="keyword">switch</span>(fruit)&#123;</span><br><span class="line">        <span class="keyword">case</span> PEAR -&gt; &#123;<span class="keyword">yield</span> <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> APPLE,MANGO,GRAPE -&gt; &#123;<span class="keyword">yield</span> <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> ORANGE,PAPAYA -&gt; &#123;<span class="keyword">yield</span> <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Such Fruit:&quot;</span> + fruit);</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(numberOfLetters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK14后上述两个特性正式可用</strong></p>
<p><strong>JDK17(预览) switch的模式匹配</strong></p>
<p>预览特性必须使用preview标注的jdk17<br>旧写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">formatter</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">formatted</span> <span class="operator">=</span> <span class="string">&quot;unknown&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Integer i) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Long l) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Double d) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">        formatted = String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> formatted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>模式匹配新写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">formatterPatternSwitch</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (o) &#123;</span><br><span class="line">        <span class="keyword">case</span> Integer i -&gt; String.format(<span class="string">&quot;int %d&quot;</span>, i);</span><br><span class="line">        <span class="keyword">case</span> Long l    -&gt; String.format(<span class="string">&quot;long %d&quot;</span>, l);</span><br><span class="line">        <span class="keyword">case</span> Double d  -&gt; String.format(<span class="string">&quot;double %f&quot;</span>, d);</span><br><span class="line">        <span class="keyword">case</span> String s  -&gt; String.format(<span class="string">&quot;String %s&quot;</span>, s);</span><br><span class="line">        <span class="keyword">default</span>        -&gt; o.toString();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接在 switch 上支持 Object 类型，这就等于同时支持多种类型，使用模式匹配得到具体类型，大大简化了语法量，这个功能很实用。</p>
<h5 id="jdk13-14-15-文本块"><a href="#jdk13-14-15-文本块" class="headerlink" title="jdk13,14,15 文本块"></a>jdk13,14,15 文本块</h5><p>现实问题：<br>在Java中，通常需要使用String类型表达HTML，XML，SQL或JSON等格式的字符串，在进行字符串赋值时需要进行转义和连接操作，然后才能编译该代码，这种表达方式难以阅读并且难以维护。</p>
<p><strong>JDK13的新特性</strong><br>使用”””作为文本块的开始符和结束符，在其中就可以放置多行的字符串，不需要进行任何转义。因此，文本块将提高Java程序的可读性和可写性。</p>
<p>基本使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">//相当于：</span></span><br><span class="line"><span class="string">&quot;line1\nline2\nline3\n&quot;</span></span><br><span class="line"><span class="comment">//或者一个连接的字符串：</span></span><br><span class="line"><span class="string">&quot;line1\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;line2\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;line3\n&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果字符串末尾不需要行终止符，则结束分隔符可以放在最后一行内容上。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">line1</span></span><br><span class="line"><span class="string">line2</span></span><br><span class="line"><span class="string">line3&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">//相当于 </span></span><br><span class="line"><span class="string">&quot;line1\nline2\nline3&quot;</span></span><br></pre></td></tr></table></figure>

<p>文本块可以表示空字符串，但不建议这样做，因为它需要两行源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">empty</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>示例：html的文本块表示</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello, 尚硅谷<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>将其复制到Java的字符串中，会展示成以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&lt;html&gt;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    &lt;body&gt;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;        &lt;p&gt;Hello, 尚硅谷&lt;/p&gt;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;    &lt;/body&gt;\n&quot;</span> +</span><br><span class="line"><span class="string">&quot;&lt;/html&gt;\n&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>即被自动进行了转义，这样的字符串看起来不是很直观，在JDK 13中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;Hello, world&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>普通多行文本，sql语句，json语句均可使用此方法</p>
<p><strong>JDK14中二次预览特性</strong><br>JDK14的版本主要增加了两个escape sequences，分别是<code> \ &lt;line-terminator&gt;</code>与<code>\s  escape sequence</code>。</p>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            SELECT id,NAME,email</span></span><br><span class="line"><span class="string">            FROM customers</span></span><br><span class="line"><span class="string">            WHERE id &gt; 4</span></span><br><span class="line"><span class="string">            ORDER BY email DESC</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>;</span><br><span class="line">    System.out.println(sql1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// \:取消换行操作</span></span><br><span class="line">    <span class="comment">// \s:表示一个空格</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">            SELECT id,NAME,email \</span></span><br><span class="line"><span class="string">            FROM customers\s\</span></span><br><span class="line"><span class="string">            WHERE id &gt; 4 \</span></span><br><span class="line"><span class="string">            ORDER BY email DESC</span></span><br><span class="line"><span class="string">            &quot;&quot;&quot;</span>;</span><br><span class="line">    System.out.println(sql2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK15中功能转正</strong></p>
<h5 id="jdk14-15-16-record数据类型"><a href="#jdk14-15-16-record数据类型" class="headerlink" title="jdk14,15,16 record数据类型"></a>jdk14,15,16 record数据类型</h5><p><code>背景</code><br>开发人员想要创建纯数据载体类（plain data carriers）通常都必须编写大量低价值、重复的、容易出错的代码。如：构造函数、getter&#x2F;setter、equals()、hashCode()以及toString()等。以至于很多人选择使用IDE的功能来自动生成这些代码。还有一些开发会选择使用一些第三方类库，如Lombok等来生成这些方法。</p>
<p><strong>JDK14中预览特性：record</strong>实现一个简单的数据载体类，为了避免编写：构造函数，访问器，equals()，hashCode () ，toString ()等，Java 14推出record。</p>
<p><code>record</code> 是一种全新的类型，其父类是<code>java.lang.Record</code>，不可再继承父类，它本质上是一个 <code>final</code> 类，同时所有的属性都是 <code>final</code> 修饰，它会自动编译出 <code>public get</code> 、<code>hashcode</code> 、<code>equals</code>、<code>toString</code>、构造器等结构，减少了代码编写量。<br>具体来说：当你用<code>record</code> 声明一个类时，该类将自动拥有以下功能：</p>
<ul>
<li>获取成员变量的简单方法，比如例题中的 name() 和 partner() 。注意区别于我们平常getter()的写法。</li>
<li>一个 equals 方法的实现，执行比较时会比较该类的所有成员属性。</li>
<li>重写 hashCode() 方法。</li>
<li>一个可以打印该类所有成员属性的 toString() 方法。</li>
<li>只有一个构造方法。</li>
</ul>
<p>此外：</p>
<ul>
<li>还可以在record声明的类中定义<strong>静态字段、静态方法、构造器或实例方法</strong>。</li>
<li>不能在record声明的类中定义实例字段；类不能声明为abstract；不能声明显式的父类等。</li>
</ul>
<p>举例1（旧写法）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    Point(<span class="type">int</span> x, <span class="type">int</span> y) &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">x</span><span class="params">()</span> &#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">y</span><span class="params">()</span> &#123;<span class="keyword">return</span> y;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Point)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">other</span> <span class="operator">=</span> (Point) o;</span><br><span class="line">        <span class="keyword">return</span> other.x == x &amp;&amp; other.y == y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Point&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;x=&quot;</span> + x +</span><br><span class="line">                <span class="string">&quot;, y=&quot;</span> + y +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Point</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>JDK15中第二次预览特性</strong><br><strong>JDK16中转正特性</strong></p>
<p><code>记录不适合哪些场景</code><br>record的设计目标是提供一种将数据建模为数据的好方法。它也不是 JavaBeans 的直接替代品，因为record的方法不符合 JavaBeans 的 get 标准。另外 JavaBeans 通常是可变的，而记录是不可变的。尽管它们的用途有点像，但记录并不会以某种方式取代 JavaBean。</p>
<h5 id="jdk15-16-17-密封类"><a href="#jdk15-16-17-密封类" class="headerlink" title="jdk15,16,17 密封类"></a>jdk15,16,17 密封类</h5><p>背景：</p>
<p>在 Java 中如果想让一个类不能被继承和修改，这时我们应该使用 <code>final</code> 关键字对类进行修饰。不过这种要么可以继承，要么不能继承(final修饰)的机制不够灵活，有些时候我们可能想让某个类可以被某些类型继承，但是又不能随意继承，是做不到的。Java 15 尝试解决这个问题，引入了 <code>sealed</code> 类，被 <code>sealed</code> 修饰的类可以指定子类。这样这个类就只能被指定的类继承。</p>
<p><strong>JDK15的预览特性：</strong><br>通过密封的类和接口来限制超类的使用，密封的类和接口限制其它可能继承或实现它们的其它类或接口。<br>具体使用：</p>
<ul>
<li>使用修饰符<code>sealed</code>，可以将一个类声明为密封类。密封的类使用保留关键字<code>permits</code>列出可以直接扩展（即extends）它的类。</li>
<li><code>sealed</code> 修饰的类的机制具有传递性，它的**子类必须使用(不可省略!)**指定的关键字进行修饰，且只能是 <code>final</code>、<code>sealed</code>、<code>non-sealed</code> 三者之一。</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> Circle, Rectangle, Square &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;...&#125; <span class="comment">//final表示Circle不能再被继承了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> <span class="keyword">permits</span> TransparentRectangle, FilledRectangle &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TransparentRectangle</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FilledRectangle</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> &#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">non-sealed</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;...&#125; <span class="comment">//non-sealed表示可以允许任何类继承，不可以省略</span></span><br></pre></td></tr></table></figure>

<p><strong>JDK16二次预览特性</strong><br><strong>JDK17中转正特性</strong></p>
<h4 id="jdk9-17-API"><a href="#jdk9-17-API" class="headerlink" title="jdk9-17 API"></a>jdk9-17 API</h4><h5 id="jdk8-Optional类"><a href="#jdk8-Optional类" class="headerlink" title="jdk8 Optional类"></a>jdk8 Optional类</h5><p><strong>JDK8的新特性</strong></p>
<p>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，Google在著名的Guava项目引入了Optional类，通过检查空值的方式避免空指针异常。受到Google的启发，Optional类已经成为Java 8类库的一部分。<code>Optional&lt;T&gt;</code> 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。如果值存在，则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<ol>
<li><code>创建Optional类对象的方法：</code></li>
</ol>
<ul>
<li>static <T> Optional<T> empty() ：用来创建一个空的Optional实例</li>
<li>static <T> Optional<T> of(T value) ：用来创建一个Optional实例，value必须非空</li>
<li><code>static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code> ：用来创建一个Optional实例，value可能是空，也可能非空</li>
</ul>
<ol start="2">
<li><code>判断Optional容器中是否包含对象：</code></li>
</ol>
<ul>
<li>boolean isPresent() : 判断Optional容器中的值是否存在</li>
<li>void ifPresent(Consumer&lt;? super T&gt; consumer) ：判断Optional容器中的值是否存在，如果存在，就对它进行Consumer指定的操作，如果不存在就不做</li>
</ul>
<ol start="3">
<li><code>获取Optional容器的对象：</code></li>
</ol>
<ul>
<li>T get(): 如果调用对象包含值，返回该值。否则抛异常。T get()与of(T value)配合使用</li>
<li><code>T orElse(T other) </code>：orElse(T other) 与ofNullable(T value)配合使用，如果Optional容器中非空，就返回所包装值，如果为空，就用orElse(T other)other指定的默认值（备胎）代替</li>
<li>T orElseGet(Supplier&lt;? extends T&gt; other) ：如果Optional容器中非空，就返回所包装值，如果为空，就用Supplier接口的Lambda表达式提供的值代替</li>
<li>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果Optional容器中非空，就返回所包装值，如果为空，就抛出你指定的异常类型代替原来的NoSuchElementException</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;lllll&quot;</span>;</span><br><span class="line">    string = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//1. 实例化</span></span><br><span class="line">    Optional&lt;String&gt; optional = Optional.ofNullable(string);</span><br><span class="line">    <span class="type">String</span> <span class="variable">string3</span> <span class="operator">=</span> <span class="string">&quot;ggggg&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">finallystr</span> <span class="operator">=</span> optional.orElse(string3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>这是JDK9-11的新特性</strong></p>
<table>
<thead>
<tr>
<th><strong>新增方法</strong></th>
<th><strong>描述</strong></th>
<th><strong>新增的版本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>boolean isEmpty()</td>
<td>判断value是否为空</td>
<td>JDK  11</td>
</tr>
<tr>
<td>ifPresentOrElse(Consumer&lt;? super T&gt; action, Runnable emptyAction)</td>
<td>value非空，执行参数1功能；如果value为空，执行参数2功能</td>
<td>JDK  9</td>
</tr>
<tr>
<td>Optional<T> or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</td>
<td>value非空，返回对应的Optional；value为空，返回形参封装的Optional</td>
<td>JDK  9</td>
</tr>
<tr>
<td>Stream<T> stream()</td>
<td>value非空，返回仅包含此value的Stream；否则，返回一个空的Stream</td>
<td>JDK  9</td>
</tr>
<tr>
<td>T orElseThrow()</td>
<td>value非空，返回value；否则抛异常NoSuchElementException</td>
<td>JDK  10</td>
</tr>
</tbody></table>
<h5 id="jdk9-（了解）String存储结构和API变更"><a href="#jdk9-（了解）String存储结构和API变更" class="headerlink" title="jdk9+（了解）String存储结构和API变更"></a>jdk9+（了解）String存储结构和API变更</h5><p><strong>这是JDK9的新特性。</strong><br>String 再也不用 char[] 来存储啦，改成了 byte[] 加上编码标记，节约了一些空间。</p>
<p>拓展：StringBuffer 与 StringBuilder<br>那StringBuffer 和 StringBuilder 是否仍无动于衷呢？</p>
<blockquote>
<p>String-related classes such as AbstractStringBuilder, StringBuilder, and StringBuffer will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p>
</blockquote>
<p><strong>JDK11新特性：新增了一系列字符串处理方法</strong></p>
<table>
<thead>
<tr>
<th><strong>描述</strong></th>
<th><strong>举例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>判断字符串是否为空白</td>
<td>“  “.isBlank(); &#x2F;&#x2F; true</td>
</tr>
<tr>
<td>去除首尾空白</td>
<td>“  Javastack “.strip(); &#x2F;&#x2F; “Javastack”</td>
</tr>
<tr>
<td>去除尾部空格</td>
<td>“  Javastack “.stripTrailing(); &#x2F;&#x2F; “ Javastack”</td>
</tr>
<tr>
<td>去除首部空格</td>
<td>“  Javastack “.stripLeading(); &#x2F;&#x2F; “Javastack “</td>
</tr>
<tr>
<td>复制字符串</td>
<td>“Java”.repeat(3);&#x2F;&#x2F;  “JavaJavaJava”</td>
</tr>
<tr>
<td>行数统计</td>
<td>“A\nB\nC”.lines().count();  &#x2F;&#x2F; 3</td>
</tr>
</tbody></table>
<p><strong>JDK12新特性：String 实现了 Constable 接口</strong></p>
<p>String源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence,Constable, ConstantDesc &#123;</span><br></pre></td></tr></table></figure>

<p>java.lang.constant.Constable接口定义了抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Constable</span> &#123;</span><br><span class="line">	Optional&lt;? <span class="keyword">extends</span> <span class="title class_">ConstantDesc</span>&gt; describeConstable();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 12 String 的实现源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns an &#123;<span class="doctag">@link</span> Optional&#125; containing the nominal descriptor for this</span></span><br><span class="line"><span class="comment"> * instance, which is the instance itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@link</span> Optional&#125; describing the &#123;<span class="doctag">@linkplain</span> String&#125; instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title function_">describeConstable</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Optional.of(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单，其实就是调用 Optional.of 方法返回一个 Optional 类型。</p>
<p><strong>JDK12新特性：String新增方法</strong></p>
<p>String的transform(Function)</p>
<h5 id="JDK17-标记删除Applet-API"><a href="#JDK17-标记删除Applet-API" class="headerlink" title="JDK17 标记删除Applet API"></a>JDK17 标记删除Applet API</h5><p>Applet API 提供了一种将 Java AWT&#x2F;Swing 控件嵌入到浏览器网页中的方法。不过，目前 Applet 已经被淘汰。大部分人可能压根就没有用过 Applet。Applet API 实际上是无用的，因为所有 Web 浏览器供应商都已删除或透露计划放弃对 Java 浏览器插件的支持。Java 9 的时候，Applet API 已经被标记为过时，Java 17 的时候终于标记为删除了。</p>
<p>具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.applet.Applet</span><br><span class="line">java.applet.AppletStub</span><br><span class="line">java.applet.AppletContext</span><br><span class="line">java.applet.AudioClip</span><br><span class="line">javax.swing.JApplet</span><br><span class="line">java.beans.AppletInitializer</span><br></pre></td></tr></table></figure>

<h4 id="其它结构变化"><a href="#其它结构变化" class="headerlink" title="其它结构变化"></a>其它结构变化</h4><h5 id="JDK9：UnderScore-下划线-使用的限制"><a href="#JDK9：UnderScore-下划线-使用的限制" class="headerlink" title="JDK9：UnderScore(下划线)使用的限制"></a>JDK9：UnderScore(下划线)使用的限制</h5><p>在java 8 中，标识符可以独立使用“_”来命名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">_</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(_);</span><br></pre></td></tr></table></figure>
<p>但是，在java 9 中规定“_”不再可以单独命名标识符了，如果使用，会报错：</p>
<h5 id="JDK11：更简化的编译运行程序"><a href="#JDK11：更简化的编译运行程序" class="headerlink" title="JDK11：更简化的编译运行程序"></a>JDK11：更简化的编译运行程序</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编译</span></span><br><span class="line">javac JavaStack.java</span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">java JavaStack</span><br></pre></td></tr></table></figure>

<p>我们的认知里，要运行一个 Java 源代码必须先编译，再运行。而在 Java 11 版本中，通过一个 java 命令就直接搞定了，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java JavaStack.java</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li>执行源文件中的第一个类，第一个类必须包含主方法。</li>
</ul>
<h5 id="GC方面新特性"><a href="#GC方面新特性" class="headerlink" title="GC方面新特性"></a>GC方面新特性</h5><p>GC是Java主要优势之一。 然而，当GC停顿太长，就会开始影响应用的响应时间。随着现代系统中内存不断增长，用户和程序员希望JVM能够以高效的方式充分利用这些内存， 并且无需长时间的GC暂停时间。</p>
<h6 id="G1-GC"><a href="#G1-GC" class="headerlink" title="G1 GC"></a>G1 GC</h6><p>JDK9以后默认的垃圾回收器是G1GC。</p>
<p><strong>JDK10 : 为G1提供并行的Full GC</strong></p>
<p>G1最大的亮点就是可以尽量的避免full gc。但毕竟是“尽量”，在有些情况下，G1就要进行full gc了，比如如果它无法足够快的回收内存的时候，它就会强制停止所有的应用线程然后清理。</p>
<p>在Java10之前，一个单线程版的标记-清除-压缩算法被用于full gc。为了尽量减少full gc带来的影响，在Java10中，就把之前的那个单线程版的标记-清除-压缩的full gc算法改成了支持多个线程同时full gc。这样也算是减少了full gc所带来的停顿，从而提高性能。</p>
<p>你可以通过<code>-XX:ParallelGCThreads</code>参数来指定用于并行GC的线程数。</p>
<p><strong>JDK12：可中断的 G1 Mixed GC</strong><br><strong>JDK12：增强G1，自动返回未用堆内存给操作系统</strong></p>
<h6 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h6><p><strong>JDK12：Shenandoah GC：低停顿时间的GC</strong></p>
<p>Shenandoah 垃圾回收器是 Red Hat 在 2014 年宣布进行的一项垃圾收集器研究项目 Pauseless GC 的实现，旨在<strong>针对 JVM 上的内存收回实现低停顿的需求</strong>。<br>据 Red Hat 研发 Shenandoah 团队对外宣称，Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200 MB 还是 200 GB，都将拥有一致的系统暂停时间，不过实际使用性能将取决于实际工作堆的大小和工作负载。<br>Shenandoah GC 主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等。<br>这是一个实验性功能，不包含在默认（Oracle）的OpenJDK版本中。</p>
<p><strong>JDK15：Shenandoah垃圾回收算法转正</strong></p>
<p>Shenandoah垃圾回收算法终于从实验特性转变为产品特性，这是一个从 JDK 12 引入的回收算法，该算法通过与正在运行的 Java 线程同时进行疏散工作来减少 GC 暂停时间。Shenandoah 的暂停时间与堆大小无关，无论堆栈是 200 MB 还是 200 GB，都具有相同的一致暂停时间。<br>Shenandoah在JDK12被作为experimental引入，在JDK15变为Production；之前需要通过<code>-XX:+UnlockExperimentalVMOptions</code> <code>-XX:+UseShenandoahGC</code>来启用，现在只需要<code>-XX:+UseShenandoahGC</code>即可启用</p>
<h6 id="革命性的-ZGC"><a href="#革命性的-ZGC" class="headerlink" title="革命性的 ZGC"></a>革命性的 ZGC</h6><p><strong>JDK11：引入革命性的 ZGC</strong></p>
<p>ZGC，这应该是JDK11最为瞩目的特性，没有之一。<br>ZGC是一个并发、基于region、压缩型的垃圾收集器。<br>ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存），或压缩堆。</p>
<p><strong>JDK13：ZGC:将未使用的堆内存归还给操作系统</strong><br><strong>JDK14：ZGC on macOS和windows</strong></p>
<ul>
<li><p>JDK14之前，ZGC仅Linux才支持。现在mac或Windows上也能使用ZGC了，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</span><br></pre></td></tr></table></figure></li>
<li><p>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在<code>十毫秒以内</code>的低延迟。</p>
</li>
</ul>
<p><strong>JDK15：ZGC 功能转正</strong><br>ZGC是Java 11引入的新的垃圾收集器，经过了多个实验阶段，自此终于成为正式特性。<br>但是这并不是替换默认的GC，默认的GC仍然还是G1；之前需要通过<code>-XX:+UnlockExperimentalVMOptions</code>、<code> -XX:+UseZGC</code>来启用ZGC，现在只需要<code>-XX:+UseZGC</code>就可以。相信不久的将来它必将成为默认的垃圾回收器。</p>
<blockquote>
<p>ZGC的性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将成为服务端、大内存、低延迟应用的首选垃圾收集器。</p>
</blockquote>
<p>怎么形容Shenandoah和ZGC的关系呢？异同点大概如下：</p>
<ul>
<li>相同点：性能几乎可认为是相同的</li>
<li>不同点：ZGC是Oracle JDK的，根正苗红。而Shenandoah只存在于OpenJDK中，因此使用时需注意你的JDK版本</li>
</ul>
<p><strong>JDK16：ZGC 并发线程处理</strong></p>
<p>在线程的堆栈处理过程中，总有一个制约因素就是safepoints。在safepoints这个点，Java的线程是要暂停执行的，从而限制了GC的效率。</p>
<blockquote>
<p>我们都知道，在之前，需要 GC 的时候，为了进行垃圾回收，需要所有的线程都暂停下来，这个暂停的时间我们称为 <strong>Stop The World</strong>。<br>而为了实现 STW 这个操作， JVM 需要为每个线程选择一个点停止运行，这个点就叫做<strong>安全点（Safepoints）</strong>。<br>而ZGC的并发线程堆栈处理可以保证Java线程可以在GC safepoints的同时可以并发执行。它有助于提高所开发的Java软件应用程序的性能和效率。</p>
</blockquote>
<h4 id="小结与展望"><a href="#小结与展望" class="headerlink" title="小结与展望"></a>小结与展望</h4><p>随着云计算和 AI 等技术浪潮，当前的计算模式和场景正在发生翻天覆地的变化，不仅对 Java 的发展速度提出了更高要求，也深刻影响着 Java 技术的发展方向。<strong>传统的大型企业或互联网应用，正在被云端、容器化应用、模块化的微服务甚至是函数(FaaS， Function-as-a-Service)所替代。</strong><br><strong>Java 需要在新的计算场景下，改进开发效率。</strong>比如，Java 代码虽然进行了一些类型推断等改进，更易用的集合 API 等，但仍然给开发者留下了过于刻板、形式主义的印象，这是一个长期的改进方向。<br>Java虽然标榜面向对象编程，却毫不顾忌的加入<code>面向接口编程思想</code>，又扯出<code>匿名对象</code>的概念，每增加一个新的东西，对Java的根本（面向对象思想）的一次冲击。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> Java基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/06/24/Java-Note3-%E5%BC%82%E5%B8%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9B%86%E5%90%88%E6%B3%9B%E5%9E%8B%E5%B8%B8%E8%A7%81%E7%B1%BB/" rel="prev" title="Java-Note3-异常多线程集合泛型常见类">
                  <i class="fa fa-angle-left"></i> Java-Note3-异常多线程集合泛型常见类
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/07/15/Java-Note5-%E6%80%BB%E7%BB%93/" rel="next" title="Java-Note5-总结">
                  Java-Note5-总结 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments giscus-container">
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Shearington</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">445k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">24:44</span>
  </span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"Fushiye/Fushiye.github.io","repo_id":"R_kgDOLyiTvA","category":"Announcements","category_id":"DIC_kwDOLyiTvM4CteAo","mapping":"title","strict":0,"reactions_enabled":1,"emit_metadata":0,"theme":"light","lang":"zh-CN","crossorigin":"anonymous","input_position":"top","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
