<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_apple-touch-icon-human.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_human_32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_human_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fushiye.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism-darcula","dark":"prism-darcula"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"giscus","storage":true,"lazyload":false,"nav":null,"activeClass":"giscus"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":3,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="Spring Framework学习过程中记录的笔记，仅供参考，如有错漏，敬请指正!">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-SSM-Spring">
<meta property="og:url" content="https://fushiye.github.io/2024/08/16/Java-SSM-Spring/index.html">
<meta property="og:site_name" content="星海拾贝">
<meta property="og:description" content="Spring Framework学习过程中记录的笔记，仅供参考，如有错漏，敬请指正!">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816124456.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816131256.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816143429.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816144616.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816151122.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816212321.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240903185007.png">
<meta property="og:image" content="d:\workinenglish\typora_image\image-20241215223558541.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241215223026.png">
<meta property="og:image" content="d:\workinenglish\typora_image\image-20241215225746983.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241221195755.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241221182630.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250315203853.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241221200248.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241221232640.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241222200256.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241218220858.png">
<meta property="article:published_time" content="2024-08-15T16:05:46.000Z">
<meta property="article:modified_time" content="2025-03-15T12:39:07.297Z">
<meta property="article:author" content="Shearington">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816124456.png">


<link rel="canonical" href="https://fushiye.github.io/2024/08/16/Java-SSM-Spring/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://fushiye.github.io/2024/08/16/Java-SSM-Spring/","path":"2024/08/16/Java-SSM-Spring/","title":"Java-SSM-Spring"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java-SSM-Spring | 星海拾贝</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">星海拾贝</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探索永无止境</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">基本介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%94%E8%AE%B0%E8%AF%B4%E6%98%8E"><span class="nav-number">1.1.</span> <span class="nav-text">笔记说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%94%E8%AE%B0%E5%B9%B3%E5%8F%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text">笔记平台</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">1.1.2.</span> <span class="nav-text">参考资料</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">技术体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E4%BD%93%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB"><span class="nav-number">1.2.1.</span> <span class="nav-text">总体技术体系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%86%E6%9E%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.2.2.</span> <span class="nav-text">框架的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.2.3.</span> <span class="nav-text">Spring基本介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E5%92%8CSpringFramework%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">Spring和SpringFramework的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringFramework%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">SpringFramework主要功能模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringFramework%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">SpringFramework的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring%E6%A1%86%E6%9E%B6%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">Spring框架企业级应用开发的三层架构模式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8-IoC"><span class="nav-number">2.</span> <span class="nav-text">容器: IoC</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-IoC%E5%AE%B9%E5%99%A8%E5%92%8C%E5%AE%B9%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">Spring IoC容器和容器实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SpringIoC%E5%AE%B9%E5%99%A8"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">SpringIoC容器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#SpringIoC-%E5%AE%B9%E5%99%A8%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="nav-number">2.1.1.1.1.</span> <span class="nav-text">SpringIoC 容器接口和实现类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Spring-IoC-DI-%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.1.1.2.</span> <span class="nav-text">Spring IoC &#x2F; DI 概念</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-IoC-DI-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.1.2.</span> <span class="nav-text">Spring IoC&#x2F;DI 实现步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EXML%E7%9A%84%E7%BB%84%E4%BB%B6%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">2.2.</span> <span class="nav-text">基于XML的组件管理配置方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6-Bean-%E4%BF%A1%E6%81%AF%E5%A3%B0%E6%98%8E%E9%85%8D%E7%BD%AE-IoC"><span class="nav-number">2.2.1.</span> <span class="nav-text">组件(Bean)信息声明配置(IoC)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">基于无参构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">基于工厂模式的</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82"><span class="nav-number">2.2.1.3.1.</span> <span class="nav-text">静态工厂</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82"><span class="nav-number">2.2.1.3.2.</span> <span class="nav-text">非静态工厂</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EFactoryBean%E6%A0%87%E5%87%86%E5%B7%A5%E5%8E%82%E6%8E%A5%E5%8F%A3%E7%9A%84"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">基于FactoryBean标准工厂接口的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89%E9%85%8D%E7%BD%AE"><span class="nav-number">2.2.2.</span> <span class="nav-text">组件的依赖注入（DI）配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">基于构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%B8%AA%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0"><span class="nav-number">2.2.2.1.1.</span> <span class="nav-text">单个构造参数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E5%8F%82%E6%95%B0"><span class="nav-number">2.2.2.1.2.</span> <span class="nav-text">多个构造参数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ESetter%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">基于Setter方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IoC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.3.</span> <span class="nav-text">IoC容器的创建和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAIoC%E5%AE%B9%E5%99%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">创建IoC容器的方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96bean%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">获取bean的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.4.</span> <span class="nav-text">组件Bean的作用域和周期方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">周期方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">组件的作用域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FactoryBean%E7%89%B9%E6%80%A7%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.5.</span> <span class="nav-text">FactoryBean特性和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FactoryBean%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.5.1.</span> <span class="nav-text">FactoryBean的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%EF%BC%9AFactoryBean%E5%92%8CBeanFactory%E5%8C%BA%E5%88%AB"><span class="nav-number">2.2.5.2.</span> <span class="nav-text">面试：FactoryBean和BeanFactory区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3-XML%E7%9A%84%E7%BB%84%E4%BB%B6%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">2.3.</span> <span class="nav-text">基于注解+XML的组件管理配置方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%A0%87%E8%AE%B0%E7%BB%84%E4%BB%B6"><span class="nav-number">2.3.1.</span> <span class="nav-text">步骤1：使用注解标记组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E5%90%8D%E7%A7%B0-id"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">组件的名称(id)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A42%EF%BC%9AXML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E5%AE%9A%E6%89%AB%E6%8F%8F%E8%8C%83%E5%9B%B4"><span class="nav-number">2.3.2.</span> <span class="nav-text">步骤2：XML配置文件指定扫描范围</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%85%E5%86%B51%EF%BC%9A%E5%85%A8%E5%8C%85%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E9%85%8D%E7%BD%AE"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">情况1：全包注解扫描配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%85%E5%86%B52%EF%BC%9A%E6%8E%92%E9%99%A4%E5%8C%85%E4%B8%8B%E6%9F%90%E4%BA%9B%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">情况2：排除包下某些注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%83%85%E5%86%B53%EF%BC%9A%E4%BB%85%E9%99%90%E5%8C%85%E4%B8%8B%E6%9F%90%E4%BA%9B%E6%B3%A8%E8%A7%A3"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">情况3：仅限包下某些注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E5%AE%9A%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">2.3.3.</span> <span class="nav-text">指定周期方法和作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DI%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9A%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC"><span class="nav-number">2.3.4.</span> <span class="nav-text">DI依赖注入：组件属性赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%85%A5"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">引用类型注入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Autowired-Qualified-value-%E2%80%9Cid%E2%80%9D-%E6%B3%A8%E8%A7%A3%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="nav-number">2.3.4.1.1.</span> <span class="nav-text">@Autowired + @Qualified(value &#x3D; “id”)注解自动装配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Resource-name-%E2%80%9Cid%E2%80%9D-%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="nav-number">2.3.4.1.2.</span> <span class="nav-text">@Resource(name &#x3D; “id”)自动装配</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%85%A5"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">基本数据类型注入</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%85%8D%E7%BD%AE%E7%B1%BB-%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%8C%E5%85%A8%E6%B3%A8%E8%A7%A3%E7%BB%84%E4%BB%B6%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="nav-number">2.4.</span> <span class="nav-text">基于配置类+注解的完全注解组件管理配置方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.4.1.</span> <span class="nav-text">配置类的创建步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%88%9B%E5%BB%BAIoC%E5%AE%B9%E5%99%A8%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%BB%84%E4%BB%B6"><span class="nav-number">2.4.2.</span> <span class="nav-text">使用配置类创建IoC容器并获取组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E8%AF%B4%E6%98%8E%EF%BC%9A%E5%90%8D%E7%A7%B0%E3%80%81%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81-import"><span class="nav-number">2.4.3.</span> <span class="nav-text">附加说明：名称、周期方法、作用域、@import</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">AOP面向切面编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP%E6%80%9D%E6%83%B3%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.1.</span> <span class="nav-text">AOP思想介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-number">3.1.1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.2.</span> <span class="nav-text">解决方案 - 代理模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.3.</span> <span class="nav-text">动态代理模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B-1"><span class="nav-number">3.1.4.</span> <span class="nav-text">AOP面向切面编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AOP%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">AOP应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOP%E7%9A%84%E5%85%AB%E4%B8%AA%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">AOP的八个专业术语</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-AOP-%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6"><span class="nav-number">3.2.</span> <span class="nav-text">Spring AOP(技术框架)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0AOP"><span class="nav-number">3.2.1.</span> <span class="nav-text">基于注解方式实现AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">基本配置流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%8A%9F%E8%83%BD"><span class="nav-number">3.2.1.1.1.</span> <span class="nav-text">注解及其功能</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E7%9B%AE%E6%A0%87%E6%96%B9%E6%B3%95%E4%BF%A1%E6%81%AF"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">获取目标方法信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">切点表达式语法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%90%E5%8F%96"><span class="nav-number">3.2.1.3.1.</span> <span class="nav-text">切点表达式提取</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">环绕通知</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%87%E9%9D%A2%E4%BC%98%E5%85%88%E7%BA%A7-Order"><span class="nav-number">3.2.1.5.</span> <span class="nav-text">切面优先级@Order()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EXML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0AOP-%E4%BA%86%E8%A7%A3"><span class="nav-number">3.2.2.</span> <span class="nav-text">基于XML配置文件实现AOP(了解)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">4.</span> <span class="nav-text">声明式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">4.1.</span> <span class="nav-text">基本介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.2.</span> <span class="nav-text">基于注解的声明式事务实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6"><span class="nav-number">4.2.1.</span> <span class="nav-text">基本事务控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transactional%E6%B3%A8%E8%A7%A3%E5%B8%B8%E7%94%A8%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7"><span class="nav-number">4.2.2.</span> <span class="nav-text">@Transactional注解常用事务属性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5"><span class="nav-number">5.</span> <span class="nav-text">实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5"><span class="nav-number">5.1.</span> <span class="nav-text">容器基本配置实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B51-%E5%9F%BA%E4%BA%8EXML%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6"><span class="nav-number">5.1.1.</span> <span class="nav-text">实践1 基于XML方式整合三层架构组件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JdbcTemplate"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">JdbcTemplate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5"><span class="nav-number">5.1.1.2.</span> <span class="nav-text">数据库连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.1.3.</span> <span class="nav-text">代码实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B52-%E5%9F%BA%E4%BA%8EXML-%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6"><span class="nav-number">5.1.2.</span> <span class="nav-text">实践2 基于XML+注解方式整合三层架构组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B53-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3-%E9%85%8D%E7%BD%AE%E7%B1%BB%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6"><span class="nav-number">5.1.3.</span> <span class="nav-text">实践3 基于注解+配置类方式整合三层架构组件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5"><span class="nav-number">5.2.</span> <span class="nav-text">AOP配置实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B54-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0AOP"><span class="nav-number">5.2.1.</span> <span class="nav-text">实践4 基于注解方式实现AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96spring-aspects"><span class="nav-number">5.2.1.1.</span> <span class="nav-text">步骤1：导入依赖spring-aspects</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A42%EF%BC%9A%E6%AD%A3%E5%B8%B8%E7%BC%96%E5%86%99%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%EF%BC%8C%E5%8A%A0%E5%85%A5IoC%E5%AE%B9%E5%99%A8"><span class="nav-number">5.2.1.2.</span> <span class="nav-text">步骤2：正常编写核心业务，加入IoC容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A43%EF%BC%9A%E7%BC%96%E5%86%99IoC%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%92%8C%E6%96%87%E4%BB%B6"><span class="nav-number">5.2.1.3.</span> <span class="nav-text">步骤3：编写IoC配置类和文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A44%EF%BC%9A%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="nav-number">5.2.1.4.</span> <span class="nav-text">步骤4：测试环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A45%EF%BC%9A%E5%A2%9E%E5%BC%BA%E7%B1%BB%EF%BC%8C%E5%AE%9A%E4%B9%89%E5%9B%9B%E4%B8%AA%E5%A2%9E%E5%BC%BA%E6%96%B9%E6%B3%95%EF%BC%88%E5%AD%98%E5%82%A8%E6%A8%AA%E5%88%87%E5%85%B3%E6%B3%A8%E7%82%B9%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="nav-number">5.2.1.5.</span> <span class="nav-text">步骤5：增强类，定义四个增强方法（存储横切关注点的代码）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A46%EF%BC%9A%E5%A2%9E%E5%BC%BA%E7%B1%BB%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%88%E6%8F%92%E5%85%A5%E5%88%87%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%88%87%E7%82%B9%E6%8C%87%E5%AE%9A%EF%BC%8C%E5%88%87%E9%9D%A2%E9%85%8D%E7%BD%AE%E7%AD%89%EF%BC%89"><span class="nav-number">5.2.1.6.</span> <span class="nav-text">步骤6：增强类的配置（插入切点的位置，切点指定，切面配置等）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A47%EF%BC%9A%E5%BC%80%E5%90%AFAOP%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">5.2.1.7.</span> <span class="nav-text">步骤7：开启AOP的配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5"><span class="nav-number">5.3.</span> <span class="nav-text">声明式事务配置实践</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B55%EF%BC%9A%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.3.1.</span> <span class="nav-text">实践5：基于注解方式配置生成式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="nav-number">5.3.1.1.</span> <span class="nav-text">步骤1：导入依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A42%EF%BC%9A%E5%B0%86%E5%AF%B9%E5%BA%94%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%AF%BC%E5%85%A5IoC%E5%AE%B9%E5%99%A8%EF%BC%8C%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1%E6%B3%A8%E8%A7%A3%E6%94%AF%E6%8C%81"><span class="nav-number">5.3.1.2.</span> <span class="nav-text">步骤2：将对应事务管理器实现导入IoC容器，开启事务注解支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A43%EF%BC%9A%E5%9C%A8%E9%9C%80%E8%A6%81%E6%B7%BB%E5%8A%A0%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3-Transactional%E6%8C%87%E6%98%8E"><span class="nav-number">5.3.1.3.</span> <span class="nav-text">步骤3：在需要添加事务的方法中使用注解@Transactional指明</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86"><span class="nav-number">7.</span> <span class="nav-text">补充知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA"><span class="nav-number">7.1.</span> <span class="nav-text">测试环境的搭建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8E%E7%AB%AF%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-CrossOrigin%E6%B3%A8%E8%A7%A3"><span class="nav-number">7.2.</span> <span class="nav-text">后端跨域问题解决方案 - @CrossOrigin注解</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shearington"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Shearington</p>
  <div class="site-description" itemprop="description">诗酒趁年华</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Fushiye/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Fushiye&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shearington@foxmail.com" title="E-Mail → mailto:shearington@foxmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fushiye.github.io/2024/08/16/Java-SSM-Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Shearington">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星海拾贝">
      <meta itemprop="description" content="诗酒趁年华">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java-SSM-Spring | 星海拾贝">
      <meta itemprop="description" content="Spring Framework学习过程中记录的笔记，仅供参考，如有错漏，敬请指正!">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java-SSM-Spring
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-16 00:05:46" itemprop="dateCreated datePublished" datetime="2024-08-16T00:05:46+08:00">2024-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-03-15 20:39:07" itemprop="dateModified" datetime="2025-03-15T20:39:07+08:00">2025-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">框架与工具</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:03</span>
    </span>
</div>

            <div class="post-description">Spring Framework学习过程中记录的笔记，仅供参考，如有错漏，敬请指正!</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><h2 id="笔记说明"><a href="#笔记说明" class="headerlink" title="笔记说明"></a>笔记说明</h2><h3 id="笔记平台"><a href="#笔记平台" class="headerlink" title="笔记平台"></a>笔记平台</h3><p>（1）IDEA开发工具：2022.1.2<br>（2）JDK：Java17<strong>（Spring6要求JDK最低版本是Java17）</strong><br>（3）Spring：6.0.2</p>
<p>（4）Maven：3.6+</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><strong>主要参考资料：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AP411s7D7/?spm_id_from=333.1387.search.video_card.click&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-SSM</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/basic-knowledge-summary-of-spring.html">菜鸟教程-Spring</a></p>
<p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-framework">SpringFramework官方文档</a></p>
<p><a target="_blank" rel="noopener" href="https://spring.io/guides">Spring官方导引</a></p>
<p><strong>其他参考资料：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Vf4y127N5/?spm_id_from=333.1387.search.video_card.click&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-Spring5</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kR4y1b7Qc?vd_source=20530c92c1be8bd70e37346e3a5c037a&p=2&spm_id_from=333.788.player.switch">尚硅谷-Spring6</a></p>
<h2 id="技术体系结构"><a href="#技术体系结构" class="headerlink" title="技术体系结构"></a>技术体系结构</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816124456.png"></p>
<h3 id="总体技术体系"><a href="#总体技术体系" class="headerlink" title="总体技术体系"></a>总体技术体系</h3><p><strong>单一架构</strong><br>一个项目，一个工程，导出为一个war包，在一个Tomcat上运行。也叫all in one。<br>主要应用技术框架为：Spring , SpringMVC , Mybatis。</p>
<p><strong>分布式架构</strong><br>一个项目（对应 IDEA 中的一个 project），拆分成很多个模块，每个模块是一个 IDEA 中的一个module。每一个工程都是运行在自己的Tomcat上。模块之间可以互相调用。每一个模块内部可以看成是一个单一架构的应用<br>主要应用技术框架：SpringBoot (SSM), SpringCloud , 中间件等</p>
<h3 id="框架的理解"><a href="#框架的理解" class="headerlink" title="框架的理解"></a>框架的理解</h3><p>框架( Framework )是一个集成了基本结构、规范、设计模式、编程语言和程序库等基础组件的软件系统，它可以用来构建更高级别的应用程序。框架的设计和实现旨在解决特定领域中的常见问题，帮助开发人员更高效、更稳定地实现软件开发目标。</p>
<p>&#x3D;&#x3D;》<strong>JAVA框架实际上就是一个集成了JAVA中常见问题的解决方案的程序集合。</strong><br>&#x3D;&#x3D;》 <code>框架 = jar包 + 配置文件</code></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816131256.png" alt="文件结构角度理解框架"></p>
<p>框架的优点包括以下几点：</p>
<ol>
<li><code>提高开发效率</code>：框架提供了许多预先设计好了的组件和工具，能够帮助开发人员快速进行开发。相较于传统手写代码，在框架提供的规范化环境中，开发者可以更快地实现项目的各种要求。</li>
<li><code>降低开发成本</code>：框架的提供标准化的编程语言、数据操作等代码片段，避免了重复开发的问题，降低了开发成本，提供深度优化的系统，降低了维护成本，增强了系统的可靠性。</li>
<li><code>提高应用程序的稳定性</code>：框架通常经过了很长时间的开发和测试，其中的许多组件、代码片段和设计模式都得到了验证。重复利用这些组件有助于减少bug的出现，从而提高了应用程序的稳定性。</li>
<li><code>提供标准化的解决方案</code>：框架通常是针对某个特定领域的，通过提供标准化的解决方案，可以为开发人员提供一种共同的语言和思想基础，有助于更好地沟通和协作。</li>
</ol>
<p>框架的缺点包括以下几个方面：</p>
<ol>
<li><code>学习成本高</code>：框架通常具有特定的语言和编程范式。对于开发人员而言，需要花费时间学习其背后的架构、模式和逻辑，这对于新手而言可能会耗费较长时间。</li>
<li><code>可能存在局限性</code>：虽然框架提高了开发效率并可以帮助开发人员解决常见问题，但是在某些情况下，特定的应用需求可能超出框架的范围，从而导致应用程序无法满足要求。开发人员可能需要更多的控制权和自由度，同时需要在框架和应用程序之间进行权衡取舍。</li>
<li><code>版本变更和兼容性问题</code>：框架的版本发布和迭代通常会导致代码库的大规模变更，进而导致应用程序出现兼容性问题和漏洞。当框架变更时，需要考虑框架是否向下兼容，以及如何进行适当的测试、迁移和升级。</li>
<li><code>架构风险</code>：框架涉及到很多抽象和概念，如果开发者没有足够的理解和掌握其架构，可能会导致系统出现设计和架构缺陷，从而影响系统的健康性和安全性</li>
</ol>
<h3 id="Spring基本介绍"><a href="#Spring基本介绍" class="headerlink" title="Spring基本介绍"></a>Spring基本介绍</h3><h4 id="Spring和SpringFramework的关系"><a href="#Spring和SpringFramework的关系" class="headerlink" title="Spring和SpringFramework的关系"></a>Spring和SpringFramework的关系</h4><p><strong>广义的 Spring：Spring 技术栈（全家桶）</strong><br>广义上的<code>Spring</code>泛指以Spring Framework为基础的<code>Spring</code>技术栈。经过十多年的发展，Spring已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如SpringFramework、SpringMVC、SpringBoot、SpringCloud、SpringData、SpringSecurity等，其中SpringFramework是其他子项目的基础。这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。</p>
<p><strong>狭义的Spring：SpringFramework（基础框架）</strong><br>狭义的Spring特指SpringFramework，通常我们将它称为Spring框架。SpringFramework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：<code>依赖注入（DependencyInjection）、面向切面编程（AOP）、声明式事务管理（TX）</code>等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。<br>Spring全家桶的其他框架都是以SpringFramework框架为基础！</p>
<h4 id="SpringFramework主要功能模块"><a href="#SpringFramework主要功能模块" class="headerlink" title="SpringFramework主要功能模块"></a>SpringFramework主要功能模块</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816143429.png" alt="主要功能模块"></p>
<table>
<thead>
<tr>
<th>功能模块</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody><tr>
<td>Core Container</td>
<td>核心容器，在Spring环境下使用任何功能都必须基于IOC容器。</td>
</tr>
<tr>
<td>AOP&amp;Aspects</td>
<td>面向切面编程</td>
</tr>
<tr>
<td>TX</td>
<td>声明式事务管理。</td>
</tr>
<tr>
<td>SpringMVC</td>
<td>提供了面向Web应用程序的集成功能。</td>
</tr>
</tbody></table>
<h4 id="SpringFramework的优势"><a href="#SpringFramework的优势" class="headerlink" title="SpringFramework的优势"></a>SpringFramework的优势</h4><ol>
<li>丰富的生态系统：Spring 生态系统非常丰富，支持许多模块和库，如 Spring Boot、Spring、Security、Spring Cloud 等等，可以帮助开发人员快速构建高可靠性的企业应用程序。</li>
<li>模块化的设计：框架组件之间的松散耦合和模块化设计使得 Spring Framework 具有良好的可重用性、可扩展性和可维护性。开发人员可以轻松地选择自己需要的模块，根据自己的需求进行开发。</li>
<li>简化 Java 开发：Spring Framework 简化了 Java 开发，提供了各种工具和 API，可以降低开发复杂度和学习成本。同时，Spring Framework 支持各种应用场景，包括 Web 应用程序、RESTful API、消息传递、批处理等等。</li>
<li>不断创新和发展：Spring Framework 开发团队一直在不断创新和发展，保持与最新技术的接轨，为开发人员提供更加先进和优秀的工具和框架</li>
</ol>
<h4 id="Spring框架企业级应用开发的三层架构模式"><a href="#Spring框架企业级应用开发的三层架构模式" class="headerlink" title="Spring框架企业级应用开发的三层架构模式"></a>Spring框架企业级应用开发的三层架构模式</h4><p>在Java开发中，特别是基于Spring框架的企业级应用开发中，DAO（Data Access Object）、Service（业务服务层）和Controller（控制层）是三层架构模式的具体实现。它们各自承担着不同的职责，下面将具体介绍每个层次的含义及功能：</p>
<ol>
<li><p>DAO (Data Access Object) - 数据访问对象</p>
<ul>
<li><p><strong>职责</strong>：负责与数据库或其他持久化存储进行交互。</p>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>封装了对数据库的CRUD（创建、读取、更新、删除）操作。</li>
<li>提供了数据存取的抽象接口，使得上层逻辑不需要关心具体的数据库实现细节。</li>
<li>可以使用JDBC直接操作数据库，或者更常用的是使用ORM工具如Hibernate或MyBatis来简化数据操作。</li>
<li>通常会定义接口，并由其实现类完成具体的数据访问逻辑。</li>
</ul>
</li>
<li><p><strong>示例</strong>：<code>UserDao</code>接口及其<code>UserDaoImpl</code>实现类，用于用户信息的增删改查。</p>
</li>
</ul>
</li>
<li><p>Service (业务服务层)</p>
<ul>
<li><p><strong>职责</strong>：处理业务逻辑，作为应用程序的核心部分。</p>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>包含业务规则和流程，例如验证、计算、事务管理等。</li>
<li>调用一个或多个DAO来执行数据操作，确保数据的一致性和完整性。</li>
<li>可能涉及与其他服务的通信，比如调用第三方API或微服务。</li>
<li>是表示层（如Web控制器）和数据访问层之间的桥梁。</li>
<li>在Spring应用中，通常使用@Service注解来标识业务服务组件，并利用依赖注入来管理组件间的依赖关系。</li>
</ul>
</li>
<li><p><strong>示例</strong>：<code>UserService</code>类，它可能包含注册新用户、更新用户信息、验证用户登录等功能。</p>
</li>
</ul>
</li>
<li><p>Controller (控制层)</p>
<ul>
<li><p><strong>职责</strong>：处理HTTP请求，协调用户界面和业务逻辑。</p>
</li>
<li><p><strong>功能</strong>：</p>
<ul>
<li>接收来自用户的请求，并调用相应的Service方法来处理这些请求。</li>
<li>根据业务逻辑的处理结果，选择适当的视图（View）返回给用户，或者生成JSON&#x2F;XML等格式的数据响应。</li>
<li>在MVC模式中，控制器不直接与模型（Model）交互，而是通过服务层间接地与之沟通。</li>
<li>对于RESTful Web服务，控制器负责解析URL路径参数、查询参数、请求体等内容，并将它们转换为Java对象传递给服务层。</li>
<li>在Spring MVC或Spring Boot应用中，使用@Controller或@RestController注解来定义控制器。</li>
</ul>
</li>
<li><p><strong>示例</strong>：<code>UserController</code>类，它接收用户提交的表单数据，调用<code>UserService</code>来处理用户注册或登录请求，然后根据处理结果重定向页面或返回JSON响应。</p>
</li>
</ul>
</li>
</ol>
<p>在实际开发中，这三个层次之间通常是松耦合的，这意味着每一层都尽量减少对其他层的直接依赖，从而提高代码的可维护性和可测试性。例如，Service层不应该直接调用Controller层的方法，而应该通过接口或事件机制进行通信；同样地，DAO层也不应该知道Service层的存在，它只需要提供基本的数据操作接口即可。这种设计原则有助于创建更加模块化的软件系统，同时也便于单元测试和集成测试。</p>
<hr>
<h1 id="容器-IoC"><a href="#容器-IoC" class="headerlink" title="容器: IoC"></a>容器: IoC</h1><p><code>IoC</code>是<code>Inversion of Control</code>的简写，译为“<code>控制反转</code>”，它不是一门技术，而是<strong>一种设计思想</strong>，是一个重要的面向对象编程法则，能够指导我们如何设计出松耦合、更优良的程序。Spring 通过 IoC 容器来管理所有 Java 对象的<strong>实例化和初始化，控制对象与对象之间的依赖关系</strong>。我们将<strong>由 IoC容器管理的 Java 对象称为 Spring Bean</strong>，它与使用关键字 new 创建的 Java 对象没有任何区别。IoC 容器是 Spring 框架中最重要的核心组件之一，它贯穿了 Spring 从诞生到成长的整个过程。</p>
<p><strong>IoC容器负责管理对象的创建、配置和生命周期，控制对象与对象之间的依赖关系。</strong></p>
<p><strong>控制反转：</strong>控制反转（Inversion of Control,  IoC）是一种设计思想，用于解耦软件组件之间的依赖关系。它将传统上由程序代码直接管理的对象<strong>创建和生命周期管理</strong>的职责交给了框架或容器来处理。通过这种方式，对象不再需要自己创建或查找其依赖项，而是由外部环境（通常是IoC容器）在运行时提供这些依赖项。控制反转主要依靠依赖（Dependency Injection, DI）注入实现。</p>
<p><strong>依赖注入：</strong>依赖注入（Dependency Injection, DI）是控制反转（IoC）的一种具体实现方式，它通过将对象的依赖项作为外部配置提供给对象，而不是让对象自己创建或查找这些依赖。这样可以减少组件之间的耦合度，并且使代码更容易测试和维护。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在Spring框架中，”组件”（Component）是一个核心概念，它指的是Spring容器管理的一个对象，这个对象可以是任何POJO（Plain Old Java Object，即普通的Java对象），但它通过特定的方式被Spring框架识别并管理。Spring容器负责这些组件的创建、配置、组装和生命周期管理。</p>
<p>一个项目是由多个组件(<strong>可以复用的JAVA对象</strong>)搭建而成的：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816144616.png"></p>
<p>组件是一类可以复用的对象，但对象不一定是组件。</p>
<p>Spring能够充当组件管理角色(IoC)：</p>
<ul>
<li>组件对象实例化</li>
<li>组件属性属性赋值</li>
<li>组件对象之间引用</li>
<li>组件对象存活周期管理</li>
<li>……</li>
</ul>
<p>通过Spring管理组件，可以</p>
<ol>
<li>降低了组件之间的耦合性：Spring IoC容器通过依赖注入机制，将组件之间的依赖关系削弱，减少了程序组件之间的耦合性，使得组件更加松散地耦合。</li>
<li>提高了代码的可重用性和可维护性：将组件的实例化过程、依赖关系的管理等功能交给Spring IoC容器处理，使得组件代码更加模块化、可重用、更易于维护。</li>
<li>方便了配置和管理：Spring IoC容器通过XML文件或者注解，轻松的对组件进行配置和管理，使得组件的切换、替换等操作更加的方便和快捷。</li>
<li><em>交给Spring管理的对象（组件），方可享受Spring框架的其他功能（AOP,声明事务管理</em></li>
</ol>
<h3 id="Spring-IoC容器和容器实现"><a href="#Spring-IoC容器和容器实现" class="headerlink" title="Spring IoC容器和容器实现"></a>Spring IoC容器和容器实现</h3><p>普通容器，存储对象：数组、集合等<br>复杂容器：存储和管理对象</p>
<h4 id="SpringIoC容器"><a href="#SpringIoC容器" class="headerlink" title="SpringIoC容器"></a>SpringIoC容器</h4><p>Spring IoC容器，负责实例化、配置和组装 bean（组件）。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。配置元数据以<code>XML、Java注解或Java</code>代码形式表现。它允许表达组成应用程序的组件以及这些组件之间丰富的相互依赖关系。</p>
<h5 id="SpringIoC-容器接口和实现类"><a href="#SpringIoC-容器接口和实现类" class="headerlink" title="SpringIoC 容器接口和实现类"></a>SpringIoC 容器接口和实现类</h5><p><code>BeanFactory</code>接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！<br><code>ApplicationContext</code>是 BeanFactory 的子接口。它扩展了以下功能：</p>
<ul>
<li>更容易与 Spring 的 AOP 功能集成</li>
<li>消息资源处理（用于国际化）</li>
<li>特定于应用程序给予此接口实现，例如Web应用程序的 WebApplicationContext</li>
</ul>
<p>简而言之，BeanFactory 提供了配置框架和基本功能，而ApplicationContext 添加了更多特定于企业的功能。 ApplicationContext 是 BeanFactory 的完整超集！ </p>
<p><strong>ApplicationContext容器实现类</strong></p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>*ClassPathXmlApplicationContext</td>
<td>通过读取类路径下的<code>XML</code>格式的配置文件创建<code>IOC</code>容器对象</td>
</tr>
<tr>
<td>FileSystemXmlApplicationContext</td>
<td>通过文件系统路径读取<code>XML</code>格式的配置文件创建<code>IOC</code>容器对象</td>
</tr>
<tr>
<td>*AnnotationConfigApplicationContext</td>
<td>通过读取<code>Java配置类</code>创建<code>IOC</code>容器对象</td>
</tr>
<tr>
<td>*WebApplicationContext</td>
<td>专门为Web应用准备，基于<code>Web</code>环境创建<code>IOC</code>容器对象，并将对象引入存入<code>ServletContext</code>域中</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816151122.png" alt="常用框架"></p>
<ol>
<li>XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持。</li>
<li>注解方式：从Spring 2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component, @Service, @Autowired等），将Bean注册到Spring IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系。</li>
<li><strong>Java配置类方式</strong>：从Spring 3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置。 为了迎合当下开发环境，我们将以配置类+注解方式为主进行讲解！</li>
</ol>
<h5 id="Spring-IoC-DI-概念"><a href="#Spring-IoC-DI-概念" class="headerlink" title="Spring IoC &#x2F; DI 概念"></a>Spring IoC &#x2F; DI 概念</h5><p><strong>IoC容器</strong><br>Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令。</p>
<p><strong>IoC（Inversion of Control）控制反转</strong><br>（通过反射创建对应类的对象）<br>IoC 主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC 容器来创建和管理，即控制权由应用程序转移到 IoC 容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即 IoC 容器维护着构成应用程序的对象，并负责创建这些对象。</p>
<p><strong>DI (Dependency Injection) 依赖注入</strong><br>（将一个对象注入另一个对象的属性中–&gt;即一个对象作为另一个对象的属性的值）<br>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在 Spring 中，DI是通过 XML 配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter方法注入和接口注入。</p>
<h3 id="Spring-IoC-DI-实现步骤"><a href="#Spring-IoC-DI-实现步骤" class="headerlink" title="Spring IoC&#x2F;DI 实现步骤"></a>Spring IoC&#x2F;DI 实现步骤</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240816212321.png" alt="IoC实践步骤"></p>
<ol>
<li><code>配置元数据</code></li>
<li><code>实例化IoC容器</code></li>
<li><code>获取Bean（组件）</code></li>
</ol>
<h2 id="基于XML的组件管理配置方式"><a href="#基于XML的组件管理配置方式" class="headerlink" title="基于XML的组件管理配置方式"></a>基于XML的组件管理配置方式</h2><hr>
<h3 id="组件-Bean-信息声明配置-IoC"><a href="#组件-Bean-信息声明配置-IoC" class="headerlink" title="组件(Bean)信息声明配置(IoC)"></a>组件(Bean)信息声明配置(IoC)</h3><p>如何定义XML配置文件，声明组件类信息，交给Spring的IoC容器进行组件管理</p>
<p>常用的对象实例化方法</p>
<ol>
<li>构造函数实例化</li>
<li>工厂模式实例化<br><a href="https://fushiye.github.io/2024/09/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">工厂模式</a></li>
</ol>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>创建Maven工程，导入SpringIoC相关依赖：建议创建父工程（打包方式为pom），避免子工程重复导入</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（以下方法必须在上步完成情况下）<br>将类放入IoC容器，需要创建一个Spring配置文件，在当前工程的resources文件夹上右键 -&gt; 新建 -&gt; XML配置文件 -&gt; spring配置文件</p>
<hr>
<h4 id="基于无参构造函数"><a href="#基于无参构造函数" class="headerlink" title="基于无参构造函数"></a>基于无参构造函数</h4><p>创建一个可以使用无参构造器实例化的组件的IoC配置：<br>一个bean代表一个组件对象，包含了组件的信息；<strong>当配置文件被IoC容器读取时，会根据此实例化对象</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;组件的标识，自定义，唯一，方便后期读取&quot;</span> <span class="attr">class</span> = <span class="string">&quot;组件所属类的全限定名&quot;</span> /&gt;</span></span><br><span class="line"># 示例</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.Spring6.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>id即对象（组件）名，class即对象所属类的完整名称，包括它的包名和类名</li>
<li>根据class所指定的组件类创建一个对象（组件），名称就是id（<strong>相当于new一个class的对象id</strong>）</li>
<li>默认是单例的，写一个bean就声明一个组件，实例化一个对象。</li>
</ul>
<hr>
<h4 id="基于工厂模式的"><a href="#基于工厂模式的" class="headerlink" title="基于工厂模式的"></a>基于工厂模式的</h4><p>通过工厂模式实例化组件的IoC配置</p>
<h5 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;组件的标识，自定义，唯一，方便后期读取&quot;</span> <span class="attr">class</span> = <span class="string">&quot;工厂类的全限定名&quot;</span> <span class="attr">factory-method</span> = <span class="string">&quot;static方法名&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>id</code>即组件（对象）名称；<code>class</code>即工厂类的完整名称，包括它的包名和类名；</li>
<li><code>factory-method</code>即调用的<strong>静态的</strong>能返回实例化对象的工厂方法</li>
</ul>
<p>示例：</p>
<p>工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ClientService</span> <span class="variable">clientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientService</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">ClientService</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title function_">createInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cs&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.Spring6.ClientService&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="非静态工厂"><a href="#非静态工厂" class="headerlink" title="非静态工厂"></a>非静态工厂</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--首先 配置工厂类的组件信息，相当于实例化工厂类的对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;组件的标识，自定义，唯一，方便后期读取&quot;</span> <span class="attr">class</span> = <span class="string">&quot;工厂类的全限定名&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--然后 指定非静态工厂对象和方法名，配置生成的IoC信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;组件的标识，自定义，唯一，方便后期读取&quot;</span> <span class="attr">factory-bean</span> = <span class="string">&quot;上面bean的id&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;工厂方法名&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>factory-method指定的方法必须是非静态的</li>
</ul>
<p>示例：</p>
<p>工厂类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientService</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">static</span> <span class="variable">ClientServiceImplclientService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClientServiceImpl</span>();</span><br><span class="line">   <span class="keyword">public</span> ClientService <span class="title function_">createClientServiceInstance</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> clientService;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;defaultCS&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.Spring6.ClientService&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cs&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;defaultCS&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createInstance&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="基于FactoryBean标准工厂接口的"><a href="#基于FactoryBean标准工厂接口的" class="headerlink" title="基于FactoryBean标准工厂接口的"></a>基于FactoryBean标准工厂接口的</h4><p>工厂模式的简化，见下文。</p>
<hr>
<p>xxxxxxxxxx <groupId>org.springframework.boot</groupId><artifactId>spring-boot-maven-plugin</artifactId><version>3.0.5</version>xml</p>
<h3 id="组件的依赖注入（DI）配置"><a href="#组件的依赖注入（DI）配置" class="headerlink" title="组件的依赖注入（DI）配置"></a>组件的依赖注入（DI）配置</h3><p><code>注入：即变量赋值</code>，只是这个变量就是class类中的成员属性<br>实现IoC容器中Bean之间的引用。</p>
<p><strong>引用和被引用的组件都必须放在IoC容器中</strong></p>
<p>Spring是先创建对象再赋值的。</p>
<p>组件属性赋值（依赖注入）必须使用构造函数或有set方法！</p>
<h4 id="基于构造函数"><a href="#基于构造函数" class="headerlink" title="基于构造函数"></a>基于构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    UserDao userDao;</span><br><span class="line">    Int can;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao useDao)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao useDao,Int can)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">        <span class="built_in">this</span>.can = can;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="单个构造参数"><a href="#单个构造参数" class="headerlink" title="单个构造参数"></a><strong>单个构造参数</strong></h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--将组件全部放入IoC容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;uerDao&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.test.UserDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;uerService&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.test.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span> = <span class="string">&quot;userDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>ref</code>引用的其他的bean</li>
<li>由于SpringIoC容器会先创建对象（IoC）再进行赋值（DI），所以两个bean的顺序没有要求</li>
</ul>
<h5 id="多个构造参数"><a href="#多个构造参数" class="headerlink" title="多个构造参数"></a><strong>多个构造参数</strong></h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--将组件全部放入IoC容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;uerDao&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.test.UserDao&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--方式1，按构造参数的顺序填写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;uerService&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.test.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span> = <span class="string">&quot;userDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span> = <span class="string">&quot;19&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--方式2，按构造参数的名称填写--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--推荐！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;uerService&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.test.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span> = <span class="string">&quot;can&quot;</span> <span class="attr">value</span> = <span class="string">&quot;19&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span> = <span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span> = <span class="string">&quot;userDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--方式3，按构造参数的下标填写，小标从0开始，从左到右--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;uerService&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.test.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span> = <span class="string">&quot;1&quot;</span> <span class="attr">value</span> = <span class="string">&quot;19&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span> = <span class="string">&quot;0&quot;</span> <span class="attr">ref</span> = <span class="string">&quot;userDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>ref</code>为引用的其他的bean，<code>当属性为其他类的对象时使用;</code></li>
<li><code>value</code>为属性值，当属性为基本数据类型或引用数据类型。</li>
<li><code>name</code>为属性名称;<code>index</code>为参数下标，从0开始</li>
<li><strong>推荐使用方法2</strong></li>
</ul>
<h4 id="基于Setter方法"><a href="#基于Setter方法" class="headerlink" title="基于Setter方法"></a>基于Setter方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class MovieFinder&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleMovieLister</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> MovieFinder movieFinder;</span><br><span class="line">	<span class="keyword">private</span> String movieName;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.movieFinder = movieFinder;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMovieName</span><span class="params">(String movieName)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.movieName = movieName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过触发Setter方法进行注入:</p>
<p>如果参数是其他类的对象，需要配置其他类的bean，如movieFinder</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--将组件全部放入IoC容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;movieFinder&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.MovieFinder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;simpleMovieLister&quot;</span> <span class="attr">class</span>=<span class="string">&quot;examples.SimpleMovieLister&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- setter方法，注入movieFinder对象的标识id name = 属性名 ref = 引用bean的id值--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;movieFinder&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;movieFinder&quot;</span> /&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- setter方法，注入基本数据类型movieName name = 属性名 value= 基本类型值--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;movieName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;消失的她&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>name</code>属性名：实际上是Setter方法名去掉set后将首字母改为小写的值，在标准的Setter方法中就是属性名，若是自定义的Setter可能有别的名称</li>
<li><code>value</code>和<code>ref</code>参数二选一，若是其他类的对象，选择<code>ref</code>,置为对应bean的id</li>
</ul>
<hr>
<h3 id="IoC容器的创建和使用"><a href="#IoC容器的创建和使用" class="headerlink" title="IoC容器的创建和使用"></a>IoC容器的创建和使用</h3><p>首先回顾IoC容器的接口和实现类<br>接口：</p>
<ul>
<li>BeanFactory</li>
<li>ApplicationContext</li>
</ul>
<p>实现类：</p>
<ul>
<li>可以直接通过构造函数实例化</li>
<li><code>ClassPathXmlApplicationContext</code>  读取类路径下的XML配置方式</li>
<li><code>FileSystemXmlApplicationContext</code>  读取文件系统中的XML配置方式</li>
<li><code>AnnotationConfigApplicationContext</code>  读取配置类方式的IoC容器</li>
<li>WebApplicationContext  Web项目专属的配置方式</li>
</ul>
<hr>
<h4 id="创建IoC容器的方法："><a href="#创建IoC容器的方法：" class="headerlink" title="创建IoC容器的方法："></a>创建IoC容器的方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createIoc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">/*创建IoC容器并且读取配置文件 两种方法*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时会调用初始化方法（后文的周期方法）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// [当前推荐]</span></span><br><span class="line">    <span class="comment">// 方法1 直接创建容器并指定配置文件，配置文件可以填写一个或多个</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;ioc1.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2 先创建容器，再指定配置文件，再刷新  方法1在源码中就是按这样实现的</span></span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>();</span><br><span class="line">    applicationContext1.setConfigLocations(<span class="string">&quot;iocq.xml&quot;</span>);</span><br><span class="line">    applicationContext1.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*获取bean,方法见下文*/</span></span><br><span class="line">    </span><br><span class="line">    applicationContext1.close();<span class="comment">// 关闭容器，会调用销毁方法（后文的周期方法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="获取bean的方法"><a href="#获取bean的方法" class="headerlink" title="获取bean的方法"></a>获取bean的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*在IoC容器中获取组件Bean 三种方法*/</span></span><br><span class="line"><span class="comment">// 方法1 【推荐】 根据BeanId同时指定Bean的类型Class</span></span><br><span class="line"><span class="type">HappyComponent</span> <span class="variable">happyComponent1</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;happyComponent&quot;</span>,HappyComponent.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2 【推荐】 直接根据类型获取</span></span><br><span class="line"><span class="type">HappyComponent</span> <span class="variable">happyComponent2</span> <span class="operator">=</span> applicationContext.getBean(HappyComponent.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3 【不推荐】 直接根据BeanId获取即可，返回值为Object类型，需要强制转换</span></span><br><span class="line"><span class="type">HappyComponent</span> <span class="variable">happyComponent3</span> <span class="operator">=</span> (HappyComponent) applicationContext.getBean(<span class="string">&quot;happyComponent&quot;</span>);</span><br></pre></td></tr></table></figure>



<p><strong>注意</strong></p>
<ol>
<li>根据bean的类型获取时（方法2），同一个类型IoC容器只能有一个Bean（在XML配置文件中只能有一个此class的bean）</li>
<li>IoC的配置必须是一个实现类（即xml中的class必须是实现类），但获取时（方法2）可以根据接口类型获取值（会进行类型 instanceof ioc容器类型 &#x3D;&#x3D; true的判断）</li>
<li>三次获取的对象其实是同一个，只是用了3次，因此happyComponent1&#x3D;happyComponent2&#x3D;happyComponent3</li>
</ol>
<hr>
<h3 id="组件Bean的作用域和周期方法"><a href="#组件Bean的作用域和周期方法" class="headerlink" title="组件Bean的作用域和周期方法"></a>组件Bean的作用域和周期方法</h3><h4 id="周期方法"><a href="#周期方法" class="headerlink" title="周期方法"></a>周期方法</h4><p>在Spring管理的Bean的生命周期中，Spring容器会在特定时间点自动调用的方法。这些生命周期方法允许开发者在Bean的创建、初始化、销毁等关键时刻插入自定义的代码。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240903185007.png" alt="周期方法"><br>我们可以在组件类中定义方法，然后当IoC容器实例化和销毁组件对象的时候进行调用！这两个方法我们成为生命周期方法！类似于JavaWeb中Servlet的init&#x2F;destroy方法,我们可以在周期方法完成初始化和释放资源等工作。</p>
<p>组件类中实现业务逻辑，注意：</p>
<ol>
<li>必须是pubic、void、无参的</li>
<li>命名可以随意</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaBean</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件中声明bean时指定初始化和销毁方法</p>
<ol>
<li><code>init-method</code> 指定初始化方法名</li>
<li><code>destroy-method</code> 指定销毁方法名</li>
<li>指明后容器会在对应时间节点回调对应方法，实现其中的业务；</li>
<li>可以不用指定销毁方法名，根据实际需求</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;javaBean&quot;</span> <span class="attr">class</span> = <span class="string">&quot;com.spring.Ioc.JavaBean&quot;</span> <span class="attr">init-method</span> = <span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span> = <span class="string">&quot;clear&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="组件的作用域"><a href="#组件的作用域" class="headerlink" title="组件的作用域"></a>组件的作用域</h4><p>我们在配置文件中使用<code>&lt;bean</code> 标签声明Bean，其实就是将对象&#x2F;组件&#x2F;Bean的信息配置给SpringIoC容器，IoC容器在读取配置文件获取到这些信息之后，需要将它们转化为Java中拥有的概念。<code>&lt;bean</code>标签也就转成Spring内部的 BeanDefinition 对象，<strong>BeanDefinition与类概念一样</strong>。BeanDefinition 对象内，包含的定义信息（id,class,属性等等）也就对应&lt;bean标签内的信息！SpringIoC容器可以可以根据BeanDefinition对象反射创建多个Bean对象实例。具体<strong>创建多少个Bean的实例对象，由Bean的作用域Scope属性指定！一般情况下都采用单例。</strong></p>
<p>Scope取值及其含义：</p>
<ul>
<li><code>singleton</code>：单例，默认，一个bean标签对应一个BeanDefinition对象对应一个组件对象，也就是说只实例化一个组件对象，不论调用几次都是同一个对象；</li>
<li><code>prototype</code>：多例，一个bean标签对应一个BeanDefinition对象对应多个组件对象，会创建多个组件对象。调用几次创建几个对象，每次都是不同的对象；</li>
</ul>
<p><img src="D:\workinenglish\typora_image\image-20241215223558541.png" alt="image-20241215223558541"></p>
<p>作用域可选值</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241215223026.png"></p>
<p>示例：</p>
<p>配置信息：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;single&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.Spring6.JavaBeanSingle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;muti&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.Spring6.JavaBeanMuti&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试及结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">    <span class="type">JavaBeanSingle</span> <span class="variable">singleBean1</span> <span class="operator">=</span> applicationContext.getBean(JavaBeanSingle.class);</span><br><span class="line">    <span class="type">JavaBeanSingle</span> <span class="variable">singleBean2</span> <span class="operator">=</span> applicationContext.getBean(JavaBeanSingle.class);</span><br><span class="line">    System.out.println(singleBean1==singleBean2); <span class="comment">// true</span></span><br><span class="line">    <span class="type">JavaBeanMuti</span> <span class="variable">mutiBean1</span> <span class="operator">=</span> applicationContext.getBean(JavaBeanMuti.class);</span><br><span class="line">    <span class="type">JavaBeanMuti</span> <span class="variable">mutiBean2</span> <span class="operator">=</span> applicationContext.getBean(JavaBeanMuti.class);</span><br><span class="line">    System.out.println(mutiBean1==mutiBean2);  <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="FactoryBean特性和使用"><a href="#FactoryBean特性和使用" class="headerlink" title="FactoryBean特性和使用"></a>FactoryBean特性和使用</h3><p>在上文提到的组件Bean信息声明配置方法中，当使用工厂模式配置时，需要指定工厂bean对应的工厂方法。FactoryBean可以简化这个过程。<code>FactoryBean</code> 是 Spring 框架中的一个接口，它允许你将任意的工厂类集成到 Spring 的 IoC（Inversion of Control，控制反转）容器中。通过实现 <code>FactoryBean</code> 接口，你可以自定义对象的创建逻辑，并且这个对象可以通过 Spring 容器来管理，就像普通的 Spring Bean 一样。</p>
<p><code>FactoryBean</code> 接口有三个方法需要实现：</p>
<ol>
<li><code>Object getObject() throws Exception;</code><ul>
<li>这个方法返回由 <code>FactoryBean</code> 创建的对象实例。Spring 容器在获取 <code>FactoryBean</code> 管理的 bean 时会调用此方法。</li>
</ul>
</li>
<li><code>Class&lt;?&gt; getObjectType();</code><ul>
<li>返回 <code>getObject()</code> 方法所创建对象的类型。如果在创建对象之前无法确定类型，则可以返回 <code>null</code>。当对象被创建后，Spring 容器会使用此信息进行类型检查。</li>
</ul>
</li>
<li><code>boolean isSingleton();</code><ul>
<li>如果 <code>FactoryBean</code> 创建的是单例模式的对象（即在整个应用上下文中只有一个实例），则返回 <code>true</code>；否则返回 <code>false</code>。</li>
</ul>
</li>
</ol>
<p><img src="D:\workinenglish\typora_image\image-20241215225746983.png" alt="image-20241215225746983"></p>
<p>FactoryBean的使用场景</p>
<ol>
<li>代理类的创建</li>
<li>第三方框架整合</li>
<li>复杂对象实例化等</li>
</ol>
<h4 id="FactoryBean的使用"><a href="#FactoryBean的使用" class="headerlink" title="FactoryBean的使用"></a>FactoryBean的使用</h4><ol>
<li>实现FactoryBean接口并指定返回值泛型</li>
<li>重写<code>getObject()</code>和<code>getObjectType()</code>方法</li>
<li>在配置文件中按正常类的bean配置，配置实现类的bean</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaBean是希望通过工厂模式实例化的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaBean</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// FactoryBean接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaBeanFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;JavaBean&gt; &#123;</span><br><span class="line">    <span class="comment">// 附加代码开始</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 附加代码结束</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> JavaBean <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">JavaBean</span> <span class="variable">javaBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaBean</span>();</span><br><span class="line">        <span class="comment">// 附加代码开始</span></span><br><span class="line">        javaBean.setName(value);</span><br><span class="line">        <span class="comment">// 附加代码结束</span></span><br><span class="line">        <span class="keyword">return</span> javaBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> JavaBean.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件配置：</p>
<p> 以下id中<strong>javaBean是</strong>JavaBeanFactoryBean这个工厂产生的<strong>JavaBean类的bean的名称</strong>，不是JavaBeanFactoryBean类对应的bean名称，它对应的是&amp;javaBean。但如果在里面使用 property 标签配置<code>set()方法</code>的参数，则<strong>配的是工厂类的set方法而不是javaBean的set方法。</strong>所以要想给javaBean的set方法传参，需要在工厂类添加上述附加代码，将工厂类参数作为一个传递桥梁。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;javaBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.learn.Spring6.test1.JavaBeanFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用property标签传递参数必须按说明添加代码作为桥接--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;value&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Tom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUser</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取JavaBean类的对象(组件/bean)</span></span><br><span class="line">    <span class="type">JavaBean</span> <span class="variable">javaBean</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;javaBean&quot;</span>,JavaBean.class);</span><br><span class="line">    <span class="comment">// 以下方法获取的是FactoryBean</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;&amp;javaBean&quot;</span>);</span><br><span class="line">    System.out.println(javaBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="面试：FactoryBean和BeanFactory区别"><a href="#面试：FactoryBean和BeanFactory区别" class="headerlink" title="面试：FactoryBean和BeanFactory区别"></a>面试：FactoryBean和BeanFactory区别</h4><ul>
<li><code>FactoryBean</code> 是 Spring 中一种特殊的 bean，可以在 getObject() 工厂方法自定义的逻辑创建Bean！是一种能够生产其他 Bean 的 Bean。FactoryBean 在容器启动时被创建，而在实际使用时则是通过调用getObject() 方法来得到其所生产的 Bean。因此，FactoryBean 可以自定义任何所需的初始化逻辑，生产出一些定制化的 bean。<br>  一般情况下，整合第三方框架，都是通过定义FactoryBean实现！！！</li>
<li><code>BeanFactory</code> 是 Spring 框架的基础，其作为一个顶级接口定义了容器的基本行为，例如管理 bean 的生命周期、配置文件的加载和解析、bean 的装配和依赖注入等。BeanFactory 接口提供了访问 bean 的方式，例如 getBean() 方法获取指定的 bean 实例。它可以从不同的来源（例如 Mysql 数据库、XML 文件、Java 配置类等）获取 bean 定义，并将其转换为 bean 实例。同时，BeanFactory 还包含很多子类（例如，ApplicationContext 接口）提供了额外的强大功能。</li>
</ul>
<p>总的来说，FactoryBean 和 BeanFactory 的区别主要在于前者是用于创建 bean 的接口，它提供了更加灵活的初始化定制功能，而后者是用于管理 bean 的框架基础接口，提供了基本的容器功能和 bean 生命周期管理</p>
<hr>
<h2 id="基于注解-XML的组件管理配置方式"><a href="#基于注解-XML的组件管理配置方式" class="headerlink" title="基于注解+XML的组件管理配置方式"></a>基于注解+XML的组件管理配置方式</h2><p>和 XML 配置文件一样，注解本身并不能执行，注解本身仅仅只是做一个标记，具体的功能是框架检测到注解标记的位置，然后针对这个位置按照注解标记的功能来执行具体操作。<br>本质上：所有一切的操作都是 Java 代码来完成的，XML 和注解只是告诉框架中的 Java 代码如何执行。</p>
<p><strong>此方法目前只能用于自定义类，第三方类还是使用XML方法</strong></p>
<p>基本步骤：</p>
<ol>
<li>使用注解标记想要放入IoC容器的类，<code>相当于配置了id为类名首字母小写，class为当前类的bean</code>。</li>
<li>在XML中配置，告诉Spring的IoC容器在那些包下添加了IoC注解</li>
</ol>
<hr>
<h3 id="步骤1：使用注解标记组件"><a href="#步骤1：使用注解标记组件" class="headerlink" title="步骤1：使用注解标记组件"></a>步骤1：使用注解标记组件</h3><p>Spring 提供了以下多个注解，这些注解可以直接标注在 Java 类上，将它们定义成 Spring Bean。</p>
<p><strong>四种注解功能没有区别，仅用于区分不同层，便于开发人员分辨组件的作用。</strong></p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Component</code></td>
<td>该注解用于描述 Spring 中的 Bean，它是一个泛化的概念，仅仅表示容器中的一个组件（Bean），并且可以作用在应用的任何层次，例如 Service 层、Dao 层等。 使用时只需将该注解标注在相应类上即可。</td>
</tr>
<tr>
<td><code>@Repository</code></td>
<td>该注解用于将<code>数据访问层（Dao 层）</code>的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
<tr>
<td><code>@Service</code></td>
<td>该注解通常作用在<code>业务层（Service 层）</code>，用于将业务层的类标识为 Spring中的 Bean，其功能与@Component相同。</td>
</tr>
<tr>
<td><code>@Controller</code></td>
<td>该注解通常作用在<code>控制层（如SpringMVC 的 Controller）</code>，用于将控制层的类标识为 Spring 中的 Bean，其功能与 @Component 相同。</td>
</tr>
</tbody></table>
<h4 id="组件的名称-id"><a href="#组件的名称-id" class="headerlink" title="组件的名称(id)"></a>组件的名称(id)</h4><p>默认情况下，注解标记的类，其类名首字母小写后即为其对应的组件名称。</p>
<p>可以在注解中使用<code>value</code>属性指定组件名称（即组件的id）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(value=&quot;name&quot;)</span></span><br><span class="line"><span class="comment">// 或直接省略value</span></span><br><span class="line"><span class="meta">@Service(&quot;name&quot;)</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="步骤2：XML配置文件指定扫描范围"><a href="#步骤2：XML配置文件指定扫描范围" class="headerlink" title="步骤2：XML配置文件指定扫描范围"></a>步骤2：XML配置文件指定扫描范围</h3><h4 id="情况1：全包注解扫描配置"><a href="#情况1：全包注解扫描配置" class="headerlink" title="情况1：全包注解扫描配置"></a>情况1：全包注解扫描配置</h4><p>添加配置文件的方式同使用XML配置时的方法一样</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--1. 普通配置包扫描</span></span><br><span class="line"><span class="comment">       base-package 指定ioc容器在哪些包下扫描注解类，加载到容器中</span></span><br><span class="line"><span class="comment">       多个包使用&#x27;,&#x27;分隔</span></span><br><span class="line"><span class="comment">       指定包即指定了此包及其子包内的所有类</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;package1,package2,...&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="情况2：排除包下某些注解"><a href="#情况2：排除包下某些注解" class="headerlink" title="情况2：排除包下某些注解"></a>情况2：排除包下某些注解</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--2. 排除包下某些注解的扫描配置</span></span><br><span class="line"><span class="comment">       在原标签的包含下，添加&lt;context:exclude-filter子标签</span></span><br><span class="line"><span class="comment">       type=&quot;annotation&quot;，expression=&quot;注解全路径&quot;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;package1,package2,...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="情况3：仅限包下某些注解"><a href="#情况3：仅限包下某些注解" class="headerlink" title="情况3：仅限包下某些注解"></a>情况3：仅限包下某些注解</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--3. 仅限包下某些注解的扫描配置</span></span><br><span class="line"><span class="comment">       父标签下添加use-default-filters=&quot;false&quot;</span></span><br><span class="line"><span class="comment">       在原标签的包含下，添加&lt;context:exclude-filter子标签</span></span><br><span class="line"><span class="comment">       type=&quot;annotation&quot;，expression=&quot;注解全路径&quot;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;package1,package2,...&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Service&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="指定周期方法和作用域"><a href="#指定周期方法和作用域" class="headerlink" title="指定周期方法和作用域"></a>指定周期方法和作用域</h3><p>注意：<strong>多例下不会调用销毁方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为单例，无需标记，标记方法为:</span></span><br><span class="line"><span class="comment">// @Scope(scopeName = ConfigurableBeanFactory.SCOPE_SINGLETON)</span></span><br><span class="line"><span class="meta">@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span> <span class="comment">// 作用域为多例</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitDestroy</span> &#123;</span><br><span class="line">    <span class="comment">// 周期方法的命名随意，但必须是public void</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span> <span class="comment">// 初始化方法，实例化后立即调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span> <span class="comment">//销毁方法，销毁前调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy function&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="DI依赖注入：组件属性赋值"><a href="#DI依赖注入：组件属性赋值" class="headerlink" title="DI依赖注入：组件属性赋值"></a>DI依赖注入：组件属性赋值</h3><h4 id="引用类型注入"><a href="#引用类型注入" class="headerlink" title="引用类型注入"></a>引用类型注入</h4><h5 id="Autowired-Qualified-value-“id”-注解自动装配"><a href="#Autowired-Qualified-value-“id”-注解自动装配" class="headerlink" title="@Autowired + @Qualified(value &#x3D; “id”)注解自动装配"></a>@Autowired + @Qualified(value &#x3D; “id”)注解自动装配</h5><p>使用方法：</p>
<ul>
<li><p>参与自动装配的组件（需要装配、被装配）全部都必须在IoC容器中。</p>
<blockquote>
<p>如果注解为<code>Autowired(required = false)</code>就可以没有对应组件而不会报错</p>
<p>但其他代码若使用到组件会出现空指针错误！</p>
</blockquote>
</li>
<li><p>在成员变量上直接标记<code>@Autowired</code>注解即可，不需要提供setXxx()方法。</p>
</li>
<li><p>默认情况下，自动装配名字(id)和成员属性名相同的组件。</p>
</li>
<li><p>如果组件名和成员属性名不同，需要额外的注解<code>@Qualifier(value = &quot;id&quot;)</code>来指定组件。</p>
<blockquote>
<p>注意！value的取值是组件的 id 而不是组件所属的类名。组件的 id 默认是类名首字母小写。</p>
<p>@Qualifier不能单独使用</p>
</blockquote>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserComtroller</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工作过程：</strong></p>
<p>首先根据所需要的组件类型到 IOC 容器中查找</p>
<ul>
<li><code>找到唯一的 bean</code>：直接执行装配</li>
<li><code>找不到匹配这个类型的 bean</code>：装配失败</li>
<li><code>所需类型匹配的 bean 不止一个</code>：装配失败</li>
<li>没有 @Qualifier 注解：根据 @Autowired 标记位置成员变量的变量名作为bean 的 id 进行匹配<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
<li>使用 @Qualifier 注解：根据 @Qualifier 注解中指定的名称作为 bean 的id进行匹配<ul>
<li>能够找到：执行装配</li>
<li>找不到：装配失败</li>
</ul>
</li>
</ul>
<h5 id="Resource-name-“id”-自动装配"><a href="#Resource-name-“id”-自动装配" class="headerlink" title="@Resource(name &#x3D; “id”)自动装配"></a>@Resource(name &#x3D; “id”)自动装配</h5><p><code> @Resource(name = &quot;id&quot;) 相当于 @Autowired(required - true) + @Qualified(value = &quot;id&quot;)</code></p>
<p>必须导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource(name = &quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserService userSer;</span><br></pre></td></tr></table></figure>

<p>注意！@Resource注解有两个实现，必须导入<code>jalarta.annotation</code>包的</p>
<h4 id="基本数据类型注入"><a href="#基本数据类型注入" class="headerlink" title="基本数据类型注入"></a>基本数据类型注入</h4><p>方法1：直接在代码中赋值</p>
<p>方法2：@Value()注解赋值</p>
<p>方法3：@Value(“${配置文件属性项}”)注解读取配置文件赋值，可以设置默认值</p>
<blockquote>
<p>需要：XML配置文件中使用&lt;context:property-placeholder location&#x3D;”classpath:name.properties”&#x2F;&gt;导入了配置文件</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1 代码直接赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2 Value注解赋值</span></span><br><span class="line"><span class="meta">@Value(&quot;Tom&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法3 Value注解读取配置文件赋值</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;user.Address&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String Address;</span><br><span class="line"><span class="meta">@Value(&quot;$&#123;user.Job:Dancer&#125;&quot;)</span></span><br><span class="line"><span class="comment">// 若配置文件中没有配置user.Job项，则使用默认值Dancer</span></span><br><span class="line"><span class="keyword">private</span> String Job;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="基于配置类-注解的完全注解组件管理配置方式"><a href="#基于配置类-注解的完全注解组件管理配置方式" class="headerlink" title="基于配置类+注解的完全注解组件管理配置方式"></a>基于配置类+注解的完全注解组件管理配置方式</h2><p>配置类可以完全替代XML配置文件，实现：</p>
<ol>
<li>包注解扫描配置</li>
<li>引用外部配置文件</li>
<li>声明第三方依赖的bean组件</li>
</ol>
<p><strong>需要注意的是，配置类只是替代XML配置文件，并不能替代上述基于注解的组件管理配置方式，自定义类的bean组件仍然按之前的方法说明和实现依赖注入。</strong></p>
<hr>
<h3 id="配置类的创建步骤"><a href="#配置类的创建步骤" class="headerlink" title="配置类的创建步骤"></a><strong>配置类的创建步骤</strong></h3><p>步骤1：添加<code>@Configuration注</code>解，代表当前类是配置类</p>
<p>步骤2：添加实现上述三个功能的对应注解</p>
<ol>
<li><code>@ComponentScan(&quot;待扫描注解的包&quot;)</code>：包注解扫描配置，多个配置文件可以使用<code>,</code>分隔。配置类无需扫描。</li>
<li><code>@PropertySource(value=&quot;path&quot;)</code>：引用外部配置文件，多个配置文件可以使用<code>,</code>分隔。</li>
<li><code>@Bean</code>：声明第三方依赖的bean组件。<strong>每声明一个</strong>第三方依赖的bean<strong>组件都需要创建一个public方法</strong>。<ul>
<li>方法返回值类型：bean组件的类型或其接口或其父类，即组件的 <code>class</code></li>
<li>方法名：bean组件名称，即组件的 <code>id</code> </li>
<li>方法体：自定义实现过程，一般通过<code>set</code>方法实现DI依赖注入。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&quot;com.learn&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationNote1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">druidDataSource</span><span class="params">(</span></span><br><span class="line"><span class="params">            // 从外部配置文件引入配置</span></span><br><span class="line"><span class="params">            // 如果这是此组件使用，放置在方法的形参列表</span></span><br><span class="line"><span class="params">            // 如果多个组件使用，建议设置为成员变量</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;url&#125;&quot;)</span> String url,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;username&#125;&quot;)</span> String userName,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;driverClassName&#125;&quot;)</span> String driverClassName,</span></span><br><span class="line"><span class="params">            <span class="meta">@Value(&quot;$&#123;password&#125;&quot;)</span> String password</span></span><br><span class="line"><span class="params">    )</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(userName);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="使用配置类创建IoC容器并获取组件"><a href="#使用配置类创建IoC容器并获取组件" class="headerlink" title="使用配置类创建IoC容器并获取组件"></a>使用配置类创建IoC容器并获取组件</h3><p>与XML配置文件方式（使用<code>ClassPathXmlApplicationContext</code>类）不同，通过配置类创建IoC需要使用<code>AnnotationConfigApplicationContext</code>类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建IoC容器的两种方法</span></span><br><span class="line">    <span class="comment">// 方法1</span></span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span></span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ConfigurationNote1.class);</span><br><span class="line">    <span class="comment">// 可以设置多个配置类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2</span></span><br><span class="line">    <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context1</span></span><br><span class="line">            <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>();</span><br><span class="line">    context1.register(ConfigurationNote1.class);</span><br><span class="line">    context1.refresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取bean 与之前相同。</span></span><br><span class="line">    <span class="type">StudentController</span> <span class="variable">bean</span> <span class="operator">=</span> context.getBean(StudentController.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="附加说明：名称、周期方法、作用域、-import"><a href="#附加说明：名称、周期方法、作用域、-import" class="headerlink" title="附加说明：名称、周期方法、作用域、@import"></a>附加说明：名称、周期方法、作用域、@import</h3><p><strong>说明1：bean组件的名称</strong></p>
<p>默认情况下，组件的名称（id）即为方法名。</p>
<p>也可以通过<code>@Bean(name = &quot;&quot;)</code>或<code>@Bean(value = &quot;&quot;)</code>指定</p>
<p><strong>说明2：周期方法如何指定</strong></p>
<p>可以按原有注解方案（<code>@PostConstruct</code>、<code>@PreDestroy</code>）指定。</p>
<p>也可以通过<code>@Bean(initMethod = &quot;&quot;)</code>和<code>@Bean(destroyMethod = &quot;&quot;)</code>指定</p>
<p><strong>说明3：作用域如何指定</strong></p>
<p>按原有注解方案（<code>@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE) </code>）指定。</p>
<p><strong>说明4：如何引用IoC的其他组件</strong></p>
<p>被引用的组件必须放到IoC容器了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案1（推荐） 在形参列表中声明所有需要的组件及其类型</span></span><br><span class="line"><span class="comment">// 如果被使用的同类型组件有多个，形参名即被使用的组件名（id）</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate1</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">    jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 方案2 被使用的组件也是@Bean方法说明的且是无形参的，可以直接调用</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">    jdbcTemplate.setDataSource(druidDataSource());</span><br><span class="line">    <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明5：多个配置类如何整合为一个</strong></p>
<p>使用<code>@import(value = &#123;配置类名.class,配置类名.class&#125;)</code>整合到一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import(value = &#123;ConfigurationNote11.class, ConfigurationNote12.class&#125;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigurationNote1</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h1><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241221195755.png"></p>
<h2 id="AOP思想介绍"><a href="#AOP思想介绍" class="headerlink" title="AOP思想介绍"></a>AOP思想介绍</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>假如需要设计一个计算器程序，每次计算需要输出执行运算的数和结果，对于+，—等运算，它们输出部分的功能和代码是一样的。以业务场景为例，数据库操作时，开启事务和结束事务的操作也是一样的，如果每次都编写这些代码，会大大增加重复劳动。这些附加功能代码不仅对核心业务功能有干扰，导致程序员在开发核心业务功能时分散了精力，而且重复分散在各个业务功能方法中，冗余而不方便统一维护。<strong>因此</strong>，我们需要将代码解耦，把附加功能从业务功能代码中抽取出来。将重复的代码统一提取，并且<code>动态插入</code>到每个业务方法！目前我们可以实现提取重复附加功能代码到一个类中，但是如何将代码插入到各个方法中呢？这就需要引入代理模式这个设计思想。</p>
<h3 id="解决方案-代理模式"><a href="#解决方案-代理模式" class="headerlink" title="解决方案 - 代理模式"></a>解决方案 - 代理模式</h3><p>二十三种设计模式中的一种，属于<code>结构型模式</code>。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。如下图所示，当外部代码需要调用目标方法时，通过代理类调用，而不是总结调用，相当于套了一层。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241221182630.png"></p>
<p>代理模式有两种实现方式：<code>静态代理</code>和<code>动态代理</code>。</p>
<p>静态代理在编译时就已经确定了代理类和被代理类的关系。静态代理中，代理类和被代理类都实现了相同的接口，或者代理类继承了被代理类。代理类持有对被代理类的引用，并且可以在调用被代理类的方法前后添加额外的功能。这种方式不够灵活，每一个目标方法都必须有一个固定的代理，这样当我们今后增加目标方法时也必须重新编写其对应的代理，导致了大量重复代码，增加了维护成本。</p>
<h3 id="动态代理模式"><a href="#动态代理模式" class="headerlink" title="动态代理模式"></a>动态代理模式</h3><p>动态代理（Dynamic Proxy）模式是在运行时创建代理类和对象，而不是在编译时就确定。动态代理可以在不修改目标对象代码的情况下为对象添加额外的行为，并且可以为多个接口创建代理，而不需要像静态代理那样为每个接口都编写一个具体的代理类。这使得它非常适合用于AOP（面向切面编程）、事务管理、权限检查等场景。</p>
<p>Java有两种主要的动态代理实现技术，没有实现接口的目标类只能通过Spring-CGLIB实现动态代理：</p>
<ul>
<li><code>JDK动态代理：</code>JDK提供了内置的支持来实现动态代理，主要通过 <code>java.lang.reflect.Proxy</code> 类和 <code>java.lang.reflect.InvocationHandler</code> 接口。需要被代理的目标类必须实现接口，JDK会根据目标类的接口动态生成一个代理对象。代理对象和目标对象有相同的接口。</li>
<li><code>Spring-Cglib</code>：通过继承被代理的目标类实现代理，不需要目标类实现接口。</li>
</ul>
<p>JDK实现动态代理十分复杂，Spring框架集成了Cglib，使用Spring框架中的可以大大简化，无需编写代理代码，直接配置即可。</p>
<h3 id="AOP面向切面编程-1"><a href="#AOP面向切面编程-1" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h3><p><code>AOP：Aspect Oriented Programming面向切面编程</code>。AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。在<code>OOP</code>下，子类可以完全使用父类的方法（继承）或是完全重新定义父类的方法（重写），但无法对父类的方法做出局部 的更改。AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。使用AOP，可以在不修改原来代码的基础上添加新功能。</p>
<h4 id="AOP应用场景"><a href="#AOP应用场景" class="headerlink" title="AOP应用场景"></a>AOP应用场景</h4><p>AOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。AOP可以应用于各种场景，以下是一些常见的AOP应用场景：</p>
<ol>
<li>日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。</li>
<li>事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。</li>
<li>安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。</li>
<li>性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。</li>
<li>异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。</li>
<li>缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。</li>
<li>动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。 综上所述，</li>
</ol>
<p><strong>AOP主要就是用于解决非核心业务代码的冗余问题，只要代码中有一部分代码在不同代码中多次出现，就可以使用AOP思想简化。</strong></p>
<h4 id="AOP的八个专业术语"><a href="#AOP的八个专业术语" class="headerlink" title="AOP的八个专业术语"></a>AOP的八个专业术语</h4><p><strong>1-横切关注点</strong></p>
<p>从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。</p>
<p>AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<p><strong>2-通知(增强)</strong></p>
<p>每一个横切关注点上要做的事情都需要写一个方法来实现（即提取出的代码形成的方法），这样的方法就叫<code>通知方法</code>。</p>
<ul>
<li>前置通知：在被代理的目标方法<code>前</code>执行</li>
<li>返回通知：在被代理的目标方法<code>成功结束</code>后执行（寿终正寝）</li>
<li>异常通知：在被代理的目标方法<code>异常结束</code>后执行（死于非命）</li>
<li>后置通知：在被代理的目标方法<code>最终结束</code>后执行（盖棺定论）无论成功还是异常结束</li>
<li>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<p><strong>3-连接点 joinpoint</strong></p>
<p>这也是一个纯逻辑概念，不是语法定义的。指那些被拦截到的点。在 Spring 中，可以被动态代理拦截目标类的方法</p>
<p><strong>4-切入点 pointcut</strong></p>
<p>定位连接点的方式，或者可以理解成被选中的连接点！是一个表达式，比如execution(* com.spring.service.impl..(..))。符合条件的每个方法都是一个具体的连接点</p>
<p><strong>5-切面 aspect</strong></p>
<p>切入点和通知的结合。是一个类</p>
<p><strong>6-目标 target</strong></p>
<p>被代理的目标对象。</p>
<hr>
<p><strong>7-代理 proxy</strong></p>
<p>向目标对象应用通知之后创建的代理对象。</p>
<p><strong>8-织入 weave</strong></p>
<p>指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/BlogPicture/main/img_blog/20250315203853.png"></p>
<h2 id="Spring-AOP-技术框架"><a href="#Spring-AOP-技术框架" class="headerlink" title="Spring AOP(技术框架)"></a>Spring AOP(技术框架)</h2><p>Spring AOP底层技术：</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241221200248.png"></p>
<p><strong>在目标方法类有接口的情况下，Spring框架自动使用jdk方式构建AOP，没有接口时自动使用CGLIB</strong></p>
<h3 id="基于注解方式实现AOP"><a href="#基于注解方式实现AOP" class="headerlink" title="基于注解方式实现AOP"></a>基于注解方式实现AOP</h3><h4 id="基本配置流程"><a href="#基本配置流程" class="headerlink" title="基本配置流程"></a>基本配置流程</h4><p>具体流程可以参考 【实践 - 实践4】，这里仅记录理论知识。 </p>
<ol>
<li>导入依赖</li>
<li>正常编写核心业务，加入IoC容器</li>
<li>编写IoC配置类和文件</li>
<li>测试环境</li>
<li>增强类，定义增强方法（存储横切关注点的代码）</li>
<li>增强类的配置（插入切点的位置，切点指定，切面配置等）</li>
<li>开启AOP的配置</li>
</ol>
<p><strong>导入依赖spring-aspects</strong></p>
<p>此依赖集成了实现AOP的所有需要的依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="注解及其功能"><a href="#注解及其功能" class="headerlink" title="注解及其功能"></a>注解及其功能</h5><p>增强类需要<code>@Aspect</code>注解说明，也需要放入IoC容器，因此还需要<code>@Component</code></p>
<p>配置类需要<code>@EnableAspectJAutoProxy</code>注解说明开启AOP;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    try&#123;                                               ——|</span></span><br><span class="line"><span class="comment">//        前置通知；@Before(value =&quot;切点表达式&quot;)               |</span></span><br><span class="line">          核心代码；                                         |</span><br><span class="line"><span class="comment">//        后置通知；@AfterReturning(value =&quot;切点表达式&quot;)       |</span></span><br><span class="line"><span class="comment">//    &#125;catch()&#123;                                             &gt; 环绕通知；@Around(value =&quot;切点表达式&quot;)</span></span><br><span class="line"><span class="comment">//        异常通知；@AfterThrowing(value =&quot;切点表达式&quot;)        |</span></span><br><span class="line"><span class="comment">//    &#125;finally&#123;                                             |</span></span><br><span class="line"><span class="comment">//        最后通知；@After(value =&quot;切点表达式&quot;)                |</span></span><br><span class="line"><span class="comment">//    &#125;                                                   ——|</span></span><br></pre></td></tr></table></figure>



<h4 id="获取目标方法信息"><a href="#获取目标方法信息" class="headerlink" title="获取目标方法信息"></a>获取目标方法信息</h4><p><strong>获取目标方法的信息</strong>，在增强方法的声明中添加<code>JointPoint</code>类（<code>org.aspectj.lang.JoinPoint</code>包下的）形参：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取目标方法所属类的信息</span></span><br><span class="line">    <span class="comment">// 类名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> joinPoint.getTarget().getClass().getSimpleName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标方法的信息</span></span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">funcName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    <span class="comment">// 修饰符</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> joinPoint.getSignature().getModifiers();</span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> Modifier.toString(modifiers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标方法参数列表</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    System.out.println(className + <span class="string">&quot; &quot;</span> + string + <span class="string">&quot; &quot;</span> + funcName + <span class="string">&quot; function start&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>获取目标方法的返回值</strong>，需要在增强方法中添加<code>Object</code>类的形参，并修改注解，增加<code>returning</code>属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(* com.fu.service.imp.*.*(..))&quot;,returning = &quot;result&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">success</span><span class="params">(Object result)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;function success and result is &quot;</span>+ result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>获取目标方法执行的异常</strong>，需要在增强方法中添加<code>Throwable</code>类的形参，并修改注解，增加<code>throwing</code>属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(* com.fu.service.imp.*.*(..))&quot;,throwing = &quot;t&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(Throwable t)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;function error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="切点表达式语法"><a href="#切点表达式语法" class="headerlink" title="切点表达式语法"></a>切点表达式语法</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241221232640.png"></p>
<p>固定语法：<code>execution(1 2 3.4.5(6))</code>：基本按正则表达式</p>
<ol>
<li><p>访问修饰符</p>
</li>
<li><p>方法的返回参数类型</p>
<blockquote>
<p>如果不考虑访问修饰符和方法的返回参数类型，可以使用一个 <code>*</code> 符号代替上述二者。</p>
<p>如果不考虑访问修饰符或方法的返回参数类型，就必须两者一起忽略；</p>
<p>如果考虑访问修饰符或方法的返回参数类型，就必须都考虑，都填写。</p>
</blockquote>
</li>
<li><p>包的位置</p>
<ul>
<li><p>具体包的位置，如：<code>com.fu.service.imp</code></p>
</li>
<li><p>单层模糊匹配，使用一个<code>*</code>，如：<code>com.fu.service.*</code></p>
</li>
<li><p>任意层模糊匹配，使用<code>..</code>，但不能以此开头，如：<code>com..imp</code>。</p>
<blockquote>
<p>匹配所有包下的Imp包：*..imp</p>
</blockquote>
</li>
</ul>
</li>
<li><p>类的名称</p>
<ul>
<li>可以填写具体类，如：<code>CalculatorPureImp</code></li>
<li>可以全部模糊，即匹配包下所有类，使用一个<code>*</code>。</li>
<li>可以部分模糊，按正则表达式，如：<code>*imp</code>。</li>
</ul>
</li>
<li><p>方法名，语法与类名一致。</p>
</li>
<li><p>参数列表：</p>
<ul>
<li>无参：<code>()</code></li>
<li>有具体参，参数必须按照填写顺序，如：<code>(String)</code>，只有一个String参数</li>
<li>模糊参数，有没有，有几个参数均可以：<code>(..)</code></li>
<li>部分模糊参数，如：第一个参数是int，其后是否存在参数，有哪些参数均无所谓，使用<code>(int..)</code></li>
</ul>
</li>
</ol>
<h5 id="切点表达式提取"><a href="#切点表达式提取" class="headerlink" title="切点表达式提取"></a>切点表达式提取</h5><p>为了避免后续修改时需要修改大量切点表达式，我们可以将切点表达式提取出来并复用：</p>
<p><strong>方法1：当前类提取</strong></p>
<p>在切点表达式所在的增强类中定义一个空方法，添加注解<code>@Pointcut(value = &quot;提取的切点表达式&quot;)</code>，然后修改其他使用切点表达式的增强方法，将切点表达式改为调用空方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pc</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Before(&quot;pc()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;function start&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@AfterReturning(&quot;pc()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;function success&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>方法2：创建一个切点存储类</strong>，单独维护切点表达式，其他增强类通过<code>类的全限定符.方法名</code>调用。这个类也需要放到IoC容器。</p>
<p>创建切点存储类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PointCuts</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pc</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他增强类使用切点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAOP</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;com.fu.PointCuts.pc()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(&quot;com.fu.PointCuts.pc()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxAroundAdvice</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知需要在通知中定义目标方法的执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 目标方法，参数不能省略（获取目标方法的信息，执行方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标方法返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;com.fu.PointCuts.pc()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transaction</span><span class="params">(ProceedingJoinPoint joinPoint)</span>&#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;事务开启&quot;</span>);     <span class="comment">// 相当于前置通知</span></span><br><span class="line">            result = joinPoint.proceed(args);</span><br><span class="line">            System.out.println(<span class="string">&quot;事务提交&quot;</span>);     <span class="comment">// 相当于返回通知</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            <span class="comment">// 必须再抛出异常，方便调用目标方法的调用者获取</span></span><br><span class="line">            System.out.println(<span class="string">&quot;事务回滚&quot;</span>);     <span class="comment">// 相当于异常通知</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;事务结束&quot;</span>);     <span class="comment">// 相当于后置通知</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="切面优先级-Order"><a href="#切面优先级-Order" class="headerlink" title="切面优先级@Order()"></a>切面优先级@Order()</h4><p><strong>注意：使用的是<code>org.springframework.core.annotation</code>下的<code>@Order()</code>注解</strong></p>
<p>在增强类声明时添加注解<code>@Order(值)</code>可以指定该类下增强方法的优先级。<code>@Order(值)</code>注解的值越小，优先级越高，优先级越高的切面，前置通知越先执行，后置通知越后执行，即优先级低的被优先级高的包围。执行顺序如下：</p>
<p>高优先级切面前置通知  –&gt;  低优先级切面所有通知方法  –&gt;  高优先级切面其他通知</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(10)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxAroundAdvice</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知需要在通知中定义目标方法的执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 目标方法，参数不能省略（获取目标方法的信息，执行方法）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标方法返回值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around(&quot;com.fu.PointCuts.pc()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transaction</span><span class="params">(ProceedingJoinPoint joinPoint)</span>&#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;事务开启&quot;</span>);     <span class="comment">// 相当于前置通知</span></span><br><span class="line">            result = joinPoint.proceed(args);</span><br><span class="line">            System.out.println(<span class="string">&quot;事务提交&quot;</span>);     <span class="comment">// 相当于返回通知</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            <span class="comment">// 必须再抛出异常，方便调用目标方法的调用者获取</span></span><br><span class="line">            System.out.println(<span class="string">&quot;事务回滚&quot;</span>);     <span class="comment">// 相当于异常通知</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;事务结束&quot;</span>);     <span class="comment">// 相当于后置通知</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order(20)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAOP</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;com.fu.PointCuts.pc()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(&quot;com.fu.PointCuts.pc()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<blockquote>
<p>事务开启<br>function start<br>function success<br>function finish<br>事务提交<br>事务结束</p>
</blockquote>
<hr>
<h3 id="基于XML配置文件实现AOP-了解"><a href="#基于XML配置文件实现AOP-了解" class="headerlink" title="基于XML配置文件实现AOP(了解)"></a>基于XML配置文件实现AOP(了解)</h3><p>如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.fu&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--声明切点标签--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pc&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.fu.service.imp.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切面配置标签</span></span><br><span class="line"><span class="comment">            ref = 增强对象</span></span><br><span class="line"><span class="comment">            order = 优先级</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;txAroundAdvice&quot;</span> <span class="attr">order</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;logAOP&quot;</span> <span class="attr">order</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;start&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如果返回通知有返回值Object类参数，就需要returning属性--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;success&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc&quot;</span> <span class="attr">returning</span>=<span class="string">&quot;result&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如果返回通知有异常Throwable类参数，就需要throwing属性--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;error&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc&quot;</span> <span class="attr">throwing</span>=<span class="string">&quot;t&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;finish&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.fu.service.imp.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>





<hr>
<h1 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h1><h2 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>声明式事务是指使用注解或 XML 配置的方式来控制事务的提交和回滚。开发者只需要添加配置即可， 具体事务的实现由第三方框架实现，避免我们直接进行事务操作。使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。<br><strong>区别：</strong></p>
<ul>
<li>编程式事务需要手动编写代码来管理事务</li>
<li>声明式事务可以通过配置文件或注解来控制事务。</li>
</ul>
<p><strong>Spring声明式事务对应依赖</strong></p>
<ul>
<li><code>spring-tx</code>: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等）</li>
<li><code>spring-jdbc</code>: 包含DataSource方式事务管理器实现类DataSourceTransactionManager</li>
<li><code>spring-orm</code>: 包含其他持久层框架的事务管理器实现类例如：Hibernate&#x2F;Jpa等</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241222200256.png"></p>
<h2 id="基于注解的声明式事务实现"><a href="#基于注解的声明式事务实现" class="headerlink" title="基于注解的声明式事务实现"></a>基于注解的声明式事务实现</h2><h3 id="基本事务控制"><a href="#基本事务控制" class="headerlink" title="基本事务控制"></a>基本事务控制</h3><ol>
<li>将对应事务管理器实现导入IoC容器，所在类使用<code>@EnableTransactionManagement</code>开启事务注解支持</li>
</ol>
<blockquote>
<p>MyBatis、jdbcTempate   –&gt; DataSourceTM</p>
<p>hibernate –&gt;  HibernateTM  </p>
</blockquote>
<ol start="2">
<li>使用注解<code>@Transactional</code>指定哪些方法需要添加事务</li>
</ol>
<p>具体参考【实践-实践5】</p>
<h3 id="Transactional注解常用事务属性"><a href="#Transactional注解常用事务属性" class="headerlink" title="@Transactional注解常用事务属性"></a>@Transactional注解常用事务属性</h3><p>方法上的@Transactional注解会覆盖类上的@Transactional注解。</p>
<ol>
<li><p><code>只读模式：@Transactional(readOnly = true)</code>：只读模式可以提高查询事务的效率，当事务中只有查询语句时，建议使用只读模式。</p>
<ul>
<li>默认情况下，只读模式处于关闭状态。</li>
<li>应用场景：一般情况下，我们都通过类注解的方式对类内全部方法添加事务，而类内查询方法可以通过再次添加注解并开启只读模式，提高查询效率。</li>
</ul>
</li>
<li><p><code>超时时间：@Transactional(timeout = 10)</code>：超时时间，当事务执行时间（被添加事务的方法执行时间）超过设定时间时，会回滚事务，抛出<code>TransactionTimeOutException</code>异常并释放资源。</p>
<ul>
<li>默认情况下，超时时间为 -1 ，即永不超时。</li>
<li>单位为秒。</li>
</ul>
</li>
<li><p><code>指定异常回滚：@Transactional(rollbackFor = Exception.class)</code>：除了默认的运行时异常之外，当指示的特定的异常发生时也应该回滚事务。即在原有的运行时异常回滚基础上添加其他异常回滚。</p>
<ul>
<li><strong>默认情况下，Spring 的事务管理器对未检查（unchecked）的异常，即继承自 <code>RuntimeException</code>(运行时异常) 的异常，以及错误（Error）进行自动回滚。</strong></li>
<li>建议设置为<code>Exception.class</code>，即所有异常均会回滚</li>
</ul>
</li>
<li><p><code>指定异常不回滚：@Transactional(noRollbackFor = Exception.class)</code>：指定事务（方法）在回滚的异常范围内发生对应异常时不发生回滚。</p>
<ul>
<li>一般情况下，与<code>rollbackFor</code>属性一起使用，很少使用</li>
</ul>
</li>
<li><p><code>事务隔离级别：@Transactional(isolation = Isolation.DEFAULT)</code>：事务的隔离级别</p>
<ul>
<li>建议设置为第二隔离级别即<code>Isolation.READ_COMMITTED</code></li>
</ul>
</li>
<li><p><code>事务的传播行为：@Transactional(propagation = Propagation.REQUIRED)</code>：指示当此事务（方法）被其他事务调用时的反应。同一个类中的事务相互调用没有影响</p>
<ul>
<li>场景：假设事务（方法）A执行过程中调用了事务（方法）B，那么事务B是加入事务A还是独立执行呢？</li>
<li>参数：<ul>
<li><strong>REQUIRED</strong> (默认)：（加入父方法的事务）如果当前存在事务，则加入该事务；如果当前不存在事务，则创建一个新的事务。</li>
<li><strong>SUPPORTS</strong>：如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务方式执行。</li>
<li><strong>MANDATORY</strong>：如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</li>
<li><strong>REQUIRES_NEW</strong>：（独立事务）创建一个新的事务，如果当前存在事务，则暂停当前事务。</li>
<li><strong>NOT_SUPPORTED</strong>：以非事务方式执行操作，如果当前存在事务，则暂停当前事务。</li>
<li><strong>NEVER</strong>：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
<li><strong>NESTED</strong>：如果当前存在事务，则在嵌套事务内执行；如果当前不存在事务，则创建一个新的事务。</li>
</ul>
</li>
<li>推荐使用<code>REQUIRED</code>.</li>
<li>同一个类中的事务相互调用没有影响，因为并不会经过代理对象。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="容器基本配置实践"><a href="#容器基本配置实践" class="headerlink" title="容器基本配置实践"></a>容器基本配置实践</h2><h3 id="实践1-基于XML方式整合三层架构组件"><a href="#实践1-基于XML方式整合三层架构组件" class="headerlink" title="实践1 基于XML方式整合三层架构组件"></a>实践1 基于XML方式整合三层架构组件</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241218220858.png"></p>
<h4 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h4><p>简化数据库的crud，不提供连接池。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 创建连接池对象，参考jdbc笔记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实例化对象</span></span><br><span class="line"><span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">jdbcTemplate.setDataSource(连接池对象)；</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 2. 调用方法</span></span><br><span class="line">jdbcTemplate.update();  <span class="comment">// DDL DML DCL 非查询语句</span></span><br><span class="line">jdbcTemplate.queryForObject();  <span class="comment">// DQL 查询单个对象</span></span><br><span class="line">jdbcTemplate.query();  <span class="comment">// DQL 查询集合</span></span><br></pre></td></tr></table></figure>

<h4 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h4><p><strong>注意！</strong> 使用Spring时，如果连接数据库时配置的user是root的话，它会优先自动获取本机的用户，以本机用户作为登录数据库的账户，而不是选择root。</p>
<p>基于硬编码方式实现连接</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///test&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0306.&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;druidDataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>基于软编码方式：xml中导入外部jdbc 配置文件properties的变量采用<code>$&#123;key&#125;$</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	xmlns:context的路径必须确保是以context结尾的</span></span><br><span class="line"><span class="comment">	xsi:schemaLocation需要包含xmlns:context的路径</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	读取外部properties配置文件  classpath填写路径，多个文件使用’,‘分隔</span></span><br><span class="line"><span class="comment">    context:property-placeholder location=&quot;classpath:jdbc.properties&quot;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	采用$&#123;key&#125;引入配置文件变量，key即变量名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;druidDataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testJdbc</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForIoC</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> applicationContext.getBean(JdbcTemplate.class);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into students(id,name,gender,age,class) values(?,?,?,?,?)&quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * sql可以带占位符 ？ 且占位符只能代替值不能代替关键字</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> jdbcTemplate.update(sql,<span class="string">&quot;10&quot;</span>,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;18&quot;</span>,<span class="string">&quot;32&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;rows = &quot;</span> + rows);</span><br><span class="line"></span><br><span class="line">        sql = <span class="string">&quot;select * from students where id = ?;&quot;</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student0</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, (rs, rowNum)-&gt;&#123;</span><br><span class="line">                <span class="comment">// rs 结果集 rowNum 行数</span></span><br><span class="line">                <span class="comment">// rs结果集中获取列的值，赋值给实体类对象</span></span><br><span class="line">                <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">                student.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">                student.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                student.setGender(rs.getString(<span class="string">&quot;gender&quot;</span>));</span><br><span class="line">                student.setAge(rs.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">                student.setClasses(rs.getString(<span class="string">&quot;class&quot;</span>));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> student;</span><br><span class="line">        &#125;,<span class="number">1</span>); <span class="comment">// 1是sql占位符对应参数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;student = &quot;</span> + student0);</span><br><span class="line">        sql = <span class="string">&quot;select * from students;&quot;</span>;</span><br><span class="line">        jdbcTemplate.query(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Student&gt;(Student.class));</span><br><span class="line">        <span class="comment">// BeanPropertyRowMapper 可以在列名和属性名一致的情况下自动映射列和属性值</span></span><br><span class="line">        <span class="comment">// 如果数据库列和类的属性值不同，可以在查询时取别名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="实践2-基于XML-注解方式整合三层架构组件"><a href="#实践2-基于XML-注解方式整合三层架构组件" class="headerlink" title="实践2 基于XML+注解方式整合三层架构组件"></a>实践2 基于XML+注解方式整合三层架构组件</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AP411s7D7?spm_id_from=333.788.videopod.episodes&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=33">实践2</a></p>
<h3 id="实践3-基于注解-配置类方式整合三层架构组件"><a href="#实践3-基于注解-配置类方式整合三层架构组件" class="headerlink" title="实践3 基于注解+配置类方式整合三层架构组件"></a>实践3 基于注解+配置类方式整合三层架构组件</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1AP411s7D7?spm_id_from=333.788.videopod.episodes&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=38">实践3</a></p>
<h2 id="AOP配置实践"><a href="#AOP配置实践" class="headerlink" title="AOP配置实践"></a>AOP配置实践</h2><h3 id="实践4-基于注解方式实现AOP"><a href="#实践4-基于注解方式实现AOP" class="headerlink" title="实践4 基于注解方式实现AOP"></a>实践4 基于注解方式实现AOP</h3><ol>
<li>导入依赖</li>
<li>正常编写核心业务，加入IoC容器</li>
<li>编写IoC配置类和文件</li>
<li>测试环境</li>
<li>增强类，定义三个增强方法（存储横切关注点的代码）</li>
<li>增强类的配置（插入切点的位置，切点指定，切面配置等）</li>
<li>开启AOP的配置</li>
</ol>
<h4 id="步骤1：导入依赖spring-aspects"><a href="#步骤1：导入依赖spring-aspects" class="headerlink" title="步骤1：导入依赖spring-aspects"></a>步骤1：导入依赖spring-aspects</h4><p>此依赖集成了实现AOP的所有需要的依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="步骤2：正常编写核心业务，加入IoC容器"><a href="#步骤2：正常编写核心业务，加入IoC容器" class="headerlink" title="步骤2：正常编写核心业务，加入IoC容器"></a>步骤2：正常编写核心业务，加入IoC容器</h4><p>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fu.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fu.service.imp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fu.service.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorPureImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i - j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i * j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i / j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="步骤3：编写IoC配置类和文件"><a href="#步骤3：编写IoC配置类和文件" class="headerlink" title="步骤3：编写IoC配置类和文件"></a>步骤3：编写IoC配置类和文件</h4><p>本次只使用配置类方式配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.fu.service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="步骤4：测试环境"><a href="#步骤4：测试环境" class="headerlink" title="步骤4：测试环境"></a>步骤4：测试环境</h4><p>当使用AOP（面向切面编程）时，实际被注入到其他bean中或者从Spring的IoC（Inversion of  Control，控制反转）容器中获取的对象，并不是定义的原始bean（即目标对象），而是一个由Spring创建的代理对象。这个代理对象包装了原始bean，并可以拦截对原始bean方法的调用，以便在这些方法调用前后执行额外的行为（如日志记录、事务管理等）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fu.Config;</span><br><span class="line"><span class="keyword">import</span> com.fu.service.Calculator;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit.jupiter.SpringJUnitConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringJUnitConfig(value = Config.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Calculator calculator;</span><br><span class="line">    <span class="comment">// 放到IoC容器的不是目标对象，而是代理对象！</span></span><br><span class="line">    <span class="comment">// 因此这里</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAOP</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(calculator.add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AOPTest</code> 类通过 <code>@Autowired</code> 注解自动注入了一个 <code>Calculator</code> 接口的实现。根据Spring AOP的工作原理，如果<code>Calculator</code>接口的实现类被配置了切面（AOP增强），那么Spring IoC容器中实际存放的将是一个代理对象，而不是直接是<code>Calculator</code>接口的具体实现类实例。</p>
<p>这意味着当调用 <code>calculator.add(1, 2)</code> 方法时，实际上首先会与代理对象进行交互。这个代理对象负责拦截对<code>add</code>方法的调用，并可以在执行实际的<code>add</code>方法之前或之后应用额外的行为（例如事务管理、日志记录等）。只有当这些额外的行为（如果有的话）被执行完毕后，代理对象才会将请求转发给真正的<code>Calculator</code>实现类来执行<code>add</code>方法。</p>
<p>当前<code>Calculator</code>接口有一个实现类<code>CalculatorPureImpl</code>，并且我们为<code>Calculator</code>定义了一些AOP切面来记录每次调用<code>add</code>方法的日志信息。在这种情况下，Spring会在运行时创建一个<code>CalculatorPureImpl</code>的代理对象，并将它作为<code>Calculator</code>类型的bean注册到IoC容器中。</p>
<p>因此，在<code>AOPTest</code>中的<code>testAOP</code>方法执行时：</p>
<ol>
<li>当尝试访问<code>calculator</code>成员变量时，实际上获取的是由Spring创建的代理对象。</li>
<li>调用<code>calculator.add(1, 2)</code>时，首先是由代理对象处理这个调用。</li>
<li>代理对象检查是否有任何适用于<code>add</code>方法的前置通知、环绕通知等，并相应地执行它们。</li>
<li>然后，代理对象调用<code>CalculatorPureImpl</code>的真实<code>add</code>方法。</li>
<li>最后，代理对象可以再执行任何后置通知或最终处理逻辑，如返回结果前的日志记录。</li>
<li><code>System.out.println(calculator.add(1,2));</code> 输出计算的结果。</li>
</ol>
<h4 id="步骤5：增强类，定义四个增强方法（存储横切关注点的代码）"><a href="#步骤5：增强类，定义四个增强方法（存储横切关注点的代码）" class="headerlink" title="步骤5：增强类，定义四个增强方法（存储横切关注点的代码）"></a>步骤5：增强类，定义四个增强方法（存储横切关注点的代码）</h4><p>假设对于方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + j;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想要创建一个日志，在代码中显示方法的执行过程，添加代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function start&quot;</span>);		<span class="comment">// 附加功能代码，在核心代码执行前执行</span></span><br><span class="line">         result = i + j; 							<span class="comment">// 原有核心代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;function success&quot;</span>);		<span class="comment">// 附加功能代码，在核心代码成功结束后执行</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function error&quot;</span>);		<span class="comment">// 附加功能代码，在核心代码异常结束后执行</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function finish&quot;</span>);		<span class="comment">// 附加功能代码，在核心代码结束最后执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>附加功能代码在核心代码的几个位置代表需要创建几个通知方法</strong></p>
<p>根据附加功能代码的位置，可以判断出需要定义四个<code>增强方法/通知方法</code>，分别是：</p>
<ul>
<li>前置通知：在被代理的目标方法<code>前</code>执行</li>
<li>返回通知：在被代理的目标方法<code>成功结束</code>后执行（寿终正寝）</li>
<li>异常通知：在被代理的目标方法<code>异常结束</code>后执行（死于非命）</li>
<li>后置通知：在被代理的目标方法<code>最终结束</code>后执行（盖棺定论）无论成功还是异常结束</li>
</ul>
<p>或者使用环绕通知：</p>
<ul>
<li>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li>
</ul>
<p>因此创建通知类&#x2F;增强类，并根据增强方法的类型添加对应的注解.</p>
<h4 id="步骤6：增强类的配置（插入切点的位置，切点指定，切面配置等）"><a href="#步骤6：增强类的配置（插入切点的位置，切点指定，切面配置等）" class="headerlink" title="步骤6：增强类的配置（插入切点的位置，切点指定，切面配置等）"></a>步骤6：增强类的配置（插入切点的位置，切点指定，切面配置等）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAOP</span> &#123;</span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function start&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterReturning(value =&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">success</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@AfterThrowing(value =&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(value =&quot;execution(* com.fu.service.imp.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;function finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="步骤7：开启AOP的配置"><a href="#步骤7：开启AOP的配置" class="headerlink" title="步骤7：开启AOP的配置"></a>步骤7：开启AOP的配置</h4><p>如果使用XML配置文件:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果使用配置类：在类声明前添加注解<code>@EnableAspectJAutoProxy</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="声明式事务配置实践"><a href="#声明式事务配置实践" class="headerlink" title="声明式事务配置实践"></a>声明式事务配置实践</h2><h3 id="实践5：基于注解方式配置生成式事务"><a href="#实践5：基于注解方式配置生成式事务" class="headerlink" title="实践5：基于注解方式配置生成式事务"></a>实践5：基于注解方式配置生成式事务</h3><h4 id="步骤1：导入依赖"><a href="#步骤1：导入依赖" class="headerlink" title="步骤1：导入依赖"></a>步骤1：导入依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="步骤2：将对应事务管理器实现导入IoC容器，开启事务注解支持"><a href="#步骤2：将对应事务管理器实现导入IoC容器，开启事务注解支持" class="headerlink" title="步骤2：将对应事务管理器实现导入IoC容器，开启事务注解支持"></a>步骤2：将对应事务管理器实现导入IoC容器，开启事务注解支持</h4><p>实践中使用JdbcTemplate，因此使用DataSourceTM</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 加入TransactionManager事务管理器实现</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">dataSourceTransactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    dataSourceTransactionManager.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> dataSourceTransactionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启事务注解支持，在上述组件声明所在的类添加注解<code>@EnableTransactionManagement</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 开启事务注解的支持</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br></pre></td></tr></table></figure>



<h4 id="步骤3：在需要添加事务的方法中使用注解-Transactional指明"><a href="#步骤3：在需要添加事务的方法中使用注解-Transactional指明" class="headerlink" title="步骤3：在需要添加事务的方法中使用注解@Transactional指明"></a>步骤3：在需要添加事务的方法中使用注解@Transactional指明</h4><p>注解<code>@Transactional</code>可以<strong>添加到类或方法</strong>上，表明此类下所有方法或此方法需要添加事务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> &#123;</span><br><span class="line">    studentDao.updateAgeById(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">    studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>笔记主要内容：</p>
<table>
<thead>
<tr>
<th>核心点</th>
<th>掌握目标</th>
</tr>
</thead>
<tbody><tr>
<td>spring框架理解</td>
<td>spring家族和spring framework框架</td>
</tr>
<tr>
<td>spring核心功能</td>
<td>ioc&#x2F;di , aop , tx</td>
</tr>
<tr>
<td>spring ioc &#x2F; di</td>
<td>组件管理、ioc容器、ioc&#x2F;di , 三种配置方式</td>
</tr>
<tr>
<td>spring aop</td>
<td>aop和aop框架和代理技术、基于注解的aop配置</td>
</tr>
<tr>
<td>spring tx</td>
<td>声明式和编程式事务、动态事务管理器、事务注解、属性</td>
</tr>
</tbody></table>
<h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><h2 id="测试环境的搭建"><a href="#测试环境的搭建" class="headerlink" title="测试环境的搭建"></a>测试环境的搭建</h2><p>可以简化测试代码，在测试时无需使用代码创建IoC容器。</p>
<p>假如当前有组件类 StudentController，需要测试其功能，在<code>src/test/java</code>下创建了测试类，执行如下操作：</p>
<p><strong>步骤1：POM文件导入外部依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>步骤2：如下设置测试类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定XML配置文件使用 locations</span></span><br><span class="line"><span class="comment">// @SpringJUnitConfig(locations = &quot;classpath:note.xml&quot;)</span></span><br><span class="line"><span class="comment">// 指定配置类使用 value</span></span><br><span class="line"><span class="comment">// 多个配置文件或配置类，使用&#123;&#125;并通过`,`分隔</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(value = CofigurationNote1.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNote1</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentController controller;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        controller.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>附加说明：</strong></p>
<ol>
<li>如果配置文件位于 <code>src/main/resources/config/</code> 目录下，应该这样写：<code>locations = &quot;classpath:note.xml&quot;</code></li>
<li>如果不提供 <code>locations</code> 或 <code>classes</code> 属性，Spring 将尝试查找与测试类同名的配置类（如果存在）</li>
<li><code>value</code>属性和<code>classes</code>属性通用，均可以省略。<code>locations</code>不可省略</li>
</ol>
<h2 id="后端跨域问题解决方案-CrossOrigin注解"><a href="#后端跨域问题解决方案-CrossOrigin注解" class="headerlink" title="后端跨域问题解决方案 - @CrossOrigin注解"></a>后端跨域问题解决方案 - @CrossOrigin注解</h2><p><code>@CrossOrigin</code> 注解是Spring框架提供的一个便捷工具，用于解决跨域资源共享（CORS）问题。它允许你灵活地配置哪些源可以访问你的资源。</p>
<ul>
<li><p><strong>功能</strong>：</p>
<ul>
<li>该注解能够指定允许访问的源（通过<code>origins</code>属性），支持的方法类型（通过<code>methods</code>属性），以及是否允许凭据（通过<code>allowCredentials</code>属性）等。</li>
<li>可以应用于类级别或方法级别，分别影响整个控制器或单个请求处理方法。</li>
</ul>
</li>
<li><p><strong>使用方法</strong>：</p>
<ul>
<li><strong>类级别</strong>：在控制器类上添加<code>@CrossOrigin</code>，为所有映射方法设置相同的CORS策略。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://example.com&quot;, maxAge = 3600)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure></li>
<li><strong>方法级别</strong>：直接在特定的请求处理方法上添加，覆盖类级别的设置。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CrossOrigin(maxAge = 3600)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/greet&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">greeting</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Hello, World&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>这种注解方式简化了CORS配置，使得开发人员可以快速实现对跨域请求的支持，而无需手动配置复杂的过滤器或编写额外的代码来处理HTTP头信息。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring/" rel="tag"><i class="fa fa-tag"></i> Spring</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/08/11/T-Git/" rel="prev" title="T-Git">
                  <i class="fa fa-angle-left"></i> T-Git
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/08/17/P-Tinyhttpd/" rel="next" title="P-Tinyhttpd">
                  P-Tinyhttpd <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments giscus-container">
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Shearington</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">453k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">25:09</span>
  </span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"Fushiye/Fushiye.github.io","repo_id":"R_kgDOLyiTvA","category":"Announcements","category_id":"DIC_kwDOLyiTvM4CteAo","mapping":"title","strict":0,"reactions_enabled":1,"emit_metadata":0,"theme":"light","lang":"zh-CN","crossorigin":"anonymous","input_position":"top","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
