<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_apple-touch-icon-human.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_human_32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_human_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fushiye.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism-darcula","dark":"prism-darcula"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"giscus","storage":true,"lazyload":false,"nav":null,"activeClass":"giscus"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":3,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="MySQL架构和性能优化学习笔记，欢迎指正~">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL-Note2-架构索引调优">
<meta property="og:url" content="https://fushiye.github.io/2024/09/07/MySQL-Note2-%E6%9E%B6%E6%9E%84%E7%B4%A2%E5%BC%95%E8%B0%83%E4%BC%98/index.html">
<meta property="og:site_name" content="星海拾贝">
<meta property="og:description" content="MySQL架构和性能优化学习笔记，欢迎指正~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815203947.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815212511.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815214908.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815215830.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815224101.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815230654.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815231147.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815234813.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240907164038.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240907180553.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241210211128.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240913120933.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/COMPACT.drawio.webp">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240914144049.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240914144142.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/image-20241029210111120.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/image-20241029221101195.png">
<meta property="og:image" content="d:\workinenglish\typora_image\image-20241029222229266.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/image-20241029223134112.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/image-20241029224809588.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241030225458.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241030225547.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241030214912.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241031223228.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241030094627.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241101163352.png">
<meta property="og:image" content="d:\workinenglish\typora_image\image-20241105223115832.png">
<meta property="og:image" content="d:\workinenglish\typora_image\image-20241105223136340.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241112224542.png">
<meta property="og:image" content="d:\workinenglish\typora_image\image-20241112225323050.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241113145255.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241122232904.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241122232928.png">
<meta property="article:published_time" content="2024-09-07T07:07:46.000Z">
<meta property="article:modified_time" content="2025-02-15T14:38:55.522Z">
<meta property="article:author" content="Shearington">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815203947.png">


<link rel="canonical" href="https://fushiye.github.io/2024/09/07/MySQL-Note2-%E6%9E%B6%E6%9E%84%E7%B4%A2%E5%BC%95%E8%B0%83%E4%BC%98/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://fushiye.github.io/2024/09/07/MySQL-Note2-%E6%9E%B6%E6%9E%84%E7%B4%A2%E5%BC%95%E8%B0%83%E4%BC%98/","path":"2024/09/07/MySQL-Note2-架构索引调优/","title":"MySQL-Note2-架构索引调优"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MySQL-Note2-架构索引调优 | 星海拾贝</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">星海拾贝</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探索永无止境</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL%E6%9E%B6%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">MySQL架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux%E4%B8%ADMySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95"><span class="nav-number">1.1.</span> <span class="nav-text">Linux中MySQL的数据目录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95"><span class="nav-number">1.1.1.</span> <span class="nav-text">MySQL的数据目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB"><span class="nav-number">1.1.2.</span> <span class="nav-text">InnoDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyISBM"><span class="nav-number">1.1.3.</span> <span class="nav-text">MyISBM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.</span> <span class="nav-text">用户和权限管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.1.</span> <span class="nav-text">[!] 用户的创建和管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.2.</span> <span class="nav-text">[!] 用户密码管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">设置当前用户密码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">设置其他用户密码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86-%E8%BF%87%E6%9C%9F%E5%92%8C%E9%87%8D%E7%94%A8"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">MySQL密码管理-过期和重用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="nav-number">1.2.2.3.1.</span> <span class="nav-text">密码过期策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%86%E7%A0%81%E9%87%8D%E7%94%A8%E7%AD%96%E7%95%A5"><span class="nav-number">1.2.2.3.2.</span> <span class="nav-text">密码重用策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.3.</span> <span class="nav-text">[!] 权限管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8%E5%92%8C%E6%8E%88%E6%9D%83%E5%8E%9F%E5%88%99"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">权限列表和授权原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%88%E6%9D%83"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">授权</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%9D%83%E9%99%90"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">查看权限</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B6%E5%9B%9E%E6%9D%83%E9%99%90"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">收回权限</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-%E6%9D%83%E9%99%90%E8%A1%A8"><span class="nav-number">1.2.4.</span> <span class="nav-text">(了解)权限表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#user%E8%A1%A8"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">user表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#db%E3%80%81table-priv%E3%80%81columns-priv%E3%80%81procs-priv%E8%A1%A8"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">db、table_priv、columns_priv、procs_priv表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.5.</span> <span class="nav-text">(了解)访问控制流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%92%E8%89%B2%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.6.</span> <span class="nav-text">[!] 角色管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%92%E8%89%B2%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">角色的创建和管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%92%E8%89%B2%E7%9A%84%E6%8E%88%E4%BA%88%EF%BC%8C%E6%BF%80%E6%B4%BB%E5%92%8C%E5%89%A5%E5%A4%BA"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">角色的授予，激活和剥夺</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E8%A7%92%E8%89%B2"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">强制角色</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">逻辑架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="nav-number">1.3.1.</span> <span class="nav-text">MySQL逻辑架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%B1%82"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">连接层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">服务器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E6%93%8E%E5%B1%82"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">引擎层</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%A6%81-SQL%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">(重要) SQL的执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL8-0%E4%B8%AD%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">MySQL8.0中执行流程的测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL5-7%E4%B8%AD%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">MySQL5.7中执行流程的测试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3-Oracle%E4%B8%AD%E7%9A%84SQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">(了解)Oracle中的SQL执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="nav-number">1.3.4.</span> <span class="nav-text">数据库缓存池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.4.</span> <span class="nav-text">存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.4.1.</span> <span class="nav-text">查看存储引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.4.2.</span> <span class="nav-text">设置表的存储引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.4.3.</span> <span class="nav-text">引擎介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91InnoDB-%E5%BC%95%E6%93%8E%EF%BC%9A%E5%85%B7%E5%A4%87%E5%A4%96%E9%94%AE%E6%94%AF%E6%8C%81%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">【重要】InnoDB 引擎：具备外键支持功能的事务存储引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91MyISAM-%E5%BC%95%E6%93%8E%EF%BC%9A%E4%B8%BB%E8%A6%81%E7%9A%84%E9%9D%9E%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">【重要】MyISAM 引擎：主要的非事务处理存储引擎</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E4%BA%86%E8%A7%A3%E3%80%91Archive-%E5%BC%95%E6%93%8E%EF%BC%9A%E7%94%A8%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%AD%98%E6%A1%A3"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">【了解】Archive 引擎：用于数据存档</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E4%BA%86%E8%A7%A3%E3%80%91CSV-%E5%BC%95%E6%93%8E%EF%BC%9A%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E4%BB%A5%E9%80%97%E5%8F%B7%E5%88%86%E9%9A%94%E5%90%84%E4%B8%AA%E6%95%B0%E6%8D%AE%E9%A1%B9"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">【了解】CSV 引擎：存储数据时，以逗号分隔各个数据项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%90%E4%BA%86%E8%A7%A3%E3%80%91Memory-%E5%BC%95%E6%93%8E%EF%BC%9A%E7%BD%AE%E4%BA%8E%E5%86%85%E5%AD%98%E7%9A%84%E8%A1%A8"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">【了解】Memory 引擎：置于内存的表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Blackhole%E3%80%81Merge%E3%80%81NDB%E3%80%81Federated"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">Blackhole、Merge、NDB、Federated</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E3%80%90%E9%87%8D%E8%A6%81%E3%80%91InnoDB%E5%90%88MyISAM%E5%AF%B9%E6%AF%94"><span class="nav-number">1.4.4.</span> <span class="nav-text">【重要】InnoDB合MyISAM对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%92%8C%E8%B0%83%E4%BC%98"><span class="nav-number">2.</span> <span class="nav-text">索引和调优</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">索引的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E7%B4%A2%E5%BC%95"><span class="nav-number">2.1.2.</span> <span class="nav-text">设计索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.3.</span> <span class="nav-text">常见的索引概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">聚簇索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%EF%BC%88%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E3%80%81%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">二级索引（非聚簇索引、辅助索引）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%88%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E4%B8%80%E7%A7%8D%EF%BC%89"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">联合索引（非聚簇索引的一种）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="nav-number">2.1.4.</span> <span class="nav-text">InnoDB的索引方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Compact%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">Compact行格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB%E7%9A%84B-%E7%B4%A2%E5%BC%95%E8%A1%A5%E5%85%85"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">InnoDB的B+索引补充</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyISAM%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="nav-number">2.1.5.</span> <span class="nav-text">MyISAM的索引方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="nav-number">2.1.6.</span> <span class="nav-text">索引的代价</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B-%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.</span> <span class="nav-text">为什么选择B+树作为索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="nav-number">2.2.1.</span> <span class="nav-text">全表遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.2.</span> <span class="nav-text">哈希结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">自适应哈希索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">2.2.3.</span> <span class="nav-text">二叉搜索树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AVL%E6%A0%91"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">AVL树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-balance-%E6%A0%91%EF%BC%88%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%89"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">B(balance)树（多路平衡查找树）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91-1"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">B+树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#R%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.3.4.</span> <span class="nav-text">R树索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">InnoDB数据存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E2%80%93-%E9%A1%B5"><span class="nav-number">2.3.1.</span> <span class="nav-text">数据库的存储结构 – 页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A3%81%E7%9B%98%E4%B8%8E%E5%86%85%E5%AD%98%E4%BA%A4%E4%BA%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">磁盘与内存交互的基本单位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">页的大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.1.3.</span> <span class="nav-text">页的结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E7%9A%84%E4%B8%8A%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.1.4.</span> <span class="nav-text">页的上层结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E7%9A%84%E5%85%B7%E4%BD%93%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.2.</span> <span class="nav-text">页的具体内部结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B4%E5%92%8C%E6%96%87%E4%BB%B6%E5%B0%BE"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">文件头和文件尾</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="nav-number">2.3.2.1.1.</span> <span class="nav-text">文件头</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%B0%BE"><span class="nav-number">2.3.2.1.2.</span> <span class="nav-text">文件尾</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E3%80%81%E7%94%A8%E6%88%B7%E8%AE%B0%E5%BD%95%E3%80%81%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">空闲空间、用户记录、最大最小记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E5%A4%B4%E5%92%8C%E9%A1%B5%E7%9B%AE%E5%BD%95"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">页头和页目录</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95"><span class="nav-number">2.3.2.3.1.</span> <span class="nav-text">页目录</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E5%A4%B4"><span class="nav-number">2.3.2.3.2.</span> <span class="nav-text">页头</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.3.3.</span> <span class="nav-text">行格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">变长字段长度列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NULL%E5%80%BC%E5%88%97%E8%A1%A8"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">NULL值列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF%EF%BC%885B%EF%BC%89"><span class="nav-number">2.3.3.3.</span> <span class="nav-text">记录头信息（5B）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE"><span class="nav-number">2.3.3.4.</span> <span class="nav-text">记录的真实数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dynamic%E5%92%8CCompressed"><span class="nav-number">2.3.3.5.</span> <span class="nav-text">Dynamic和Compressed</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%8C%E6%BA%A2%E5%87%BA"><span class="nav-number">2.3.3.5.1.</span> <span class="nav-text">行溢出</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redundant"><span class="nav-number">2.3.3.6.</span> <span class="nav-text">Redundant</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E3%80%81%E6%AE%B5%E5%92%8C%E7%A2%8E%E7%89%87%E5%8C%BA"><span class="nav-number">2.3.4.</span> <span class="nav-text">区、段和碎片区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%8C%BA%E3%80%81%E6%AE%B5%E5%92%8C%E7%A2%8E%E7%89%87%E6%AE%B5%EF%BC%9F"><span class="nav-number">2.3.4.1.</span> <span class="nav-text">为什么要有区、段和碎片段？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%BA%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">2.3.4.2.</span> <span class="nav-text">区的分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="nav-number">2.3.5.</span> <span class="nav-text">表空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="nav-number">2.3.5.1.</span> <span class="nav-text">独立表空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="nav-number">2.3.5.2.</span> <span class="nav-text">系统表空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">2.4.</span> <span class="nav-text">索引的创建和删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.4.1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">2.4.1.1.</span> <span class="nav-text">索引的分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-number">2.4.2.</span> <span class="nav-text">创建索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E6%97%B6%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="nav-number">2.4.2.0.1.</span> <span class="nav-text">创建表时添加索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%91%E8%A1%A8%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="nav-number">2.4.2.0.2.</span> <span class="nav-text">向表添加索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="nav-number">2.4.3.</span> <span class="nav-text">删除索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL8-0%E7%B4%A2%E5%BC%95%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">2.4.4.</span> <span class="nav-text">MySQL8.0索引的新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E9%99%8D%E5%BA%8F%E7%B4%A2%E5%BC%95"><span class="nav-number">2.4.4.1.</span> <span class="nav-text">支持降序索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E8%97%8F%E7%B4%A2%E5%BC%95"><span class="nav-number">2.4.4.2.</span> <span class="nav-text">隐藏索引</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E7%B4%A2%E5%BC%95%E9%9A%90%E8%97%8F%E5%92%8C%E5%8F%AF%E8%A7%81"><span class="nav-number">2.4.4.2.1.</span> <span class="nav-text">设置索引隐藏和可见</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">2.5.</span> <span class="nav-text">索引的设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E5%90%88%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">2.5.1.</span> <span class="nav-text">适合创建索引的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E9%80%82%E5%90%88%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">2.5.2.</span> <span class="nav-text">不适合作为索引的情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.6.</span> <span class="nav-text">性能分析工具的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.6.1.</span> <span class="nav-text">数据库服务器优化的一般步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0"><span class="nav-number">2.6.2.</span> <span class="nav-text">查看系统参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%84%E7%B1%BB%E7%B3%BB%E7%BB%9F%E6%80%A7%E8%83%BD%E5%8F%82%E6%95%B0"><span class="nav-number">2.6.2.1.</span> <span class="nav-text">各类系统性能参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%9F%E8%AE%A1SQL%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%88%90%E6%9C%AC%EF%BC%9Alast-query-cost"><span class="nav-number">2.6.2.2.</span> <span class="nav-text">统计SQL的查询成本：last_query_cost</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%BD%8D%E6%89%A7%E8%A1%8C%E6%85%A2%E7%9A%84-SQL%EF%BC%9A%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-number">2.6.3.</span> <span class="nav-text">定位执行慢的 SQL：慢查询日志</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%BC%80%E5%85%B3%E6%83%85%E5%86%B5"><span class="nav-number">2.6.3.1.</span> <span class="nav-text">查看慢查询日志开关情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%93%E5%BC%80-%E5%85%B3%E9%97%AD%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-number">2.6.3.2.</span> <span class="nav-text">打开&#x2F;关闭慢查询日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E6%85%A2%E6%9F%A5%E8%AF%A2%E9%98%88%E5%80%BClong-query-time"><span class="nav-number">2.6.3.3.</span> <span class="nav-text">修改慢查询阈值long_query_time</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B0%B8%E4%B9%85%E4%BF%AE%E6%94%B9%E4%B8%8A%E8%BF%B0%E5%8F%82%E6%95%B0"><span class="nav-number">2.6.3.4.</span> <span class="nav-text">永久修改上述参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%EF%BC%9Amysqldumpslow"><span class="nav-number">2.6.3.5.</span> <span class="nav-text">慢查询日志分析工具：mysqldumpslow</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B-SQL-%E6%89%A7%E8%A1%8C%E6%88%90%E6%9C%AC%EF%BC%9ASHOW-PROFILE"><span class="nav-number">2.6.4.</span> <span class="nav-text">查看 SQL 执行成本：SHOW PROFILE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%EF%BC%9AEXPLAIN"><span class="nav-number">2.6.5.</span> <span class="nav-text">分析查询语句：EXPLAIN</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">2.6.5.1.</span> <span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EXPLAIN%E5%90%84%E5%88%97%E7%9A%84%E5%85%B7%E4%BD%93%E4%BD%9C%E7%94%A8"><span class="nav-number">2.6.5.2.</span> <span class="nav-text">EXPLAIN各列的具体作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#table"><span class="nav-number">2.6.5.2.1.</span> <span class="nav-text">table</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#id"><span class="nav-number">2.6.5.2.2.</span> <span class="nav-text">id</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#select-type"><span class="nav-number">2.6.5.2.3.</span> <span class="nav-text">select_type</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#type-%E9%87%8D%E8%A6%81"><span class="nav-number">2.6.5.2.4.</span> <span class="nav-text">type(重要)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#possible-keys%E3%80%81key%E3%80%81key-len"><span class="nav-number">2.6.5.2.5.</span> <span class="nav-text">possible_keys、key、key_len</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ref%E3%80%81rows%E3%80%81filtered"><span class="nav-number">2.6.5.2.6.</span> <span class="nav-text">ref、rows、filtered</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Extra%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="nav-number">2.6.5.2.7.</span> <span class="nav-text">Extra（重要）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EXPLAIN%E7%9A%84%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BD%BF%E7%94%A8"><span class="nav-number">2.6.6.</span> <span class="nav-text">EXPLAIN的进一步使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-explain%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="nav-number">2.6.6.1.</span> <span class="nav-text">1. explain的四种输出格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#show-warnings%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">2.6.6.2.</span> <span class="nav-text">show warnings的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E5%99%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92-trace"><span class="nav-number">2.6.7.</span> <span class="nav-text">分析优化器的执行计划 trace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E7%9B%91%E6%8E%A7%E5%88%86%E6%9E%90%E8%A7%86%E5%9B%BE-sys-schema"><span class="nav-number">2.6.8.</span> <span class="nav-text">MySQL监控分析视图-sys schema</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%92%8C%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">2.7.</span> <span class="nav-text">索引优化和查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">2.7.1.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E6%A1%88%E4%BE%8B"><span class="nav-number">2.7.2.</span> <span class="nav-text">索引失效案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">关联查询优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.7.2.2.</span> <span class="nav-text">左外连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.7.2.3.</span> <span class="nav-text">内连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JOIN-%E8%AF%AD%E5%8F%A5%E5%8E%9F%E7%90%86"><span class="nav-number">2.7.2.4.</span> <span class="nav-text">JOIN 语句原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Simple-Nested-Loop-Join-%EF%BC%88%E7%AE%80%E5%8D%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="nav-number">2.7.2.4.1.</span> <span class="nav-text">Simple Nested-Loop Join （简单嵌套循环连接）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Index-Nested-Loop-Join-%EF%BC%88%E7%B4%A2%E5%BC%95%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="nav-number">2.7.2.4.2.</span> <span class="nav-text">Index Nested-Loop Join （索引嵌套循环连接）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Block-Nested-Loop-Join-%EF%BC%88%E5%9D%97%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="nav-number">2.7.2.4.3.</span> <span class="nav-text">Block  Nested-Loop Join （块嵌套循环连接）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">2.7.3.</span> <span class="nav-text">子查询优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="nav-number">2.7.4.</span> <span class="nav-text">排序优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#filesort%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E8%B7%AF%E6%8E%92%E5%BA%8F%E5%92%8C%E5%8D%95%E8%B7%AF%E6%8E%92%E5%BA%8F"><span class="nav-number">2.7.4.1.</span> <span class="nav-text">filesort算法：双路排序和单路排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Group-by%E4%BC%98%E5%8C%96"><span class="nav-number">2.7.5.</span> <span class="nav-text">Group by优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">2.7.6.</span> <span class="nav-text">分页查询优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%BC%98%E5%85%88"><span class="nav-number">2.7.7.</span> <span class="nav-text">覆盖索引优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">2.7.8.</span> <span class="nav-text">字符串的索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8ICP"><span class="nav-number">2.7.9.</span> <span class="nav-text">索引下推ICP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ICP%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="nav-number">2.7.9.1.</span> <span class="nav-text">ICP的使用条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ICP%E5%BC%80%E5%90%AF%E5%85%B3%E9%97%AD"><span class="nav-number">2.7.9.2.</span> <span class="nav-text">ICP开启关闭</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="nav-number">2.7.10.</span> <span class="nav-text">普通索引和唯一索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">2.7.11.</span> <span class="nav-text">其他查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#EXISTS%E5%92%8CIN%E7%9A%84%E5%8C%BA%E5%88%86"><span class="nav-number">2.7.11.1.</span> <span class="nav-text">EXISTS和IN的区分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#COUNT-%E5%92%8CCOUNT-%E5%AD%97%E6%AE%B5-%E6%95%88%E7%8E%87"><span class="nav-number">2.7.11.2.</span> <span class="nav-text">COUNT(*)和COUNT(字段)效率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LIMIT-1-%E5%AF%B9%E4%BC%98%E5%8C%96%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-number">2.7.11.3.</span> <span class="nav-text">LIMIT 1 对优化的影响</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%94%A8COMMIT"><span class="nav-number">2.7.11.4.</span> <span class="nav-text">多用COMMIT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">2.7.11.5.</span> <span class="nav-text">其他</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B-%E6%B7%98%E5%AE%9D%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%BB%E9%94%AE%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.7.12.</span> <span class="nav-text">示例 - 淘宝数据库的主键设置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1%E7%9A%84%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.7.12.1.</span> <span class="nav-text">核心业务的主键设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%A2%9EID%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.7.12.2.</span> <span class="nav-text">自增ID的问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="nav-number">2.8.</span> <span class="nav-text">数据库设计规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%AE-%E7%A0%81-%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="nav-number">2.8.1.</span> <span class="nav-text">键(码)和属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%BC%8F"><span class="nav-number">2.8.2.</span> <span class="nav-text">范式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1NF%EF%BC%88%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F%EF%BC%89"><span class="nav-number">2.8.2.1.</span> <span class="nav-text">1NF（第一范式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2NF%EF%BC%88%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F%EF%BC%89"><span class="nav-number">2.8.2.2.</span> <span class="nav-text">2NF（第二范式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3NF%EF%BC%88%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%EF%BC%89"><span class="nav-number">2.8.2.3.</span> <span class="nav-text">3NF（第三范式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BCNF%EF%BC%88Boyce-Codd%E8%8C%83%E5%BC%8F%EF%BC%89"><span class="nav-number">2.8.2.4.</span> <span class="nav-text">BCNF（Boyce-Codd范式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4NF%EF%BC%88%E7%AC%AC%E5%9B%9B%E8%8C%83%E5%BC%8F%EF%BC%89"><span class="nav-number">2.8.2.5.</span> <span class="nav-text">4NF（第四范式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5NF%EF%BC%88%E7%AC%AC%E4%BA%94%E8%8C%83%E5%BC%8F%EF%BC%89"><span class="nav-number">2.8.2.6.</span> <span class="nav-text">5NF（第五范式）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E8%8C%83%E5%BC%8F"><span class="nav-number">2.8.3.</span> <span class="nav-text">反范式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E8%8C%83%E5%BC%8F%E7%9A%84%E6%96%B0%E9%97%AE%E9%A2%98"><span class="nav-number">2.8.3.1.</span> <span class="nav-text">反范式的新问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E8%8C%83%E5%BC%8F%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.8.3.2.</span> <span class="nav-text">反范式的适用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ER%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.8.4.</span> <span class="nav-text">ER模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ER%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="nav-number">2.8.4.1.</span> <span class="nav-text">ER模型的基本组成部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ER%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">2.8.4.2.</span> <span class="nav-text">ER模型和数据表的转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">2.8.5.</span> <span class="nav-text">数据表的设计原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1%E7%BC%96%E5%86%99%E5%BB%BA%E8%AE%AE"><span class="nav-number">2.8.6.</span> <span class="nav-text">数据库对象编写建议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.8.6.1.</span> <span class="nav-text">对于数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E4%BA%8E%E8%A1%A8%E5%92%8C%E5%88%97"><span class="nav-number">2.8.6.2.</span> <span class="nav-text">对于表和列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%B4%A2%E5%BC%95"><span class="nav-number">2.8.6.3.</span> <span class="nav-text">关于索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8ESQL%E7%BC%96%E5%86%99"><span class="nav-number">2.8.6.4.</span> <span class="nav-text">关于SQL编写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PowerDesigner%E8%AE%BE%E8%AE%A1ER%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.8.7.</span> <span class="nav-text">PowerDesigner设计ER模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%B6%E4%BB%96%E8%B0%83%E4%BC%98%E7%AD%96%E7%95%A5"><span class="nav-number">2.9.</span> <span class="nav-text">数据库其他调优策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E8%B0%83%E4%BC%98%E9%97%AE%E9%A2%98"><span class="nav-number">2.9.1.</span> <span class="nav-text">如何定位调优问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E7%9A%84%E7%BB%B4%E5%BA%A6%E5%92%8C%E6%AD%A5%E9%AA%A4"><span class="nav-number">2.9.2.</span> <span class="nav-text">调优的维度和步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84DBMS"><span class="nav-number">2.9.2.0.1.</span> <span class="nav-text">1.选择合适的DBMS</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E4%BC%98%E5%8C%96%E8%A1%A8%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.9.2.0.2.</span> <span class="nav-text">2.优化表的设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E4%BC%98%E5%8C%96%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.9.2.0.3.</span> <span class="nav-text">3.优化逻辑查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E4%BC%98%E5%8C%96%E7%89%A9%E7%90%86%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.9.2.0.4.</span> <span class="nav-text">4.优化物理查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E4%BD%BF%E7%94%A8redis%E6%88%96Memcached"><span class="nav-number">2.9.2.0.5.</span> <span class="nav-text">5.使用redis或Memcached</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-%E5%BA%93%E7%BA%A7%E4%BC%98%E5%8C%96"><span class="nav-number">2.9.2.0.6.</span> <span class="nav-text">6. 库级优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">2.9.3.</span> <span class="nav-text">优化MySQL服务器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6"><span class="nav-number">2.9.3.1.</span> <span class="nav-text">优化服务器硬件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96MySQL%E5%8F%82%E6%95%B0"><span class="nav-number">2.9.3.2.</span> <span class="nav-text">优化MySQL参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84"><span class="nav-number">2.9.4.</span> <span class="nav-text">优化数据库结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E8%A1%A8%EF%BC%8C%E6%A3%80%E6%9F%A5%E8%A1%A8%E5%92%8C%E4%BC%98%E5%8C%96%E8%A1%A8"><span class="nav-number">2.9.4.1.</span> <span class="nav-text">分析表，检查表和优化表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E6%9E%90%E8%A1%A8"><span class="nav-number">2.9.4.1.1.</span> <span class="nav-text">**分析表 **</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E8%A1%A8"><span class="nav-number">2.9.4.1.2.</span> <span class="nav-text">检查表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E8%A1%A8"><span class="nav-number">2.9.4.1.3.</span> <span class="nav-text">优化表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="nav-number">2.9.5.</span> <span class="nav-text">大表优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5"><span class="nav-number">2.9.6.</span> <span class="nav-text">其他优化策略</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shearington"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Shearington</p>
  <div class="site-description" itemprop="description">诗酒趁年华</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Fushiye/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Fushiye&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shearington@foxmail.com" title="E-Mail → mailto:shearington@foxmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fushiye.github.io/2024/09/07/MySQL-Note2-%E6%9E%B6%E6%9E%84%E7%B4%A2%E5%BC%95%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Shearington">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星海拾贝">
      <meta itemprop="description" content="诗酒趁年华">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="MySQL-Note2-架构索引调优 | 星海拾贝">
      <meta itemprop="description" content="MySQL架构和性能优化学习笔记，欢迎指正~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL-Note2-架构索引调优
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-07 15:07:46" itemprop="dateCreated datePublished" datetime="2024-09-07T15:07:46+08:00">2024-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-15 22:38:55" itemprop="dateModified" datetime="2025-02-15T22:38:55+08:00">2025-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">缓存与数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>36k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2:01</span>
    </span>
</div>

            <div class="post-description">MySQL架构和性能优化学习笔记，欢迎指正~</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>参考资料：<br><a target="_blank" rel="noopener" href="https://mysql.net.cn/doc/refman/8.0/en/">MySQL中文文档</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=96">MySQL高级篇-尚硅谷</a></p>
<h1 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h1><h2 id="Linux中MySQL的数据目录"><a href="#Linux中MySQL的数据目录" class="headerlink" title="Linux中MySQL的数据目录"></a>Linux中MySQL的数据目录</h2><h3 id="MySQL的数据目录"><a href="#MySQL的数据目录" class="headerlink" title="MySQL的数据目录"></a>MySQL的数据目录</h3><p>数据库存放路径：<code>/var/lib/mysql</code></p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>数据与索引一同</p>
<p><strong>MySQL5.7</strong><br>数据库存放路径下存有默认数据库和创建的数据库同名的文件夹。数据库文件夹中会有文件：<code>db.opt</code>,<code>表名.frm</code>,<code>表名.idb</code>。<br><code>db.opt</code>：存放本数据库使用的字符集、比较规则等<br><code>表名.frm</code>：存储对应表的结构<br><code>表名.idb</code>：（独立表空间）5.5.6后表中的数据默认存储在此文件中。（表中数据也可能存储在上层目录中的ibdata1（系统表空间，初始12M）文件中）<br>视图没有对应idb文件–&gt;没有自己的数据</p>
<p><strong>MySQL8.0</strong>后frm文件的改为sdi文件，不再提供opt文件</p>
<h3 id="MyISBM"><a href="#MyISBM" class="headerlink" title="MyISBM"></a>MyISBM</h3><p>数据与索引分开存储</p>
<p><strong>MySQL5.7</strong><br>数据库存放路径下存有默认数据库和创建的数据库同名的文件夹。数据库文件夹中会有文件：<code>db.opt</code>,<code>表名.frm</code>,<code>表名.MYD</code>,<code>表名.MYI</code>。<br><code>db.opt</code>：存放本数据库使用的字符集、比较规则等<br><code>表名.frm</code>：存储对应表的结构<br><code>表名.MYD</code>：存储数据<br><code>表名.MYI</code>：存储索引，与<code>表名.MYD</code>一起相当于innodb中的<code>表名.idb</code></p>
<h2 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h2><p>注意：角色、用户应当尽可能使用全名如<code>userName@hostName</code>,<code>roleName@hostName</code>;</p>
<h3 id="用户的创建和管理"><a href="#用户的创建和管理" class="headerlink" title="[!] 用户的创建和管理"></a>[!] 用户的创建和管理</h3><p>MySQL中的初始用户，可在表mysql&#x2F;user（主键为host,user联合）中查看，包括mysql.infoschema、mysql.session、mysql.sys、root</p>
<p>创建用户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span> [identified <span class="keyword">by</span> <span class="string">&#x27;password&#x27;</span>][,<span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span> [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;passwd&#x27;</span>]];</span><br><span class="line"><span class="comment">-- host为主机名，%表示任何主机，localhost表示本机;[]为可选参数</span></span><br></pre></td></tr></table></figure>

<p>修改用户(不建议)：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> mysql.user <span class="keyword">SET</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;newname&#x27;</span> <span class="keyword">WHERE</span> <span class="keyword">USER</span><span class="operator">=</span><span class="string">&#x27;oldname&#x27;</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>删除用户：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法1 推荐，完全删除</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span>[,<span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span>]…;</span><br><span class="line"><span class="comment">-- 方法2 不建议，有残余文件</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> Host<span class="operator">=</span><span class="string">&#x27;hostname&#x27;</span> <span class="keyword">AND</span> <span class="keyword">User</span><span class="operator">=</span><span class="string">&#x27;username&#x27;</span></span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>


<h3 id="用户密码管理"><a href="#用户密码管理" class="headerlink" title="[!] 用户密码管理"></a>[!] 用户密码管理</h3><h4 id="设置当前用户密码"><a href="#设置当前用户密码" class="headerlink" title="设置当前用户密码"></a>设置当前用户密码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.（推荐） 使用ALTER USER命令来修改当前用户密码 </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="keyword">USER</span>() IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"><span class="comment">-- 2.（不推荐）使用SET语句来修改当前用户密码</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD<span class="operator">=</span><span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"><span class="comment">-- 3.（不推荐）MySQL5.7使用SET语句来修改当前用户密码</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="operator">=</span> PASSWORD(<span class="string">&#x27;123456&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="设置其他用户密码"><a href="#设置其他用户密码" class="headerlink" title="设置其他用户密码"></a>设置其他用户密码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.（推荐） 使用ALTER USER命令来修改用户密码 </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"><span class="comment">-- 2.（不推荐）使用SET语句来修改普通用户密码</span></span><br><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;hostname&#x27;</span><span class="operator">=</span><span class="string">&#x27;new_password&#x27;</span>;</span><br><span class="line"><span class="comment">-- 3.（不推荐）使用UPDATE语句修改普通用户的密码 </span></span><br><span class="line"><span class="keyword">UPDATE</span> MySQL.user <span class="keyword">SET</span> authentication_string <span class="operator">=</span> PASSWORD(&quot;newpasswd&quot;) <span class="keyword">WHERE</span> <span class="keyword">User</span> <span class="operator">=</span> &quot;username&quot; <span class="keyword">AND</span> Host <span class="operator">=</span> &quot;hostname&quot;;</span><br></pre></td></tr></table></figure>


<h4 id="MySQL密码管理-过期和重用"><a href="#MySQL密码管理-过期和重用" class="headerlink" title="MySQL密码管理-过期和重用"></a>MySQL密码管理-过期和重用</h4><h5 id="密码过期策略"><a href="#密码过期策略" class="headerlink" title="密码过期策略"></a>密码过期策略</h5><p>在MySQL中，数据库管理员可以<code>手动设置</code>账号密码过期，也可以建立一个<code>自动密码过期策略</code>。过期策略可以是<code>全局的</code>，也可以为<code>每个账号</code>设置单独的过期策略。</p>
<p>全局过期设置：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法1 使用SQL语句更改该变量的值并持久化</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST default_password_lifetime <span class="operator">=</span> <span class="number">180</span>; <span class="comment">-- 建立全局策略，设置密码每隔180天过期</span></span><br><span class="line"><span class="comment">-- 方法2 配置文件my.cnf中进行维护</span></span><br><span class="line">[mysqld]</span><br><span class="line">default_password_lifetime<span class="operator">=</span><span class="number">180</span> <span class="comment">-- 建立全局策略，设置密码每隔180天过期</span></span><br></pre></td></tr></table></figure>

<p>单独用户过期设置:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置kangshifu账号密码每90天过期：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="type">INTERVAL</span> <span class="number">90</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="type">INTERVAL</span> <span class="number">90</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="comment">-- 永不过期：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE NEVER;</span><br><span class="line"><span class="comment">-- 延用全局密码过期策略：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE <span class="keyword">DEFAULT</span>;</span><br><span class="line"><span class="comment">-- 立即过期</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD EXPIRE;</span><br></pre></td></tr></table></figure>

<h5 id="密码重用策略"><a href="#密码重用策略" class="headerlink" title="密码重用策略"></a>密码重用策略</h5><p>限制用户不能设置最近使用过的密码</p>
<p>全局设置</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法1 使用SQL语句</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST password_history <span class="operator">=</span> <span class="number">6</span>; <span class="comment">--设置不能选择最近使用过的6个密码</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST password_reuse_interval <span class="operator">=</span> <span class="number">365</span>; <span class="comment">--设置不能选择最近一年内的密码</span></span><br><span class="line"><span class="comment">-- 方法2 配置文件my.cnf中进行维护</span></span><br><span class="line">[mysqld]</span><br><span class="line">password_history<span class="operator">=</span><span class="number">6</span></span><br><span class="line">password_reuse_interval<span class="operator">=</span><span class="number">365</span></span><br></pre></td></tr></table></figure>

<p>单独用户设置:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不能使用最近5个密码：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD HISTORY <span class="number">5</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD HISTORY <span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 不能使用最近365天内的密码：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br><span class="line"><span class="comment">-- 既不能使用最近5个密码，也不能使用365天内的密码</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;kangshifu&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> PASSWORD HISTORY <span class="number">5</span> PASSWORD REUSE <span class="type">INTERVAL</span> <span class="number">365</span> <span class="keyword">DAY</span>;</span><br></pre></td></tr></table></figure>

<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="[!] 权限管理"></a>[!] 权限管理</h3><h4 id="权限列表和授权原则"><a href="#权限列表和授权原则" class="headerlink" title="权限列表和授权原则"></a>权限列表和授权原则</h4><p>查看权限列表：<code>show privileges;</code><br>常用权限组合：</p>
<ol>
<li><code>CREATE和DROP权限</code>，可以创建新的数据库和表，或删除（移掉）已有的数据库和表。如果将MySQL数据库中的DROP权限授予某用户，用户就可以删除MySQL访问权限保存的数据库。</li>
<li><code>SELECT、INSERT、UPDATE和DELETE权限</code>允许在一个数据库现有的表上实施操作。</li>
<li><code>SELECT权限</code>只有在它们真正从一个表中检索行时才被用到。</li>
<li><code>INDEX权限</code>允许创建或删除索引，INDEX适用于已有的表。如果具有某个表的CREATE权限，就可以在CREATE TABLE语句中包括索引定义。</li>
<li><code>ALTER权限</code>可以使用ALTER TABLE来更改表的结构和重新命名表。</li>
<li><code>CREATE ROUTINE权限</code>用来创建保存的程序（函数和程序），<code>ALTER ROUTINE权限</code>用来更改和删除保存的程序，<code>EXECUTE权限</code>用来执行保存的程序。</li>
<li><code>GRANT权限</code>允许授权给其他用户，可用于数据库、表和保存的程序。</li>
<li><code>FILE权限</code>使用户可以使用LOAD DATA INFILE和SELECT … INTO OUTFILE语句读或写服务器上的文件，任何被授予FILE权限的用户都能读或写MySQL服务器上的任何文件（说明用户可以读任何数据库目录下的文件，因为服务器可以访问这些文件）</li>
</ol>
<p><strong>授权与安全原则</strong></p>
<ol>
<li>只授予能<code>满足需要的最小权限</code>，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。</li>
<li>创建用户的时候<code>限制用户的登录主机</code>，一般是限制成指定IP或者内网IP段。</li>
<li>为每个用户<code>设置满足密码复杂度的密码</code>。</li>
<li>定期清理不需要的用户，回收权限或者删除用户</li>
</ol>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p>给用户授权的方式有 2 种，分别是通过把<code>角色赋予用户给用户授权</code>和<code>直接给用户授权</code>。用户是数据库的使用者，我们可以通过给用户授予访问数据库中资源的权限，来控制使用者对数据库的访问，消除安全隐患。</p>
<p>直接授权</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n <span class="keyword">ON</span> databaseName.tableName <span class="keyword">TO</span> username<span class="variable">@hostname</span> [IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;passwd&#x27;</span>] [<span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION];</span><br><span class="line"><span class="comment">-- 示例：插删改查</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">INSERT</span>,<span class="keyword">DELETE</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> atguigudb.<span class="operator">*</span> <span class="keyword">TO</span> li4<span class="variable">@localhost</span>;</span><br><span class="line"><span class="comment">-- 示例：所有权限（不包括GRANT）</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> joe@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line"><span class="comment">-- 示例：查看权限和授权权限</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前用户权限</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="built_in">CURRENT_USER</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看某用户全局权限</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;userName&#x27;</span>@<span class="string">&#x27;hostName&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="收回权限"><a href="#收回权限" class="headerlink" title="收回权限"></a>收回权限</h4><p>使用 REVOKE语句 取消用户的某些权限。使用REVOKE收回权限之后，用户账户的记录将从db、host、tables_priv和columns_priv表中删除，但是用户账户记录仍然在user表中保存（删除user表中的账户记录使用DROP USER语句）。</p>
<p><strong>删除用户前必须收回一切权限</strong><br>被夺权用户重新登录后生效，当前登录下权限不变</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 语法</span></span><br><span class="line"><span class="keyword">REVOKE</span> 权限<span class="number">1</span>,权限<span class="number">2</span>,…权限n <span class="keyword">ON</span> databaseName.tableName <span class="keyword">FROM</span> username<span class="variable">@hostname</span>;</span><br><span class="line"><span class="comment">-- 示例：收回一切权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">FROM</span> joe@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="了解-权限表"><a href="#了解-权限表" class="headerlink" title="(了解)权限表"></a>(了解)权限表</h3><h4 id="user表"><a href="#user表" class="headerlink" title="user表"></a>user表</h4><p>user表是MySQL中最重要的一个权限表，记录用户账号和权限信息，有49个字段，可以分成4类，分别是范围列（或用户列）、权限列、安全列和资源控制列。</p>
<p><strong>范围列（或用户列）</strong></p>
<ul>
<li><code>host</code>: 表示连接类型，可取如下范围：<ul>
<li><code>%</code> 表示所有远程通过TCP方式的连接</li>
<li><code>IP地址</code> 如(192.168.1.2、127.0.0.1)通过制定ip地址进行的TCP方式的连接</li>
<li><code>机器名</code> 通过制定网络中的机器名进行的TCP方式的连接</li>
<li><code>::1</code> IPv6的本地ip地址，等同于IPv4的 127.0.0.1</li>
<li><code>localhost</code> 本地方式通过命令行方式的连接 ，比如mysql -u xxx -p xxx 方式的连接。</li>
</ul>
</li>
<li><code>user</code>: 表示用户名，同一用户通过不同方式链接的权限是不一样的。</li>
<li><code>password</code>: 密码<blockquote>
<p>所有密码串通过password(明文字符串)生成的密文字符串。MySQL8.0在用户管理方面增加了角色管理，默认的密码加密方式也做了调整，由之前的SHA1改为了SHA2，不可逆。同时加上MySQL5.7的禁用用户和用户过期的功能，MySQL在用户管理方面的功能和安全性都较之前版本大大的增强了。mysql5.7及之后版本的密码保存到authentication_string字段中不再使用password字段。</p>
</blockquote>
</li>
</ul>
<p><strong>权限列</strong></p>
<ul>
<li>Grant_priv字段: 表示是否拥有GRANT权限</li>
<li>Shutdown_priv字段: 表示是否拥有停止MySQL服务的权限</li>
<li>Super_priv字段: 表示是否拥有超级权限</li>
<li>Execute_priv字段: 表示是否拥有EXECUTE权限。拥有EXECUTE权限，可以执行存储过程和函数。</li>
<li>Select_priv, Insert_priv等: 为该用户所拥有的权限。</li>
</ul>
<p><strong>安全列</strong> </p>
<blockquote>
<p>安全列只有6个字段，其中两个是ssl相关的（ssl_type、ssl_cipher），用于加密；两个是x509相关的（x509_issuer、x509_subject），用于标识用户；另外两个Plugin字段用于验证用户身份的插件，该字段不能为空。如果该字段为空，服务器就使用内建授权验证机制验证用户身份。</p>
</blockquote>
<p><strong>资源控制列</strong><br>资源控制列的字段用来限制用户使用的资源，包含4个字段，分别为：</p>
<ul>
<li>max_questions，用户每小时允许执行的查询操作次数；</li>
<li>max_updates，用户每小时允许执行的更新操作次数；</li>
<li>max_connections，用户每小时允许执行的连接操作次数；</li>
<li>max_user_connections，用户允许同时建立的连接次数。</li>
</ul>
<h4 id="db、table-priv、columns-priv、procs-priv表"><a href="#db、table-priv、columns-priv、procs-priv表" class="headerlink" title="db、table_priv、columns_priv、procs_priv表"></a>db、table_priv、columns_priv、procs_priv表</h4><p><strong>db表</strong></p>
<ol>
<li><code>用户列</code>: db表用户列有3个字段，分别是Host、User、Db。这3个字段分别表示主机名、用户名和数据库名。表示从某个主机连接某个用户对某个数据库的操作权限，这3个字段的组合构成了db表的主键。</li>
<li><code>权限列</code>: Create_routine_priv和Alter_routine_priv这两个字段决定用户是否具有创建和修改存储过程的权限。</li>
</ol>
<p><strong>tables_priv表</strong> 设置表的操作权限<br>tables_priv表有8个字段，分别是Host、Db、User、Table_name、Grantor、Timestamp、Table_priv和Column_priv，各个字段说明如下：</p>
<ul>
<li>Host、Db、User和Table_name四个字段分别表示主机名、数据库名、用户名和表名。</li>
<li><code>Grantor</code>表示修改该记录的用户。</li>
<li><code>Timestamp</code>表示修改该记录的时间。</li>
<li><code>Table_priv</code>表示对象的操作权限。包括Select、Insert、Update、Delete、Create、Drop、Grant、References、Index和Alter。</li>
<li><code>Column_priv</code>字段表示对表中的列的操作权限，包括Select、Insert、Update和References。</li>
</ul>
<p><strong>columns_priv表</strong> 设置表的某一列的权限 </p>
<p><strong>procs_priv表</strong> 设置存储过程和存储函数的操作权限</p>
<h3 id="了解-访问控制流程"><a href="#了解-访问控制流程" class="headerlink" title="(了解)访问控制流程"></a>(了解)访问控制流程</h3><p><strong>1 连接核实阶段</strong><br>当用户试图连接MySQL服务器时，服务器基于用户的身份以及用户是否能提供正确的密码验证身份来确定接受或者拒绝连接。即客户端用户会在连接请求中提供用户名、主机地址、用户密码，MySQL服务器接收到用户请求后，会<strong>使用user表中的host、user和authentication_string</strong>这3个字段<strong>匹配</strong>客户端提供信息。服务器只有在user表记录的Host和User字段匹配客户端主机名和用户名，并且提供正确的密码时才接受连接。如果连接核实没有通过，服务器就完全拒绝访问；否则，服务器接受连接，然后进入阶段2等待用户请求。</p>
<p><strong>2 请求核实阶段</strong><br>一旦建立了连接，服务器就进入了访问控制的阶段2，也就是请求核实阶段。对此连接上进来的每个请求，服务器检查该请求要执行什么操作、是否有足够的权限来执行它，这正是需要授权表中的权限列发挥作用的地方。这些权限可以来自user、db、table_priv和column_priv表。确认权限时，MySQL<code>首先检查user表</code> ，如果指定的权限没有在user表中被授予，那么MySQL就会<code>继续检查db表</code>，db表是下一安全层级，其中的权限限定于数据库层级，在该层级的SELECT权限允许用户查看指定数据库的所有表中的数据；如果在该层级没有找到限定的权限，则MySQL继续<code>检查tables_priv表以及columns_priv表</code>，如果所有权限表都检查完毕，但还是没有找到允许的权限操作，MySQL将返回错误信息 ，用户请求的操作不能执行，操作失败。</p>
<blockquote>
<p>提示： MySQL通过向下层级的顺序（从user表到columns_priv表）检查权限表，但并不是所有的权限都要执行该过程。例如，一个用户登录到MySQL服务器之后只执行对MySQL的管理操作，此时只涉及管理权限，因此MySQL只检查user表。另外，如果请求的权限操作不被允许，MySQL也不会继续检查下一层级的表。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815203947.png" alt="MySQL访问控制机制"></p>
<h3 id="角色管理"><a href="#角色管理" class="headerlink" title="[!] 角色管理"></a>[!] 角色管理</h3><p>为用户授予不同角色，从而实现不同角色用户拥有不同权限，简化管理</p>
<h4 id="角色的创建和管理"><a href="#角色的创建和管理" class="headerlink" title="角色的创建和管理"></a>角色的创建和管理</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建角色: host_name省略时默认为%，role_name不可省略，不可为空。</span></span><br><span class="line"><span class="keyword">CREATE</span> ROLE <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>] [,<span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>]]...</span><br><span class="line"><span class="comment">-- 为角色授权</span></span><br><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> table_name <span class="keyword">TO</span> <span class="string">&#x27;role_name&#x27;</span>[@<span class="string">&#x27;host_name&#x27;</span>];</span><br><span class="line"><span class="comment">-- 查看角色权限</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;role_name&#x27;</span>;</span><br><span class="line"><span class="comment">-- 回收权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> privileges <span class="keyword">ON</span> tablename <span class="keyword">FROM</span> <span class="string">&#x27;rolename&#x27;</span>;</span><br><span class="line"><span class="comment">-- 删除角色：拥有此角色的用户也会失去对应权限</span></span><br><span class="line"><span class="keyword">DROP</span> ROLE role [,role2]...</span><br></pre></td></tr></table></figure>

<h4 id="角色的授予，激活和剥夺"><a href="#角色的授予，激活和剥夺" class="headerlink" title="角色的授予，激活和剥夺"></a>角色的授予，激活和剥夺</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 角色的授予：默认没有激活权限</span></span><br><span class="line"><span class="keyword">GRANT</span> role [,role2,...] <span class="keyword">TO</span> <span class="keyword">user</span> [,user2,...];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 角色的激活：必须激活才真正拥有权限</span></span><br><span class="line"><span class="comment">-- 方法1 </span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">DEFAULT</span> ROLE <span class="keyword">ALL</span> <span class="keyword">TO</span> <span class="string">&#x27;userName&#x27;</span>@<span class="string">&#x27;hostName&#x27;</span>;</span><br><span class="line"><span class="comment">-- 方法2：将activate_all_roles_on_login设置为ON，此后授予角色默认激活</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> activate_all_roles_on_login<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看用户角色</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_ROLE</span>();<span class="comment">-- 方法1</span></span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;userName&#x27;</span>@<span class="string">&#x27;hostName&#x27;</span>;<span class="comment">-- 方法2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 角色的剥夺：剥夺之后用户登录权限失效，若剥夺时在线，不会立即失去权限</span></span><br><span class="line"><span class="keyword">REVOKE</span> role <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>


<h4 id="强制角色"><a href="#强制角色" class="headerlink" title="强制角色"></a>强制角色</h4><p>mandatory_roles可以通过在系统变量的值中命名它们来将角色指定为强制性的。服务器将强制角色视为授予所有用户，因此无需明确授予任何帐户。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">mandatory_roles<span class="operator">=</span><span class="string">&#x27;role1,role2@localhost,r3@%.atguigu.com&#x27;</span>; <span class="comment">-- 服务开启前可修改my.cnf</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST mandatory_roles <span class="operator">=</span> <span class="string">&#x27;role1,role2@localhost,r3@%.example.com&#x27;</span>; <span class="comment">-- 系统重启后仍然有效</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> mandatory_roles <span class="operator">=</span> <span class="string">&#x27;role1,role2@localhost,r3@%.example.com&#x27;</span>; <span class="comment">-- 系统重启后失效</span></span><br></pre></td></tr></table></figure>


<h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815212511.png" alt="启动和加载配置项"></p>
<p><strong>三层结构：</strong></p>
<ol>
<li>连接层：客户端和服务器端建立连接，客户端发送 SQL 至服务器端；</li>
<li>SQL 层（服务层）：对 SQL 语句进行查询处理；与数据库文件的存储方式无关；</li>
<li>存储引擎层：与数据库文件打交道，负责数据的存储和读取</li>
</ol>
<h3 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815214908.png" alt="MySQL服务器端逻辑架构"></p>
<h4 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h4><p>系统（客户端）访问 MySQL 服务器前，做的第一件事就是建立TCP连接。经过三次握手建立连接成功后，MySQL服务器对TCP传输过来的账号密码做身份认证、权限获取。</p>
<ul>
<li>用户名或密码不对，会收到一个Access denied for user错误，客户端程序结束执行</li>
<li>用户名密码认证通过，会从权限表查出账号拥有的权限与连接关联，之后的权限判断逻辑，都将依赖于此时读到的权限<br>TCP连接收到请求后，必须要分配给一个线程专门与这个客户端的交互。所以还会有个线程池，去走后面的流程。每一个连接从线程池中获取线程，省去了创建和销毁线程的开销。<br><strong>控制连接数量和线程</strong></li>
</ul>
<h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ol>
<li>SQLInterface:SQL接口<blockquote>
<p>接收用户的SQL命令，并且返回用户需要查询的结果。比如SELECT…FROM就是调用SQL Interface<br>MySQL支持DML（数据操作语言）、DDL（数据定义语言）、存储过程、视图、触发器、自定义函数等多种SQL语言接口</p>
</blockquote>
</li>
<li>Parser:解析器<blockquote>
<p>在解析器中对SQL语句进行语法分析、语义分析。将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。<br>在SQL命令传递到解析器的时候会被解析器验证和解析，并为其创建语法树，并根据数据字典丰富查询语法树，会验证该客户端是否具有执行该查询的权限。创建好语法树后，MySQL还会对SQl查询进行语法上的优化，进行查询重写。</p>
</blockquote>
</li>
<li>Optimizer:查询优化器<blockquote>
<p>SQL语句在语法解析之后、查询之前会使用查询优化器确定SQL语句的执行路径，生成一个执行计划。<br>这个执行计划表明应该使用哪些索引进行查询（全表检索还是使用索引检索），表之间的连接顺序如何，最后会按照执行计划中的步骤调用存储引擎提供的方法来真正的执行查询，并将查询结果返回给用户。<br>它使用“选取-投影-连接”策略进行查询。例如：<br>这个SELECT查询先根据WHERE语句进行选取，而不是将表全部查询出来以后再进行gender过滤。这个SELECT查询先根据id和name进行属性投影，而不是将属性全部取出以后再进行过滤，将这两个查询条件连接起来生成最终查询结果。</p>
</blockquote>
</li>
<li>Caches&amp;Buffers：查询缓存组件<blockquote>
<p>MySQL内部维持着一些Cache和Buffer，比如QueryCache用来缓存一条SELECT语句的执行结果，如果能够在其中找到对应的查询结果，那么就不必再进行查询解析、优化和执行的整个过程了，直接将结果反馈给客户端。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。这个查询缓存可以在不同客户端之间共享。从MySQL5.7.20开始，不推荐使用查询缓存，并在MySQL8.0中删除。</p>
</blockquote>
</li>
</ol>
<h4 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h4><p>插件式存储引擎层（ Storage Engines），真正的负责了MySQL中数据的存储和提取，对物理服务器级别维护的底层数据执行操作，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。<br>MySQL 8.0.25默认支持的存储引擎<code>show engines</code></p>
<p>存储层<br>所有的数据，数据库、表的定义，表的每一行的内容，索引，都是存在文件系统上，以文件的方式存在的，并完成与存储引擎的交互。当然有些存储引擎比如InnoDB，也支持不使用文件系统直接管理裸设备，但现代文件系统的实现使得这样做没有必要了。在文件系统之下，可以使用本地磁盘，可以使用DAS、NAS、SAN等各种存储系统。</p>
<h3 id="重要-SQL的执行流程"><a href="#重要-SQL的执行流程" class="headerlink" title="(重要) SQL的执行流程"></a>(重要) SQL的执行流程</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815215830.png" alt="SQL执行流程"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815224101.png" alt="SQL执行顺序"></p>
<p>总体流程简述：</p>
<ol>
<li>查询缓存：查询是否有相同的SQL语句，有则直接返回结果<blockquote>
<p>相同的查询操作(所有字符包括大小写都必须相同)才会命中查询缓存；包含某些系统函数、用户自定义变量和函数、一些系统表的无法缓存；增删改等会导致缓存失效的时候 &#x3D;&#x3D;》 mysql8去除;5.7也是默认关闭</p>
</blockquote>
</li>
<li>解析器词法、语法、语义解析，生成语法树</li>
<li>优化器优化：确定 SQL 语句的执行路径，比如是根据全表检索 ，还是根据索引检索等</li>
<li>执行器：判断用户是否有权限，执行并缓存</li>
</ol>
<h4 id="MySQL8-0中执行流程的测试"><a href="#MySQL8-0中执行流程的测试" class="headerlink" title="MySQL8.0中执行流程的测试"></a>MySQL8.0中执行流程的测试</h4><ol>
<li>确认profiling 是否开启 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@profiling</span>;</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span></span><br><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li>多次执行相同SQL查询</li>
<li>查看当前会话产生的全部profiles <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure></li>
<li>查看上一条命令对应profile: <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile;</span><br></pre></td></tr></table></figure>
 可见SQL语句执行过程：<br> <img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815230654.png" alt="命令执行过程"></li>
</ol>
<h4 id="MySQL5-7中执行流程的测试"><a href="#MySQL5-7中执行流程的测试" class="headerlink" title="MySQL5.7中执行流程的测试"></a>MySQL5.7中执行流程的测试</h4><ol>
<li>配置文件&#x2F;etc&#x2F;my.cnf中开启查询缓存 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type=1</span><br></pre></td></tr></table></figure></li>
<li>重启mysql服务 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure></li>
<li>开启查询执行计划 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
<li>多次执行相同SQL查询</li>
<li>查看当前会话产生的全部profiles</li>
<li>查看上一条命令对应profile:</li>
</ol>
<p>可见SQL语句执行过程</p>
<h3 id="了解-Oracle中的SQL执行流程"><a href="#了解-Oracle中的SQL执行流程" class="headerlink" title="(了解)Oracle中的SQL执行流程"></a>(了解)Oracle中的SQL执行流程</h3><p>共享池：用于判断SQL语句是否存在缓存和执行计划<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815231147.png" alt="Oracle中的SQL执行流程"></p>
<ol>
<li>语法检查：检查 SQL 拼写是否正确，如果不正确，Oracle 会报语法错误。</li>
<li>语义检查：检查 SQL 中的访问对象是否存在。比如我们在写 SELECT 语句的时候，列名写错了，系统就会提示错误。语法检查和语义检查的作用是保证 SQL 语句没有错误。</li>
<li>权限检查：看用户是否具备访问该数据的权限。</li>
<li>共享池检查：共享池（Shared Pool）是一块内存池，最主要的作用是缓存 SQL 语句和该语句的执行计划。</li>
<li>优化器：优化器中就是要进行硬解析，也就是决定怎么做，比如创建解析树，生成执行计划。</li>
<li>执行器：当有了解析树和执行计划之后，就知道了SQL该怎么被执行，这样就可以在执行器中执行语句了</li>
</ol>
<p><strong>共享池</strong></p>
<p>在共享池中，Oracle首先对SQL语句进行Hash运算，然后根据Hash值在库缓存（LibraryCache）中查找，如果存在SQL语句的执行计划，就直接拿来执行，直接进入“执行器”的环节，这就是<code>软解析</code>。<br>如果没有找到SQL语句和执行计划，Oracle就需要创建解析树进行解析，生成执行计划，进入“优化器”这个步骤，这就是<code>硬解析</code>。。<br>共享池是Oracle中的术语，包括了<code>库缓存，数据字典缓冲区</code>等。我们上面已经讲到了库缓存区，它主要缓存SQL语句和执行计划。而数据字典缓冲区存储的是Oracle中的对象定义，比如表、视图、索引等对象。当对SQL语句进行解析的时候，如果需要相关的数据，会从数据字典缓冲区中提取。库缓存这一个步骤，决定了SQL语句是否需要进行硬解析。为了提升SQL的执行效率，我们应该尽量<br>避免硬解析，因为在SQL的执行过程中，创建解析树，生成执行计划是很消耗资源的。<br>如何避免硬解析，尽量使用软解析呢？<br>在Oracle中，绑定变量是它的一大特色。绑定变量就是在SQL语句中使用变量，通过不同的变量取值来改变SQL的执行结果。这样做的好处是能提升软解析的可能性，不足之处在于可能会导致生成的执行计划不够优化，因此是否需要绑定变量还需要视情况而定。</p>
<h3 id="数据库缓存池"><a href="#数据库缓存池" class="headerlink" title="数据库缓存池"></a>数据库缓存池</h3><p>InnoDB 存储引擎是以页为单位来管理存储空间的，我们进行的增删改查操作其实本质上都是在访问页面（包括读页面、写页面、创建新页面等操作）。而磁盘I&#x2F;O需要消耗的时间很多，而在内存中进行操作，效率则会高很多，为了能让数据表或者索引中的数据随时被我们所用，DBMS 会申请 占用内存来作为数据缓冲池 ，在真正访问页面之前，需要把在磁盘上的页缓存到内存中的 Buffer Pool 之后才可以访<br>问。这样做的好处是可以让磁盘活动最小化，从而减少与磁盘直接进行 I&#x2F;O 的时间。这种策略对提升 SQL 语句的查询性能来说至关重要。如果索引的数据在缓冲池里，那么访问的成本就会降低很多。</p>
<p>InnoDB 缓冲池包括了数据页、索引页、插入缓冲、锁信息、自适应Hash和数据字典信息等，是InnoDB占用内存的主体。</p>
<p><strong>缓存原则</strong>：<code>位置 * 频次</code><br>首先，位置决定效率，提供缓冲池就是为了在内存中可以直接访问数据。<br>其次，频次决定优先级顺序。因为缓冲池的大小是有限的，比如磁盘有200G，但是内存只有 16G，缓冲池大小只有1G，就无法将所有数据都加载到缓冲池里，这时就涉及到优先级顺序，会优先对使用频次高的热数据进行加载。</p>
<p>注意：查询缓存是提前把 查询结果缓存起来，与缓冲池完全不同。</p>
<p>在数据库进行页面读操作的时候，首先会判断该页面是否在缓冲池中，如果存在就直接读取，如果不存在，就会通过内存或磁盘将页面存放到缓冲池中再进行读取。<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240815234813.png"></p>
<p>数据更新时，如果数据存在缓冲池，优先更新缓冲池中数据，一定时间后更新磁盘。</p>
<p><strong>查看和设置缓冲池大小</strong></p>
<p>InnoDB 存储引擎</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询 </span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span></span><br><span class="line"><span class="comment">-- 设置 默认128MB</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> innodb_buffer_pool_size <span class="operator">=</span> <span class="number">268435456</span>;</span><br><span class="line"><span class="comment">-- 或修改配置文件</span></span><br><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_size <span class="operator">=</span> <span class="number">268435456</span></span><br></pre></td></tr></table></figure>

<p><strong>多个Buffer Pool</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询 </span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_instances&#x27;</span></span><br><span class="line"><span class="comment">-- 设置</span></span><br><span class="line">[server]</span><br><span class="line">innodb_buffer_pool_instances <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="comment">-- 每个缓冲池的大小是总共的大小除以实例的个数</span></span><br></pre></td></tr></table></figure>


<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p><strong>存储引擎实际上指的就是表的类型</strong></p>
<h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><p>1、查看系统提供的所有存储引擎</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">show</span> engines \G;</span><br></pre></td></tr></table></figure>

<p>2、 查看系统默认存储引擎<br><strong>默认使用 InnoDB 作为表的存储引擎（MySQL&gt;&#x3D;5.5）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@default_storage_engine</span>;</span><br></pre></td></tr></table></figure>

<p>3、修改系统默认存储引擎</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> DEFAULT_STORAGE_ENGINE<span class="operator">=</span>MyISAM;</span><br><span class="line"><span class="comment">-- 或修改配置文件my.conf</span></span><br><span class="line"><span class="keyword">default</span><span class="operator">-</span>storage<span class="operator">-</span>engine<span class="operator">=</span>MyISAM</span><br><span class="line"><span class="comment">-- 重启服务</span></span><br><span class="line">systemctl restart mysqld.service</span><br></pre></td></tr></table></figure>

<h3 id="设置表的存储引擎"><a href="#设置表的存储引擎" class="headerlink" title="设置表的存储引擎"></a>设置表的存储引擎</h3><p>1、创建表时指定，不指定使用默认</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">建表语句;</span><br><span class="line">) ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure>

<p>2、修改表的存储引擎</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ENGINE <span class="operator">=</span> 存储引擎名称;</span><br></pre></td></tr></table></figure>


<h3 id="引擎介绍"><a href="#引擎介绍" class="headerlink" title="引擎介绍"></a>引擎介绍</h3><h4 id="【重要】InnoDB-引擎：具备外键支持功能的事务存储引擎"><a href="#【重要】InnoDB-引擎：具备外键支持功能的事务存储引擎" class="headerlink" title="【重要】InnoDB 引擎：具备外键支持功能的事务存储引擎"></a>【重要】InnoDB 引擎：具备外键支持功能的事务存储引擎</h4><p><strong>相对MyISAM处理效率差，内存要求高</strong></p>
<ul>
<li>MySQL&gt;&#x3D;5.5时默认采用此引擎</li>
<li>MySQL的<code>默认事务型引擎</code>，它被设计用来处理大量的短期(short-lived)事务。可以确保事务的完整提交(Commit)和回滚(Rollback)。</li>
<li>除了增加和查询外，还需要<code>更新、删除</code>操作，应<code>优先选择</code>InnoDB存储引擎。</li>
<li><strong>除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</strong></li>
<li>数据文件结构：（参考<code>MySQL数据目录</code>）<ul>
<li>表名.frm 存储表结构（MySQL8.0时，合并在表名.ibd中）</li>
<li>表名.ibd 存储数据和索引</li>
</ul>
</li>
<li>InnoDB是<strong>为处理巨大数据量的最大性能设计</strong> 。<blockquote>
<p>在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在MySQL8.0中不存在了。</p>
</blockquote>
</li>
<li>对比MyISAM的存储引擎， InnoDB写的<strong>处理效率差</strong>一些 ，并且会占用更多的磁盘空间以保存数据和索引。</li>
<li>MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还要缓存真实数据，对<strong>内存要求较高</strong>，而且内存大小对性能有决定性的影响。</li>
</ul>
<h4 id="【重要】MyISAM-引擎：主要的非事务处理存储引擎"><a href="#【重要】MyISAM-引擎：主要的非事务处理存储引擎" class="headerlink" title="【重要】MyISAM 引擎：主要的非事务处理存储引擎"></a>【重要】MyISAM 引擎：主要的非事务处理存储引擎</h4><p><strong>相对InnoDB 不支持事务、行级锁、外键，崩溃后无法安全恢复</strong></p>
<ul>
<li>MySQL5.5之前默认的存储引擎</li>
<li>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM<code>不支持事务、行级锁、外键</code>，有一个毫无疑问的缺陷就是<code>崩溃后无法安全恢复</code>。</li>
<li>优势是访问的速度快 ，对事务完整性没有要求或者以SELECT、INSERT为主的应用</li>
<li>针对数据统计有额外的常数存储。故而<code>count(*) 的查询效率很高</code></li>
<li>数据文件结构：（参考<code>MySQL数据目录</code>）<ul>
<li>表名.frm 存储表结构</li>
<li>表名.MYD 存储数据 (MYData)</li>
<li>表名.MYI 存储索引 (MYIndex)</li>
</ul>
</li>
<li>应用场景：<code>只读应用或者以读为主的业务</code></li>
</ul>
<h4 id="【了解】Archive-引擎：用于数据存档"><a href="#【了解】Archive-引擎：用于数据存档" class="headerlink" title="【了解】Archive 引擎：用于数据存档"></a>【了解】Archive 引擎：用于数据存档</h4><ul>
<li>仅支持<code>插入和查询</code>功能，插入后不可更改；<code>插入效率高而查询较差</code></li>
<li>5.5后支持索引</li>
<li>使用<code>zlib压缩库</code>，常用作仓库使用</li>
<li>使用<code>行级锁</code>；支持<code>AUTO_INCREMENT</code>列属性，此列可具体唯一或非唯一索引</li>
<li>会创建以表名为名称，后缀为<code>.ARZ</code>的文件</li>
<li><strong>适合存储日志和数据采集；适合存储大量的独立的作为历史记录的数据；</strong><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240907164038.png"></li>
</ul>
<h4 id="【了解】CSV-引擎：存储数据时，以逗号分隔各个数据项"><a href="#【了解】CSV-引擎：存储数据时，以逗号分隔各个数据项" class="headerlink" title="【了解】CSV 引擎：存储数据时，以逗号分隔各个数据项"></a>【了解】CSV 引擎：存储数据时，以逗号分隔各个数据项</h4><ul>
<li><strong>可以将普通CSV文件作为MySQL的表处理</strong></li>
<li>可以作为一种<strong>数据交换机制</strong>，非常有用</li>
<li>存储的数据的文件以<code>.CSV</code>为后缀，可以直接在操作系统中通过文本编辑器等读取</li>
<li>对数据的<code>快速导入导出</code>有明显优势</li>
<li><code>不能有空列</code></li>
</ul>
<h4 id="【了解】Memory-引擎：置于内存的表"><a href="#【了解】Memory-引擎：置于内存的表" class="headerlink" title="【了解】Memory 引擎：置于内存的表"></a>【了解】Memory 引擎：置于内存的表</h4><p>Memory采用的逻辑介质是<code>内存</code>，<code>响应速度很快</code>，但是当mysqld守护进程崩溃的时候<code>数据会丢失</code>。另外，要求存储的数据是数据长度不变的格式，比如，Blob和Text类型的数据不可用(长度不固定的)</p>
<p>!Memory<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240907165524.png"></a></p>
<h4 id="Blackhole、Merge、NDB、Federated"><a href="#Blackhole、Merge、NDB、Federated" class="headerlink" title="Blackhole、Merge、NDB、Federated"></a>Blackhole、Merge、NDB、Federated</h4><ol>
<li><code>Blackhole</code>引擎：丢弃写操作，读操作会返回空内容</li>
<li><code>Merge</code>引擎：管理多个MyISAM表构成的表集合</li>
<li><code>NDB</code>引擎：MySQL集群专用存储引擎<blockquote>
<p>也叫做 NDB Cluster 存储引擎，主要用于<code>MySQL Cluster分布式集群</code>环境，类似于Oracle的RAC集群。</p>
</blockquote>
</li>
<li><code>Federated</code>引擎：访问远程表<blockquote>
<p>Federated引擎是访问其他MySQL服务器的一个<code>代理</code> ，尽管该引擎看起来提供了一种很好的<code>跨服务器</code>的灵活性 ，但也经常带来问题，因此<code>默认是禁用的</code></p>
</blockquote>
</li>
</ol>
<h3 id="【重要】InnoDB合MyISAM对比"><a href="#【重要】InnoDB合MyISAM对比" class="headerlink" title="【重要】InnoDB合MyISAM对比"></a>【重要】InnoDB合MyISAM对比</h3><table>
<thead>
<tr>
<th>特点</th>
<th>MyISAM</th>
<th>InnoDB</th>
<th>MEMORY</th>
<th>MERGE</th>
<th>NDB</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>有</td>
<td>64TB</td>
<td>有</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td><strong>事务安全</strong></td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>锁机制</strong></td>
<td>表锁，即使操作一条记录也会锁住整个表不适合高并发的操作</td>
<td>行锁，操作时只锁某一行<br>不对其它行有影响，适合高并发的操作</td>
<td>表锁</td>
<td>表锁</td>
<td>行锁</td>
</tr>
<tr>
<td>B树索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>哈希索引</td>
<td></td>
<td></td>
<td>支持</td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>集群索引</td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据缓存</td>
<td></td>
<td>支持</td>
<td>支持</td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>索引缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据<br>对内存要求较高，而且内存大小对性能有决定性的影响</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据可压缩</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>空间使用</td>
<td>低</td>
<td>高</td>
<td>N&#x2F;A</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>内存使用</td>
<td>低</td>
<td>高</td>
<td>中等</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>批量插入的速度</td>
<td>高</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td><strong>支持外键</strong></td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240907180553.png" alt="对比"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="索引和调优"><a href="#索引和调优" class="headerlink" title="索引和调优"></a>索引和调优</h1><p><strong>提高数据库并发访问的效率，首先考虑优化SQL和索引，然后是使用缓存的策略，最后才是数据库采用主从架构实现读写分离。</strong>如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241210211128.png"></p>
<h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>定义</strong>：<br>索引（Index）是帮助MySQL高效获取数据的数据结构。<code>本质是一种数据结构</code>。你可以简单理解为”排好序的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现<code>高级查找算法</code>。</p>
<p><strong>优点</strong></p>
<ol>
<li>提高数据检索的效率，降低<code>数据库的IO成本</code>，这也是创建索引最主要的原因。 </li>
<li>通过创建唯一索引，可以保证数据库表中每一行<code>数据的唯一性</code>。</li>
<li>在实现数据的参考完整性方面，<code>可以加速表和表之间的连接</code>。换句话说，对于有依赖关系的子表和父表联合查询时，可以提高查询速度。 </li>
<li>在使用分组和排序子句进行数据查询时，可以显著<code>减少查询中分组和排序的时间</code>，降低了CPU的消耗。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><code>创建索引和维护索引要耗费时间</code>，并且随着数据量的增加，所耗费的时间也会增加。 </li>
<li>索引需要占<code>磁盘空间</code> ，除了数据表占数据空间之外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。</li>
<li>虽然索引大大提高了查询速度，同时却会<code>降低更新表的速度</code>。当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。</li>
</ol>
<p><strong>索引可以提高查询的效率，但会降低插入效率，因此当插入大量数据时，应当先删除索引，插入数据后再重新创建索引</strong></p>
<h3 id="设计索引"><a href="#设计索引" class="headerlink" title="设计索引"></a>设计索引</h3><p>InnoDB存储引擎<code>每次从磁盘中读取数据到内存中的基本单位是页(16KB)</code>（不是最小单位）</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240913120933.png" alt="单个数据页示例"></p>
<p>当单个数据页无法存放所有数据时，就需要分配新的数据页，而新分配的<code>数据页编号</code>可能并<code>不是连续的</code>，只是通过链表连接.</p>
<blockquote>
<p>InnoDB将表空间划分为多个连续的区，每个区默认由64个页组成。这种分配方式意味着数据页在物理上是按区为单位进行分配的，而不是单个页。因此，当需要新的数据页时，InnoDB可能会分配整个区，而不是单个页，这会导致页编号的跳跃。随着数据的插入、删除和更新，表空间中的某些区可能会变得碎片化，即数据页不是连续存储的。为了优化存储效率和性能，InnoDB可能会通过合并碎片区或重新分配空间来减少碎片化。这种操作也会影响到数据页的编号连续性。</p>
</blockquote>
<p>在根据某个搜索条件查找一些记录时可能要遍历所有的数据页，因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。</p>
<p>如果我们 <code>想快速的定位到需要查找的记录在哪些数据页</code><br>可以为快速定位记录所在的数据页而 <code>建立一个目录</code> ，建这个目录必须完成下边这些事:</p>
<ol>
<li>下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。（添加数据时也必须按顺序）</li>
<li>给所有的页建立一个目录项。</li>
</ol>
<p><strong>实际上相当于给数据存在顺序的链表建一个索引</strong></p>
<h3 id="常见的索引概念"><a href="#常见的索引概念" class="headerlink" title="常见的索引概念"></a>常见的索引概念</h3><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p><strong>聚簇索引只有搜索条件是主键时才能发挥作用</strong><br>聚簇索引并不是一种单独的索引类型，而是一种<code>数据存储方式</code>（所有的用户记录全部存储在叶子结点，也就是所谓的<code>索引即数据，数据即索引。</code>（数据页中存储的可能是索引也可能是数据）聚簇即指数据行合相邻的键值聚簇的存储在一起</p>
<p><strong>特点：</strong></p>
<ol>
<li><p>使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li><code>页内</code>的记录是按照主键的大小顺序排成一个<code>单向链表</code> 。</li>
<li>各个存放<code>用户记录的页</code>也是根据页中用户记录的主键大小顺序排成一个<code>双向链表</code>。</li>
<li>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个<code>双向链表</code>。</li>
</ul>
</li>
<li><p>B+树的<code>叶子节点</code>存储的是<code>完整的用户记录</code>。</p>
<blockquote>
<p>完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
</blockquote>
</li>
</ol>
<p><strong>InnoDB中会自动创建聚簇索引，不需要显示创建</strong></p>
<p><strong>优点：</strong></p>
<ol>
<li><code>数据访问更快</code>，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快(不需要回表)</li>
<li>聚簇索引对于主键的<code>排序查找</code>和<code>范围查找</code>速度非常快</li>
<li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以<code>节省了大量的io操作</code>。</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li><code>插入速度严重依赖于插入顺序</code>，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<code>自增的ID列为主键</code></li>
<li><code>更新主键的代价很高</code>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们<code>一般定义主键为不可更新</code></li>
<li><code>二级索引访问需要两次索引查找</code>，第一次找到主键值，第二次根据主键值找到行数据</li>
</ol>
<p><strong>限制</strong></p>
<ol>
<li>MyISAM不支持</li>
<li>一个表只能有一个聚簇索引，一般就是主键</li>
<li>没有主键就使用<code>非空且唯一</code>的列作为索引，也没有就隐式定义一个主键</li>
<li>主键列应当尽可能选用有序的顺序id</li>
</ol>
<h4 id="二级索引（非聚簇索引、辅助索引）"><a href="#二级索引（非聚簇索引、辅助索引）" class="headerlink" title="二级索引（非聚簇索引、辅助索引）"></a>二级索引（非聚簇索引、辅助索引）</h4><p><strong>使用其他列作为搜索条件时，可以使用二级索引</strong>。通过建立多棵B+树，不同树中的数据采用不同的排序规则，如树1采用列1的数据大小构建，叶子结点只存储列1的数据。这种B+树和上文的聚簇索引B+树存在以下不同</p>
<ol>
<li><p>使用记录某列(设为C2)的大小进行记录和页的排序，这包括三个方面的含义：</p>
<ul>
<li><code>页内</code>的记录是按照C2的大小顺序排成一个<code>单向链表</code> 。</li>
<li>各个存放<code>用户记录的页</code>也是根据页中用户记录的C2列大小顺序排成一个<code>双向链表</code>。</li>
<li>存放<code>目录项记录的页</code>分为不同的层次，在同一层次中的页也是根据页中目录项记录的C2列大小顺序排成一个<code>双向链表</code>。</li>
</ul>
</li>
<li><p>B+树的<code>叶子节点</code>存储的<code>不是完整的用户记录</code>,而是<code>C2列+页号</code>。</p>
<blockquote>
<p>完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。</p>
</blockquote>
</li>
</ol>
<p>我们根据这个以某列(C2)大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根据某列(C2)的值查找到完整的用户记录的话，仍然需要到<code>聚簇索引</code>中再查一遍，这个过程称为<code>回表</code>。也就是根据c2列的值查询一条完整的用户记录需要使用到2棵B+树.<br>查找过程：</p>
<ol>
<li>根据根页面，快速定位到目录项记录所在的页的页号（可能需要两层）</li>
<li>通过目录项记录确定用户记录真实所在的页</li>
<li>到真实存储用户记录的页中找到具体记录</li>
<li>这棵非聚簇索引B+树的具体记录中只存储了c2列的数据和主键列（或聚簇索引依赖的其他列）的数据，因此还需要根据主键值查找聚簇索引，重复1~3.</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>InnoDB中一个表中<code>只能有一个聚簇索引</code>，<code>多个</code>依赖其他字段构建的<code>二级索引</code></p>
<p>聚簇索引和二级索引的区别：</p>
<ol>
<li>聚簇索引叶子节点存储的就是<code>数据记录</code>，非聚簇索引存储的是<code>数据位置</code>（由依赖列和主键列构成）</li>
<li>聚簇索引会<code>影响</code>数据表的<code>物理存储顺序</code>，非聚簇索引不影响</li>
<li>一个表<code>只能有一个聚簇索引</code>（只能有一种顺序存储方式），<code>可以有多个非聚簇索引</code></li>
<li>聚簇索引的<code>查询效率高</code>，但插入删除等<code>更新</code>操作<code>效率低</code>(针对的是索引对应的B+树的更新和查询，不是实际数据的更新查询，因为实际数据更新不可避免地需要修改各B+树。每次更新，聚簇索引都需要更改；而非聚簇索引的B+树不一定被修改，因为其对应列数据不一定发生变化。)</li>
</ol>
<p>聚簇索引是主键对应的 或 没有主键时非空唯一列对应的 或 都没有时隐式定义的主键列对应的 索引</p>
<h4 id="联合索引（非聚簇索引的一种）"><a href="#联合索引（非聚簇索引的一种）" class="headerlink" title="联合索引（非聚簇索引的一种）"></a>联合索引（非聚簇索引的一种）</h4><p>可以同时<code>以多个列</code>的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照c2和c3列的大小进行排序，这个包含两层含义：</p>
<ol>
<li>先把各个记录和页按照c2列进行排序。</li>
<li>在记录的c2列相同的情况下，采用c3列进行排序<br> 注意一点，以c2和c3列的大小为排序规则建立的B+树称为<code>联合索引</code>，本质上也是一个二级索引。它的意思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：</li>
<li>建立<code>联合索引</code>只会建立如上图一样的1棵B+树。</li>
<li>为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。</li>
</ol>
<h3 id="InnoDB的索引方案"><a href="#InnoDB的索引方案" class="headerlink" title="InnoDB的索引方案"></a>InnoDB的索引方案</h3><p>数据索引存储在同一文件，参见&lt;MySQL架构-Linux中的MySQL的数据目录-InnoDB&gt;</p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/base/row_format.html#innodb-%E8%A1%8C%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B">参考资料-小林coding-行格式</a></p>
<p>每一数据页中的数据就是很多行构成的，每一行数据都有存储数据的格式，叫做<code>行格式</code></p>
<p>InnoDB 提供了 4 种行格式，分别是<code>Redundant</code>、<code>Compact</code>、<code>Dynamic</code>和<code>Compressed</code>行格式。<br>Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。</p>
<h4 id="Compact行格式"><a href="#Compact行格式" class="headerlink" title="Compact行格式"></a>Compact行格式</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/COMPACT.drawio.webp"></p>
<p>一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。</p>
<ol>
<li>记录的额外信息:分为三部分<ol>
<li>变长字段长度列表：存储varchar(n)等类型变长数据的设计长度，只有存在变长数据时才有此字段。按列顺序逆序存放（提高cache命中率），如第一列变长实际长1字节，第二列3字节，则存放时为03 01，</li>
<li>NULL 值列表：NULL是不会存放在行格式中记录的真实数据部分里的，而是存储在此字段中，只有存在允许为NULL的列时才有此字段，同样按列顺序逆序存放（提高cache命中率）。用一个bit表示某个允许NULL值的列，当其值为0时表示不为NULL，为1表示为NULL;NULL 值列表必须用整数个字节的位，因此允许为NULL的列不足8的整数倍数时，使用0填充高位。如三列可为NULL，只有2，3列为NULL，则存储为0000 0110.</li>
<li>记录头信息：通常包括delete_mask(标记此记录是否被删除)；next_record(下一条记录位置（可见通过链表组织）)；<code>recode_type</code>(当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录（头），3表示最大记录（尾）)等</li>
</ol>
</li>
<li>记录的真实数据：除了我们定义的字段，还有三个隐藏字段，分别为：<ol>
<li>row_id：占6字节，非必需，建表时没有指定主键或唯一约束列就hi有此字段</li>
<li>trx_id：占6字节，必需，事务id，表示生成此条数据的事务</li>
<li>roll_pointer：7字节，必需，记录上一个版本的指针</li>
</ol>
</li>
</ol>
<h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240914144049.png"><br>通过如上的方法，当数据页足够多时，就会形成<code>B+树</code><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240914144142.png"><br><code>B+树</code>一般不超过4层，因为每个数据页为64KB，每个代表目录页的数据页可以存放1000条数据，假设每个数据页能存放100条数据，那四层<code>B+树</code>就能存放<code>100*1000*1000*1000</code>即<code>一千亿</code>条数据，足够存放大多数数据库的数据了。<br><strong>因此精确查找最多只需要查找4次</strong></p>
<h4 id="InnoDB的B-索引补充"><a href="#InnoDB的B-索引补充" class="headerlink" title="InnoDB的B+索引补充"></a>InnoDB的B+索引补充</h4><ol>
<li><code>根结点页面永远是根节点页面，与表同生共死</code>。创建索引时并不是自底向上的，而是在用户创建表时，自动创建一个B+树聚簇索引，构建一个根节点页面，没有插入数据时，B+树索引对应的根节点中既没有用户记录也没有目录项记录；当插入数据时，先把此根节点存储满；满后将记录全部复制到新分配的页，然后再开一个新页存储新插入的数据，根节点就记录这两个数据页的目录项，根节点是二层中的最高层；直到满时，再重复操作，根结点成为三层中的最高层。</li>
<li><code>内节点中目录项的唯一性</code>。内节点中目录项记录的内容是<code>索引列+页号</code>的搭配，二层索引还会有<code>主键列</code>。因为二层索引的索引列数据可能相同，两页的索引列可能相同。（这也是为什么主键不可过长的原因）</li>
<li><code>一个页至少要存储两条数据记录</code></li>
</ol>
<h3 id="MyISAM的索引方案"><a href="#MyISAM的索引方案" class="headerlink" title="MyISAM的索引方案"></a>MyISAM的索引方案</h3><p>数据索引分开存储，参见&lt;MySQL架构-Linux中的MySQL的数据目录-MyISAM&gt;</p>
<ol>
<li>MyISAM中的所有索引都是非聚簇索引</li>
<li>用户<code>记录按照插入的顺序</code>单独存储在一个文件(数据文件)中</li>
<li>索引信息存储到另一个文件(索引文件)中，会为<code>主键</code>创建一个<code>索引</code>，其叶子存储<code>主键值+数据记录地址</code></li>
<li>必须进行一次回表操作，但回表操作十分迅速，因为是直接按地址查找的</li>
<li>MyISAM可以没有主键，也不会隐式生成</li>
</ol>
<h3 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h3><ol>
<li><code>占用空间</code></li>
<li><code>增删改等更新操作维护索引需要花费时间</code></li>
</ol>
<h2 id="为什么选择B-树作为索引"><a href="#为什么选择B-树作为索引" class="headerlink" title="为什么选择B+树作为索引"></a>为什么选择B+树作为索引</h2><p>磁盘的I&#x2F;O操作是影响MySQL查询效率的关键，创建索引主要目的就是为了降低磁盘I&#x2F;O的操作次数。以下逐个数据结构和算法分析为什么选择B+树。</p>
<h3 id="全表遍历"><a href="#全表遍历" class="headerlink" title="全表遍历"></a>全表遍历</h3><p>显然效率极差</p>
<h3 id="哈希结构"><a href="#哈希结构" class="headerlink" title="哈希结构"></a>哈希结构</h3><p>Memory存储引擎支持此种索引方式。这种索引方式适合键值型数据库，如<code>redis</code>存储的核心就是哈希表</p>
<ol>
<li>哈希索引仅能满足&#x3D;、&lt;&gt;、IN查询，当进行范围查询是，时间复杂度会退化到O(n),而数能保持O(log2n)</li>
<li>哈希数据的存储时没有顺序的，不利于<code>ORDER BY</code></li>
<li>对于联合索引，哈希值是将联合索引键合并后计算的，无法单独对一个或几个索引键进行查询</li>
<li>对于等值查询，通常情况下哈希索引效率更高，但如果索引列的重复值很多，效率会降低。</li>
</ol>
<h4 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h4><p>InnoDB的自适应哈希索引（Adaptive Hash Index，简称AHI）是InnoDB存储引擎特有的一项关键特性，旨在提升查询性能和数据库的整体性能。</p>
<p>自适应哈希索引是InnoDB存储引擎为了优化某些热点数据的查询性能而自动构建的一种内存中的哈希索引结构。它不同于传统的哈希索引，因为它是自动和动态的。InnoDB会根据查询模式和数据访问频率自动决定是否构建哈希索引，并且会根据数据的变化和查询模式的变化动态地调整哈希索引。</p>
<p>具体来说，当InnoDB注意到某些索引值被频繁地以等值查询的方式访问时，它会在内存中为这些值建立哈希索引，从而加速后续的等值查询。这个过程是自动的，不需要用户干预。自适应哈希索引是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引，只是对热点页建立哈希索引。</p>
<h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树在一些情况下会退化成链表，严重降低查询性能，因此引入<code>二叉平衡树</code>AVL树</p>
<h4 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h4><p>这是一颗空树或者其左右子树的高度差的绝对值不超过1，并且左右子树均是平衡二叉树。常见的平衡二叉树包括平衡二叉搜索树、红黑树、大小堆、伸展树等。</p>
<p>平衡二叉搜索树的搜索时间复杂度为O(log2n)</p>
<h4 id="B-balance-树（多路平衡查找树）"><a href="#B-balance-树（多路平衡查找树）" class="headerlink" title="B(balance)树（多路平衡查找树）"></a>B(balance)树（多路平衡查找树）</h4><p>B树是一种自平衡的树状数据结构，能够对存储的数据进行O(log n)的时间复杂度进行查找、插入和删除。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/image-20241029210111120.png"></p>
<p><strong>特性</strong></p>
<ul>
<li>一个m阶的B树，每个节点最多可以有m个子节点，且每个节点至少有ceil(m&#x2F;2)个子节点（除了根节点和叶子节点外）。对于根节点，其子树个数范围为[2, m]，节点内值的个数范围为[1, m-1]。</li>
<li><strong>自平衡性</strong>：B树通过一系列的插入和删除操作保持树的平衡，确保所有叶子节点都位于同一深度。这种平衡性使得从根节点到任何叶子节点的路径长度相同，从而保证了查找、插入和删除操作的高效性。</li>
<li><strong>有序性</strong>：B树中的节点关键字都是有序的，这有助于在查找过程中快速定位数据。具体来说，每个节点的关键字都是递增排列的，且子节点的关键字值分布在父节点的关键字之间。</li>
<li><strong>节点分裂与合并</strong>：当节点因插入操作而变满时，会进行分裂操作，将节点中的部分关键字和子树分配给新的节点，并在父节点中插入新的关键字以维持树的平衡。同样地，在删除操作中，如果节点中的关键字数量过少，可能会通过合并相邻节点或重新平衡树来保持树的性质。</li>
</ul>
<p><strong>B树的非叶子结点也需要存储记录。</strong></p>
<h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h4><p>B树和B+树的差异：</p>
<blockquote>
<ol>
<li><p>有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数+1</p>
</li>
<li><p>B+树非叶子节点的关键字也会同时存在于子节点中，并且是在子节点中所有关键字的最大（或最小）。</p>
</li>
<li><p>非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非叶子节点既保存索引，也保存数据记录 。</p>
</li>
<li><p>所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大小从小到大顺序链接。</p>
</li>
</ol>
</blockquote>
<h4 id="R树索引"><a href="#R树索引" class="headerlink" title="R树索引"></a>R树索引</h4><p>R-Tree在MySQL很少使用，仅支持 geometry数据类型 ，支持该类型的存储引擎只有myisam、bdb、innodb、ndb、archive几种。</p>
<h2 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h2><h3 id="数据库的存储结构-–-页"><a href="#数据库的存储结构-–-页" class="headerlink" title="数据库的存储结构 – 页"></a>数据库的存储结构 – 页</h3><p>数据库管理存储空间的基本单位是页（Page），数据库I&#x2F;O操作的最小单位是页。</p>
<h4 id="磁盘与内存交互的基本单位"><a href="#磁盘与内存交互的基本单位" class="headerlink" title="磁盘与内存交互的基本单位"></a>磁盘与内存交互的基本单位</h4><p>InnoDB将数据划分为若干页，以页作为磁盘和内存之间交互的基本单位，即一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。</p>
<blockquote>
<p>在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。</p>
</blockquote>
<h4 id="页的大小"><a href="#页的大小" class="headerlink" title="页的大小"></a>页的大小</h4><p>MySQL中每页的默认大小是16KB。SQL Server默认为8KB，Oracle中以块代替页，每块大小可为 2、4、8、16、32、64KB.</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看默认页大小</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_page_size%&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="页的结构"><a href="#页的结构" class="headerlink" title="页的结构"></a>页的结构</h4><p><strong>页间采用双向链表关联</strong>，在物理结构上可能并不相连。</p>
<p>每个数据页中的<strong>记录</strong>按照主键值从小到大的顺序形成<strong>单向链表</strong>。</p>
<p>每个数据页会生成内部记录对应的<strong>页目录</strong></p>
<p>（除了数据页还有目录页）</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/image-20241029221101195.png"></p>
<h4 id="页的上层结构"><a href="#页的上层结构" class="headerlink" title="页的上层结构"></a>页的上层结构</h4><p><img src="D:\workinenglish\typora_image\image-20241029222229266.png" alt="image-20241029222229266"></p>
<p>页的上层结构<strong>区</strong></p>
<blockquote>
<p>InnoDB中，默认区大小为1MB，一个区分配<strong>64</strong>个连续的页，</p>
</blockquote>
<p>区的上层结构<strong>段</strong></p>
<blockquote>
<p>段是数据库中的分配单位，不同类型的数据库对象（表、索引）以不同的段形式存在。如当我们创建一张表时会创建一个表段。一个段可能包含一个到多个区</p>
</blockquote>
<p>段的上层结构<strong>表空间</strong></p>
<blockquote>
<p>是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。</p>
</blockquote>
<h3 id="页的具体内部结构"><a href="#页的具体内部结构" class="headerlink" title="页的具体内部结构"></a>页的具体内部结构</h3><p>页按类型分，可以分为数据页（保存B+树节点）、系统页、Undo页和事务数据页等。</p>
<p>数据页的存储空间被划分为七部分：文件头(38B)、页头(56B)、最大最小记录(26B)、用户记录、空闲空间、页目录、文件尾(8B)。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/image-20241029223134112.png"></p>
<h4 id="文件头和文件尾"><a href="#文件头和文件尾" class="headerlink" title="文件头和文件尾"></a>文件头和文件尾</h4><h5 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a><strong>文件头</strong></h5><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/image-20241029224809588.png"></p>
<p><strong>校验和</strong>：首尾均有，用于磁盘和内存的同步，每次更新重新计算校验和，如果首尾校验和不相等，说明同步过程出现问题。</p>
<h5 id="文件尾"><a href="#文件尾" class="headerlink" title="文件尾"></a><strong>文件尾</strong></h5><p>前4个字节代表页的校验和：这个部分是和File Header中的校验和相对应的。<br>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）：这个部分也是为了校验页的完整性的，<br>如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。</p>
<h4 id="空闲空间、用户记录、最大最小记录"><a href="#空闲空间、用户记录、最大最小记录" class="headerlink" title="空闲空间、用户记录、最大最小记录"></a>空闲空间、用户记录、最大最小记录</h4><p>User Records中的这些记录按照指定的行格式一条一条摆在User Records部分，相互之间形成单链表。</p>
<h4 id="页头和页目录"><a href="#页头和页目录" class="headerlink" title="页头和页目录"></a>页头和页目录</h4><h5 id="页目录"><a href="#页目录" class="headerlink" title="页目录"></a>页目录</h5><p>存储着每个分组中的最大值的地址偏移。在页中，记录是以单向链表的形式进行存储的，检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此在页结构中专门设计了页目录这个模块，专门给记录做一个目录，通过二分查找法的方式进行检索，提升效率。</p>
<p><strong>页目录的设计和二分查找</strong></p>
<ol>
<li>将所有的记录分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录。</li>
<li>第 1 组，也就是最小记录所在的分组只有 1 个记录； 最后一组，就是最大记录所在的分组，会有 1-8 条记录； 其余的组记录数量在 4-8 条之间。 这样做的好处是，除了第 1 组（最小记录所在组）以外，其余组的记录数会尽量平分。</li>
<li>在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段。</li>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。</li>
</ol>
<h5 id="页头"><a href="#页头" class="headerlink" title="页头"></a>页头</h5><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241030225458.png"></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241030225547.png"></p>
<h3 id="行格式"><a href="#行格式" class="headerlink" title="行格式"></a>行格式</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241030214912.png"></p>
<p>MySQL5.1默认设置为<code>Compact</code>行格式，一条完整的记录可以被分为记录的额外信息和真实数据两大部分</p>
<table>
<thead>
<tr>
<th align="center">额外信息</th>
<th>真实数据</th>
</tr>
</thead>
<tbody><tr>
<td align="center">变长字段长度列表| NULL值列表| 记录头信息</td>
<td>列1的值|</td>
</tr>
</tbody></table>
<p>InnoDB有4种行格式：<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>、<code>Compressed</code></p>
<p>查看</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表使用的行格式:</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">like</span> <span class="string">&#x27;表名&#x27;</span>\G</span><br><span class="line"><span class="comment">-- 查看MySQL默认行格式</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@innodb_default_row_format</span></span><br><span class="line"><span class="comment">-- 指定表的行格式</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(id <span class="type">int</span>,name <span class="type">varchar</span>(<span class="number">15</span>)) row_format<span class="operator">=</span>compact;</span><br><span class="line"><span class="comment">-- 修改表的行格式</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp row_format<span class="operator">=</span>compact</span><br></pre></td></tr></table></figure>

<p>以<code>compact</code>为例介绍行格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">15</span>)，email <span class="type">varchar</span>(<span class="number">20</span>)) row_format<span class="operator">=</span>compact;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,name,email)<span class="keyword">values</span>(<span class="number">0</span>,<span class="string">&#x27;zhangshan&#x27;</span>,<span class="string">&#x27;1212@qq.com&#x27;</span>),(<span class="number">1</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="keyword">NULL</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241031223228.png"></p>
<h4 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h4><p>记录了变长字段的实际长度，按列的逆序存储，每个变长字段的长度占1个字节。</p>
<p>以上述第一条数据为例，变长字段<code>name</code>和<code>email</code>，分别为<code>zhangshan</code>、<code>1212@qq.com</code>，因此其对应的长度分别为<code>0x09</code>、<code>0x0B</code>（一个字节），存储时存储为<code>0B09</code>。</p>
<h4 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h4><p>记录了为NULL值的列，如果表中没有允许为NULL值的列，则没有这个字段。</p>
<p>用比特位代表是否为NULL，为1表示NULL,为0表示不为NULL；只表示允许为NULL的字段。如四个字段，一个是主键，则其不可能为NULL，因此NULL值列表有3比特，代表可以其他为NULL的三个字段。顺序也是反过来存放的。</p>
<ul>
<li>假设表有N列，并且其中M列允许存储NULL值。</li>
<li>则NULL值列表的大小为 <code>(M + 7) // 8</code> 字节。这里的 <code>//</code> 表示整数除法。</li>
</ul>
<blockquote>
<p>为什么要有NULL值列表？</p>
<p>假设四字段数据为a、NULL、NULL、b，若不存储NULL值，则a,b相邻存储，不知道哪个字段是NULL；若使用特殊字符代表NULL存储在a,b之间，占用太多空间。</p>
</blockquote>
<h4 id="记录头信息（5B）"><a href="#记录头信息（5B）" class="headerlink" title="记录头信息（5B）"></a>记录头信息（5B）</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241030094627.png"></p>
<p>主要字段：</p>
<ul>
<li><p><strong>delete_mask</strong>： 标记当前记录是否被删除，占1个二进制位，1代表被删除。</p>
<blockquote>
<p>为避免每次删除都需要重新排列记录，导致性能消耗，采用删除标记的方式。</p>
<p>所有被删除的记录会组成 垃圾链表 ；这个链表中记录所占的空间称为 可重用空间</p>
<p>插入新的记录会覆盖垃圾链表中的记录。</p>
</blockquote>
</li>
<li><p><strong>min_rec_mask</strong>：B+树的每层非叶子节点(存储目录项记录的页）中的最小记录会标记为1，其他记录均被标记为0.</p>
</li>
<li><p><strong>record_type</strong>：表示当前记录的类型</p>
<ul>
<li>0：普通记录</li>
<li>1：B+树非叶子节点记录</li>
<li>2：最小记录</li>
<li>3：最大记录</li>
</ul>
</li>
<li><p><strong>heap_no</strong>：表示当前记录在本页中的位置。</p>
<blockquote>
<p>MySQL中会自动给每个页添加两条记录，分别代表最小记录和最大记录，它们的heap_no分别为0、1，称为伪记录（虚拟记录），因此实际我们的记录从2开始编号。</p>
</blockquote>
</li>
<li><p><strong>n_owned</strong>：页目录中每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段</p>
<blockquote>
<p>最小记录所在分组只能有1条记录，最大记录分组可以在1<del>8之间，其他分组在4</del>8之间</p>
</blockquote>
</li>
<li><p><strong>next_record</strong>：表示从当前记录的真实数据到下一条记录的真实数据的<strong>地址偏移量</strong>。</p>
<blockquote>
<p>最小记录（指的是heap_no中提到的自动添加的记录，也即页的具体内部结构中的“最小记录”，而不是我们添加的记录中的“最小”）的next_record指向第一条记录，最后一条记录的next_record指向最大记录</p>
</blockquote>
</li>
</ul>
<h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>这部分除了记录我们自己定义的列的数据外，还存在三个隐藏列：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>row_id</td>
<td>否</td>
<td>6字节</td>
<td>行ID，唯一标识一条记录，当不存在能唯一标识记录的列时，会自动生成此列</td>
</tr>
<tr>
<td>transaction_id</td>
<td>是</td>
<td>6字节</td>
<td>事务ID</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>是</td>
<td>7字节</td>
<td>回滚指针</td>
</tr>
</tbody></table>
<p>记录在实际数据之前</p>
<h4 id="Dynamic和Compressed"><a href="#Dynamic和Compressed" class="headerlink" title="Dynamic和Compressed"></a>Dynamic和Compressed</h4><p>MySQL5.7和8.0默认使用的是Dynamic。</p>
<p>大体上与Compact一样。</p>
<p>Compressed会对存储的数据以zlib算法进行压缩，因此对BLOB，TEXT，VARCHAR这些大长度数据能够更有效地存储</p>
<h5 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h5><p>InnoDB存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。</p>
<p>一个页最多存储16KB即16384字节，而varchar(M)类型的列最多可以存放65535字节，那么就会出现一个页存储不了一条记录的情况，这就是<code>行溢出</code></p>
<p>当出现行溢出时，就会进行分页存储，并用20字节指示下一存储页。具体处理存在区别：</p>
<ol>
<li>Dynamic和Compressed对于存储在BLOB中的数据采用了完全行溢出的方式，即原数据页只存储20字节的指针，指向溢出页的地址，而实际数据存储在溢出页中</li>
<li>Compact和Redundant会在原数据页的真实数据处存储一部分数据（768个前缀字节）</li>
</ol>
<h4 id="Redundant"><a href="#Redundant" class="headerlink" title="Redundant"></a>Redundant</h4><p>与Compact区别在于</p>
<ol>
<li>变长字段长度列表和NULL值列表被字段长度偏移列表取代，所有字段（包括隐藏字段）无论是否变长、是否可以为NULL，均记录其长度，并且记录的不是具体的长度，而是字段结尾相对第一个字段开头存的偏移。</li>
<li>记录头信息多出：<ol>
<li>n_fields（10B）字段，记录列的数量</li>
<li>1byte_offs_flag（1B）字段，记录字段长度偏移列表中每个列对应的偏移量使用1字节表示还是两字节表示。</li>
</ol>
</li>
<li>记录头信息没有了record_type</li>
</ol>
<p>已被淘汰，仅为向前支持。</p>
<h3 id="区、段和碎片区"><a href="#区、段和碎片区" class="headerlink" title="区、段和碎片区"></a>区、段和碎片区</h3><h4 id="为什么要有区、段和碎片段？"><a href="#为什么要有区、段和碎片段？" class="headerlink" title="为什么要有区、段和碎片段？"></a>为什么要有区、段和碎片段？</h4><p><strong>区：</strong></p>
<p>B+树的每一层的页都会形成一个双向链表，如果数据量很大，多个页的物理距离可能很远，不利于查询。一个区即连续的64页，当数据量太大是，为某个索引分配空间的时候就不在按照页为单位分配，而以区为单位分配，从而提高效率。</p>
<p><strong>段：</strong></p>
<p>对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有数据段、索引段、回滚段。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。<br>在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。<br>段其实不对应表空间中的某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。</p>
<p><strong>碎片区：</strong></p>
<p>对于数据量较小的表，以完整的区为单位分配给某个段太浪费存储空间。因此InnoDB提出了一个碎片（fragment）区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是<br>碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。<br><strong>碎片区直属于表空间</strong>，并不属于任何一个段。<br>所以此后为某个段分配存储空间的策略是这样的：</p>
<ul>
<li>在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。</li>
<li>当某个段已经占用了32个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。</li>
</ul>
<p>所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面已经一些完整的区的集合</p>
<h4 id="区的分类"><a href="#区的分类" class="headerlink" title="区的分类"></a>区的分类</h4><p>区大体上可以分为四类：</p>
<ul>
<li><code>空闲的区(FREE)</code>：现在还没有用到这个区中的任何页面。</li>
<li><code>有剩余空间的碎片区(FREE_FRAG)</code>：表示碎片区中还有可用的页面</li>
<li><code>没有剩余空间的碎片区(FULL_FRAG)</code>：表示碎片区中的所有页面都被使用，没有空闲页面。</li>
<li><code>附属于某个段的区(FSEG)</code>：每一索引都可以分为叶子节点段和非叶子节点段</li>
</ul>
<p>FREE、FREE_FRAG、FULL_FRAG三个状态的区都是独立的，直属于表空间，FSEG附属于某个段。</p>
<h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>是一个逻辑容器，表空间存储的对象是段，一个表空间可以有一个到多个段，但一个段只能属于一个表空间。表空间数据库有一个到多个表空间组成，从管理上可以划分为<code>系统表空间</code>、<code>独立表空间</code>、<code>撤销表空间</code>和<code>临时表空间</code>。</p>
<h4 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h4><p>每张表有一个独立的表空间，其数据和索引信息均存储在自己的表空间中，可以在不同数据库之间迁移。</p>
<h4 id="系统表空间"><a href="#系统表空间" class="headerlink" title="系统表空间"></a>系统表空间</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241101163352.png"></p>
<h2 id="索引的创建和删除"><a href="#索引的创建和删除" class="headerlink" title="索引的创建和删除"></a>索引的创建和删除</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h4><p>MySQL的索引包括</p>
<ul>
<li><p>普通索引</p>
<blockquote>
<p>可以创建在任何数据类型中</p>
</blockquote>
</li>
<li><p>唯一性索引</p>
<blockquote>
<p>使用UNIQUE声明的字段（具有唯一性约束的字段）自动创建该索引，一张表可以有多个唯一索引。若在某一字段上创建唯一性索引，也就相当于添加了唯一性约束</p>
</blockquote>
</li>
<li><p>主键索引</p>
<blockquote>
<p>具有主键约束的字段自动创建该索引；若在某一字段上创建主键索引，也相当于添加了主键约束。一张表只能有一个主键索引。</p>
</blockquote>
</li>
<li><p>全文索引</p>
<blockquote>
<p>使用参数<code>FULLTEXT</code>可以设置全文索引，且只能创建在字符文本系列类型字段上。（已经不能跟上需求，被专门化搜索引擎取代）</p>
</blockquote>
</li>
<li><p>单列索引</p>
</li>
<li><p>多列索引</p>
</li>
<li><p>空间索引等。</p>
</li>
</ul>
<p>从 <strong>功能逻辑</strong> 上说，索引主要有 4 种，分别是<code>普通索引</code>、<code>唯一索引</code>、&#96;&#96;主键索引<code>、</code>全文索引<code>。 按照 **物理实现**方式 ，索引可以分为 2 种：</code>聚簇索引<code>和</code>非聚簇索引<code>。 按照 **作用字段个数** 进行划分，分成</code>单列索引<code>和</code>联合索引&#96;</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h5 id="创建表时添加索引"><a href="#创建表时添加索引" class="headerlink" title="创建表时添加索引"></a>创建表时添加索引</h5><p><strong>隐式创建</strong></p>
<p>在建表时，如果指定了主键约束、唯一性约束（外键约束也有唯一性约束），会自动创建对应的主键索引和唯一性索引，索引名即为字段名。</p>
<p> <strong>显式创建</strong></p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name [col_name data_type] [<span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT <span class="operator">|</span> SPATIAL ][INDEX <span class="operator">|</span> KEY][index_name](col_name[length]) [ <span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<p>说明:</p>
<ul>
<li><code>UNIQUE</code> | <code>FULLTEXT</code> | <code>SPATIAL </code>为可选参数，分别代表唯一索引、全文索引、空间索引。</li>
<li><code>INDEX</code> | <code>key</code>为同义词，作用相同，表示创建的是索引。</li>
<li>index_name 为可选参数，默认使用col_name作为索引名</li>
<li>col_name 为需要创建索引的字段列，必须从数据表定义的多个字段中选择</li>
<li>length为可选参数，表示索引长度，<strong>只有字符串类型</strong>的字段才能指定长度</li>
<li><code>ASC</code> | <code>DESC</code> 指定升序或降序的索引值存储。</li>
</ul>
<p><strong>查看索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp；</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> emp；</span><br></pre></td></tr></table></figure>

<p><strong>创建普通索引</strong></p>
<p><code>INDEX</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(empId <span class="type">INT</span>,empName <span class="type">VARCHAR</span>(<span class="number">15</span>),age <span class="type">INT</span>,birYear <span class="keyword">YEAR</span>, INDEX idx_name(empName));</span><br></pre></td></tr></table></figure>

<p><strong>创建唯一索引</strong></p>
<p><code>UNIQUE INDEX</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(empId <span class="type">INT</span>,empName <span class="type">VARCHAR</span>(<span class="number">15</span>),age <span class="type">INT</span>,birYear <span class="keyword">YEAR</span>, <span class="keyword">UNIQUE</span> INDEX idx_empId(empId));</span><br></pre></td></tr></table></figure>

<p><strong>创建主键索引</strong></p>
<p>只能通过隐式创建方式，通过指定主键约束列来创建，删除同样通过删除主键约束的方式删除。</p>
<p><strong>创建多列（联合）索引</strong></p>
<p><code>INDEX</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(empId <span class="type">INT</span>,empName <span class="type">VARCHAR</span>(<span class="number">15</span>),age <span class="type">INT</span>,birYear <span class="keyword">YEAR</span>, INDEX idx_IdName(empId <span class="keyword">ASC</span>,empName <span class="keyword">DESC</span>));  <span class="comment">-- 之前的全部是单列索引。</span></span><br><span class="line"><span class="comment">-- 最常用于索引的字段放在最左侧</span></span><br></pre></td></tr></table></figure>

<p><strong>创建全文索引</strong></p>
<p><code>FULLTEXT INDEX</code></p>
<p>注意一些版本并不支持，且应当先添加数据再建立索引比较好。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 仅能在CHAR，VARCHAR，TEXT列创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(empId <span class="type">INT</span>,empName <span class="type">VARCHAR</span>(<span class="number">15</span>),info <span class="type">VARCHAR</span>(<span class="number">255</span>), FULLTEXT INDEX idx_Info(<span class="number">50</span>));</span><br><span class="line"><span class="comment">-- 以info的前50个字符作为索引</span></span><br></pre></td></tr></table></figure>

<p>在创建全文索引之后，应当使用<code>MATCH</code>+<code>AGAINST</code>方式取代LIKE查询索引列，提速N倍</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">MATCH</span>(info) AGAINST(<span class="string">&#x27;查询字符串&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>创建空间索引</strong></p>
<p>要求空间类型字段必须非空，使用<code>SPATIAL INDEX</code>关键字创建</p>
<h5 id="向表添加索引"><a href="#向表添加索引" class="headerlink" title="向表添加索引"></a>向表添加索引</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> book(</span><br><span class="line">	id <span class="type">INT</span>,</span><br><span class="line">	name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">	info <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    comments <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    pubYear <span class="keyword">YEAR</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>增加索引有两种方式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL<span class="operator">|</span>] INDEX indexName(colName);</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX indexName <span class="keyword">ON</span> tableName(ColName);</span><br></pre></td></tr></table></figure>

<p>添加主键索引就是添加主键约束。</p>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>删除索引有两种方式：DROP</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">DROP</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL<span class="operator">|</span>] INDEX indexName;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX indexName <span class="keyword">ON</span> tableName;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>删除主键索引就是删除主键约束。</p>
</li>
<li><p>添加<code>AUTO_INCREMENT</code>约束的字段不能被删除唯一索引，因为<code>AUTO_INCREMENT</code>字段必须被唯一性约束。</p>
</li>
<li><p>删除表中的列，如果该列是联合索引的组成部分，则该列也会从索引中删除。</p>
</li>
</ul>
<h3 id="MySQL8-0索引的新特性"><a href="#MySQL8-0索引的新特性" class="headerlink" title="MySQL8.0索引的新特性"></a>MySQL8.0索引的新特性</h3><h4 id="支持降序索引"><a href="#支持降序索引" class="headerlink" title="支持降序索引"></a>支持降序索引</h4><p>MySQL8.0之前创建的都是升序索引，进行反向扫描效率很低，MySQL8.0开始正式支持降序索引，但降序索引的语法在5.7就已合法，只是功能未实现。</p>
<p>适用于经常需要降序的查询。</p>
<h4 id="隐藏索引"><a href="#隐藏索引" class="headerlink" title="隐藏索引"></a>隐藏索引</h4><p>有些时候我们可能错误删除索引后又不得不重新创建，会消耗大量系统资源。因此引入了<strong>隐藏索引</strong>，对于不再使用的索引，我们可以先设置未隐藏索引，<strong>索引隐藏后数据库操作不能再使用</strong>，如果对操作和性能没有太大影响，再删除。这种先将索引设置为隐藏索引再删除的方式就是<strong>软删除</strong>。这个方法同样可以验证索引对某些操作的性能是否有影响。</p>
<p><strong>主键不能设置为隐藏索引</strong>。当表中没有主键时，表中的一个唯一非空列会成为隐式主键，同样不能设置为隐藏索引。</p>
<p><strong>索引隐藏后，其内容也会随着表的更新而更新</strong>。因此建议不需要的隐藏索引及时删除。</p>
<h5 id="设置索引隐藏和可见"><a href="#设置索引隐藏和可见" class="headerlink" title="设置索引隐藏和可见"></a>设置索引隐藏和可见</h5><p>索引使用关键字<code>VISIBLE</code>和<code>INVISIBLE</code>表示索引的可见性，可在创建、添加索引的语句最末尾添加二者之一来标识，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(empId <span class="type">INT</span>,empName <span class="type">VARCHAR</span>(<span class="number">15</span>),age <span class="type">INT</span>,birYear <span class="keyword">YEAR</span>, INDEX idx_name(empName)) INVISIBLE;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL<span class="operator">|</span>] INDEX indexName(colName) INVISIBLE;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX indexName <span class="keyword">ON</span> tableName(ColName) INVISIBLE;</span><br></pre></td></tr></table></figure>



<p><strong>也可以修改索引的可见性</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ALTER</span> INDEX indexName INVISIBLE<span class="operator">|</span>VISIBLE</span><br></pre></td></tr></table></figure>



<p>可以设置隐藏索引对查询优化器可见：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> SESSION optimizer_switch <span class="operator">=</span> &quot;use_invisible_index=on&quot;;</span><br></pre></td></tr></table></figure>



<h2 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h2><p><strong>单表的索引不应该超过6个</strong></p>
<blockquote>
<ol>
<li>太多索引会占用过多空间</li>
<li>索引会影响插入、更新、删除的性能</li>
<li>索引多会导致优化器选择最适合的索引过慢。</li>
</ol>
</blockquote>
<h3 id="适合创建索引的情况"><a href="#适合创建索引的情况" class="headerlink" title="适合创建索引的情况"></a>适合创建索引的情况</h3><p>一、字段的数值<strong>拥有唯一性</strong>的限制</p>
<p>索引本身具有约束作用，如果数据表中<strong>某一个字段是唯一的</strong>，那么就可以直接创建<strong>唯一索引</strong>或<strong>主键索引</strong></p>
<blockquote>
<p>业务上具有唯一性的字段，即使是组合字段，也必须创建唯一索引。</p>
<p>创建唯一索引带来的插入删除效率的降低远不及其对查询效率的提高</p>
</blockquote>
<p>二、频繁作为<code>WHERE</code>查询条件的字段</p>
<p>三、经常<code>GROUP BY</code>（分组）和<code>ORDER BY</code>（排序）的字段</p>
<blockquote>
<p>针对GROUP BY 和ORDER BY常常一起使用的场景，建议创建联合索引，并且GROUP BY的字段放在ORDER BY前</p>
</blockquote>
<p>四、<code>UPDATE</code>、<code>DELETE</code>的<code>WHERE</code>条件列</p>
<blockquote>
<p>若更新字段不是索引字段，效率提升明显。</p>
</blockquote>
<p>五、<code>DISTINCT</code>字段需要创建索引</p>
<p>六、多表<code>JOIN</code>连接操作时，创建索引的事项</p>
<blockquote>
<ol>
<li>连接表的数量尽量不要超过3张</li>
<li>对 WHERE 条件创建索引</li>
<li>对用于连接（ON）的字段创建索引，并且该字段在多张表中<strong>类型必须一致</strong></li>
</ol>
</blockquote>
<p>七、使用<strong>列的类型小</strong>的字段创建索引</p>
<blockquote>
<p>类型从大到小：</p>
<p>整型：TINYINT、MEDIUMINT、INT、BIGINT</p>
</blockquote>
<p>八、使用<strong>字符串的前缀</strong>而不是整个字符串创建索引</p>
<p>字符串截取长度建议采用以下语句，寻找最接近于1且长度最短时的情况，一般为20：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(列名,索引长度为<span class="number">10</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub10，<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(列名,索引长度为<span class="number">15</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub15，<span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(列名,索引长度为<span class="number">20</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> sub20</span><br><span class="line"><span class="keyword">FROM</span> tableName</span><br></pre></td></tr></table></figure>

<p>九、<strong>区分度高（散列性高）</strong>的列适合用于创建索引</p>
<p>采用如下语句计算区分度，越接近<code>1</code>越好，一般<code>33%</code>已经为较高效索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> colName)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tableName <span class="operator">-</span><span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>十、使用<strong>最频繁</strong>的列放在<strong>联合索引</strong>的<strong>左</strong>侧</p>
<p>十一、在<strong>多个字段都需要</strong>创建索引的情况下，<strong>联合索引优于单值索引</strong></p>
<h3 id="不适合作为索引的情况"><a href="#不适合作为索引的情况" class="headerlink" title="不适合作为索引的情况"></a>不适合作为索引的情况</h3><p>一、在<code>where</code>中不会使用到的字段，不需要创建索引</p>
<p>二、数据量较小的表，不应当创建索引</p>
<p>三、存在<strong>大量重复数据</strong>的列不应当创建索引</p>
<blockquote>
<p>数据重复度高于10%时，就不应该在此字段上建立索引</p>
</blockquote>
<p>四、避免对<strong>经常更新的表</strong>创建过多的索引</p>
<p>五、不建议用<strong>无序的值</strong>作为索引</p>
<blockquote>
<p>如身份证、UID等</p>
</blockquote>
<p>六、及时删除不再使用或很少使用的索引</p>
<p>七、不要定义冗余或重复的索引</p>
<h2 id="性能分析工具的使用"><a href="#性能分析工具的使用" class="headerlink" title="性能分析工具的使用"></a>性能分析工具的使用</h2><h3 id="数据库服务器优化的一般步骤"><a href="#数据库服务器优化的一般步骤" class="headerlink" title="数据库服务器优化的一般步骤"></a>数据库服务器优化的一般步骤</h3><p><img src="D:\workinenglish\typora_image\image-20241105223115832.png" alt="image-20241105223115832"></p>
<p><img src="D:\workinenglish\typora_image\image-20241105223136340.png" alt="image-20241105223136340"></p>
<p>SQL及索引 –&gt; 数据库表结构 –&gt; 系统配置 –&gt; 硬件 </p>
<h3 id="查看系统参数"><a href="#查看系统参数" class="headerlink" title="查看系统参数"></a>查看系统参数</h3><h4 id="各类系统性能参数"><a href="#各类系统性能参数" class="headerlink" title="各类系统性能参数"></a>各类系统性能参数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span> <span class="operator">|</span> SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;参数&#x27;</span></span><br></pre></td></tr></table></figure>

<p>常见的参数包括：</p>
<blockquote>
<p>Connections: 连接MySQL服务器次数</p>
<p>Uptime: MySQL服务器上线时间</p>
<p>Slow_queries: 慢查询次数</p>
<p>Innodb_rows_read: Select查询返回的次数</p>
<p>Innodb_rows_inserted: 执行Insert插入操作的次数</p>
<p>Innodb_rows_updated: 执行update更新操作的次数</p>
<p>Innodb_rows_deleted: 执行delete删除操作的次数</p>
<p>Com_select: 查询操作次数</p>
<p>Com_insert: 插入操作次数，对于批量插入的操作，记录一次</p>
<p>Com_update: 更新操作次数</p>
<p>Com_delete: 删除操作次数</p>
</blockquote>
<h4 id="统计SQL的查询成本：last-query-cost"><a href="#统计SQL的查询成本：last-query-cost" class="headerlink" title="统计SQL的查询成本：last_query_cost"></a>统计SQL的查询成本：last_query_cost</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;last_query_cost&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="定位执行慢的-SQL：慢查询日志"><a href="#定位执行慢的-SQL：慢查询日志" class="headerlink" title="定位执行慢的 SQL：慢查询日志"></a>定位执行慢的 SQL：慢查询日志</h3><p>慢查询日志可以记录MySQL中<strong>响应时间超过阈值</strong>的语句，阈值可以自己定义，参数为<code>long_query_time</code>，单位是<code>秒</code>。</p>
<p>默认情况下，慢查询日志是关闭的，应当只在需要调优时打开。</p>
<p>日志应当及时删除。</p>
<h4 id="查看慢查询日志开关情况"><a href="#查看慢查询日志开关情况" class="headerlink" title="查看慢查询日志开关情况"></a>查看慢查询日志开关情况</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h4 id="打开-关闭慢查询日志"><a href="#打开-关闭慢查询日志" class="headerlink" title="打开&#x2F;关闭慢查询日志"></a>打开&#x2F;关闭慢查询日志</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> slow_query_log <span class="operator">=</span> <span class="keyword">on</span>; <span class="comment">-- or off</span></span><br></pre></td></tr></table></figure>



<h4 id="修改慢查询阈值long-query-time"><a href="#修改慢查询阈值long-query-time" class="headerlink" title="修改慢查询阈值long_query_time"></a>修改慢查询阈值long_query_time</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 临时修改，重启失效</span></span><br></pre></td></tr></table></figure>



<h4 id="永久修改上述参数"><a href="#永久修改上述参数" class="headerlink" title="永久修改上述参数"></a>永久修改上述参数</h4><p>修改<code>my.cnf</code>文件，在<code>[mysqld]</code>下增加或修改参数如下：</p>
<blockquote>
<p>slow_query_log &#x3D; ON  #OFF</p>
<p>slow_query_log_file &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;slow.log  # 日志文件的目录和文件名</p>
<p>long_query_time &#x3D; 3</p>
<p>log_output &#x3D; FILE</p>
</blockquote>
<p>重启服务器生效。</p>
<h4 id="慢查询日志分析工具：mysqldumpslow"><a href="#慢查询日志分析工具：mysqldumpslow" class="headerlink" title="慢查询日志分析工具：mysqldumpslow"></a>慢查询日志分析工具：mysqldumpslow</h4><p>此工具不在数据库中运行，而是在shell中</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow --help  # 查看帮助</span><br></pre></td></tr></table></figure>

<p>包含以下参数：</p>
<blockquote>
<p>-a: 不将数字抽象成N，字符串抽象成S<br>-s: 是表示按照何种方式排序：<br>    c: 访问次数<br>    l: 锁定时间<br>    r: 返回记录<br>    t: 查询时间<br>    al:平均锁定时间<br>    ar:平均返回记录数<br>    at:平均查询时间 （默认方式）<br>    ac:平均查询次数<br>-t: 即为返回前面多少条的数据；</p>
<p>-g: 后边搭配一个正则匹配模式，大小写不敏感的</p>
</blockquote>
<p>常用操作如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到返回记录集最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到访问次数最多的10个SQL</span></span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/slow.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到按照时间排序的前10条里面含有左连接的查询语句</span></span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span></span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/slow.log | more</span><br></pre></td></tr></table></figure>

<p>使用如下命令在删除日志后重新生成日志文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -uroot -p flush-logs slow</span><br></pre></td></tr></table></figure>



<h3 id="查看-SQL-执行成本：SHOW-PROFILE"><a href="#查看-SQL-执行成本：SHOW-PROFILE" class="headerlink" title="查看 SQL 执行成本：SHOW PROFILE"></a>查看 SQL 执行成本：SHOW PROFILE</h3><p>此命令即将弃用，以后可以通过information_schema中的profiling表查看</p>
<p>相关命令如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看是否开启执行成本监控</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br><span class="line"><span class="comment">-- 打开/关闭show profile</span></span><br><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> &quot;ON&quot; <span class="comment">-- or OFF</span></span><br><span class="line"><span class="comment">-- 查看最近一次查询开销</span></span><br><span class="line"><span class="keyword">show</span> profile</span><br><span class="line"><span class="comment">-- 查看当前会话都有哪些profile</span></span><br><span class="line"><span class="keyword">show</span> profiles</span><br><span class="line"><span class="comment">-- 查看某一命令的某一开销</span></span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Show profile的常用查询参数：</strong></p>
<blockquote>
<p>① ALL：显示所有的开销信息。 </p>
<p>② BLOCK IO：显示块IO开销。</p>
<p>③ CONTEXT SWITCHES：上下文切换开<br>销。</p>
<p>④ CPU：显示CPU开销信息。</p>
<p>⑤ IPC：显示发送和接收开销信息。</p>
<p>⑥ MEMORY：显示内存开销信<br>息。 </p>
<p>⑦ PAGE FAULTS：显示页面错误开销信息。</p>
<p>⑧ SOURCE：显示和Source_function，Source_file，<br>Source_line相关的开销信息。 </p>
<p>⑨ SWAPS：显示交换次数开销信息。</p>
</blockquote>
<p><strong>开发过程中需要留意以下结论</strong>,出现说明SQL语句需要优化</p>
<blockquote>
<p><strong>converting HEAP to MyISAM</strong> 查询结果太大，内存不足，数据需要向磁盘搬了</p>
<p>creating tmp table: 创建临时表，先拷贝数据到临时表，用完再删除</p>
<p>copying to tmp table on disk: 把内存中的临时表复制到磁盘上</p>
<p>locked:</p>
</blockquote>
<h3 id="分析查询语句：EXPLAIN"><a href="#分析查询语句：EXPLAIN" class="headerlink" title="分析查询语句：EXPLAIN"></a>分析查询语句：EXPLAIN</h3><p><strong>参考文献</strong></p>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">MySQL5.7</a><br><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.htm">MySQL8.0</a></p>
<p><strong>版本区别</strong></p>
<p>MySQL 5.6.3以前只能<code>EXPLAIN SELECT</code> ；MYSQL 5.6.3以后就可以 <code>EXPLAIN SELECT</code>，<code>UPDATE</code>，<code>DELETE</code><br>在<code>5.7</code>以前的版本中，想要显示 <code>partitions</code> 需要使用 <code>explain partitions</code> 命令；想要显示<code>filtered</code> 需要使用 <code>explain extended</code> 命令。在5.7版本后，默认explain直接显示partitions和filtered中的信息</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> select_options</span><br><span class="line"><span class="comment">-- or</span></span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">SELECT</span> select_opyions</span><br></pre></td></tr></table></figure>



<p><code>EXPLAIN</code>语句的输出结果中各列的作用如下:</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>在一个大的查询语句中每个SELECT关键字都对应一个 唯一的id</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT关键字对应的那个查询的类型</td>
</tr>
<tr>
<td>table</td>
<td>表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td>type</td>
<td>针对单表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际上使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>实际使用到的索引长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td>rows</td>
<td>预估的需要读取的记录条数</td>
</tr>
<tr>
<td>filtered</td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>一些额外的信息</td>
</tr>
</tbody></table>
<h4 id="EXPLAIN各列的具体作用"><a href="#EXPLAIN各列的具体作用" class="headerlink" title="EXPLAIN各列的具体作用"></a>EXPLAIN各列的具体作用</h4><p>explain不考虑各种cache，不能显示MySQL在执行查询时所作的优化工作，不会说明触发器、存储过程的信息或用户自定义函数对查询的影响，且部分统计信息是估计值。</p>
<h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><blockquote>
<p>不论我们的查询语句有多复杂，里边儿 包含了多少个表 ，到最后也是需要对每个表进行 单表访问 的，所以MySQL规定EXPLAIN语句输出的每条记录都对应着某个单表的访问方法，该条记录的table列代表着该表的表名（有时不是真实的表名字，可能是简称）</p>
</blockquote>
<h5 id="id"><a href="#id" class="headerlink" title="id"></a><strong>id</strong></h5><p>当查询语句包含联合查询时，我们把前面的表称为驱动表，后面的表称为被驱动表。</p>
<p>（查询优化器可能对查询进行优化，可能导致驱动表和被驱动表颠倒）</p>
<blockquote>
<p>我们写的查询语句一般都以 SELECT 关键字开头，每一个SELECT对应一个id。（内涵子查询的语句，可能经过子查询优化器优化后转为联合查询，因此也可能不是一个SELECT对应一个id)</p>
</blockquote>
<ol>
<li>id如果相同，可以认为是一组，从上往下顺序执行</li>
<li>在所有组中，id值越大，优先级越高，越先执行</li>
<li><strong>关注点</strong>：id号每个号码，表示一趟独立的查询, 一个sql的查询趟数越少越好</li>
</ol>
<h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a><strong>select_type</strong></h5><p>常见字段如下：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>查询语句不包含UNION或子查询的</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>包含 UNION、UNION ALL、子查询的查询语句，最左边的select对应的select_type</td>
</tr>
<tr>
<td>UNION</td>
<td>包含 UNION、UNION ALL、子查询的查询语句，除了最左边的select对应的select_type</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>包含 UNION、UNION ALL、子查询的查询语句，若生成了临时表，针对临时表的查询即为此类，如：<br /><code>select * from s1 union all select * from s2</code>中需要对UNION后的临时表进行去重</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>若包含子查询的查询语句不能转为对应的<code>semi-join</code>形式，且此子查询是<strong>不相关</strong>子查询，则该子查询的第一个<code>select</code>关键字对应的查询即为此类，如：</td>
</tr>
<tr>
<td>DEPENDENT SUBQUERY</td>
<td>若包含子查询的查询语句不能转为对应的<code>semi-join</code>形式，且此子查询是<strong>相关</strong>子查询，则该子查询的第一个<code>select</code>关键字对应的查询即为此类，如：</td>
</tr>
<tr>
<td>DEPENDENT UNION</td>
<td>包含 UNION、UNION ALL的大查询语句，如果各个小查询都依赖于外层查询的花，除了最左的小查询，其余小查询均属于此。</td>
</tr>
<tr>
<td>DERIVED</td>
<td>包含派生表的查询，派生表对应的子查询属于此类，如：<br /><code>SELECT * from (select key1,count(*) as c from s1 group by key1)as derived_s1 where c &gt; 1</code></td>
</tr>
<tr>
<td>MATERIALIZED</td>
<td>当查询优化器再执行包含子查询的语句时，选择将子查询物化后于外层查询进行连接查询时，该子查询属于此类</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="type-重要"><a href="#type-重要" class="headerlink" title="type(重要)"></a><strong>type</strong>(重要)</h5><p>执行计划的一条记录就代表着MySQL对某个表的<code>执行查询时的访问方法</code>，又称“访问类型”，即<code>type</code>字段。<code>type</code> 字段表示 MySQL 优化器选择的访问类型，它揭示了 MySQL 如何查找所需的数据行。完整的访问方法包括：(按查询效率排序，越往后的方法效率越差)</p>
<ol>
<li><p><code>system</code>：当表中<code>只有一条记录</code>且该表的存储引擎的统计数据是精确的(这种引擎下使用count(*)可以直接得到数据而无需遍历表），如MyISAM，Memory；则其对应的访问方法即为此。</p>
</li>
<li><p><code>const</code>：当我们根据<code>主键</code>或<code>唯一二级索引</code>与常数进行等值匹配时，对单表的访问对应此方法</p>
<blockquote>
<p>select * from s1 where id &#x3D; 1;</p>
</blockquote>
</li>
<li><p><code>eq_ref</code>：连接查询中，被驱动表是通过主键或唯一二级索引等值匹配的方式访问的。</p>
<blockquote>
<p>select * from s1 inner join s2 on s1.id &#x3D; s2.id</p>
<p>此时s1表通过all访问，每得到一个相当于常数的id后与s2匹配</p>
</blockquote>
</li>
<li><p><code>ref</code>：当通过普通的二级索引列与常量进行等值匹配来查询某个表时。</p>
<p> <strong>阿里巴巴开发手册要求尽量得到以上级别</strong></p>
</li>
<li><p><code>full_text</code>：全文索引</p>
</li>
<li><p><code>ref_or_null</code>：当通过普通的二级索引列,且该列值可能为<code>null</code>时，与常量进行等值匹配来查询某个表时。</p>
</li>
<li><p><code>index_merge</code>：Index Merge是MySQL查询优化器在处理SELECT查询时，通过同时使用多个索引来提高查询性能的一种技术。其核心思想是将多个索引的扫描结果进行合并，生成最终的结果集。包括<code>intersection</code>交集合并、<code>union</code>并集合并、<code>sort_union</code>有序并集合并。</p>
</li>
<li><p><code>unique_subquery</code>：</p>
<ol>
<li><strong>子查询优化</strong>：这个访问类型通常出现在涉及子查询的场景中，尤其是当子查询返回唯一行时。MySQL 优化器可能会识别到这种情况，并将子查询转换为一种更高效的查找方法。</li>
<li><strong>唯一索引</strong>：<code>unique_subquery</code> 意味着 MySQL 使用了唯一索引来查找子查询中的唯一行。这种类型通常发生在子查询中的 <code>WHERE</code> 子句使用了唯一索引列来过滤数据。</li>
<li><strong>性能优化</strong>：由于使用了唯一索引，<code>unique_subquery</code> 通常比全表扫描或其他非索引访问方法更快。这是因为唯一索引能够快速定位所需的数据行，而无需扫描整个表或大量数据。</li>
</ol>
</li>
<li><p><code>index_subquery</code>：</p>
</li>
<li><p><code>range</code>:</p>
<p><strong>阿里巴巴开发手册要求最低不能低于此线</strong></p>
</li>
<li><p><code>index</code>: <code>index</code>表示MySQL通过全索引扫描的方式查找数据。这意味着MySQL会遍历整个索引树来查找匹配的行，但它不会回表去查找对应的数据行（除非索引是覆盖索引）。然而，在某些情况下，即使索引扫描后还需要回表获取数据，<code>type</code>仍然可能显示为<code>index</code>，特别是当查询的列完全包含在索引中时。<code>index</code>访问类型通常出现在使用索引列进行查找但查询的列不完全包含在索引中的情况下</p>
</li>
<li><p><code>all</code>：表示MySQL通过全表扫描的方式查找数据。这意味着MySQL会遍历整个数据表来查找匹配的行，而不使用任何索引。</p>
</li>
</ol>
<h5 id="possible-keys、key、key-len"><a href="#possible-keys、key、key-len" class="headerlink" title="possible_keys、key、key_len"></a>possible_keys、key、key_len</h5><p>possible_keys表示某个查询语句中，对某个表执行单表查询时可能使用的索引有哪些，一般查询涉及的字段若存在索引，都会列出。</p>
<p>key表示实际用到的索引有哪些。</p>
<p>key_len表示联合索引实际使用的索引长度（字节数），可以检测是否充分利用索引，对于使用同一个索引的查询，key_len越长越好。</p>
<p>key_len的计算公式：<code>字符集单位长度（unicode=3,gdk=2,ascii=1) * 字符数 + 1（如果可以为NULL) + 2(如果为变长类型)</code></p>
<h5 id="ref、rows、filtered"><a href="#ref、rows、filtered" class="headerlink" title="ref、rows、filtered"></a>ref、rows、filtered</h5><p>ref 当使用索引列等值查询时，与索引列进行等值匹配的对象信息，可能是常数、某一列、函数等</p>
<p>rows 预估想要读取的记录条数，越小越好。</p>
<p>filtered 某个表经过搜索条件过滤后剩余记录条数与rows的百分比，越高越好。对于单表查询，此字段影响不大；对于连接查询，它决定了被驱动表需要执行的次数：<code>rows * filtered</code></p>
<h5 id="Extra（重要）"><a href="#Extra（重要）" class="headerlink" title="Extra（重要）"></a>Extra（重要）</h5><p>说明额外信息，包括一些不适合在其他列显示但又十分重要的信息，可以通过此更准确地理解MySQL如何执行给定的查询语句。，以下是比较重要的一些信息：</p>
<ol>
<li><p><code>No tables used</code>：当查询语句中没有<code>from</code>子句时，提示</p>
</li>
<li><p><code>Impossible WHERE</code>：查询语句的<code>WHERE</code>子句永远为<code>FALSE</code>时显示</p>
</li>
<li><p><code>Using WHERE</code>：当我们使用全表扫描（不使用索引）来执行某个查询，且该语句的<code>where</code>子句中有针对该表的搜索条件时  或   当我们使用索引来执行某个查询，且该语句的<code>where</code>子句中有除了该索引包含的列之外的搜索条件时</p>
</li>
<li><p><code>No matching min/max row</code>:当查询列表中含有<code>MIN</code>或<code>MAX</code>聚合函数，但没有符合<code>where</code>子句的搜索条件的记录时</p>
</li>
<li><p><code>Using Index</code>：当我们的查询列表以及搜索条件中只包含属于某个索引的列，也就是在可以使用覆盖索引的情况下，此时不需要进行回表操作了。</p>
</li>
<li><p><code>Using index condition</code>：有些搜索条件中虽然出现了索引列却不能只使用索引时</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> s1 <span class="keyword">where</span> key1 <span class="operator">&gt;</span> <span class="string">&#x27;z&#x27;</span> <span class="keyword">and</span> key1 <span class="keyword">like</span> <span class="string">&#x27;%a&#x27;</span>; <span class="comment">-- 表中有基于key1建立的索引</span></span><br><span class="line"><span class="comment">-- 上述查询，需要先查询key1对应的索引，找到满足 &gt; &#x27;z&#x27;的对应的主键值，再回表找到对应数据，找到满足like &#x27;%a&#x27;的</span></span><br><span class="line"><span class="comment">-- 优化涉及索引条件下推</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Using join buffer</code>:当连接查询执行过程中，被驱动表不能有效利用索引加快访问速度，MySQL一般会为其分配一个名为<code>join buffer</code>的内存块以加快查询</p>
</li>
<li><p><code>NOt exists</code>：当使用左外连接，<code>where</code>子句包含要求被驱动表的某一列等于<code>null</code>的搜索条件，而此列又不允许为<code>null</code>时</p>
</li>
<li><p><code>using intersect(...)</code>、<code>using union(..)</code>、<code>using sort_union(..)</code>，分别表示准备使用<code>intersect</code>、<code>union</code>、<code>sort-union</code>索引合并的方式执行查询，（）中为合并的索引名称</p>
</li>
<li><p><code>zero limit</code>：<code>limit</code>子句的参数为0时</p>
</li>
<li><p><code>NULL</code>：有些情况下对结果集中记录进行排序可以使用到索引</p>
</li>
<li><p><code>using filesort</code>：排序无法使用索引，只能在内存（记录少时）或磁盘（记录多时）中进行排序时，<strong>应当尽量建立索引来规避</strong></p>
</li>
<li><p><code>using temporary</code>：当我们需要用临时表实现时，如执行许多包含<code>distinct</code>、<code>group by</code>, <code>union</code>等子句的查询过程中，如果不能有效地利用索引完成，MySQL可能就需要通过建立内部临时表来执行查询。<strong>应当尽量建立索引来规避</strong></p>
</li>
</ol>
<h3 id="EXPLAIN的进一步使用"><a href="#EXPLAIN的进一步使用" class="headerlink" title="EXPLAIN的进一步使用"></a>EXPLAIN的进一步使用</h3><h4 id="1-explain的四种输出格式"><a href="#1-explain的四种输出格式" class="headerlink" title="1. explain的四种输出格式"></a>1. explain的四种输出格式</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN FORMAT <span class="operator">=</span> JSON<span class="operator">/</span>TREE<span class="operator">/</span> <span class="keyword">SELECT</span> ...</span><br></pre></td></tr></table></figure>

<ol>
<li>传统格式：</li>
<li>JSON格式：相对于传统格式，多了成本属性，输出信息最为详尽</li>
<li>TREE格式：</li>
<li>可视化输出：</li>
</ol>
<h4 id="show-warnings的使用"><a href="#show-warnings的使用" class="headerlink" title="show warnings的使用"></a>show warnings的使用</h4><p>使用explain后可以紧接着使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> warnnings\G</span><br></pre></td></tr></table></figure>

<p>三个字段，Level、Code、Message。</p>
<p>Message会显示优化重写的结果</p>
<h3 id="分析优化器的执行计划-trace"><a href="#分析优化器的执行计划-trace" class="headerlink" title="分析优化器的执行计划 trace"></a>分析优化器的执行计划 trace</h3><p>MySQL5.6引入，默认关闭，开启如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set optimizer_trace = &#x27;enabled = on&#x27;,end_markers_in_json = on; -- 以json格式输出</span><br><span class="line">set optimizer_trace_max_size = 100000;		-- 设置可以使用的内存大小，避免json太大无法显示</span><br><span class="line">select * from information_schema.optimizer_trace\G   -- 查看结果</span><br></pre></td></tr></table></figure>



<h3 id="MySQL监控分析视图-sys-schema"><a href="#MySQL监控分析视图-sys-schema" class="headerlink" title="MySQL监控分析视图-sys schema"></a>MySQL监控分析视图-sys schema</h3><ol>
<li>主机相关：以host_summary开头，主要汇总了IO延迟的信息。</li>
<li>Innodb相关：以innodb开头，汇总了innodb buffer信息和事务等待innodb锁的信息。</li>
<li>I&#x2F;o相关：以io开头，汇总了等待I&#x2F;O、I&#x2F;O使用量情况。</li>
<li>内存使用情况：以memory开头，从主机、线程、事件等角度展示内存的使用情况</li>
<li>连接与会话信息：processlist和session相关视图，总结了会话相关信息。</li>
<li>表相关：以schema_table开头的视图，展示了表的统计信息。</li>
<li>索引信息：统计了索引的使用情况，包含冗余索引和未使用的索引情况。</li>
<li>语句相关：以statement开头，包含执行全表扫描、使用临时表、排序等的语句信息。</li>
<li>用户相关：以user开头的视图，统计了用户使用的文件I&#x2F;O、执行语句统计信息。</li>
<li>等待事件相关信息：以wait开头，展示等待事件的延迟情况</li>
</ol>
<p>常见命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">-- 查看冗余索引</span><br><span class="line">select * from sys.schema_redundant_indexes;</span><br><span class="line">-- 查询未使用过的索引</span><br><span class="line">select * from sys.schema_unused_indexes;</span><br><span class="line">-- 查询索引使用情况</span><br><span class="line">select index_name,rows_selected,rows_inserted,rows_updated,rows_deleted from sys.schema_index_statistics where table_schema = &#x27;dbname&#x27;;</span><br><span class="line"></span><br><span class="line"># 1. 查询表的访问量  -&gt; 高访问量的可以放到内存中</span><br><span class="line">select table_schema,table_name,sum(io_read_requests+io_write_requests) as io from</span><br><span class="line">sys.schema_table_statistics group by table_schema,table_name order by io desc;</span><br><span class="line"># 2. 查询占用bufferpool较多的表</span><br><span class="line">select object_schema,object_name,allocated,data</span><br><span class="line">from sys.innodb_buffer_stats_by_table order by allocated limit 10;</span><br><span class="line"># 3. 查看表的全表扫描情况</span><br><span class="line">select * from sys.statements_with_full_table_scans where db=&#x27;dbname&#x27;</span><br><span class="line"></span><br><span class="line">#1. 监控SQL执行的频率</span><br><span class="line">select db,exec_count,query from sys.statement_analysis</span><br><span class="line">order by exec_count desc;</span><br><span class="line">#2. 监控使用了排序的SQL</span><br><span class="line">select db,exec_count,first_seen,last_seen,query</span><br><span class="line">from sys.statements_with_sorting limit 1;</span><br><span class="line">#3. 监控使用了临时表或者磁盘临时表的SQL</span><br><span class="line">select db,exec_count,tmp_tables,tmp_disk_tables,query</span><br><span class="line">from sys.statement_analysis where tmp_tables&gt;0 or tmp_disk_tables &gt;0</span><br><span class="line">order by (tmp_tables+tmp_disk_tables) desc;</span><br><span class="line"></span><br><span class="line">#1. 查看消耗磁盘IO的文件</span><br><span class="line">select file,avg_read,avg_write,avg_read+avg_write as avg_io</span><br><span class="line">from sys.io_global_by_file_by_bytes order by avg_read limit 10;</span><br><span class="line"></span><br><span class="line">#1. 行锁阻塞情况</span><br><span class="line">select * from sys.innodb_lock_waits;</span><br></pre></td></tr></table></figure>











<h2 id="索引优化和查询优化"><a href="#索引优化和查询优化" class="headerlink" title="索引优化和查询优化"></a>索引优化和查询优化</h2><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>使用JOIN替换子查询</li>
<li>为JOIN的连接条件字段创建合适的索引</li>
<li>全值匹配最佳规则：查询条件包含多个字段，最好创建联合索引</li>
<li>最佳左前缀规则：联合索引中，最常用的字段应当排在最左边。</li>
<li>组合索引，范围查询的字段应当放在索引最后</li>
<li>为Order by、Where、Group By子句的字段建立索引：如果where子句的字段和order by子句字段相同，使用单列索引，否则使用联合索引。</li>
</ol>
<h3 id="索引失效案例"><a href="#索引失效案例" class="headerlink" title="索引失效案例"></a>索引失效案例</h3><p><strong>SQL是否使用索引，与数据库版本、数据量、数据选择度均有关系。</strong></p>
<ol>
<li><p>全值匹配最佳规则：查询条件包含多个字段，最好创建联合索引</p>
</li>
<li><p>最佳左前缀规则：联合索引中，最常用的字段应当排在最左边。</p>
</li>
<li><p>主键插入顺序：主键插入时应当尽可能从小到大的顺序，因为存储时是按主键从大到小的顺序的。</p>
</li>
<li><p>数据库和表的字符集应当统计，尽可能使用utf8mb4</p>
</li>
<li><p>计算、函数、类型转换（自动&#x2F;手动）导致的索引失效：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 在name字段有索引时：</span><br><span class="line">select * from student where name like &#x27;ab%&#x27;;		-- 较优 可以使用索引</span><br><span class="line">select * from student where LEFT(name,3) = &#x27;abc&#x27;;   -- 较差 无法使用索引</span><br><span class="line">select * from student where studentNo + 1 = 1001;   -- 不能使用索引 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>范围条件右边的列索引失效：经常范围查询的字段应当放到联合索引的最后，否则会导致此字段的右侧字段索引无法使用</p>
</li>
<li><p>不等于（!&#x3D;或&lt;&gt;)索引失效：</p>
</li>
<li><p><code>is null</code> 可以使用索引，<code>is not null</code> 不可以使用索引，<code>not like</code>同理：数据表最好有<code>not null</code>约束，null可以以实际值替代，如int以0表示，字符以“”表示。</p>
</li>
<li><p><code>like</code>以通配符<code>%</code>开头索引失效：</p>
</li>
<li><p><code>or</code>前后存在非索引列，索引失效</p>
</li>
</ol>
<p><strong>一般建议</strong></p>
<ul>
<li>单列索引，尽可能选择针对当前query过滤性最好的</li>
<li>组合索引，当前query过滤性最好的字段在最前面</li>
<li>组合索引，尽可能选择能够包含当前query中where子句的更多字段的索引</li>
<li>组合索引，范围查询的字段应当放在索引最后。</li>
</ul>
<h4 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h4><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><ol>
<li>各表的连接条件字段应当保持类型一致。</li>
<li>外连接的情况下，左侧的必为驱动表，右侧必为被驱动表</li>
</ol>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><ol>
<li>内连接的情况下，左右表地位一样，可能经过优化器优化后，左侧的表变成了被驱动表。</li>
</ol>
<blockquote>
<p>如果表的连接条件中只有一个字段拥有索引，拥有索引的字段所在的表为驱动表</p>
<p>如果表的连接条件中均没有索引，小表作为驱动表，“小表驱动大表”</p>
</blockquote>
<h4 id="JOIN-语句原理"><a href="#JOIN-语句原理" class="headerlink" title="JOIN 语句原理"></a>JOIN 语句原理</h4><p>假设驱动表有A条记录，被驱动表有B条记录。</p>
<h5 id="Simple-Nested-Loop-Join-（简单嵌套循环连接）"><a href="#Simple-Nested-Loop-Join-（简单嵌套循环连接）" class="headerlink" title="Simple Nested-Loop Join （简单嵌套循环连接）"></a>Simple Nested-Loop Join （简单嵌套循环连接）</h5><p>当连接的表均没有索引时</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241112224542.png"></p>
<p>在此情况下，性能极差，但显然驱动表A的记录越少，效率越高。</p>
<h5 id="Index-Nested-Loop-Join-（索引嵌套循环连接）"><a href="#Index-Nested-Loop-Join-（索引嵌套循环连接）" class="headerlink" title="Index Nested-Loop Join （索引嵌套循环连接）"></a>Index Nested-Loop Join （索引嵌套循环连接）</h5><p>此时被驱动表有索引：</p>
<p><img src="D:\workinenglish\typora_image\image-20241112225323050.png" alt="image-20241112225323050"></p>
<p>如果被驱动表加索引，效率有很大提高，但如果索引不是主键索引，还需要一次回表操作。</p>
<h5 id="Block-Nested-Loop-Join-（块嵌套循环连接）"><a href="#Block-Nested-Loop-Join-（块嵌套循环连接）" class="headerlink" title="Block  Nested-Loop Join （块嵌套循环连接）"></a>Block  Nested-Loop Join （块嵌套循环连接）</h5><p>MySQL8.0.20后删除此算法，使用HASH JOIN算法</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241113145255.png"></p>
<p>通过<code>show variables like &#39;%optimizer_switch%&#39;</code> 查看block_nested_loop，默认开启</p>
<p>默认情况下<code>join_buffer_size = 256k</code>。在32位操作系统中最大申请4G，64位操作系统下，仅windows可以申请超过4G</p>
<table>
<thead>
<tr>
<th>开销统计</th>
<th>SNLJ</th>
<th>INLJ</th>
<th>BNLJ</th>
</tr>
</thead>
<tbody><tr>
<td>外表扫描次数</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>内表扫描次数</td>
<td>A</td>
<td>xxxxxxxxxx – 用于存储过程和函数、触发器 45000可换为其他错误码SIGNAL SQLSTATE ‘45000’ SET MESSAGE_TEXT &#x3D; ‘自定义错误消息’;  sql</td>
<td>A*used_column_size&#x2F;join_buffer_size+1</td>
</tr>
<tr>
<td>读取记录次数</td>
<td>A+B*A</td>
<td>A+B(match)</td>
<td>A+B*(A*used_column_size&#x2F;join_buffer_size)</td>
</tr>
<tr>
<td>回表读取记录次数</td>
<td>0</td>
<td>A*Index(height)</td>
<td>B*A</td>
</tr>
<tr>
<td>JOIN比较次数</td>
<td>B*A</td>
<td>B(match)(if possible)</td>
<td>0</td>
</tr>
</tbody></table>
<p>整体效率：INLJ &gt; BNLJ &gt; SNLJ</p>
<p><strong>总结</strong></p>
<ul>
<li>保证被驱动表的JOIN字段已经创建了索引</li>
<li>需要JOIN 的字段，数据类型保持绝对一致。</li>
<li>LEFT JOIN 时，选择小表作为驱动表， 大表作为被驱动表 。减少外层循环的次数。</li>
<li>INNER JOIN 时，MySQL会自动将 小结果集的表选为驱动表 。选择相信MySQL优化策略。</li>
<li>能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)</li>
<li>不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询。</li>
<li>衍生表建不了索引</li>
</ul>
<h3 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a>子查询优化</h3><p>子查询的效率较低，这是因为：</p>
<ol>
<li>子查询需要为内层查询结果创建一个临时表，查询完毕后再撤销，占用大量CPU和IO资源</li>
<li>子查询产生的临时表不会存在索引表，查询效率低</li>
<li>结果集较大的子查询，对查询性能影响很大</li>
</ol>
<p><strong>应当尽量使用JOIN替代子查询</strong></p>
<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p><strong>业务中排序应当尽量放到程序端完成</strong></p>
<p>MySQL中支持两种排序方式，<code>FileSort</code>和<code>Index</code>:</p>
<ul>
<li>FileSort：在内存中进行，占用CPU较多，如果待排序结果集较大，可能还需要产生临时文件I&#x2F;O到磁盘中，效率低。</li>
<li>Index：索引可以保证数据有序，不需要再继续排序。</li>
</ul>
<p>因此，为Order by子句的字段建立索引，可以使得其在查询时的速度更快。</p>
<p>如果where子句的字段和order by子句字段相同，使用单列索引，否则使用联合索引。无法使用Index排序，需要对filesort进行优化。</p>
<p>排序索引的失效：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from student order by age,classId;</span><br><span class="line">-- 设有联合索引（age,classId），但由于查询的是全部数据，即使索引排序后还是需要回表获取数据，这个过程可能比获取全部数据后内存排序还慢。</span><br></pre></td></tr></table></figure>

<ol>
<li><p>查询的信息含有非索引字段并且没有limit，索引失效</p>
</li>
<li><p>order by时的规则与索引规则不一致：方向错误后顺序错误，索引均失效</p>
</li>
</ol>
<blockquote>
<p>顺序错误：排序时联合索引前面的字段不包含却包含后面的、字段顺序错误</p>
<p>方向错误：降序索引升序排列，升序索引降序排列</p>
</blockquote>
<ol start="3">
<li>无过滤，不索引。</li>
</ol>
<h4 id="filesort算法：双路排序和单路排序"><a href="#filesort算法：双路排序和单路排序" class="headerlink" title="filesort算法：双路排序和单路排序"></a>filesort算法：双路排序和单路排序</h4><p>双路排序（慢）：4.1在前使用，两次扫描磁盘，首先读取行指针和orderby字段并排序，读取到内存中，再从磁盘读取其他字段。</p>
<p>单路排序（快）：读取查询需要的所有列之后，在buffer中排序。需要更多的内存空间，但由于buffer有限，如果需要排序的数据超过buffer，就需要生成临时文件，反而增加I&#x2F;O开销。</p>
<p><strong>因此不得不使用filesort排序时，应当</strong></p>
<p><strong>1. 尽可能提高buffer的大小</strong></p>
<p><strong>2. 提高max_length_for_sort_data</strong></p>
<p>**3. 不要使用select * **</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;sort_buffer_size&#x27;;</span><br><span class="line">show variables like &#x27;max_length_for_sort_data&#x27;; --影响单双路排序的选择，如果排序字段长度大于此值，则偏向使用双路，默认1024B</span><br></pre></td></tr></table></figure>



<h3 id="Group-by优化"><a href="#Group-by优化" class="headerlink" title="Group by优化"></a>Group by优化</h3><p>与order by 类似，仍需注意：</p>
<ol>
<li>能使用where就用where，比having效率高</li>
<li>包含order by ,group by, distinct的语句，where过滤后结果应当不超过1000条，否则会导致SQL过慢。</li>
</ol>
<h3 id="分页查询优化"><a href="#分页查询优化" class="headerlink" title="分页查询优化"></a>分页查询优化</h3><p><strong>优化思路1：</strong>在索引上完成排序分页操作，最后根据主键关联回表查询需要的其他字段内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student t ,(select id from student order by id limit 2000000,10) a where a.id = t.id;</span><br></pre></td></tr></table></figure>

<p><strong>优化思路2：</strong>此方案适用于主键递增的表，将limit查询转换为某个位置的查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where id &gt; 2000000 limit 10;</span><br></pre></td></tr></table></figure>



<h3 id="覆盖索引优先"><a href="#覆盖索引优先" class="headerlink" title="覆盖索引优先"></a>覆盖索引优先</h3><p>覆盖索引：</p>
<p><strong>理解方式一：</strong>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它<br>不必读取整个行。毕竟索引叶子节点存储了它们索引的数据；当能通过读取索引就可以得到想要的数<br>据，那就不需要读取行了。一个索引包含了满足查询结果的数据就叫做覆盖索引。<br><strong>理解方式二：</strong>非聚簇复合索引的一种形式，它包括在查询里的SELECT、JOIN和WHERE子句用到的所有列<br>（即建索引的字段正好是覆盖查询条件中所涉及的字段）。</p>
<p>好处：</p>
<ol>
<li>避免Innodb表进行索引的二次查询（回表）</li>
<li>可以把随机IO变成顺序IO加快查询效率</li>
</ol>
<p>弊端：</p>
<ol>
<li>索引字段的维护 总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这是业务<br> DBA，或者称为业务数据架构师的工作。</li>
</ol>
<h3 id="字符串的索引"><a href="#字符串的索引" class="headerlink" title="字符串的索引"></a>字符串的索引</h3><blockquote>
<p>使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考<br>虑的一个因素。</p>
</blockquote>
<h3 id="索引下推ICP"><a href="#索引下推ICP" class="headerlink" title="索引下推ICP"></a>索引下推ICP</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from people where zipcode = &#x27;0001&#x27; and lastname like &#x27;%张%&#x27; and address like &#x27;%北京%&#x27;;  -- 存在联合索引（zipcode,lastname,firstname)</span><br></pre></td></tr></table></figure>

<p>索引下推（Index Condition Pushdown，简称ICP）是MySQL 5.6版本引入的一种数据查询优化技术。</p>
<p><strong>含有索引字段但索引又失效</strong></p>
<p>索引下推技术利用了数据库引擎中的索引和过滤条件，将部分过滤工作下推到存储引擎层面进行处理，从而减少不必要的数据读取和传输。在传统的查询执行过程中，数据库引擎首先根据索引定位到符合过滤条件的数据行，并将这些行读取到内存中，然后再进行进一步的过滤操作。而索引下推则在这一步骤中尽可能地将过滤操作下推到存储引擎层面，避免将不符合条件的数据行读取到内存中。</p>
<p>举例：</p>
<ol>
<li><strong>使用索引定位</strong>：首先，MySQL会使用<code>zipcode</code>上的索引来快速定位到<code>zipcode = &#39;0001&#39;</code>范围内的所有行。</li>
<li><strong>下推过滤条件</strong>：然后，MySQL会将<code>lastname like &#39;%张%&#39;</code>这个条件下推到存储引擎层（因为联合索引中包含了<code>lastname</code>列，但<code>like</code>子句导致又不能使用索引）。这意味着存储引擎在读取索引页时，会检查每个索引项是否满足<code>lastname like &#39;%张%</code>这个条件。只有满足条件的索引项才会被进一步处理，对应的数据行才会被读取到内存中。</li>
<li><strong>回表查询</strong>：经过<code>lastname like &#39;%张%</code>过滤之后，结果集更少，回表查询次数更少。</li>
<li><strong>减少数据读取</strong>：通过这种方式，MySQL可以减少不必要的数据读取和传输，因为存储引擎层已经根据索引和过滤条件过滤掉了一部分不符合条件的数据。</li>
</ol>
<h4 id="ICP的使用条件"><a href="#ICP的使用条件" class="headerlink" title="ICP的使用条件"></a>ICP的使用条件</h4><ol>
<li>访问表的类型必须是<code>range,ref,eq_ref,ref_or_null</code>之一</li>
<li>用于<code>innodb</code>或<code>MyISAM</code>引擎，</li>
<li><code>innodb</code>只用于<code>二级索引</code>，覆盖索引下不支持ICP（回表才能有ICP）</li>
<li>相关子查询条件不能使用ICP</li>
</ol>
<h4 id="ICP开启关闭"><a href="#ICP开启关闭" class="headerlink" title="ICP开启关闭"></a>ICP开启关闭</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set optimizer_switch = &#x27;index_condition_pushdown=on/off&#x27;</span><br><span class="line">-- 或在查询语句中添加/*+ no_icp(tablename)*/</span><br><span class="line">select /*+ no_icp(tablename)*/ * from tablename ...</span><br></pre></td></tr></table></figure>



<h3 id="普通索引和唯一索引"><a href="#普通索引和唯一索引" class="headerlink" title="普通索引和唯一索引"></a>普通索引和唯一索引</h3><h3 id="其他查询优化"><a href="#其他查询优化" class="headerlink" title="其他查询优化"></a>其他查询优化</h3><h4 id="EXISTS和IN的区分"><a href="#EXISTS和IN的区分" class="headerlink" title="EXISTS和IN的区分"></a>EXISTS和IN的区分</h4><p>索引是前提，小表驱动大表。如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A WHERE cc IN (SELECT cc FROM B);</span><br><span class="line">SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc = A.cc);</span><br></pre></td></tr></table></figure>

<p>当A小于B时，用EXISTS。因为EXISTS的首先，相当于外表循环，实现的逻辑类似于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> A</span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> B</span><br><span class="line">    	<span class="keyword">if</span> j.cc == i.cc then ...        </span><br></pre></td></tr></table></figure>

<p>当B小于A时用IN， 因为实现的逻辑类似于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> B </span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> A</span><br><span class="line">    	<span class="keyword">if</span> j.cc == i.cc then ...</span><br></pre></td></tr></table></figure>

<p>那个表小就用哪个表驱动，A表小用EXISTS,B表小用IN</p>
<h4 id="COUNT-和COUNT-字段-效率"><a href="#COUNT-和COUNT-字段-效率" class="headerlink" title="COUNT(*)和COUNT(字段)效率"></a>COUNT(*)和COUNT(字段)效率</h4><p>没有本质区别，主要看使用的存储引擎，innodb是O(n)，MyISAM是O(1)</p>
<p>在innodb中使用count(字段)是尽可能使用二级索引，因为主键使用聚簇索引，包含的信息太多。</p>
<h4 id="LIMIT-1-对优化的影响"><a href="#LIMIT-1-对优化的影响" class="headerlink" title="LIMIT 1 对优化的影响"></a>LIMIT 1 对优化的影响</h4><p>针对扫描全表的SQL语句，如果确定结果集只有一条，加上可以提高效率；对于建立唯一索引的字段，可以通过索引查询而不需要全表扫描，不必添加</p>
<h4 id="多用COMMIT"><a href="#多用COMMIT" class="headerlink" title="多用COMMIT"></a>多用COMMIT</h4><p>只要有可能，在程序中尽量多使用 COMMIT，这样程序的性能得到提高，需求也会因为 COMMIT 所释放<br>的资源而减少。<br>COMMIT 所释放的资源：</p>
<ol>
<li>回滚段上用于恢复数据的信息</li>
<li>被程序语句获得的锁</li>
<li>redo &#x2F; undo log buffer 中的空间</li>
<li>管理上述 3 种资源中的内部花费</li>
</ol>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol>
<li>尽可能不使用select *</li>
</ol>
<h3 id="示例-淘宝数据库的主键设置"><a href="#示例-淘宝数据库的主键设置" class="headerlink" title="示例 - 淘宝数据库的主键设置"></a>示例 - 淘宝数据库的主键设置</h3><p>主键可以考虑哪些字段？</p>
<ol>
<li>自增ID：不行，问题见下文</li>
<li>业务字段：不行，无法预测未来业务字段是否会因为需求而出现重复。</li>
</ol>
<p>非核心业务如告警、日志、监控等信息可以使用自增ID</p>
<h4 id="核心业务的主键设计"><a href="#核心业务的主键设计" class="headerlink" title="核心业务的主键设计"></a>核心业务的主键设计</h4><p><strong>确保全局唯一并且单调递增：</strong>UUID</p>
<p>在极大量数据（10亿+）也可能出现重复的UUID.</p>
<p>UUID的构成：</p>
<blockquote>
<p>UUID(36B) &#x3D; 时间+UUID版本 (16B)  - 时钟序列(4B) - MAC地址(12B)  还需要4B存储4个 ‘-’</p>
<p>如： 40b826ac-a5b9-11ef-ab01-005056c00001  </p>
<p>时间低位32bit    时间中位16bit    时间高位 12bit  UUID版本4bit</p>
</blockquote>
<p><strong>为什么UUID是全局唯一的？</strong><br>在UUID中时间部分占用60位，存储的类似TIMESTAMP的时间戳，但表示的是从1582-10-15 00：00：00.00到现在的100ns的计数。可以看到UUID存储的时间精度比TIMESTAMPE更高，时间维度发生重复的概率降低到1&#x2F;100ns。<br>时钟序列是为了避免时钟被回拨导致产生时间重复的可能性。MAC地址用于全局唯一。<br><strong>为什么UUID占用36个字节？</strong><br>UUID根据字符串进行存储，设计时还带有无用”-“字符串，因此总共需要36个字节。<br><strong>为什么UUID是随机无序的呢？</strong><br>因为UUID的设计中，将时间低位放在最前面，而这部分的数据是一直在变化的，并且是无序。</p>
<p><strong>改造UUID</strong><br>若将时间高低位互换，则时间就是单调递增的了，也就变得单调递增了。MySQL 8.0可以更换时间低位和时间高位的存储方式，这样UUID就是有序的UUID了。MySQL 8.0还解决了UUID存在的空间占用的问题，除去了UUID字符串中无意义的”-“字符串，并且将字符串用二进制类型保存，这样存储空间降低为了<code>16字节</code>。<br>可以通过MySQL8.0提供的<code>uuid_to_bin</code>函数实现上述功能，同样的，MySQL也提供了<code>bin_to_uuid</code>函数进行<br>转化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET @uuid = UUID();</span><br><span class="line">SELECT @uuid,uuid_to_bin(@uuid),uuid_to_bin(@uuid,TRUE);</span><br></pre></td></tr></table></figure>

<p><strong>通过函数uuid_to_bin(@uuid,true)将UUID转化为有序UUID</strong></p>
<h4 id="自增ID的问题"><a href="#自增ID的问题" class="headerlink" title="自增ID的问题"></a>自增ID的问题</h4><p>除了简单，都是缺点：</p>
<ol>
<li>可靠性不高：存在回溯问题，8.0修复</li>
<li>安全性不高：暴露的接口很容易造成信息泄露</li>
<li>性能差</li>
<li>交互多：插入的时候还需要执行last_insert_id()函数获取刚插入的自增值，增加开销</li>
<li>局部唯一性：仅在当前数据库实例唯一而不是全局唯一，也就是说局部唯一性，这对分布式系统简直是噩梦</li>
</ol>
<h2 id="数据库设计规范"><a href="#数据库设计规范" class="headerlink" title="数据库设计规范"></a>数据库设计规范</h2><p>良好的数据库的设计要求：</p>
<ul>
<li>节省数据存储空间</li>
<li>保证数据完整性</li>
<li>方便进行数据库应用系统开发</li>
</ul>
<h3 id="键-码-和属性"><a href="#键-码-和属性" class="headerlink" title="键(码)和属性"></a>键(码)和属性</h3><table>
<thead>
<tr>
<th>类型</th>
<th>定义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>超键</strong></td>
<td>能唯一标识记录的字段或字段集合</td>
<td><code>(student_id)</code>, <code>(student_id, name)</code></td>
</tr>
<tr>
<td><strong>候选键</strong></td>
<td>超键的最小子集，无冗余字段</td>
<td><code>(student_id)</code></td>
</tr>
<tr>
<td><strong>主键</strong></td>
<td>从候选键中选出的唯一标识记录的键</td>
<td><code>student_id</code></td>
</tr>
<tr>
<td><strong>外键</strong></td>
<td>关联其他表主键，用于建立表之间的关系</td>
<td><code>student_id</code> 在 <code>Enrollments</code> 中</td>
</tr>
<tr>
<td><strong>主属性</strong></td>
<td>主键字段或候选键字段</td>
<td><code>student_id</code></td>
</tr>
<tr>
<td><strong>非主属性</strong></td>
<td>非主键字段，不用于唯一标识记录</td>
<td><code>name</code>, <code>email</code></td>
</tr>
</tbody></table>
<h3 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h3><p>在关系型数据库中，关于数据表设计的基本原则、规则就称为范式。可以理解为，一张数据表的设计结<br>构需要满足的某种设计标准的 级别 。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p>
<p>级别越高，冗余度越低，同时高阶范式必须满足低阶范式的要求。</p>
<p><strong>一般的关系型数据库最高遵循到BCNF，普遍为3NF。</strong></p>
<table>
<thead>
<tr>
<th>范式</th>
<th>主要目标</th>
<th>解决的问题</th>
<th>示例问题</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1NF</strong></td>
<td>确保每列值是原子化的</td>
<td>列中包含多个值</td>
<td>一列记录多个课程名称</td>
</tr>
<tr>
<td><strong>2NF</strong></td>
<td>消除部分函数依赖</td>
<td>非主属性只依赖部分主键</td>
<td>教师信息依赖课程 ID</td>
</tr>
<tr>
<td><strong>3NF</strong></td>
<td>消除传递函数依赖</td>
<td>非主属性依赖其他非主属性</td>
<td>部门信息依赖教师信息</td>
</tr>
<tr>
<td><strong>BCNF</strong></td>
<td>消除主属性依赖于非主属性的情况</td>
<td>主属性依赖于非主属性</td>
<td>课程信息依赖教师信息</td>
</tr>
<tr>
<td><strong>4NF</strong></td>
<td>消除多值依赖</td>
<td>一个主键对应多个独立属性</td>
<td>学生课程和爱好独立相关性</td>
</tr>
<tr>
<td><strong>5NF</strong></td>
<td>消除连接依赖</td>
<td>数据表无法再分解</td>
<td>复杂的多对多关系</td>
</tr>
</tbody></table>
<hr>
<h4 id="1NF（第一范式）"><a href="#1NF（第一范式）" class="headerlink" title="1NF（第一范式）"></a><strong>1NF（第一范式）</strong></h4><p><strong>定义</strong>：表中的每一列只能包含<strong>单一值</strong>，即表是原子化的。<br><strong>要求</strong>：  </p>
<ol>
<li>表格中所有列的值都是不可再分的原子值。  </li>
<li>每一列的数据类型保持一致。</li>
</ol>
<p><strong>示例</strong>（未满足 1NF）：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Courses</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math, English</td>
</tr>
</tbody></table>
<p><strong>满足 1NF 后</strong>：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
</tr>
<tr>
<td>1</td>
<td>English</td>
</tr>
</tbody></table>
<hr>
<h4 id="2NF（第二范式）"><a href="#2NF（第二范式）" class="headerlink" title="2NF（第二范式）"></a><strong>2NF（第二范式）</strong></h4><p><strong>定义</strong>：在满足 1NF 的基础上，消除<strong>部分函数依赖</strong>，即非主属性完全依赖于主键。<br><strong>要求</strong>：  </p>
<ol>
<li>表必须已经满足 1NF。  </li>
<li>非主属性必须依赖于整个主键，而不是主键的一部分（在复合主键的情况下）。</li>
</ol>
<p><strong>部分函数依赖导致的问题</strong></p>
<p>假设有比赛表，字段包含球员编号、姓名、年龄、比赛编号，时间，场地等</p>
<ol>
<li>数据冗余：一个球员参加多场比赛，其姓名年龄多次出现</li>
<li>插入异常：一场未确定参赛人员的比赛无法添加</li>
<li>删除异常：一场已确定但参赛人员没有的比赛会被删除</li>
<li>更新异常：同一场比赛时间一修改就得修改多条信息</li>
</ol>
<p><strong>示例</strong>（未满足 2NF）：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course_ID</th>
<th>Teacher</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
<td>Dr. Smith</td>
</tr>
<tr>
<td>1</td>
<td>English</td>
<td>Dr. Brown</td>
</tr>
</tbody></table>
<p><strong>问题</strong>：<code>Teacher</code> 依赖于 <code>Course_ID</code>，而不是整个主键 <code>Student_ID, Course_ID</code>。<br><strong>满足 2NF 后</strong>：<br>将表拆分：  </p>
<ol>
<li><strong>Student-Course 表</strong>：  <table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course_ID</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
</tr>
</tbody></table>
</li>
</ol>
<p>| 1          | English   |</p>
<ol start="2">
<li><strong>Course-Teacher 表</strong>：  <table>
<thead>
<tr>
<th>Course_ID</th>
<th>Teacher</th>
</tr>
</thead>
<tbody><tr>
<td>Math</td>
<td>Dr. Smith</td>
</tr>
<tr>
<td>English</td>
<td>Dr. Brown</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<h4 id="3NF（第三范式）"><a href="#3NF（第三范式）" class="headerlink" title="3NF（第三范式）"></a><strong>3NF（第三范式）</strong></h4><p><strong>定义</strong>：在满足 2NF 的基础上，消除<strong>传递函数依赖</strong>，即非主属性不能依赖于其他非主属性。<br><strong>要求</strong>：  </p>
<ol>
<li>表必须已经满足 2NF。  </li>
<li>非主属性之间不能有传递依赖。</li>
</ol>
<p><strong>示例</strong>（未满足 3NF）：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course_ID</th>
<th>Teacher</th>
<th>Department</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
<td>Dr. Smith</td>
<td>Math Dept</td>
</tr>
<tr>
<td>1</td>
<td>English</td>
<td>Dr. Brown</td>
<td>English Dept</td>
</tr>
</tbody></table>
<p><strong>问题</strong>：<code>Department</code> 依赖于 <code>Teacher</code>，而不是 <code>Student_ID, Course_ID</code>。<br><strong>满足 3NF 后</strong>：<br>拆分为两张表：  </p>
<ol>
<li><strong>Student-Course 表</strong>：  <table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course_ID</th>
<th>Teacher</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
<td>Dr. Smith</td>
</tr>
</tbody></table>
</li>
</ol>
<p>| 1          | English   | Dr. Brown |</p>
<ol start="2">
<li><strong>Teacher-Department 表</strong>：  <table>
<thead>
<tr>
<th>Teacher</th>
<th>Department</th>
</tr>
</thead>
<tbody><tr>
<td>Dr. Smith</td>
<td>Math Dept</td>
</tr>
<tr>
<td>Dr. Brown</td>
<td>English Dept</td>
</tr>
</tbody></table>
</li>
</ol>
<hr>
<h4 id="BCNF（Boyce-Codd范式）"><a href="#BCNF（Boyce-Codd范式）" class="headerlink" title="BCNF（Boyce-Codd范式）"></a><strong>BCNF（Boyce-Codd范式）</strong></h4><p><strong>定义</strong>：在满足 3NF 的基础上，主属性不能依赖于非主属性。<br><strong>要求</strong>：  </p>
<ol>
<li>表必须已经满足 3NF。  </li>
<li>如果一个非主属性可以决定主属性，则违反 BCNF。</li>
</ol>
<p><strong>示例</strong>（未满足 BCNF）：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course_ID</th>
<th>Teacher</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
<td>Dr. Smith</td>
</tr>
<tr>
<td>2</td>
<td>Math</td>
<td>Dr. Smith</td>
</tr>
</tbody></table>
<p><strong>问题</strong>：<code>Teacher</code> 可以决定 <code>Course_ID</code>，但它不是主键。<br><strong>满足 BCNF 后</strong>：<br>拆分为两张表：  </p>
<ol>
<li><p><strong>Teacher-Course 表</strong>：  </p>
<table>
<thead>
<tr>
<th>Teacher</th>
<th>Course_ID</th>
</tr>
</thead>
<tbody><tr>
<td>Dr. Smith</td>
<td>Math</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Student-Teacher 表</strong>：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Teacher</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Dr. Smith</td>
</tr>
</tbody></table>
</li>
</ol>
<p>| 2          | Dr. Smith |</p>
<hr>
<h4 id="4NF（第四范式）"><a href="#4NF（第四范式）" class="headerlink" title="4NF（第四范式）"></a><strong>4NF（第四范式）</strong></h4><p><strong>定义</strong>：在满足 BCNF 的基础上，消除<strong>多值依赖</strong>。<br><strong>要求</strong>：  </p>
<ol>
<li>表必须已经满足 BCNF。  </li>
<li>同一主键下，不能有多个独立的多值属性。</li>
</ol>
<p><strong>示例</strong>（未满足 4NF）：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course</th>
<th>Hobby</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
<td>Reading</td>
</tr>
<tr>
<td>1</td>
<td>Math</td>
<td>Music</td>
</tr>
</tbody></table>
<p><strong>问题</strong>：<code>Course</code> 和 <code>Hobby</code> 是独立的多值属性。<br><strong>满足 4NF 后</strong>：<br>拆分为两张表：  </p>
<ol>
<li><p><strong>Student-Course 表</strong>：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Course</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Math</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Student-Hobby 表</strong>：  </p>
<table>
<thead>
<tr>
<th>Student_ID</th>
<th>Hobby</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Reading</td>
</tr>
</tbody></table>
</li>
</ol>
<p>| 1          | Music   |</p>
<hr>
<h4 id="5NF（第五范式）"><a href="#5NF（第五范式）" class="headerlink" title="5NF（第五范式）"></a><strong>5NF（第五范式）</strong></h4><p><strong>定义</strong>：在满足 4NF 的基础上，消除<strong>连接依赖（Join Dependency）</strong>，确保表不能再无损分解。<br><strong>要求</strong>：  </p>
<ol>
<li>表必须已经满足 4NF。  </li>
<li>数据表的分解不能导致数据丢失。</li>
</ol>
<p><strong>示例</strong>：<br>涉及复杂多对多关系的情况，一般很少直接使用。</p>
<hr>
<h3 id="反范式"><a href="#反范式" class="headerlink" title="反范式"></a>反范式</h3><p>遵循性能优先原则，若严格按照范式，可能产生大量的关联查询，影响性能。</p>
<h4 id="反范式的新问题"><a href="#反范式的新问题" class="headerlink" title="反范式的新问题"></a>反范式的新问题</h4><ul>
<li>存储 空间变大 了</li>
<li>一个表中字段做了修改，另一个表中冗余的字段也需要做同步修改，否则 数据不一致</li>
<li>若采用存储过程来支持数据的更新、删除等额外操作，如果更新频繁，会非常 消耗系统资源</li>
<li>在 数据量小 的情况下，反范式不能体现性能的优势，可能还会让数据库的设计更加 复杂</li>
</ul>
<h4 id="反范式的适用场景"><a href="#反范式的适用场景" class="headerlink" title="反范式的适用场景"></a>反范式的适用场景</h4><p>当冗余信息有价值或者能 大幅度提高查询效率 的时候，我们才会采取反范式的优化。</p>
<ol>
<li>增加冗余字段的建议</li>
<li>历史快照、历史数据的需要<br> 在现实生活中，我们经常需要一些冗余信息，比如订单中的收货人信息，包括姓名、电话和地址等。每次发生的 订单收货信息 都属于 历史快照 ，需要进行保存，但用户可以随时修改自己的信息，这时保存这些冗余信息是非常有必要的。</li>
<li>反范式优化也常用在 数据仓库 的设计中，因为数据仓库通常 存储历史数据 ，对增删改的实时性要求不强，对历史数据的分析需求强。这时适当允许数据的冗余度，更方便进行数据分析。</li>
</ol>
<h3 id="ER模型"><a href="#ER模型" class="headerlink" title="ER模型"></a>ER模型</h3><p><strong>ER模型</strong>（Entity-Relationship Model，实体-关系模型）是一种用于<strong>数据建模</strong>的图形化方法，通常用于设计数据库的概念模型。通过描述<strong>实体</strong>（Entity）、<strong>属性</strong>（Attribute）、以及实体之间的<strong>关系</strong>（Relationship），它可以帮助我们直观地理解数据库的逻辑结构。</p>
<hr>
<h4 id="ER模型的基本组成部分"><a href="#ER模型的基本组成部分" class="headerlink" title="ER模型的基本组成部分"></a><strong>ER模型的基本组成部分</strong></h4><ol>
<li><strong>实体（Entity）</strong><ul>
<li><strong>定义</strong>：指现实世界中的事物、对象、或概念，通常是可以被区分的独立存在。</li>
<li><strong>分类</strong>：<ul>
<li><strong>强实体（Strong Entity）</strong>：具有唯一标识的实体，例如“学生”有学号作为主键。</li>
<li><strong>弱实体（Weak Entity）</strong>：依赖于其他实体，没有唯一标识符，例如“订单明细”依赖于“订单”。</li>
</ul>
</li>
<li><strong>表示方式</strong>：用<strong>矩形框</strong>表示实体。</li>
</ul>
</li>
<li><strong>属性（Attribute）</strong><ul>
<li><strong>定义</strong>：指实体或关系的特征或性质。</li>
<li><strong>分类</strong>：<ul>
<li><strong>简单属性</strong>：不能再分解的属性，例如姓名。</li>
<li><strong>复合属性</strong>：可以进一步分解的属性，例如地址包含国家、省、市等。</li>
<li><strong>多值属性</strong>：可以有多个值的属性，例如电话号码。</li>
<li><strong>派生属性</strong>：从其他属性推导而来的属性，例如年龄可以由出生日期计算得出。</li>
</ul>
</li>
<li><strong>表示方式</strong>：用<strong>椭圆</strong>表示属性，连接到实体或关系。</li>
</ul>
</li>
<li><strong>关系（Relationship）</strong><ul>
<li><strong>定义</strong>：描述两个或多个实体之间的联系。</li>
<li><strong>分类</strong>：<ul>
<li><strong>一对一（1:1）</strong>：一个实体只能和另一个实体关联，例如“人”和“身份证”。</li>
<li>一对多（1:M）：一个实体可以和多个实体关联，例如“班级”和“学生”。</li>
<li>多对多（M:M）：多个实体可以互相关联，例如“学生”和“课程”。</li>
</ul>
</li>
<li><strong>表示方式</strong>：用<strong>菱形</strong>表示关系，连接相关的实体。</li>
</ul>
</li>
</ol>
<h4 id="ER模型和数据表的转换"><a href="#ER模型和数据表的转换" class="headerlink" title="ER模型和数据表的转换"></a>ER模型和数据表的转换</h4><ol>
<li><p>一个实体对应一个表，先转换强实体</p>
</li>
<li><p>一个多对多关系转换为一个数据表</p>
</li>
<li><p>通过外键表达1对多的关系</p>
<blockquote>
<p>外键约束应当尽可能少使用，通过业务逻辑实现</p>
</blockquote>
</li>
<li><p>把属性转换为表的字段</p>
</li>
</ol>
<h3 id="数据表的设计原则"><a href="#数据表的设计原则" class="headerlink" title="数据表的设计原则"></a>数据表的设计原则</h3><p><strong>三少一多</strong></p>
<ol>
<li><p>数据表的个数越少越好</p>
</li>
<li><p>数据表中的字段个数越少越好</p>
</li>
<li><p>数据表中的联合主键的字段个数越少越好</p>
</li>
<li><p>使用主键和外键越多越好</p>
<blockquote>
<p>这里的外键不是指表中实现外键约束，而是业务逻辑层实现外键</p>
</blockquote>
</li>
</ol>
<h3 id="数据库对象编写建议"><a href="#数据库对象编写建议" class="headerlink" title="数据库对象编写建议"></a>数据库对象编写建议</h3><h4 id="对于数据库"><a href="#对于数据库" class="headerlink" title="对于数据库"></a>对于数据库</h4><ol>
<li><p>【强制】库的名称必须控制在32个字符以内，只能使用英文字母、数字和下划线，建议以英文字母开头。</p>
</li>
<li><p>【强制】库名中英文 一律小写 ，不同单词采用 下划线 分割。须见名知意。</p>
</li>
<li><p>【强制】库的名称格式：业务系统名称_子系统名。</p>
</li>
<li><p>【强制】库名禁止使用关键字（如type,order等）。</p>
</li>
<li><p>【强制】创建数据库时必须 显式指定字符集 ，并且字符集只能是utf8或者utf8mb4。创建数据库SQL举例：CREATE DATABASE crm_fund DEFAULT CHARACTER SET ‘utf8’ ;</p>
</li>
<li><p>【建议】对于程序连接数据库账号，遵循 权限最小原则使用数据库账号只能在一个DB下使用，不准跨库。程序使用的账号 原则上不准有drop权限 。</p>
</li>
<li><p>【建议】临时库以 tmp_ 为前缀，并以日期为后缀；备份库以 bak_ 为前缀，并以日期为后缀。</p>
</li>
</ol>
<h4 id="对于表和列"><a href="#对于表和列" class="headerlink" title="对于表和列"></a>对于表和列</h4><ol>
<li><p>【强制】表和列的名称必须控制在32个字符以内，表名只能使用英文字母、数字和下划线，建议以 英文字母开头 。</p>
</li>
<li><p>【强制】 表名、列名一律小写 ，不同单词采用下划线分割。须见名知意。</p>
</li>
<li><p>【强制】表名要求有模块名强相关，同一模块的表名尽量使用 统一前缀 。比如：crm_fund_item</p>
</li>
<li><p>【强制】创建表时必须 显式指定字符集 为utf8或utf8mb4。</p>
</li>
<li><p>【强制】表名、列名禁止使用关键字（如type,order等）。</p>
</li>
<li><p>【强制】创建表时必须 显式指定表存储引擎 类型。如无特殊需求，一律为InnoDB。</p>
</li>
<li><p>【强制】建表必须有comment。</p>
</li>
<li><p>【强制】字段命名应尽可能使用表达实际含义的英文单词或 缩写 。如：公司 ID，不要使用corporation_id, 而用corp_id 即可。</p>
</li>
<li><p>【强制】布尔值类型的字段命名为 is_描述 。如member表上表示是否为enabled的会员的字段命名为 is_enabled。</p>
</li>
<li><p>【强制】禁止在数据库中存储图片、文件等大的二进制数据通常文件很大，短时间内造成数据量快速增长，数据库进行数据库读取时，通常会进行大量的随机IO操作，文件很大时，IO操作很耗时。通常存储于文件服务器，数据库只存储文件地址信息。</p>
</li>
<li><p>【建议】建表时关于主键： 表必须有主键 (1)强制要求主键为id，类型为int或bigint，且为auto_increment 建议使用unsigned无符号型。 (2)标识表里每一行主体的字段不要设为主键，建议设为其他字段如user_id，order_id等，并建立unique key索引。因为如果设为主键且主键值为随机插入，则会导致innodb内部页分裂和大量随机I&#x2F;O，性能下降。</p>
</li>
<li><p>【建议】核心表（如用户表）必须有行数据的 创建时间字段 （create_time）和 最后更新时间字段（update_time），便于查问题。</p>
</li>
<li><p>【建议】表中所有字段尽量都是 NOT NULL 属性，业务可以根据需要定义 DEFAULT值 。 因为使用NULL值会存在每一行都会占用额外存储空间、数据迁移容易出错、聚合函数计算结果偏差等问<br>题。</p>
</li>
<li><p>【建议】所有存储相同数据的 列名和列类型必须一致 （一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）。</p>
</li>
<li><p>【建议】中间表（或临时表）用于保留中间结果集，名称以 tmp_ 开头。备份表用于备份或抓取源表快照，名称以 bak_ 开头。中间表和备份表定期清理。</p>
</li>
<li><p>【示范】一个较为规范的建表语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_info (</span><br><span class="line">`id` int unsigned NOT NULL AUTO_INCREMENT COMMENT &#x27;自增主键&#x27;,</span><br><span class="line">`user_id` bigint(11) NOT NULL COMMENT &#x27;用户id&#x27;,</span><br><span class="line">`username` varchar(45) NOT NULL COMMENT &#x27;真实姓名&#x27;,</span><br><span class="line">`email` varchar(30) NOT NULL COMMENT &#x27;用户邮箱&#x27;,</span><br><span class="line">`nickname` varchar(45) NOT NULL COMMENT &#x27;昵称&#x27;,</span><br><span class="line">`birthday` date NOT NULL COMMENT &#x27;生日&#x27;,</span><br><span class="line">`sex` tinyint(4) DEFAULT &#x27;0&#x27; COMMENT &#x27;性别&#x27;,</span><br><span class="line">`short_introduce` varchar(150) DEFAULT NULL COMMENT &#x27;一句话介绍自己，最多50个汉字&#x27;,</span><br><span class="line">`user_resume` varchar(300) NOT NULL COMMENT &#x27;用户提交的简历存放地址&#x27;,</span><br><span class="line">`user_register_ip` int NOT NULL COMMENT &#x27;用户注册时的源ip&#x27;,</span><br><span class="line">`create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">`update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE</span><br><span class="line">CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,</span><br><span class="line">`user_review_status` tinyint NOT NULL COMMENT &#x27;用户资料审核状态，1为通过，2为审核中，3为未</span><br><span class="line">通过，4为还未提交审核&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">UNIQUE KEY `uniq_user_id` (`user_id`),</span><br><span class="line">KEY `idx_username`(`username`),</span><br><span class="line">KEY `idx_create_time_status`(`create_time`,`user_review_status`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&#x27;网站用户基本信息&#x27;</span><br></pre></td></tr></table></figure>


</li>
<li><p>【建议】创建表时，可以使用可视化工具。这样可以确保表、字段相关的约定都能设置上。实际上，我们通常很少自己写 DDL 语句，可以使用一些可视化工具来创建和操作数据库和数据表。可视化工具除了方便，还能直接帮我们将数据库的结构定义转化成 SQL 语言，方便数据库和数据表结构的导出和导入。</p>
</li>
</ol>
<h4 id="关于索引"><a href="#关于索引" class="headerlink" title="关于索引"></a>关于索引</h4><ol>
<li>【强制】InnoDB表必须主键为id int&#x2F;bigint auto_increment，且主键值 禁止被更新 。</li>
<li>【强制】InnoDB和MyISAM存储引擎表，索引类型必须为 BTREE 。</li>
<li>【建议】主键的名称以 pk_ 开头，唯一键以 uni_ 或 uk_ 开头，普通索引以 idx_ 开头，一律使用小写格式，以字段的名称或缩写作为后缀。</li>
<li>【建议】多单词组成的columnname，取前几个单词首字母，加末单词组成column_name。如:sample 表 member_id 上的索引：idx_sample_mid。</li>
<li>【建议】单个表上的索引个数 不能超过6个 。</li>
<li>【建议】在建立索引时，多考虑建立 联合索引 ，并把区分度最高的字段放在最前面。</li>
<li>【建议】在多表 JOIN 的SQL里，保证被驱动表的连接列上有索引，这样JOIN 执行效率最高。</li>
<li>【建议】建表或加索引时，保证表里互相不存在 冗余索引 。 比如：如果表里已经存在key(a,b)，则key(a)为冗余索引，需要删除</li>
</ol>
<h4 id="关于SQL编写"><a href="#关于SQL编写" class="headerlink" title="关于SQL编写"></a>关于SQL编写</h4><ol>
<li>【强制】程序端SELECT语句必须指定具体字段名称，禁止写成 *。</li>
<li>【建议】程序端insert语句指定具体字段名称，不要写成INSERT INTO t1 VALUES(…)。</li>
<li>【建议】除静态表或小表（100行以内），DML语句必须有WHERE条件，且使用索引查找。</li>
<li>【建议】INSERT INTO…VALUES(XX),(XX),(XX).. 这里XX的值不要超过5000个。 值过多虽然上线很快，但会引起主从同步延迟。</li>
<li>【建议】SELECT语句不要使用UNION，推荐使用UNION ALL，并且UNION子句个数限制在5个以内。</li>
<li>【建议】线上环境，多表 JOIN 不要超过5个表。</li>
<li>【建议】减少使用ORDER BY，和业务沟通能不排序就不排序，或将排序放到程序端去做。ORDERBY、GROUP BY、DISTINCT 这些语句较为耗费CPU，数据库的CPU资源是极其宝贵的。</li>
<li>【建议】包含了ORDER BY、GROUP BY、DISTINCT 这些查询的语句，WHERE 条件过滤出来的结果集请保持在1000行以内，否则SQL会很慢。</li>
<li>【建议】对单表的多次alter操作必须合并为一次。对于超过100W行的大表进行alter table，必须经过DBA审核，并在业务低峰期执行，多个alter需整合在一起。 因为alter table会产生 表锁 ，期间阻塞对于该表的所有写入，对于业务可能会产生极大影响。</li>
<li>【建议】批量操作数据时，需要控制事务处理间隔时间，进行必要的sleep。</li>
<li>【建议】事务里包含SQL不超过5个。因为过长的事务会导致锁数据较久，MySQL内部缓存、连接消耗过多等问题。</li>
<li>【建议】事务里更新语句尽量基于主键或UNIQUE KEY，如UPDATE… WHERE id&#x3D;XX;<br>PRIMARY KEY (<code>id</code>),<br>UNIQUE KEY <code>uniq_user_id</code> (<code>user_id</code>),<br>KEY <code>idx_username</code>(<code>username</code>),<br>KEY <code>idx_create_time_status</code>(<code>create_time</code>,<code>user_review_status</code>)<br>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;’网站用户基本信息’<br>否则会产生间隙锁，内部扩大锁定范围，导致系统性能下降，产生死锁。</li>
</ol>
<h3 id="PowerDesigner设计ER模型"><a href="#PowerDesigner设计ER模型" class="headerlink" title="PowerDesigner设计ER模型"></a>PowerDesigner设计ER模型</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iq4y1u7vj?spm_id_from=333.788.player.switch&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=158">参考视频</a></p>
<hr>
<h2 id="数据库其他调优策略"><a href="#数据库其他调优策略" class="headerlink" title="数据库其他调优策略"></a>数据库其他调优策略</h2><hr>
<h3 id="如何定位调优问题"><a href="#如何定位调优问题" class="headerlink" title="如何定位调优问题"></a>如何定位调优问题</h3><ol>
<li>用户反馈</li>
<li>日志分析</li>
<li>服务器资源使用监控</li>
<li>数据库内部状况监控</li>
<li>其他</li>
</ol>
<hr>
<h3 id="调优的维度和步骤"><a href="#调优的维度和步骤" class="headerlink" title="调优的维度和步骤"></a>调优的维度和步骤</h3><h5 id="1-选择合适的DBMS"><a href="#1-选择合适的DBMS" class="headerlink" title="1.选择合适的DBMS"></a>1.选择合适的DBMS</h5><ul>
<li>对安全性和事务性处理要求高的，应当使用商业数据库管理系统，如Oracle</li>
<li>采用MySQL时应当采用合适的存储引擎。</li>
<li>或采用非关系型数据库如<code>键值型数据库</code>、<code>文档型数据库</code>，<code>搜索引擎</code>，<code>列式存储</code>，<code>图形数据库</code>。</li>
</ul>
<h5 id="2-优化表的设计"><a href="#2-优化表的设计" class="headerlink" title="2.优化表的设计"></a>2.优化表的设计</h5><ol>
<li>表应当尽量<code>遵循三范式原则</code></li>
<li>查询，尤其是<code>多表联合查询</code>较多的表，采用<code>反范式</code>优化，实现空间换取时间，通过增加冗余字段提高查询效率</li>
<li><code>表字段的数据类型</code>的选择，关系到查询效率的高低和存储空间的大小。一般而言，遵循：<ol>
<li>能采用数值型就不要采用字符型</li>
<li>字符长度应当尽可能短</li>
<li>固定长度采用char，非固定长度采用varchar</li>
</ol>
</li>
</ol>
<h5 id="3-优化逻辑查询"><a href="#3-优化逻辑查询" class="headerlink" title="3.优化逻辑查询"></a>3.优化逻辑查询</h5><p>如子查询重写，等价谓词重写，视图重写，条件简化，连接消除和嵌套连接消除等。</p>
<h5 id="4-优化物理查询"><a href="#4-优化物理查询" class="headerlink" title="4.优化物理查询"></a>4.优化物理查询</h5><p><strong>核心是索引的创建和正确使用</strong></p>
<h5 id="5-使用redis或Memcached"><a href="#5-使用redis或Memcached" class="headerlink" title="5.使用redis或Memcached"></a>5.使用redis或Memcached</h5><h5 id="6-库级优化"><a href="#6-库级优化" class="headerlink" title="6. 库级优化"></a>6. 库级优化</h5><ol>
<li><p>读写分离</p>
<p> <img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241122232904.png"></p>
</li>
<li><p>数据分片</p>
</li>
</ol>
<p>​	<img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20241122232928.png"></p>
<h3 id="优化MySQL服务器"><a href="#优化MySQL服务器" class="headerlink" title="优化MySQL服务器"></a>优化MySQL服务器</h3><p>一方面是对硬件进行优化，另一方面对MySQL服务的参数进行优化，一般需要专业的数据库管理员完成。</p>
<h4 id="优化服务器硬件"><a href="#优化服务器硬件" class="headerlink" title="优化服务器硬件"></a>优化服务器硬件</h4><ol>
<li>配置较大的内存</li>
<li>配置高速磁盘系统</li>
<li>合理分布磁盘I&#x2F;O</li>
<li>配置多处理器</li>
</ol>
<h4 id="优化MySQL参数"><a href="#优化MySQL参数" class="headerlink" title="优化MySQL参数"></a>优化MySQL参数</h4><ul>
<li><code>innodb_buffer_pool_size</code> ：这个参数是Mysql数据库最重要的参数之一，表示InnoDB类型的 表和索引的最大缓存 。它不仅仅缓存 索引数据 ，还会缓存 表的数据 。这个值越大，查询的速度就会越快。但是这个值太大会影响操作系统的性能。</li>
<li><code>key_buffer_size</code> ：表示 索引缓冲区的大小 。索引缓冲区是所有的 线程共享 。增加索引缓冲区可以得到更好处理的索引（对所有读和多重写）。当然，这个值不是越大越好，它的大小取决于内存的大小。如果这个值太大，就会导致操作系统频繁换页，也会降低系统性能。对于内存在 4GB 左右的服务器该参数可设置为 256M 或 384M 。</li>
<li><code>table_cache</code> ：表示 同时打开的表的个数 。这个值越大，能够同时打开的表的个数越多。物理内存越大，设置就越大。默认为2402，调到512-1024最佳。这个值不是越大越好，因为同时打开的表太多会影响操作系统的性能。<br>  <code>query_cache_size</code> ：表示 查询缓冲区的大小 。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，就要增加Query_cache_size的值；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。MySQL8.0之后失效。该参数需要和query_cache_type配合使用。<br>  <code>query_cache_type</code> 的值是0时，所有的查询都不使用查询缓存区。但是query_cache_type&#x3D;0并不<br>  会导致MySQL释放query_cache_size所配置的缓存区内存。<ul>
<li>当query_cache_type&#x3D;1时，所有的查询都将使用查询缓存区，除非在查询语句中指定SQL_NO_CACHE ，如SELECT SQL_NO_CACHE * FROM tbl_name。</li>
<li>当query_cache_type&#x3D;2时，只有在查询语句中使用 SQL_CACHE 关键字，查询才会使用查询缓存区。使用查询缓存区可以提高查询的速度，这种方式只适用于修改操作少且经常执行相同的查询操作的情况。</li>
</ul>
</li>
<li><code>sort_buffer_size</code>：表示每个 需要进行排序的线程分配的缓冲区的大小 。增加这个参数的值可以提高 ORDER BY 或 GROUP BY 操作的速度。默认数值是2 097 144字节（约2MB）。对于内存在4GB左右的服务器推荐设置为6-8M，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6＝ 600MB。</li>
<li><code>join_buffer_size = 8M </code>：表示 联合查询操作所能使用的缓冲区大小 ，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</li>
<li><code>read_buffer_size</code> ：表示 每个线程连续扫描时为扫描的每个表分配的缓冲区的大小（字节） 。当线程从表中连续读取记录时需要用到这个缓冲区。SET SESSION read_buffer_size&#x3D;n可以临时设置该参数的值。默认为64K，可以设置为4M。</li>
<li><code>innodb_flush_log_at_trx_commit</code> ：表示 何时将缓冲区的数据写入日志文件 ，并且将日志文件写入磁盘中。该参数对于innoDB引擎非常重要。该参数有3个值，分别为0、1和2。该参数的默认值为1。<ul>
<li>值为 0 时，表示 每秒1次 的频率将数据写入日志文件并将日志文件写入磁盘。每个事务的commit并不会触发前面的任何操作。该模式速度最快，但不太安全，mysqld进程的崩溃会导致上一秒钟所有事务数据的丢失。</li>
<li>值为 1 时，表示 每次提交事务时 将数据写入日志文件并将日志文件写入磁盘进行同步。该模式是最安全的，但也是最慢的一种方式。因为每次事务提交或事务外的指令都需要把日志写入（flush）硬盘。</li>
<li>值为 2 时，表示 每次提交事务时 将数据写入日志文件， 每隔1秒 将日志文件写入磁盘。该模<br>  式速度较快，也比0安全，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数<br>  据才可能丢失。</li>
</ul>
</li>
<li><code>innodb_log_buffer_size </code>：这是 InnoDB 存储引擎的 事务日志所使用的缓冲区 。为了提高性能，也是先将信息写入 Innodb Log Buffer 中，当满足 innodb_flush_log_trx_commit 参数所设置的相应条件（或者日志缓冲区写满）之后，才会将日志写到文件（或者同步到磁盘）中。</li>
<li><code>max_connections </code>：表示 允许连接到MySQL数据库的最大数量 ，默认值是 151 。如果状态变量connection_errors_max_connections 不为零，并且一直增长，则说明不断有连接请求因数据库连接数已达到允许最大值而失败，这是可以考虑增大max_connections 的值。在Linux 平台下，性能好的服务器，支持 500-1000 个连接不是难事，需要根据服务器性能进行评估设定。这个连接数 不是越大越好 ，因为这些连接会浪费内存的资源。过多的连接可能会导致MySQL服务器僵死。</li>
<li><code>back_log </code>：用于 控制MySQL监听TCP端口时设置的积压请求栈大小 。如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源，将会报错。5.6.6 版本之前默认值为 50 ， 之后的版本默认为 50 + （max_connections &#x2F; 5）， 对于Linux系统推荐设置为小于512的整数，但最大不超过900。如果需要数据库在较短的时间内处理大量连接请求， 可以考虑适当增大back_log 的值。</li>
<li><code>thread_cache_size</code> ： 线程池缓存线程数量的大小 ，当客户端断开连接后将当前线程缓存起来，当在接到新的连接请求时快速响应无需创建新的线程 。这尤其对那些使用短连接的应用程序来说可以极大的提高创建连接的效率。那么为了提高性能可以增大该参数的值。默认为60，可以设置为120。</li>
<li><code>wait_timeout</code> ：指定 一个请求的最大连接时间 ，对于4GB左右内存的服务器可以设置为5-10。</li>
<li><code>interactive_timeout</code>：表示服务器在关闭连接前等待行动的秒数。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iq4y1u7vj/?spm_id_from=333.788.videopod.episodes&vd_source=20530c92c1be8bd70e37346e3a5c037a&p=159">参考实例</a></p>
<h3 id="优化数据库结构"><a href="#优化数据库结构" class="headerlink" title="优化数据库结构"></a>优化数据库结构</h3><ol>
<li>拆分表：冷热数据分离</li>
<li>增加中间表</li>
<li>增加冗余字段（反范式化）</li>
<li>优化数据类型：<ul>
<li>整数类型数据优化<ul>
<li>整数字段类型优先使用<code>INT</code></li>
<li>非负型数据优先使用无符号整型<code>UNSIGNED</code></li>
</ul>
</li>
<li>既可以使用文本类型也可以使用整数类型的字段，要选择使用整数类型。</li>
<li>避免使用TEXT、BLOB数据类型</li>
<li>避免使用ENUM类型</li>
<li>使用TIMESTAMP存储时间</li>
<li>用DECIMAL代替FLOAT和DOUBLE存储精确浮点数</li>
</ul>
</li>
<li>优化插入记录的速度<ol>
<li>MyISAM引擎的表：<ol>
<li>禁用索引</li>
<li>禁用唯一性检查</li>
<li>使用批量插入</li>
<li>使用LOAD DATA INFILE 批量导入</li>
</ol>
</li>
<li>InnoDB引擎<ol>
<li>禁止唯一性检查</li>
<li>禁止外键检查</li>
<li>禁止自动提交</li>
</ol>
</li>
</ol>
</li>
<li>使用非空约束</li>
</ol>
<h4 id="分析表，检查表和优化表"><a href="#分析表，检查表和优化表" class="headerlink" title="分析表，检查表和优化表"></a>分析表，检查表和优化表</h4><p>MySQL提供了分析表、检查表和优化表的语句，分析表用于分析关键字的分布，检查表检查表是否存在错误，优化表消除删除或更新造成的空间浪费</p>
<h5 id="分析表"><a href="#分析表" class="headerlink" title="**分析表 **"></a>**分析表 **</h5><p>基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name[,tbl_name]</span><br></pre></td></tr></table></figure>

<p>在分析表的过程中，会对表添加<code>只读锁</code>，因此不能更新和插入数据。ANALYZE TABLE语句能够分析InnoDB和MyISAM类型的表，但是不能作用于视图。</p>
<p>ANALYZE TABLE分析后的统计结果会反应到<code>cardinality</code>的值，该值统计了表中某一键所在的列不重复的值的个数。<strong>该值越接近表中的总行数，则在表连接查询或者索引查询时，就越优先被优化器选择使用</strong>。</p>
<h5 id="检查表"><a href="#检查表" class="headerlink" title="检查表"></a>检查表</h5><p>基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br></pre></td></tr></table></figure>

<p>CHECK TABLE语句在执行过程中也会给表加上 <code>只读锁</code> </p>
<p>能够检查InnoDB和MyISAM类型的表是否存在错误，对于MyISAM类型的表，CHECK TABLE语句还会更新关键字统计数据。而且，CHECK TABLE也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。</p>
<p>其中，tbl_name是表名；option参数有5个取值，分别是QUICK、FAST、MEDIUM、EXTENDED和CHANGED。各个选项的意义分别是：</p>
<ul>
<li>QUICK ：不扫描行，不检查错误的连接。</li>
<li>FAST ：只检查没有被正确关闭的表。</li>
<li>CHANGED ：只检查上次检查后被更改的表和没有被正确关闭的表。</li>
<li>MEDIUM ：扫描行，以验证被删除的连接是有效的。也可以计算各行的关键字校验和，并使用计算<br>  出的校验和验证这一点。</li>
<li>EXTENDED ：对每行的所有关键字进行一个全面的关键字查找。这可以确保表是100%一致的，但<br>  是花的时间较长。</li>
</ul>
<p>option只对MyISAM类型的表有效，对InnoDB类型的表无效。</p>
<h5 id="优化表"><a href="#优化表" class="headerlink" title="优化表"></a>优化表</h5><p><strong>方式1：OPTIMIZE TABLE</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure>

<p>OPTILMIZE TABLE语句只能优化表中的VARCHAR 、 BLOB 或 TEXT 类型的字段。一个表使用了这些字段的数据类型，若已经删除了表的一大部分数据，或者已经对含有可变长度行的表（含有VARCHAR、BLOB或TEXT列的表）进行了很多更新 ，则应使用OPTIMIZE TABLE来重新利用未使用的空间，并整理数据文件的 碎片 。OPTIMIZE TABLE 语句对InnoDB和MyISAM类型的表都有效。该语句在执行过程中也会给表加上 <code>只读锁</code> 。</p>
<p><strong>方法2：使用mysqlcheck命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlcheck -o DatabaseName tablename -u root -p *******</span><br></pre></td></tr></table></figure>



<h3 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h3><ol>
<li><strong>限定查询的范围：</strong>禁止不带任何限制数据范围条件的查询语句。</li>
<li><strong>读写分离：</strong>主库负责写，从库负责读，利用主从复制。包括一主一从，双主双从等模式</li>
<li><strong>垂直拆分：</strong>当数据量达到千万级以上时，可能就需要采用垂直拆分。包括<code>垂直分库</code>（一个数据库按功能模块分成多份，存储在不同的数据库服务器上，关联表在同一个数据库中）和<code>垂直分表</code>（将一张数据表拆分为多张，经常一起使用的列就放在一起）</li>
<li><strong>水平拆分</strong><ul>
<li>尽量控制单表的数据量在<code>1000万以内</code>，可以采用历史数据分档（用于日志数据）或水平分表（用于业务数据）等。</li>
<li>水平拆分最好分库。</li>
<li>水平拆分能够支持非常大的数据量存储，应用端改造也小，但分片事务难以解决，跨节点Join性能差，逻辑复杂。部分专家<strong>建议不要对数据进行分片以避免带来逻辑，部署和运维上的复杂度</strong></li>
</ul>
</li>
</ol>
<p>数据库分片的两种常见方案：<br>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。<br>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</p>
<h3 id="其他优化策略"><a href="#其他优化策略" class="headerlink" title="其他优化策略"></a>其他优化策略</h3><p>MySQL8.0下：</p>
<ol>
<li><p>服务器语句超时处理</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL MAX_EXECUTION_TIME=2000; -- 毫秒为单位</span><br></pre></td></tr></table></figure>

</li>
<li><p>创建全局通用表空间</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create tablespace name add datafile &#x27;filename.ibd&#x27; file_block_size = 16k; --创建名为name的以filename.idb为存储文件的共享表空间</span><br><span class="line">-- 创建表空间后，可以在创建表或修改表时使用tablespace指定表空间</span><br><span class="line">create table test(id int,name varchar(10)) engine=innodb default charset utf8mb4 tablespace name;</span><br><span class="line">-- 或</span><br><span class="line">alter table test tablespace name;</span><br><span class="line">-- 若使用此表空间的表都删除后，即可删除此共享表空间</span><br><span class="line">drop tablespace name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p>隐藏索引对调优的帮助</p>
</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i> MySQL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/09/07/MySQL-Note1-%E8%AF%AD%E6%B3%95%E8%AF%AD%E5%8F%A5/" rel="prev" title="MySQL-Note1-语法语句">
                  <i class="fa fa-angle-left"></i> MySQL-Note1-语法语句
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/09/26/MySQL-Challenges/" rel="next" title="MySQL-Challenges">
                  MySQL-Challenges <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments giscus-container">
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Shearington</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">449k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">24:58</span>
  </span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"Fushiye/Fushiye.github.io","repo_id":"R_kgDOLyiTvA","category":"Announcements","category_id":"DIC_kwDOLyiTvM4CteAo","mapping":"title","strict":0,"reactions_enabled":1,"emit_metadata":0,"theme":"light","lang":"zh-CN","crossorigin":"anonymous","input_position":"top","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
