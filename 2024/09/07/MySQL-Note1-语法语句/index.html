<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_apple-touch-icon-human.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_human_32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_human_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fushiye.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism-darcula","dark":"prism-darcula"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"giscus","storage":true,"lazyload":false,"nav":null,"activeClass":"giscus"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":3,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="MySQL基本语法学习笔记，欢迎指正~">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL-Note1-语法语句">
<meta property="og:url" content="https://fushiye.github.io/2024/09/07/MySQL-Note1-%E8%AF%AD%E6%B3%95%E8%AF%AD%E5%8F%A5/index.html">
<meta property="og:site_name" content="星海拾贝">
<meta property="og:description" content="MySQL基本语法学习笔记，欢迎指正~">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240804180925.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801103242.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801113019.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801120940.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801170016.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801165938.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801121258.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801213549.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802182716.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802184122.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802184153.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232700.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232738.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232848.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232924.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232956.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802233046.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802233122.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240803104059.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240803104202.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240804120046.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240804145645.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240807155020.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240808212056.png">
<meta property="article:published_time" content="2024-09-07T07:07:38.000Z">
<meta property="article:modified_time" content="2025-02-15T14:38:52.149Z">
<meta property="article:author" content="Shearington">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240804180925.png">


<link rel="canonical" href="https://fushiye.github.io/2024/09/07/MySQL-Note1-%E8%AF%AD%E6%B3%95%E8%AF%AD%E5%8F%A5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://fushiye.github.io/2024/09/07/MySQL-Note1-%E8%AF%AD%E6%B3%95%E8%AF%AD%E5%8F%A5/","path":"2024/09/07/MySQL-Note1-语法语句/","title":"MySQL-Note1-语法语句"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>MySQL-Note1-语法语句 | 星海拾贝</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">星海拾贝</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探索永无止境</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="nav-number">1.</span> <span class="nav-text">基础篇</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">基本概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">1.1.1.</span> <span class="nav-text">关系型数据库和非关系型数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.1.2.</span> <span class="nav-text">关系型数据库详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD"><span class="nav-number">1.1.3.</span> <span class="nav-text">MySQL的安装和卸载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.4.</span> <span class="nav-text">MySQL 基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA"><span class="nav-number">1.1.5.</span> <span class="nav-text">数据库和表的导入导出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.6.</span> <span class="nav-text">MySQL中的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.7.</span> <span class="nav-text">图形化界面工具的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.1.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83"><span class="nav-number">1.2.</span> <span class="nav-text">SQL语言规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E8%AF%AD%E8%A8%80%E7%9A%84%E8%A7%84%E5%88%99%E4%B8%8E%E8%A7%84%E8%8C%83"><span class="nav-number">1.2.1.</span> <span class="nav-text">SQL语言的规则与规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BF%E9%87%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83"><span class="nav-number">1.2.2.</span> <span class="nav-text">阿里数据库规范</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DML-SELECT%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">DML-SELECT使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.1.</span> <span class="nav-text">基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%AD%E5%8F%A5%E7%BB%93%E6%9E%84%E5%92%8C%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-number">1.3.2.</span> <span class="nav-text">语句结构和执行顺序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#select%E8%AF%AD%E5%8F%A5%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">select语句结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">SQL语句执行过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL-%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">SQL 的执行原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.3.3.</span> <span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6-div-mod"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">算术运算符 + - * &#x2F;(div) %(mod)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">比较运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#REGEXP%E3%80%81RLIKE-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">REGEXP、RLIKE 正则表达式匹配字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.3.3.5.</span> <span class="nav-text">位运算符和运算符优先级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E5%92%8C%E5%88%86%E9%A1%B5"><span class="nav-number">1.3.4.</span> <span class="nav-text">排序和分页</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ORDER-BY-%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">ORDER BY 排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LIMIT-%E5%88%86%E9%A1%B5"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">LIMIT 分页</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.3.5.</span> <span class="nav-text">多表查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%A7%84%E8%8C%83"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">基本规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">内连接和外连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sql99-%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">sql99 自然连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.6.</span> <span class="nav-text">函数的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">单行函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">聚合函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">结构函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84"><span class="nav-number">1.3.7.</span> <span class="nav-text">分组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GROUP-BY"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">GROUP BY</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HAVING%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">HAVING的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.3.8.</span> <span class="nav-text">子查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">单行子查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.3.8.2.</span> <span class="nav-text">多行子查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.3.8.3.</span> <span class="nav-text">相关子查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.3.9.</span> <span class="nav-text">正则表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DDL-%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E4%BF%AE%E6%94%B9%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">1.4.</span> <span class="nav-text">DDL-数据库、表的创建、修改和删除</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.4.1.</span> <span class="nav-text">数据库基本操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E4%BF%AE%E6%94%B9%E3%80%81%E5%88%A0%E9%99%A4"><span class="nav-number">1.4.2.</span> <span class="nav-text">表的创建、修改、删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DML-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9"><span class="nav-number">1.5.</span> <span class="nav-text">DML-数据的增删改</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="nav-number">1.5.1.</span> <span class="nav-text">添加数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="nav-number">1.5.2.</span> <span class="nav-text">更新和删除数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%88%97"><span class="nav-number">1.5.3.</span> <span class="nav-text">计算列</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F"><span class="nav-number">1.6.</span> <span class="nav-text">约束</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E7%A9%BA%E7%BA%A6%E6%9D%9F-NOT-NULL"><span class="nav-number">1.6.1.</span> <span class="nav-text">非空约束 NOT NULL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E6%80%A7%E7%BA%A6%E6%9D%9F-UNIQUE"><span class="nav-number">1.6.2.</span> <span class="nav-text">唯一性约束 UNIQUE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E7%BA%A6%E6%9D%9F-PRIMARY-KEY"><span class="nav-number">1.6.3.</span> <span class="nav-text">主键约束 PRIMARY KEY</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E5%88%97-AUTO-INCREMENT"><span class="nav-number">1.6.4.</span> <span class="nav-text">自增列 AUTO_INCREMENT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%94%AE%E7%BA%A6%E6%9D%9F-FOREIGN-KEY"><span class="nav-number">1.6.5.</span> <span class="nav-text">外键约束 FOREIGN KEY</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%8F%91%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">开发建议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%BA%A6%E6%9D%9F-CHECK"><span class="nav-number">1.6.6.</span> <span class="nav-text">检查约束 CHECK</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%80%BC%E7%BA%A6%E6%9D%9F-DEFAULT"><span class="nav-number">1.6.7.</span> <span class="nav-text">默认值约束 DEFAULT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">1.6.8.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE"><span class="nav-number">1.7.</span> <span class="nav-text">视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E6%9F%A5%E7%9C%8B%E3%80%81%E4%BF%AE%E6%94%B9%E5%92%8C%E5%88%A0%E9%99%A4"><span class="nav-number">1.7.1.</span> <span class="nav-text">视图的创建、查看、修改和删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%86%E5%9B%BE%E6%95%B0%E6%8D%AE%E7%9A%84%E6%9B%B4%E6%96%B0"><span class="nav-number">1.7.2.</span> <span class="nav-text">视图数据的更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.</span> <span class="nav-text">存储过程和存储函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.8.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.8.2.</span> <span class="nav-text">存储过程的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.8.3.</span> <span class="nav-text">存储函数的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%A5%E7%9C%8B%E4%BF%AE%E6%94%B9%E5%88%A0%E9%99%A4"><span class="nav-number">1.8.4.</span> <span class="nav-text">存储过程和存储函数的查看修改删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE"><span class="nav-number">1.8.5.</span> <span class="nav-text">使用建议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E6%B8%B8%E6%A0%87"><span class="nav-number">1.9.</span> <span class="nav-text">变量、流程控制和游标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">1.9.1.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">系统变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">用户变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.9.2.</span> <span class="nav-text">定义条件与处理程序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">定义条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">定义处理程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">1.9.3.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E4%B9%8B-IF"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">分支结构之 IF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84%E4%B9%8B-CASE"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">分支结构之 CASE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E4%B9%8B-LOOP"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">循环结构之 LOOP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E4%B9%8B-WHILE"><span class="nav-number">1.9.3.4.</span> <span class="nav-text">循环结构之 WHILE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E4%B9%8B-REPEAT"><span class="nav-number">1.9.3.5.</span> <span class="nav-text">循环结构之 REPEAT</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5%E4%B9%8B-LEAVE"><span class="nav-number">1.9.3.6.</span> <span class="nav-text">跳转语句之 LEAVE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC%E8%AF%AD%E5%8F%A5%E4%B9%8B-ITERATE"><span class="nav-number">1.9.3.7.</span> <span class="nav-text">跳转语句之 ITERATE</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B8%B8%E6%A0%87%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.9.4.</span> <span class="nav-text">游标的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">1.10.</span> <span class="nav-text">触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.10.1.</span> <span class="nav-text">触发器的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E5%92%8C%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="nav-number">1.10.2.</span> <span class="nav-text">查看和删除触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.10.3.</span> <span class="nav-text">触发器的优缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-0%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.11.</span> <span class="nav-text">8.0其他新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.11.1.</span> <span class="nav-text">窗口函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">语法结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%8F%E5%8F%B7%E5%87%BD%E6%95%B0"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">序号函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0"><span class="nav-number">1.11.1.3.</span> <span class="nav-text">分布函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E7%94%A8%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.11.2.</span> <span class="nav-text">公用表表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E5%85%AC%E7%94%A8%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.11.2.1.</span> <span class="nav-text">普通公用表表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%85%AC%E7%94%A8%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.11.2.2.</span> <span class="nav-text">递归公用表表达式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89"><span class="nav-number">1.12.</span> <span class="nav-text">关键字及其含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%82%E8%B0%88"><span class="nav-number">1.13.</span> <span class="nav-text">杂谈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF"><span class="nav-number">1.13.1.</span> <span class="nav-text">抛出错误</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shearington"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Shearington</p>
  <div class="site-description" itemprop="description">诗酒趁年华</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">48</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Fushiye/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Fushiye&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shearington@foxmail.com" title="E-Mail → mailto:shearington@foxmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fushiye.github.io/2024/09/07/MySQL-Note1-%E8%AF%AD%E6%B3%95%E8%AF%AD%E5%8F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Shearington">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星海拾贝">
      <meta itemprop="description" content="诗酒趁年华">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="MySQL-Note1-语法语句 | 星海拾贝">
      <meta itemprop="description" content="MySQL基本语法学习笔记，欢迎指正~">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL-Note1-语法语句
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-07 15:07:38" itemprop="dateCreated datePublished" datetime="2024-09-07T15:07:38+08:00">2024-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-15 22:38:52" itemprop="dateModified" datetime="2025-02-15T22:38:52+08:00">2025-02-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">缓存与数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>28k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:32</span>
    </span>
</div>

            <div class="post-description">MySQL基本语法学习笔记，欢迎指正~</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><span id="more"></span>

<p>参考文献：<br><a target="_blank" rel="noopener" href="https://mysql.net.cn/doc/refman/8.0/en/">MySQL中文文档</a><br><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/">MySQL官方英文文档</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=26&spm_id_from=pageDriver&vd_source=20530c92c1be8bd70e37346e3a5c037a">视频</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/janzen_pan/article/details/123016925">数据库知识1</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/rakish_wind/article/details/85028846">数据库知识2</a></p>
<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p>常见数据库管理软件：</p>
<ul>
<li>关系型数据库：Oracle MySql Microsoft-SQL-Server DB2 PostgreSQL SQLite</li>
<li>非关系型数据库：</li>
</ul>
<p>DDL:数据定义语言。create\alter\drop\rename\truncate …<br>    一旦执行不可回滚rollback！<br>DML:数据操作语言。insert\delete\update\select …<br>    默认不可回滚，自动commit，可以设置禁止自动commit从而可以回滚<code>set autocommit = false</code><br>DCL:数据控制语言。commit\rollback\savepoint\grant\revoke …</p>
<h3 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h3><p>关系型数据库：关系型数据库（Relational Database Management System, RDBMS）是一种基于关系模型的数据库管理系统。它使用表格（table）来存储和管理数据，并通过表之间的关联（relationship）来实现数据的组织和管理。在关系型数据库中，所有的数据都存储在表中，每个表都包含了一系列的行（row）和列（column），其中行代表记录（record），列代表字段（field）。关系型数据库很适合多表复杂查询，具有四大特性：原子性、一致性、隔离性、持久性（ACID）</p>
<p>关系型数据库的核心特性包括：</p>
<ul>
<li>表结构：每个表都有一个明确的结构，定义了表中可以存储哪些类型的数据。表中的每一列都有一个数据类型（如整数、字符串、日期等），以及一个描述列内容的名称。</li>
<li>关系：通过定义表之间的关联（如外键约束），关系型数据库可以表达复杂的数据关系。这种关联使得可以轻松地查询和更新多个表中的数据。</li>
<li>SQL语言：关系型数据库使用SQL（Structured Query Language，结构化查询语言）作为数据操作和查询的标准语言。SQL提供了丰富的语法来执行数据的增、删、改、查（CRUD）操作。</li>
<li>事务处理：关系型数据库支持事务处理，确保数据的一致性和完整性。事务处理包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），即ACID特性。</li>
<li>安全性：关系型数据库提供了多种安全特性，如用户认证、访问控制列表（ACL）和加密等，以保护数据的安全。<br>并发控制：支持多个用户同时访问和修改数据库，通过并发控制机制（如锁）来避免数据冲突和不一致。</li>
</ul>
<p>非关系型数据库（NoSQL）是相对于关系型数据库（SQL）的一种数据库管理系统，它的数据储存不需要固定的表格模式，且在大数据和实时应用处理上有显著优势。以下是对非关系型数据库的概念和常见类别的详细解析：<br>非关系型数据库的概念</p>
<p>非关系型数据库是一种非关系型的、分布式的、且一般不保证遵循ACID（原子性、一致性、隔离性、持久性）原则的数据存储系统。非关系型数据库以其灵活的数据模型、高可扩展性和高性能在大数据和实时应用处理中占据重要地位。不同的非关系型数据库类型适用于不同的应用场景，选择合适的数据库类型对于系统的性能和可扩展性至关重要。它的主要特点包括：</p>
<ul>
<li>数据模型灵活：不需要预先定义数据结构，可以存储复杂的数据类型。</li>
<li>横向扩展：可通过增加服务器进行扩展，具有高可扩展性。</li>
<li>读写性能高：特别适合大数据和高并发场景。</li>
</ul>
<p>非关系型数据库主要有以下几种类型：</p>
<ul>
<li>键值存储数据库（Key-Value Stores）<ul>
<li>概念：将数据存储为键值对的形式，可以快速地根据键获取对应的值。</li>
<li>特点：查找速度快，适用于处理大量数据的高访问负载，也常用于缓存和日志系统。</li>
<li>典型产品：Redis、Memcached。</li>
</ul>
</li>
<li>文档存储数据库（Document Stores）<ul>
<li>概念：以文档的形式存储数据，文档可以是JSON、XML等格式，能够存储结构化数据和非结构化数据。</li>
<li>特点：适合复杂的查询和半结构化数据的存储，灵活性高。</li>
<li>典型产品：MongoDB、CouchDB。</li>
</ul>
</li>
<li>列存储数据库（Column-Family Stores）<ul>
<li>概念：将数据存储在列中，而不是传统的关系型数据库中的行。</li>
<li>特点：查找速度快，可扩展性强，更适合分布式存储和处理大量数据。</li>
<li>典型产品：Cassandra、HBase。</li>
</ul>
</li>
<li>图形数据库（Graph Databases）<ul>
<li>概念：用于存储和查询图形结构的数据，通过节点和边来表示数据模型。</li>
<li>特点：能够高效地处理复杂的关系和网络结构，常用于社交网络、推荐系统等。</li>
<li>典型产品：Neo4j、ArangoDB。</li>
</ul>
</li>
<li>时间序列数据库（Time-Series Stores）<ul>
<li>概念：专为处理时间相关的数据而设计，如日志文件、用户活动、传感器数据等。</li>
<li>特点：通常用于分析和存储随时间变化的数据，具有快速写入、实时分析和查询的能力。</li>
<li>典型产品：InfluxDB、TimeScaleDB（基于PostgreSQL的扩展）。</li>
</ul>
</li>
</ul>
<h3 id="关系型数据库详解"><a href="#关系型数据库详解" class="headerlink" title="关系型数据库详解"></a>关系型数据库详解</h3><p>E-R模型：Entity-Relationship 实体-联系模型</p>
<p><strong>ORM(Object Relational Mapping)思想</strong><br>数据库中的一个表和Java或Python中的一个类对应<br>表中的一条数据和类中的一个对象(或实体)对应<br>表中的某一列和类中的一个字段(属性)对应</p>
<p><strong>表的关联关系</strong><br>现实中的各种实体以及实体之间的联系均使用关系模型来表示<br>一点一：<br>一对多：<br>多对多：需要创建联接表<br>自我引用：</p>
<h3 id="MySQL的安装和卸载"><a href="#MySQL的安装和卸载" class="headerlink" title="MySQL的安装和卸载"></a>MySQL的安装和卸载</h3><p>卸载：<br>控制面板中卸载MySQL相关的软件；<br>清除C:\programData\MySQL中的配置信息和自己创建的文件（可不删除）；<br>清理环境变量；清理注册表；重启</p>
<p>参考<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=7&spm_id_from=pageDriver&vd_source=20530c92c1be8bd70e37346e3a5c037a">MySQL安装卸载教程</a></p>
<h3 id="MySQL-基本介绍"><a href="#MySQL-基本介绍" class="headerlink" title="MySQL 基本介绍"></a>MySQL 基本介绍</h3><p><strong>基本功能命令：</strong></p>
<table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>登录</td>
<td>mysql -h localhost -P 3306 -u root -p <br> 客户端和服务器在同一机器时简写成：mysql -u root -p</td>
</tr>
<tr>
<td>查看版本</td>
<td>mysql -V or mysql –version</td>
</tr>
</tbody></table>
<p><strong>配置数据库详细功能</strong></p>
<table>
<thead>
<tr>
<th>数据库名称</th>
<th>数据库功能</th>
</tr>
</thead>
<tbody><tr>
<td>information_schema</td>
<td>包含了关于所有其他数据库的信息，如数据库中的表、列、数据类型、访问权限等元数据。<br>由MySQL服务器自动维护的。它对于数据库管理和查询元数据非常有用。</td>
</tr>
<tr>
<td>mysql</td>
<td>包含了MySQL服务器运行所必需的系统表，包括用户权限表、存储过程和事件等。<br>是MySQL的核心组成部分，不建议直接在这个数据库中创建或删除表。</td>
</tr>
<tr>
<td>performance_schema</td>
<td>用于监控MySQL服务器的性能。提供了丰富的数据来分析和优化MySQL服务器的性能<br>包含了各种性能指标的详细数据，如等待事件、锁信息、文件I&#x2F;O等。</td>
</tr>
<tr>
<td>sys</td>
<td>系统数据库，提供了对MySQL服务器性能的快速访问,包含了一系列视图和函数<br>这些视图和函数基于performance_schema和information_schema中的数据，但以一种更易于理解和使用的形式呈现。<br>通过使用sys数据库，可以更容易地诊断和解决MySQL服务器的性能问题。</td>
</tr>
<tr>
<td>sakila、world</td>
<td>示例数据库</td>
</tr>
</tbody></table>
<p><strong>MySQL数据目录结构</strong></p>
<p>C:\programData\MySQL\Data下存储系统自带和用户创建的数据库</p>
<p><strong>字符集</strong><br>MySQL5.0默认使用Latin字符集，不支持插入中文数据，查看和修改字符集的方法如下</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character_%&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>修改 C:\programData\MySQL\下my.ini文件，在63行左右的<code>[mysql]</code>和76行左右的<code>[mysqld]</code>分别添加后重启：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（63处添加）</span><br><span class="line">default-character-set = utf8</span><br><span class="line">（76处添加）</span><br><span class="line">character-set-server = utf8</span><br><span class="line">collation-server = utf8-general-ci</span><br></pre></td></tr></table></figure>


<p>*<strong>数据库对象</strong></p>
<table>
<thead>
<tr>
<th>数据对象</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>表(TABLE)</td>
<td>表是存储数据的逻辑单元，以行和列的形式存在，列就是字段，行就是记录</td>
</tr>
<tr>
<td>数据字典</td>
<td>就是系统表，存放数据库相关信息的表。系统表的数据通常由数据库系统维护，程序员通常不应该修改，只可查看</td>
</tr>
<tr>
<td>约束(CONSTRAINT)</td>
<td>执行数据校验的规则，用于保证数据完整性的规则</td>
</tr>
<tr>
<td>视图(VIEW)</td>
<td>一个或者多个数据表里的数据的逻辑显示，视图并不存储数据</td>
</tr>
<tr>
<td>索引(INDEX)</td>
<td>用于提高查询性能，相当于书的目录</td>
</tr>
<tr>
<td>存储过程(PROCEDURE)</td>
<td>用于完成一次完整的业务处理，没有返回值，但可通过传出参数将多个值传给调用环境</td>
</tr>
<tr>
<td>存储函数(FUNCTION)</td>
<td>用于完成一次特定的计算，具有一个返回值</td>
</tr>
<tr>
<td>触发器(TRIGGER)</td>
<td>相当于一个事件监听器，当数据库发生特定事件后，触发器被触发，完成相应的处理</td>
</tr>
</tbody></table>
<h3 id="数据库和表的导入导出"><a href="#数据库和表的导入导出" class="headerlink" title="数据库和表的导入导出"></a>数据库和表的导入导出</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source Source<span class="operator">-</span>address</span><br><span class="line"><span class="comment">-- source d:\workEnglish\testdb.sql</span></span><br><span class="line"><span class="comment">-- 可在主界面执行，导入原数据库</span></span><br><span class="line"><span class="comment">-- 或在某数据库中执行，复制源数据库数据到当前数据库并导入原数据库</span></span><br></pre></td></tr></table></figure>


<h3 id="MySQL中的数据类型"><a href="#MySQL中的数据类型" class="headerlink" title="MySQL中的数据类型"></a>MySQL中的数据类型</h3><p>参见《MySQL数据类型》专项笔记</p>
<h3 id="图形化界面工具的使用"><a href="#图形化界面工具的使用" class="headerlink" title="图形化界面工具的使用"></a>图形化界面工具的使用</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1iq4y1u7vj?p=10&spm_id_from=pageDriver&vd_source=20530c92c1be8bd70e37346e3a5c037a">参考视频</a></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>说说你了解的常见的数据库<ul>
<li>Oracle、MySQl、SQL Server、DB2、PGSQL；Redis、MongoDB、ES…..</li>
</ul>
</li>
<li>谈谈你对MySQL历史、特点的理解<br> 历史：<br> 由瑞典的MySQL AB 公司创立，1995开发出的MySQL<br> 2008年，MySQL被SUN公司收购<br> 2009年，Oracle收购SUN公司，进而Oracle就获取了MySQL<br> 2016年，MySQL8.0.0版本推出<br> 特点：<br> 开源的、关系型的数据库<br> 支持千万级别数据量的存储，大型的数据库</li>
<li>说说你对DB、DBMS、SQL的理解<br> DB：database，看做是数据库文件。 （类似于：.doc、.txt、.mp3、.avi、。。。）<br> DBMS：数据库管理系统。（类似于word工具、wps工具、记事本工具、qq影音播放器等）<br> MySQL数据库服务器中安装了MySQL DBMS,使用MySQL DBMS 来管理和操作DB，使用的是SQL语言。</li>
<li>你知道哪些非关系型数据库的类型呢？（了解）<br> 键值型数据库：Redis<br> 文档型数据库：MongoDB<br> 搜索引擎数据库：ES、Solr<br> 列式数据库：HBase<br> 图形数据库：InfoGrid</li>
<li>表与表的记录之间存在哪些关联关系？<br> ORM思想。（了解）<br> 表与表的记录之间的关系：一对一关系、一对多关系、多对多关系、自关联 （了解）</li>
<li>安装好MySQL之后在windows系统中哪些位置能看到MySQL?<br> MySQL DBMS软件的安装位置。 D:\develop_tools\MySQL\MySQL Server 8.0<br> MySQL 数据库文件的存放位置。 C:\ProgramData\MySQL\MySQL Server 8.0\Data<br> MySQL DBMS 的配置文件。 C:\ProgramData\MySQL\MySQL Server 8.0\my.ini<br> MySQL的服务（要想通过客户端能够访问MySQL的服务器，必须保证服务是开启状态的）<br> MySQL的path环境变量</li>
<li>卸载MySQL主要卸载哪几个位置的内容？<br> 使用控制面板的软件卸载，去卸载MySQL DBMS软件的安装位置。<br> D:\develop_tools\MySQL\MySQL Server 8.0<br> 手动删除数据库文件。 C:\ProgramData\MySQL\MySQL Server 8.0\Data<br> MySQL的环境变量<br> MySQL的服务进入注册表删除。（ regedit ）<br> 务必重启电脑</li>
<li>能够独立完成MySQL8.0、MySQL5.7版本的下载、安装、配置 （掌握）</li>
<li>MySQL5.7在配置完以后，如何修改配置文件？<br> 为什么要修改my.ini文件？ 默认的数据库使用的字符集是latin1。我们需要修改为：utf8<br> 修改哪些信息？<br> 修改完以后，需要重启服务。</li>
<li>熟悉常用的数据库管理和操作的工具<br>方式1：windows自带的cmd<br>方式2：mysql数据库自带的命令行窗口<br>方式3：图形化管理工具：Navicat、SQLyog、dbeaver等。</li>
</ol>
<h2 id="SQL语言规范"><a href="#SQL语言规范" class="headerlink" title="SQL语言规范"></a>SQL语言规范</h2><h3 id="SQL语言的规则与规范"><a href="#SQL语言的规则与规范" class="headerlink" title="SQL语言的规则与规范"></a>SQL语言的规则与规范</h3><p><strong>基本规则</strong></p>
<ul>
<li>SQL 可以写在一行或者多行。为了提高可读性，各子句分行写，必要时使用缩进</li>
<li>每条命令以 ; 或 \g 或 \G 结束</li>
<li>关键字不能被缩写也不能分行</li>
<li>关于标点符号<ul>
<li>必须保证所有的()、单引号、双引号是成对结束的</li>
<li>必须使用英文状态下的半角输入方式</li>
<li>字符串型和日期时间类型的数据可以使用单引号（’ ‘）表示</li>
<li>列的别名，尽量使用双引号（” “），而且不建议省略as</li>
</ul>
</li>
</ul>
<p><strong>SQL大小写规范 （建议遵守）</strong></p>
<ul>
<li>MySQL 在 Windows 环境下是大小写不敏感的</li>
<li>MySQL 在 Linux 环境下是大小写敏感的(数据库名、表名、表别名、变量名)<ul>
<li>数据库名、表名、表的别名、变量名是严格区分大小写的</li>
<li>关键字、函数名、列名(或字段名)、列的别名(字段的别名) 是忽略大小写的。</li>
</ul>
</li>
<li>推荐采用统一的书写规范：<ul>
<li>数据库名、表名、表别名、字段名、字段别名等都小写</li>
<li>SQL 关键字、函数名、绑定变量等都大写</li>
</ul>
</li>
</ul>
<p><strong>注释</strong><br>可以使用如下格式的注释结构</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 单行注释（仅mysql）</span><br><span class="line"><span class="comment">/*多行注释*/</span></span><br><span class="line"><span class="comment">-- 单行注释</span></span><br></pre></td></tr></table></figure>

<p><strong>命名规则</strong></p>
<ul>
<li>数据库、表名不得超过30个字符，变量名限制为29个</li>
<li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li>
<li>数据库名、表名、字段名等对象名中间不要包含空格</li>
<li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li>
<li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使<br>用&#96;（着重号）引起来</li>
<li>保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据<br>类型在一个表里是整数，那在另一个表里可就别变成字符型了</li>
</ul>
<p><strong>标识符命名规则</strong></p>
<ul>
<li>数据库名、表名不得超过30个字符，变量名限制为29个</li>
<li>必须只能包含 A–Z, a–z, 0–9, _共63个字符</li>
<li>数据库名、表名、字段名等对象名中间不要包含空格</li>
<li>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</li>
<li>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96;（着重号）引起来</li>
<li>保持字段名和类型的一致性：在命名字段并为其指定数据类型的时候一定要保证一致性，假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了</li>
</ul>
<h3 id="阿里数据库规范"><a href="#阿里数据库规范" class="headerlink" title="阿里数据库规范"></a>阿里数据库规范</h3><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240804180925.png" alt="阿里规范"></p>
<h2 id="DML-SELECT使用"><a href="#DML-SELECT使用" class="headerlink" title="DML-SELECT使用"></a>DML-SELECT使用</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>dual 伪表：<code>select 1+1 from dual</code></p>
<p>查看全部数据：<code>select * from tableName</code></p>
<p>查询某几列数据：<code>select column1,column2 from tableName</code></p>
<p>去除重复行：<code>select distinct col1 from tableName</code><br>distinct作用与选定的所有行，当某行一样而其他行不一样时不会过滤</p>
<p>列的别名(alias)：<code>select col1,col2 as alias1,alisa2 col3*2 as &quot;alias3&quot;, from tableName</code><br>说明：</p>
<ol>
<li>列的别名应当使用<code>&quot;</code>包裹，当由单个单词组成别名时，可以省略</li>
<li>当一个字段名紧跟其别名时，<code>as</code>可以省略:<code>select last_name name,salary*12 annual_salfrom employees</code></li>
<li>列名不一定要写在一起，可以写几个列名和其别名后再写几个，如上示例，但为方便查看，应当写完所有列名再写别名</li>
<li>别名可以用于order子句但不能用于where子句，因为where子句执行在select子句之前</li>
</ol>
<p>空值null参与运算：结果一定也是null</p>
<p><code>着重号</code>的使用：<br>当表名、列名等字段和关键字相同时，必须为字段添加``着重号</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> `<span class="keyword">order</span>`</span><br></pre></td></tr></table></figure>

<p>查询常数：<code>select &quot;武汉大学&quot; employee_id from tableName</code><br>会在查询结果中添加一列，每一行数据都标注“武汉大学”<br>+———-+————-+<br>| 武汉大学 | employee_id |<br>+———-+————-+<br>| 武汉大学 |         100 |<br>+———-+————-+</p>
<p>显示表结构：<code>describe tableName</code>简写<code>desc tableName</code><br>会显示表中所有字段的信息，包括字段名称，类型，是否为空，默认值，是否为主键外键</p>
<p>where过滤：<code>select * from tableName where name = &#39;King&#39;;</code><br>MySQL在windows下条件不区分大小写,但Oracle等数据库区分<br>where必须在from子句后</p>
<h3 id="语句结构和执行顺序"><a href="#语句结构和执行顺序" class="headerlink" title="语句结构和执行顺序"></a>语句结构和执行顺序</h3><h4 id="select语句结构"><a href="#select语句结构" class="headerlink" title="select语句结构"></a>select语句结构</h4><p>在无子查询的情况下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sql92</span></span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ...,...,....</span><br><span class="line"><span class="keyword">WHERE</span> <span class="comment">-- 多表的连接条件,不可外连接</span></span><br><span class="line"><span class="keyword">AND</span> <span class="comment">-- 不包含组函数的过滤条件</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> <span class="comment">-- 包含组函数的过滤条件</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT ...,...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- sql99</span></span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ... <span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> <span class="comment">-- 多表的连接条件</span></span><br><span class="line">(<span class="keyword">LEFT</span><span class="operator">/</span><span class="keyword">RIGHT</span>)<span class="keyword">JOIN</span> ...</span><br><span class="line"><span class="keyword">ON</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="comment">-- 不包含组函数的过滤条件</span></span><br><span class="line"><span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> <span class="comment">-- 不包含组函数的过滤条件</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> <span class="comment">-- 包含组函数的过滤条件</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT ...,...</span><br></pre></td></tr></table></figure>

<h4 id="SQL语句执行过程"><a href="#SQL语句执行过程" class="headerlink" title="SQL语句执行过程"></a>SQL语句执行过程</h4><p>关键字的书写顺序是不能颠倒的：<br><code>SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT...</code><br><code>SELECT ...FROM ... JOIN ... ON ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... LIMIT ...</code></p>
<p>SELECT 语句的执行顺序（在 MySQL 和 Oracle 中，SELECT 执行顺序基本相同）：<br><code>FROM -&gt; (ON)WHERE -&gt; GROUP BY -&gt; HAVING -&gt; SELECT 的字段 -&gt; DISTINCT -&gt; ORDER BY -&gt; LIMIT</code></p>
<h4 id="SQL-的执行原理"><a href="#SQL-的执行原理" class="headerlink" title="SQL 的执行原理"></a>SQL 的执行原理</h4><p><code>SELECT</code>是先执行<code>FROM</code>这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：</p>
<ol>
<li>首先先通过<code>CROSS JOIN</code>求笛卡尔积，相当于得到虚拟表<code>vt（virtual table）1-1</code>；</li>
<li>通过<code>ON</code>进行筛选，在虚拟表<code>vt1-1</code>的基础上进行筛选，得到虚拟表<code>vt1-2</code>；</li>
<li>添加外部行。如果我们使用的是左连接、右链接或者全连接，就会涉及到外部行，也就是在虚拟表<code>vt1-2</code>的基础上增加外部行，得到虚拟表<code>vt1-3</code>。</li>
<li>如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到是我们的原始数据。</li>
<li>当我们拿到了查询数据表的原始数据，也就是最终的虚拟表<code>vt1</code>，就可以在此基础上再进行<code>WHERE</code>阶段 。在这个阶段中，会根据<code>vt1</code>表的结果进行筛选过滤，得到虚拟表<code>vt2</code>。</li>
<li>然后进入第三步和第四步，也就是<code>GROUP</code>和<code>HAVING</code>阶段 。在这个阶段中，实际上是在虚拟表<code>vt2</code>的基础上进行分组和分组过滤，得到中间的虚拟表<code>vt3</code>和<code>vt4</code>。</li>
<li>当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到<code>SELECT</code>和<code>DISTINCT</code>阶段。首先在<code>SELECT</code>阶段会提取想要的字段，然后在<code>DISTINCT</code>阶段过滤掉重复的行，分别得到中间的虚拟表<code>vt5-1</code>和<code>vt5-2</code></li>
<li>当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是<code>ORDER BY</code>阶段 ，得到虚拟表<code>vt6</code></li>
<li>最后在<code>vt6</code>的基础上，取出指定行的记录，也就是<code>LIMIT</code>阶段 ，得到最终的结果，对应的是虚拟表<code>vt7</code>。</li>
<li>我们在写<code>SELECT</code>语句的时候，不一定存在所有的关键字，相应的阶段就会省略。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> player_id, player_name, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num <span class="comment">-- 顺序 5</span></span><br><span class="line"><span class="keyword">FROM</span> player <span class="keyword">JOIN</span> team <span class="keyword">ON</span> player.team_id <span class="operator">=</span> team.team_id <span class="comment">-- 顺序 1</span></span><br><span class="line"><span class="keyword">WHERE</span> height <span class="operator">&gt;</span> <span class="number">1.80</span> <span class="comment">--  顺序 2</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> player.team_id <span class="comment">-- 顺序 3</span></span><br><span class="line"><span class="keyword">HAVING</span> num <span class="operator">&gt;</span> <span class="number">2</span> <span class="comment">-- 顺序 4</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> num <span class="keyword">DESC</span> <span class="comment">-- 顺序 6</span></span><br><span class="line">LIMIT <span class="number">2</span> <span class="comment">-- 顺序 7</span></span><br></pre></td></tr></table></figure>

<p><strong>非组函数过滤条件写在where比having快的原因</strong><br>where先执行，经过非组函数过滤条件过滤的虚拟表含有的数据更少，使得后续子句执行速度更快！</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符-div-mod"><a href="#算术运算符-div-mod" class="headerlink" title="算术运算符 + - * &#x2F;(div) %(mod)"></a>算术运算符 + - * &#x2F;(div) %(mod)</h4><p>与非数值进行运算时会进行隐式转换，当无法转换时会按0处理<br>SQL中+只表示加法运算，如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">100</span><span class="operator">+</span><span class="string">&#x27;1&#x27;</span>,<span class="number">100</span><span class="operator">+</span><span class="string">&#x27;a&#x27;</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">-- 101,100</span></span><br></pre></td></tr></table></figure>

<p>SQL中除法(<code>/</code>和<code>div</code>效果一样)默认保留四位小数，即使是整型中间的除法也会保留<br>当分母为0时，结果为NULL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">100</span><span class="operator">/</span><span class="number">10</span>,<span class="number">100</span><span class="operator">/</span><span class="number">10.0</span>,<span class="number">100</span><span class="operator">/</span><span class="number">3</span>,<span class="number">100</span> div <span class="number">1</span>,<span class="number">100</span> div <span class="number">0</span> <span class="keyword">from</span> dual;</span><br><span class="line"><span class="comment">-- | 10.0000 |  10.0000 | 33.3333 |       100 |      NULL |</span></span><br></pre></td></tr></table></figure>

<p>取模运算(<code>%</code>和<code>mod</code>都可)：结果符号与被模数符号相同</p>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801103242.png" alt="比较运算符"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801113019.png" alt="比较关键字"></p>
<p>数值与非数值进行运算时会进行隐式转换，当无法转换时会按0处理</p>
<p>字符串和字符串进行比较运算时按ANSI的比较规则进行比较</p>
<p>只要有null参与运算，结果均为null<br><code>select last_name,commission_pct from employees where commission_pct = null;</code><br>改进：使用安全等于或<code>is null</code>关键字：<br><code>select last_name,commission_pct from employees where commission_pct &lt;=&gt; null;</code><br><code>select last_name,commission_pct from employees where commission_pct is null;</code></p>
<p><strong>is null和isnull()</strong><br><code>select last_name,commission_pct from employees where commission_pct is null;</code><br><code>select last_name,commission_pct from employees where  isnull(commission_pct);</code></p>
<p><code>between 条件1 and 条件2</code>包含边界，且条件1必须是较小的</p>
<p><code>LEAST()</code>和<code>GREATEST()</code><br>假设有一个名为 Products 的表，其中有两列 Price1 和 Price2，你想要找出这两个价格中的较小值：<br><code>SELECT ProductID, LEAST(Price1, Price2) AS LowestPrice FROM Products;</code></p>
<p><code>LIKE</code>模糊查询:</p>
<ul>
<li><code>%</code>表示0个或多个不确定字符</li>
<li><code>_</code>表示1个不确定的字符</li>
<li><code>\</code>转移字符<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name <span class="keyword">from</span> employees <span class="keyword">where</span> last_name <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span>; <span class="comment">--包含a的</span></span><br><span class="line"><span class="keyword">select</span> last_name <span class="keyword">from</span> employees <span class="keyword">where</span> last_name <span class="keyword">like</span> <span class="string">&#x27;_e%&#x27;</span>; <span class="comment">--以e为第2个字符的</span></span><br><span class="line"><span class="keyword">select</span> last_name <span class="keyword">from</span> employees <span class="keyword">where</span> last_name <span class="keyword">like</span> <span class="string">&#x27;\_e%&#x27;</span>; <span class="comment">--以_e开头的</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801120940.png" alt="逻辑运算符"></p>
<h4 id="REGEXP、RLIKE-正则表达式匹配字符串"><a href="#REGEXP、RLIKE-正则表达式匹配字符串" class="headerlink" title="REGEXP、RLIKE 正则表达式匹配字符串"></a>REGEXP、RLIKE 正则表达式匹配字符串</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801170016.png" alt="正则表达式"></p>
<ul>
<li><code>^</code>匹配以该字符后面的字符开头的字符串。</li>
<li><code>$</code>匹配以该字符前面的字符结尾的字符串。</li>
<li><code>.</code>匹配任何一个单字符。</li>
<li><code>[...]</code>匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一<br>个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。</li>
<li><code>*</code>匹配零个或多个在它前面的字符。例如，“x*”匹配任何数量的‘x’字符，“[0-9]<em>”匹配任何数量的数字，<br>而“</em>”匹配任何数量的任何字符。</li>
</ul>
<p>等价语句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name <span class="keyword">from</span> employees <span class="keyword">where</span> last_name regexp <span class="string">&#x27;^a&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> last_name <span class="keyword">from</span> employees <span class="keyword">where</span> last_name <span class="keyword">like</span> <span class="string">&#x27;a%&#x27;</span>;</span><br></pre></td></tr></table></figure>


<h4 id="位运算符和运算符优先级"><a href="#位运算符和运算符优先级" class="headerlink" title="位运算符和运算符优先级"></a>位运算符和运算符优先级</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801165938.png" alt="位运算符"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801121258.png" alt="运算符优先级"></p>
<h3 id="排序和分页"><a href="#排序和分页" class="headerlink" title="排序和分页"></a>排序和分页</h3><p>默认排序方式即为数据添加的顺序</p>
<h4 id="ORDER-BY-排序"><a href="#ORDER-BY-排序" class="headerlink" title="ORDER BY 排序"></a>ORDER BY 排序</h4><p>升序(asc):<code>select * from employees order by salary asc;</code>(order by默认排序方法)<br>降序(desc):<code>select * from employees order by salary desc;</code></p>
<p><strong>多列排序</strong>：先按 salary 升序排，salary一样按department_id降序排<br><code>select * from employees order by salary asc,department_id desc;</code></p>
<h4 id="LIMIT-分页"><a href="#LIMIT-分页" class="headerlink" title="LIMIT 分页"></a>LIMIT 分页</h4><p>便于查看，加快加载速度。<br>显示第n页，每页x条记录，则：<code>limit (n-1)*x,x</code><br>示例:<br>查看第1<del>20条记录：起始数据偏移，每页显示的条数<br><code>select last_name name,salary from employees limit 0,20;</code><br>查看第21</del>40条记录<br><code>select last_name name,salary from employees limit 21,20;</code></p>
<p><strong>MySQL8.0新特性-OFFSET关键字</strong><br>查看第21~40条记录<br><code>select last_name name,salary from employees limit 20 offset 21;</code></p>
<p>在MySQL，PostgreSQL，MariaDB和SQLite中使用limit关键字且需要放在select语句最末尾<br>在SQL Server和Access中使用top关键字，无需放到末尾：<br><code>select top 20 last_name ,salary from employees;</code><br>在DB2中，使用fetch first number rows only:<br><code>select last_name,salary from employees fetch first 20 rows only;</code><br>在Oracle中，使用rownum:<br><code>select rownum last_name ,salary from employees where rownum &lt;= 20;</code></p>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><h4 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h4><p><code>select * from table1,table2 where table1.column = table2.column;</code></p>
<ol>
<li>查询时应当尽量指明所有字段所属的表,可以加快查询速度</li>
<li>多表共有字段必须指明所在的表</li>
<li>可以给表取别名（在from子句），此后其他子句是都必须所有表的别名，而不是表的原名<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.employee_id,t2.department_name,t1.department_id </span><br><span class="line"><span class="keyword">from</span> employees t1,departments t2</span><br><span class="line"><span class="keyword">where</span> t1.department_id <span class="operator">=</span> t2.department_id;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>多表查询的父类</strong></p>
<ol>
<li>等值连接和非等值连接<ul>
<li>等值连接：<code>where t1.department_id = t2.department_id</code></li>
<li>非等值连接：<code>where t1.salary between t2.lowest_sal and j.highest_sal</code><br>员工表中含有员工工资，另一表中标注了某一级别工资上下界</li>
</ul>
</li>
<li>自连接和非自连接<ul>
<li>自连接：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.employee_id,t1.last_name,t2.employee_id,t2.last_name </span><br><span class="line"><span class="keyword">from</span> employees t1,employees t2 </span><br><span class="line"><span class="keyword">where</span> t1.manager_id <span class="operator">=</span> t2.employee_id</span><br><span class="line"><span class="comment">-- 查询员工及其管理者的信息，员工及其管理者均在员工表中</span></span><br></pre></td></tr></table></figure></li>
<li>非自连接：</li>
</ul>
</li>
<li>内连接(INNER JOIN 默认)和外连接(OUTER JOIN)</li>
</ol>
<h4 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h4><p>内连接（INNER JOIN）和外连接（OUTER JOIN）是数据库查询中常用的两种连接方式，它们用于将两个或多个表中的数据按照一定的条件进行关联，以形成所需的结果集。</p>
<p>内连接（INNER JOIN）只返回两个表中满足连接条件的行。具体而言，内连接根据指定的条件将两个表中的行进行比较，如果满足条件则将这些行组合成结果集中的一行。<br>特点：</p>
<ol>
<li>结果集：<strong>只包含符合连接条件的行</strong>。</li>
<li>操作方式：通过SELECT语句和FROM子句进行查询操作，连接条件通常在ON子句中指定。</li>
<li>优点：操作简单、效率较高。</li>
<li>缺点：可能会丢失不符合连接条件的数据。</li>
</ol>
<p>外连接（OUTER JOIN）返回两个表中的所有行，并根据连接条件进行匹配。与内连接不同，外连接<strong>不会剔除不符合连接条件的行</strong>，而是将它们保留在结果集中。外连接包括左外连接（LEFT OUTER JOIN）（保存左表不符条件的行）、右外连接（RIGHT OUTER JOIN）（保存右表不符条件的行）和全(满)外连接（FULL OUTER JOIN）（保存两表不符条件的行）。</p>
<p>特点：</p>
<ol>
<li>结果集：包含两个表中的所有行，并将符合连接条件的行进行匹配。对于不符合连接条件的行，外连接会在结果集中保留它们，并在另一张表的相应列中填充NULL值。</li>
<li>操作方式：在FROM子句中使用JOIN关键字和ON子句来定义连接条件，同时指定外连接的类型（左外连接、右外连接或全外连接）。</li>
<li>优点：能够保留更多的数据，特别是在需要分析表之间不完全匹配的数据时非常有用。</li>
<li>缺点：操作相对复杂且效率较低，因为需要处理更多的行和可能的NULL值。</li>
</ol>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sql92内连接不需要特别表明，外连接方法如下，但MySQL不支持</span></span><br><span class="line"><span class="keyword">select</span> last_name,department_name,city</span><br><span class="line"><span class="keyword">from</span> employees t1, departments t2</span><br><span class="line"><span class="keyword">where</span> t1.department_id <span class="operator">=</span> t2.department_id(<span class="operator">+</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- sql99实现内连接 inner join的inner可以省略</span></span><br><span class="line"><span class="keyword">select</span> last_name,department_name,city</span><br><span class="line"><span class="keyword">from</span> employees t1 <span class="keyword">join</span> departments t2</span><br><span class="line"><span class="keyword">on</span> t1.department_id <span class="operator">=</span> t2.department_id </span><br><span class="line"><span class="keyword">join</span> locations t3 <span class="keyword">on</span> t2.location_id <span class="operator">=</span> t3.location_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- sql99实现外连接 left outer join可以省略outer,mysql中不支持满外连接</span></span><br><span class="line"><span class="keyword">select</span> last_name,department_name</span><br><span class="line"><span class="keyword">from</span> employees t1 <span class="keyword">left</span> <span class="keyword">join</span> departments t2</span><br><span class="line"><span class="keyword">on</span> t1.department_id <span class="operator">=</span> t2.department_id </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--mysql中实现满外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br></pre></td></tr></table></figure>

<p><strong>Union &amp; Union all</strong><br>union:返回两个查询的结果集的并集，去除重复记录。<br>union all:返回两个查询的结果集的并集。对于两个结果集的重复部分，不去重。<br>说明：union执行速度比union all慢,多了去重的工作，开发中尽可能使用union all</p>
<ol>
<li><code>UNION</code> 和 <code>UNION ALL</code> 合并的多个 <code>SELECT</code> 查询中，所有查询的列数必须相同，而且每一列的数据类型必须兼容。如果列数或数据类型不一致，SQL 会报错。(即使数据类型不同，但如果可以隐式转换，MySQL 也能处理)</li>
<li><code>ORDER BY</code> 必须在最后一个 <code>SELECT</code> 之后。如果需要对合并后的结果排序，必须在最后一个 <code>SELECT</code> 查询之后使用 <code>ORDER BY</code>，不能在每个 <code>SELECT</code> 查询内部使用 <code>ORDER BY</code>。</li>
<li><code>IMIT</code> 可以在单独的查询中使用。如果你只想限制单个查询的结果数量，可以在每个 <code>SELECT</code> 查询中使用 <code>LIMIT</code>。但是，如果你想限制合并后的结果集的数量，<code>LIMIT</code> 必须在整个 <code>UNION</code> 查询的最后。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240801213549.png" alt="7种表连接"></p>
<p><strong>规范注意</strong></p>
<ol>
<li>超过三表的连接不建议使用join.</li>
<li>显示所有很可能设计满外连接</li>
</ol>
<h4 id="sql99-自然连接"><a href="#sql99-自然连接" class="headerlink" title="sql99 自然连接"></a>sql99 自然连接</h4><p>自然连接：自动基于这些表之间的共同列（即全部具有相同列名的列）来匹配记录，并将匹配到的记录组合在一起，同时消除重复的列。<br>using连接：基于这些表之间的给定的共同列（即给定的具有相同列名的列）来匹配记录，并将匹配到的记录组合在一起，同时消除重复的列。</p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> last_name,department_name</span><br><span class="line"><span class="keyword">from</span> employees t1 <span class="keyword">join</span> departments t2</span><br><span class="line"><span class="keyword">on</span> t1.department_id <span class="operator">=</span> t2.department_id </span><br><span class="line"><span class="keyword">and</span> t1.manager_id <span class="operator">=</span> t2.manager_id </span><br><span class="line"><span class="comment">-- 等价自然连接语句：</span></span><br><span class="line"><span class="keyword">select</span> last_name,department_name</span><br><span class="line"><span class="keyword">from</span> employees t1 <span class="keyword">natural</span> <span class="keyword">join</span> departments t2;</span><br><span class="line"><span class="comment">-- 等价using语句</span></span><br><span class="line"><span class="keyword">select</span> last_name,department_name</span><br><span class="line"><span class="keyword">from</span> employees t1 <span class="keyword">join</span> departments t2</span><br><span class="line"><span class="keyword">using</span>(department_id,manager_id);</span><br></pre></td></tr></table></figure>

<h3 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h3><p>不同DBMS使用的函数有很大不同，且大多不通用，这里以MySQL中的函数为例：<br><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1ScXuOXjtSSfX7g2HPn2xRg">单行函数参考文档</a><br><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1doG4ekN8jhh8TXeks3zWIQ">聚合函数参考文档</a></p>
<h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h4><p>数值型函数，角度弧度转换函数，三角函数，对数和指数，进制转换<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802182716.png" alt="数值型"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802184122.png" alt="角度和弧度"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802184153.png" alt="三角函数"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232700.png" alt="指数和对数"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232738.png" alt="进制的转换"></p>
<p>字符串函数：下标从1开始<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232848.png" alt="字符串函数1"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232924.png" alt="字符串函数2"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802232956.png" alt="字符串函数3"></p>
<p>日期函数<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802233046.png" alt="获取日期和时间"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240802233122.png" alt="日期与时间戳转换"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240803104059.png" alt="获取月份，星期等"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240803104202.png" alt="日期操作函数"><br>还有时间与秒钟转换、计算日期与时间、日期格式化和解析、流程控制、加解密、MySQL信息函数等，参考上述链接</p>
<p><strong>字符串函数</strong></p>
<ul>
<li>字符转换<ul>
<li>UPPER(str): 将字符串转换为大写。</li>
<li>LOWER(str): 将字符串转换为小写。</li>
</ul>
</li>
<li>字符串连接<ul>
<li>CONCAT(str1, str2, …): 连接两个或多个字符串。</li>
<li>CONCAT_WS(separator, str1, str2, …): 使用指定的分隔符连接两个或多个字符串。</li>
</ul>
</li>
<li>字符串长度<ul>
<li>LENGTH(str): 返回字符串的字节长度。</li>
<li>CHAR_LENGTH(str): 返回字符串的字符数，等同于CHARACTER_LENGTH(str)。</li>
</ul>
</li>
<li>字符串截取<ul>
<li>SUBSTR(str, pos, len): 从字符串中pos位置开始截取len长度子串，不填写len截取到末尾，位置从1开始计数。</li>
<li>LEFT(str, len): 返回字符串最左边的len个字符。</li>
<li>RIGHT(str, len): 返回字符串最右边的len个字符。</li>
</ul>
</li>
<li>字符串查找和替换<ul>
<li>INSTR(str, substr): 返回子串substr在字符串str中首次出现的位置。</li>
<li>LOCATE(substr, str, [pos]): 返回子串substr在字符串str中首次出现的位置，可选指定开始位置。</li>
<li>REPLACE(str, from_str, to_str): 将字符串str中的from_str替换为to_str。</li>
</ul>
</li>
<li>字符串填充和修剪<ul>
<li>LPAD(str, len, padstr): 用字符串padstr对str的左边进行填充，直到长度为len。</li>
<li>RPAD(str, len, padstr): 用字符串padstr对str的右边进行填充，直到长度为len。</li>
<li>LTRIM(str): 去除字符串左边的空格。</li>
<li>RTRIM(str): 去除字符串右边的空格。</li>
<li>TRIM(str): 去除字符串两端的空格，TRIM(BOTH ‘x’ FROM str)可以去除两端的指定字符。</li>
</ul>
</li>
</ul>
<p><strong>数值函数</strong></p>
<ul>
<li>基本数学运算<ul>
<li>ABS(x): 返回x的绝对值。</li>
<li>MOD(x, y): 返回x除以y的余数。</li>
</ul>
</li>
<li>四舍五入和取整<ul>
<li>ROUND(x, [d]): 对x进行四舍五入，d为保留的小数位数，省略d则四舍五入到整数。</li>
<li>CEIL(x) 或 CEILING(x): 向上取整，返回不小于x的最小整数。</li>
<li>FLOOR(x): 向下取整，返回不大于x的最大整数。</li>
<li>TRUNCATE(x, d): 截断x，保留d位小数。</li>
</ul>
</li>
<li>其他数值操作<ul>
<li>RAND(): 返回一个0到1之间的随机数。</li>
<li>RAND(N): 返回一个0到1之间的随机数，N作为种子值，相同的N值产生相同的随机数。</li>
</ul>
</li>
</ul>
<p><strong>日期和时间函数</strong></p>
<ul>
<li>当前日期和时间<ul>
<li>NOW(): 返回当前的日期和时间。</li>
<li>CURDATE(): 返回当前的日期（不含时间）。</li>
<li>CURTIME(): 返回当前的时间（不含日期）。</li>
</ul>
</li>
<li>日期和时间操作<ul>
<li>DATE_ADD(date, INTERVAL expr type): 向日期添加指定的时间间隔。</li>
<li>DATE_SUB(date, INTERVAL expr type): 从日期减去指定的时间间隔。</li>
<li>DATEDIFF(expr1, expr2): 返回两个日期之间的天数差，可能为正负(<code>date1 - date2</code>)。</li>
</ul>
</li>
<li>日期和时间的格式化与提取<ul>
<li>DATE_FORMAT(date, format): 将日期格式化为指定的字符串。</li>
<li>STR_TO_DATE(str, format): 将字符串按照指定的格式转换为日期。</li>
<li>YEAR(date): 提取日期的年份。</li>
<li>MONTH(date): 提取日期的月份。</li>
<li>DAY(date): 提取日期的日。</li>
<li>HOUR(time): 提取时间的小时数。</li>
<li>MINUTE(time): 提取时间的分钟数。</li>
<li>SECOND(time): 提取时间的秒数。</li>
</ul>
</li>
</ul>
<p><strong>其他常用函数</strong></p>
<ul>
<li><code>COALESCE(value1, value2, ..., value_n)</code>用于返回参数列表中第一个非空值。</li>
</ul>
<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>聚合函数作用于一组数据，并对一组数据返回一个值。<br>MySQL中聚合函数不可嵌套<br>使用聚合函数时可以不使用<code>group by</code><br>常用聚合函数类型：</p>
<ul>
<li><p>只能用于数值型数据</p>
<ul>
<li><p>平均值AVG()</p>
</li>
<li><p>总和SUM()</p>
</li>
<li><p>方差VARIANCE()；标准差 STDDEV()；</p>
</li>
</ul>
</li>
<li><p>可用于任意数据类型</p>
<ul>
<li><p>最大值MAX()</p>
</li>
<li><p>最小值MIN()</p>
</li>
<li><p>数据总条数COUNT()</p>
</li>
</ul>
</li>
<li><p>可用于字符串型</p>
<ul>
<li><code>GROUP_CONCAT([DISTINCT] expression [ORDER BY ...] [SEPARATOR &#39;separator&#39;])</code> ：用于将分组中的多个值连接成一个字符串，常用于生成包含多个值的列表。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">select</span> <span class="built_in">avg</span>(salary),<span class="built_in">sum</span>(salary),<span class="built_in">max</span>(salary),<span class="built_in">min</span>(salary),<span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> employees;</span><br><span class="line"><span class="comment">-- avg(salary) | sum(salary) | max(salary) | min(salary) | count(*) |</span></span><br><span class="line"><span class="comment">-- 6461.682243 |   691400.00 |    24000.00 |     2100.00 |           107 |</span></span><br></pre></td></tr></table></figure>

<p>count()说明：</p>
<ul>
<li>用count(<em>)，count(1)，count(列名)谁好呢?<br>对于MyISAM引擎的表是没有区别的。这种引擎内部有一计数器在维护着行数。<br>对于Innodb引擎的表用count(</em>),count(1)直接读行数，复杂度是O(n)，因为innodb真的要去数一遍。但好<br>于具体的count(列名)。</li>
<li>能不能使用count(列名)替换count(*)?<br>不要使用 count(列名)来替代 count(*) ， count(*) 是 SQL92 定义的标准统计行数的语法，跟数<br>据库无关，跟 NULL 和非 NULL 无关。</li>
<li>count(*)会统计值为 NULL 的行，而 <strong>count(列名)不会统计此列为 NULL 值的行</strong>。</li>
</ul>
<p><strong>注意</strong>：<br><code>avg(列名) = sum(列名) / count(列名)</code>，因此会自动过滤<code>null</code>值的数据，因此，当数据中存在null值而计算平均值需要考虑为Null的数据时，如计算公司平均奖金，需要考虑无奖金员工，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(commission_pct)<span class="operator">/</span><span class="built_in">count</span>(ifnull(commission_pct,<span class="number">0</span>)) <span class="keyword">as</span> avg_com <span class="keyword">from</span> employees;</span><br></pre></td></tr></table></figure>

<h4 id="结构函数"><a href="#结构函数" class="headerlink" title="结构函数"></a>结构函数</h4><p>只分为单行和聚合，单列出这个只是为了方便查看</p>
<ol>
<li><code>IFNULL(expr1, expr2)</code> 其中，expr1是要判断的表达式，如果expr1为NULL，则返回expr2的值；否则，返回expr1的值。</li>
<li><code>NULLIF()</code> 用于比较两个值，如果它们相等，则返回 <code>NULL</code>，否则返回第一个值。</li>
<li><code>COALESCE()</code> 是一个更通用的函数，它可以接受多个参数，并返回第一个非 <code>NULL</code> 的值。</li>
<li><code>IF(condition, value_if_true, value_if_false)</code> 函数</li>
</ol>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><h4 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h4><p>使用GROUP BY子句将表中的数据分成若干组</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> department_id,<span class="built_in">avg</span>(salary) <span class="keyword">from</span> employees t1 <span class="keyword">group</span> <span class="keyword">by</span> department_id;</span><br></pre></td></tr></table></figure>

<p><strong>with rollup的使用</strong><br>with rollup会针对组函数所得的结果再使用一次组函数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(salary) <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> job_id <span class="keyword">with</span> <span class="keyword">rollup</span>;</span><br><span class="line"><span class="comment">-- 最后会添加一条相当于select sum(salary) from employees;的执行结果的数据</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li><code>select</code>子句中出现的非组函数的字段必须出现在<code>group by</code>子句中，反之不成立</li>
<li><code>where</code>子句必须在<code>from</code>子句后，<code>group by</code>应当在<code>order by</code>前，<code>from</code>后</li>
<li>使用<code>group by</code>子句必须是在<code>select</code>子句中有组函数的前提下</li>
<li>使用<code>with rollup</code>就不能使用<code>order by</code></li>
</ol>
<h4 id="HAVING的使用"><a href="#HAVING的使用" class="headerlink" title="HAVING的使用"></a>HAVING的使用</h4><p>在分组<code>group by</code>后的结果数据中显示符合<code>having</code>条件的分组.<br><strong>如果过滤的条件中包含组函数，就必须写在having子句中，不能写在where子句中</strong></p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> department_id,<span class="built_in">Max</span>(salary) </span><br><span class="line"><span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> department_id <span class="keyword">in</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>) </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> department_id </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">max</span>(salary)<span class="operator">&gt;</span><span class="number">10000</span>;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>使用前提：<code>HAVING</code>不能单独使用，必须要跟<code>GROUP BY</code>一起使用且必须写在<code>GROUP BY</code>子句后。</li>
<li>写在<code>where</code>下的子句也可以写在<code>having</code>下，但会降低运行效率，因此当过滤条件中不包含组函数时，应当写在<code>where</code>子句中 &#x3D;&#x3D;&gt; <code>having</code>适用范围更广，<code>where</code>运行效率更高，</li>
</ol>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p><strong>子查询的基本语法结构：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...,....       </span><br><span class="line"><span class="keyword">FROM</span> ...,...,....</span><br><span class="line"><span class="keyword">WHERE</span> expr operation </span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">SELECT</span> ...,....,...</span><br><span class="line">    <span class="keyword">FROM</span> ...,...,....</span><br><span class="line">    <span class="keyword">WHERE</span> ...</span><br><span class="line">    ....</span><br><span class="line">   )</span><br><span class="line">...</span><br><span class="line"><span class="comment">-- 子查询也可以写在having子句、case-when子句、from子句（需要有别名）等</span></span><br></pre></td></tr></table></figure>


<p>说明：</p>
<ol>
<li>子查询（内查询）在主查询之前一次执行完成。</li>
<li>子查询的结果被主查询（外查询）使用.</li>
<li>子查询要包含在括号内，放在比较条件的右侧</li>
<li>子查询可以放在<code>where</code>子句，<code>having</code>子句，<code>case-when</code>子句的<code>when</code>后</li>
<li>子查询的结果作为表、视图或临时表时<code>必须取别名</code>，其他情况建议取别名</li>
</ol>
<p><strong>子查询的分类</strong></p>
<ol>
<li>从内查询返回结果的条目数：<ul>
<li>单行子查询和多行子查询</li>
<li>单行操作符对应单行子查询，多行操作符对应多行子查询</li>
</ul>
</li>
<li>从内查询是否被执行多次<ul>
<li>相关子查询和不相关子查询，如<ul>
<li>相关子查询：查询工资大于本部门平均工资的员工信息，由于多个部门的存在，内查询需要多次执行</li>
<li>不相关子查询：查询工资大于本公司平均工资的员工信息</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>非法使用子查询</strong></p>
<ol>
<li>使用多行子查询时使用单行的操作符</li>
<li>多行子查询的内查询如果为空会出现<code>Empty set (0.01 sec)</code></li>
</ol>
<h4 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h4><p>单行操作符：<code>=  != &lt; &lt;= &gt;= &gt;</code></p>
<p>示例：查询与141号或174号员工的manager_id和department_id相同的其他员工的employee_id，<br>manager_id，department_id</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法一</span></span><br><span class="line"><span class="keyword">select</span> employee_id,manager_id,department_id </span><br><span class="line"><span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> manager_id <span class="operator">=</span> (<span class="keyword">select</span> manager_id </span><br><span class="line">                    <span class="keyword">from</span> employees </span><br><span class="line">                    <span class="keyword">where</span> employee_id <span class="operator">=</span> <span class="number">141</span>)</span><br><span class="line"><span class="keyword">and</span> department_id <span class="operator">=</span> (<span class="keyword">select</span> department_id </span><br><span class="line">                    <span class="keyword">from</span> employees </span><br><span class="line">                    <span class="keyword">where</span> employee_id <span class="operator">=</span> <span class="number">141</span>);</span><br><span class="line"><span class="comment">-- 方式二</span></span><br><span class="line"><span class="keyword">select</span> employee_id,manager_id,department_id </span><br><span class="line"><span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> (manager_id,department_id) <span class="operator">=</span> (<span class="keyword">select</span> manager_id,department_id </span><br><span class="line">                                    <span class="keyword">from</span> employees </span><br><span class="line">                                    <span class="keyword">where</span> employee_id <span class="operator">=</span> <span class="number">141</span>);</span><br></pre></td></tr></table></figure>

<h4 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h4><p>多行子查询操作符：<code>IN ANY ALL SOME</code><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240804120046.png" alt="多行子查询操作符"></p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- any 查询从事其他工作的 比从事&quot;IT_PROG&quot;工作的 任一个 员工工资低 的员工姓名和工资</span></span><br><span class="line"><span class="keyword">select</span> last_name,salary <span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="keyword">any</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> employees <span class="keyword">where</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- all 查询从事其他工作的 比从事&quot;IT_PROG&quot;工作的 所有 员工工资低 的员工姓名和工资</span></span><br><span class="line"><span class="keyword">select</span> last_name,salary <span class="keyword">from</span> employees </span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="keyword">all</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> employees <span class="keyword">where</span> job_id <span class="operator">=</span> <span class="string">&#x27;IT_PROG&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询平均工资最低的部门id</span></span><br><span class="line"><span class="keyword">select</span> department_id <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> department_id</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(salary) <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">min</span>(avg_sal) </span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(salary) avg_sal <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> department_id) t_avg_sal);</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">select</span> department_id <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> department_id </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(salary) <span class="operator">&lt;=</span> <span class="keyword">all</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(salary) avg_sal <span class="keyword">from</span> employees <span class="keyword">group</span> <span class="keyword">by</span> department_id);</span><br></pre></td></tr></table></figure>

<h4 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h4><p>上述单多行子查询的举例均为不相关子查询<br>如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为<code>关联子查询</code>。相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240804145645.png" alt="相关子查询的执行过程"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询工资大于本部门平均工资的员工的姓名和工资。也可以使用from子查询+多表查询的方法哦</span></span><br><span class="line"><span class="keyword">select</span> last_name,salary,department_id <span class="keyword">from</span> employees e1 <span class="keyword">where</span> salary <span class="operator">&gt;</span> (<span class="keyword">select</span> <span class="built_in">avg</span>(salary) <span class="keyword">from</span> employees e2 <span class="keyword">where</span> department_id <span class="operator">=</span> e1.department_id);</span><br><span class="line"><span class="comment">-- 查询员工的姓名工资并按照department_name排序</span></span><br><span class="line"><span class="keyword">select</span> last_name,salary <span class="keyword">from</span> employees e1 <span class="keyword">order</span> <span class="keyword">by</span>(<span class="keyword">select</span> department_name <span class="keyword">from</span> departments d1 <span class="keyword">where</span> e1.department_id <span class="operator">=</span> d1.department_id) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p><strong>EXISTS 与 NOT EXISTS关键字</strong></p>
<p>关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。</p>
<ol>
<li>如果在子查询中不存在满足条件的行：<ul>
<li>条件返回 FALSE</li>
<li>继续在子查询中查找</li>
</ul>
</li>
<li>如果在子查询中存在满足条件的行：<ul>
<li>不在子查询中继续查找</li>
<li>条件返回 TRUE</li>
<li>NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询管理者的employee_id </span></span><br><span class="line"><span class="keyword">select</span> employee_id,last_name <span class="keyword">from</span> employees <span class="keyword">where</span> employee_id <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> manager_id <span class="keyword">from</span> employees);</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">select</span> employee_id,last_name <span class="keyword">from</span> employees e1 <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees e2 <span class="keyword">where</span> e1.employee_id <span class="operator">=</span> e2.employee_id);</span><br></pre></td></tr></table></figure>

<p>相关查询在数据库表更新删除有很大应用场景<br>自连接比子查询好</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p> MySQL提供了 <code>REGEXP</code> 和 <code>NOT REGEXP</code> 运算符来使用正则表达式进行字符串匹配。</p>
<p><strong>语法：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name REGEXP <span class="string">&#x27;pattern&#x27;</span>;</span><br></pre></td></tr></table></figure>



<p>正则表达式的基本组成部分：</p>
<ul>
<li><p><strong>字符</strong>：普通字符表示自己，如 <code>a</code> 匹配字母 “a”。</p>
</li>
<li><p>元字符</p>
<p>  ：具有特殊意义的字符，如：</p>
<ul>
<li><code>.</code>：匹配任何单个字符。</li>
<li><code>*</code>：匹配前一个字符零次或多次。</li>
<li><code>+</code>：匹配前一个字符一次或多次。</li>
<li><code>?</code>：匹配前一个字符零次或一次。</li>
<li><code>^</code>：匹配字符串的开头。</li>
<li><code>$</code>：匹配字符串的结尾。</li>
<li><code>[]</code>：匹配方括号内的任意字符，如 <code>[abc]</code> 匹配 “a”、”b” 或 “c”。</li>
<li><code>|</code>：逻辑或，如 <code>a|b</code> 匹配 “a” 或 “b”。</li>
</ul>
</li>
</ul>
<p>如一个有效的电子邮件具有前缀名称和域，其中：</p>
<ol>
<li><strong>前缀</strong> 名称是一个字符串，可以包含字母（大写或小写），数字，下划线 <code>&#39;_&#39;</code> ，点 <code>&#39;.&#39;</code> 和&#x2F;或破折号 <code>&#39;-&#39;</code> 。前缀名称 <strong>必须</strong> 以字母开头。</li>
<li><strong>域</strong> 为 <code>&#39;@leetcode.com&#39;</code></li>
</ol>
<p>示例：</p>
<p>一个有效的电子邮件具有前缀名称和域，其中：</p>
<ol>
<li><strong>前缀</strong> 名称是一个字符串，可以包含字母（大写或小写），数字，下划线 <code>&#39;_&#39;</code> ，点 <code>&#39;.&#39;</code> 和&#x2F;或破折号 <code>&#39;-&#39;</code> 。前缀名称 <strong>必须</strong> 以字母开头。</li>
<li><strong>域</strong> 为 <code>&#39;@leetcode.com&#39;</code></li>
</ol>
<p>表达式：<code>&#39;^[a-zA-Z][a-zA-Z0-9\_\.\-]*@leetcode\\.com$&#39;</code>;</p>
<h2 id="DDL-数据库、表的创建、修改和删除"><a href="#DDL-数据库、表的创建、修改和删除" class="headerlink" title="DDL-数据库、表的创建、修改和删除"></a>DDL-数据库、表的创建、修改和删除</h2><p>DDL语句一旦执行不可回滚rollback！执行后必须自动执行commit语句，因此需要慎重操作</p>
<p>MySQL8.0中DDL语句有原子性，若成功则全句成功，若某部分失败全部回滚<br>MySQL5.7没有此原子性，同时删除两个表可能有一个失败一个成功</p>
<h3 id="数据库基本操作"><a href="#数据库基本操作" class="headerlink" title="数据库基本操作"></a>数据库基本操作</h3><p>数据库的创建create和删除drop(慎重！)</p>
<ol>
<li>使用默认字符集创建数据库：<code>create database name;</code></li>
<li>使用指定字符集创建数据库：<code>create database name character set &#39;utf8&#39;;</code></li>
<li>（推荐）创建数据库，同时避免已存在报错：<code>create database if null exists name character set &#39;utf8&#39;;</code></li>
<li>删除数据库：<code>drop database name;</code></li>
<li>（推荐）删除数据库，同时避免不存在报错：<code>drop database if exists name;</code></li>
</ol>
<p>数据库的管理</p>
<ol>
<li>查看当前连接中的数据库：<code>show databases;</code></li>
<li>查看创建数据库时的操作：<code>show create database name;</code></li>
<li>切换数据库：<code>use databases;</code></li>
<li>查看当前数据库含有的表：<code>show tables;</code></li>
<li>查看当前使用的数据库：<code>select database() from dual;</code></li>
<li>查看指定数据库含有的表：<code>show tables from database_name;</code></li>
</ol>
<p>数据库的修改alter（一般不修改）</p>
<ol>
<li>更改数据库字符集：<code>ALTER DATABASE name CHARACTER SET &#39;utf8&#39;;</code> </li>
<li>数据库不可修改名称！！</li>
</ol>
<h3 id="表的创建、修改、删除"><a href="#表的创建、修改、删除" class="headerlink" title="表的创建、修改、删除"></a>表的创建、修改、删除</h3><p>表的创建create和删除drop(慎重)</p>
<ol>
<li>常用建表方法(使用数据库的字符集)：<br><code>CREATE TABLE IF NOT EXISTS table_name( column_name INT, column_name1 VARCHAR(2)...);</code><br>同时可以指定表的字符集，只需要在末尾添加<code>character set &#39;utf8&#39;</code><br>也可以指定字段的字符集，只需要在字段类型后添加<code>character set &#39;utf8&#39;</code><br>同时可以指定表的存储引擎，在character前添加<code>engine=innod</code></li>
<li>基于现有表创建并导入相应数据：<br><code>CREATE TABLE table_name AS SELECT ... FROM ...;</code></li>
<li>删除：<code>drop table if exists table_name;</code></li>
</ol>
<p>表的管理</p>
<ol>
<li>查看表结构: <code>desc table_name;</code></li>
<li>查看创建表的语句：<code>show create table table_name;</code></li>
</ol>
<p>表的修改 alter table</p>
<ol>
<li>添加字段：<ul>
<li>添加到最后一列：<code>alter table table_name add column_name double(10,2);</code> 10位整数2位小数</li>
<li>添加到第一列：<code>alter table table_name add column_name varchar(20) first;</code> </li>
<li>添加到指定位置：<code>alter table table_name add column_name char(10) after column_name_in_table;</code></li>
</ul>
</li>
<li>修改字段：可以修改数据类型，长度、默认值、位置<ul>
<li>修改数据类型：<code>alter table table_name modify column_name char(20);</code></li>
<li>修改默认值： <code>alter table table_name modify column_name char(20) default &#39;aa&#39;;</code></li>
<li>修改位置：<code>ALTER TABLE employees MODIFY mobile VARCHAR(20) AFTER code</code></li>
</ul>
</li>
<li>重命名字段：同时可以修改<br><code>alter table table_name change column_origin_name column_new_name char(20);</code></li>
<li>删除字段：<code>alter table table_name drop column column_name</code></li>
</ol>
<p>表的重命名：</p>
<ol>
<li><code>rename table table_origin_name to table_new_name;</code></li>
<li><code>alter table table_origin_name rename to table_new_name;</code></li>
</ol>
<p>清空表的数据truncate(表的结构保留)(建议使用<code>delete from</code>!)</p>
<ol>
<li><code>truncate table table_name</code></li>
<li>建议：<code>delete from</code></li>
</ol>
<p><strong>truncate table 和 delete from</strong></p>
<ol>
<li>都可以实现对所有数据的删除并保留表结构</li>
<li>不同：<ul>
<li><code>truncate table</code>:一旦执行，数据全部删除且不可回滚</li>
<li><code>delete from</code>:一旦执行，数据可以全部删除，可以设置为能回滚</li>
</ul>
</li>
</ol>
<h2 id="DML-数据的增删改"><a href="#DML-数据的增删改" class="headerlink" title="DML-数据的增删改"></a>DML-数据的增删改</h2><p>DML操作默认情况下，执行以后会自动提交数据</p>
<h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>方式一、逐条数据添加</p>
<ol>
<li>（最推荐）一次添加多条数据，同时指明添加的字段。<strong>未指明字段默认为NULL</strong>(无not null约束时)<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp1(id,birth,salary,`name`) <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;shea&#x27;</span>,<span class="string">&#x27;2003-06-02&#x27;</span>,<span class="number">18000</span>),</span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;Freya&#x27;</span>,<span class="string">&#x27;2001-10-24&#x27;</span>,<span class="number">13000</span>);</span><br></pre></td></tr></table></figure></li>
<li>（推荐）指明添加的字段，无序按照表中声明顺序。<strong>未指明字段默认为NULL</strong>(无not null约束时)<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp1(id,birth,salary,`name`) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;shea&#x27;</span>,<span class="string">&#x27;2003-06-02&#x27;</span>,<span class="number">18000</span>);</span><br></pre></td></tr></table></figure></li>
<li>不指明添加的字段，必须严格按照表中字段声明顺序书写：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;shea&#x27;</span>,<span class="string">&#x27;2003-06-02&#x27;</span>,<span class="number">18000</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>方式二、将查询的结果插入表中<br>注意：</p>
<ol>
<li>查询的字段必须与要添加到的表的字段一一对应</li>
<li>要添加到的表中的字段长度必须不小于查询的字段的长度，否则可能添加失败</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,`name`,salary) <span class="keyword">select</span> employee_id,last_name,salary <span class="keyword">from</span> employees <span class="keyword">where</span> department_id <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>


<h3 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h3><p><strong>更新数据</strong><br>可以实现批量修改数据<br>修改数据可能因为约束导致修改失败<br><code>update ... set ... where...</code><br>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> emp2 <span class="keyword">set</span> hire_date <span class="operator">=</span> curdate() <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">update</span> emp2 <span class="keyword">set</span> hire_date <span class="operator">=</span> curdate(),salary <span class="operator">=</span> <span class="number">14000</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><strong>删除数据</strong><br>删除数据可能因为约束导致删除失败<br><code>delete from ... where ...</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp2 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h3 id="计算列"><a href="#计算列" class="headerlink" title="计算列"></a>计算列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1(</span><br><span class="line">   a <span class="type">INT</span>,</span><br><span class="line">   b <span class="type">INT</span>,</span><br><span class="line">   C <span class="type">INT</span> GENERATED ALWAYS <span class="keyword">AS</span> (a<span class="operator">+</span>b) VIRTUAL <span class="comment">-- 计算列，修改a,b自动更新</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>


<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>数据完整性（Data Integrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。它是防止数据库中<br>存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出的。为了保证数据的完整性，SQL规范以约束的方式对表数据进行额外的条件限制。从以下四个方面考虑：</p>
<ol>
<li>实体完整性（Entity Integrity）：例如，同一个表中，不能存在两条完全相同无法区分的记录</li>
<li>域完整性（Domain Integrity）：例如：年龄范围0-120，性别范围“男&#x2F;女”</li>
<li>引用完整性（Referential Integrity）：例如：员工所在部门，在部门表中要能找到这个部门</li>
<li>用户自定义完整性（User-defined Integrity）：例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍</li>
</ol>
<p>约束是表级的强制规定。</p>
<p><strong>约束的分类</strong></p>
<ol>
<li>根据约束数据列的限制，约束可分为：<ul>
<li>单列约束：每个约束只约束一列</li>
<li>多列约束：每个约束可约束多列数据</li>
</ul>
</li>
<li>根据约束的作用范围，约束可分为：<ul>
<li>列级约束：只能作用在一个列上，跟在列的定义后面</li>
<li>表级约束：可以作用在多个列上，不与列一起，而是单独定义</li>
</ul>
</li>
<li>根据约束起的作用，约束可分为：<ul>
<li>NOT NULL 非空约束，规定某个字段不能为空</li>
<li>UNIQUE 唯一约束，规定某个字段在整个表中是唯一的</li>
<li>PRIMARY KEY 主键(非空且唯一)约束</li>
<li>FOREIGN KEY 外键约束</li>
<li>CHECK 检查约束(MySQL8.0前不支持，可以使用但无效果)</li>
<li>DEFAULT 默认值约束</li>
</ul>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建约束</span></span><br><span class="line"><span class="comment">-- 可以在创建表时规定约束（通过 CREATE TABLE 语句），或者在表创建之后通过 ALTER TABLE 语句规定约束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表拥有的约束</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名称&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="非空约束-NOT-NULL"><a href="#非空约束-NOT-NULL" class="headerlink" title="非空约束 NOT NULL"></a>非空约束 NOT NULL</h3><p>默认情况下，所有的类型的值都可以是NULL，包括INT、FLOAT等数据类型，使用<code>NOT NULL</code>限定某个字段&#x2F;某列的值不允许为空.</p>
<p><strong>特点</strong></p>
<ol>
<li>非空约束只能出现在表对象的列上，只能某个列单独限定非空，不能组合非空</li>
<li>一个表可以有很多列都分别限定了非空</li>
<li>空字符串’’不等于NULL，0也不等于NULL</li>
</ol>
<p><strong>添加非空约束</strong>注意是否存在默认值约束，参见默认值约束章节</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1(id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,last_name <span class="type">varchar</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,email <span class="type">varChar</span>(<span class="number">15</span>));</span><br><span class="line"><span class="comment">-- 修改时添加 当字段中含有NULL值时必须先修改值为非NULL,否则失败</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test1 MODIFY email <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="唯一性约束-UNIQUE"><a href="#唯一性约束-UNIQUE" class="headerlink" title="唯一性约束 UNIQUE"></a>唯一性约束 UNIQUE</h3><p>用来限制某个字段&#x2F;某列的值不能重复。</p>
<p><strong>特点</strong></p>
<ol>
<li>同一个表可以有多个唯一约束。</li>
<li>唯一约束可以是某一个列的值唯一，也可以多个列组合的值唯一。</li>
<li>唯一性约束<strong>允许列值为空</strong>，且可以有多个为空</li>
<li>在创建唯一约束的时候，如果不给唯一约束命名，就默认和列名相同，组合列默认和第一列名字相同。</li>
<li>MySQL会给唯一约束的列上默认创建一个唯一索引。</li>
</ol>
<p><strong>添加唯一性约束</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加</span></span><br><span class="line"><span class="comment">-- 列级约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1(id <span class="type">INT</span> <span class="keyword">UNIQUE</span>,last_name <span class="type">varchar</span>(<span class="number">15</span>),email <span class="type">varChar</span>(<span class="number">15</span>) <span class="keyword">UNIQUE</span>);</span><br><span class="line"><span class="comment">-- 表级约束 </span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test2(id <span class="type">INT</span>,email <span class="type">VARCHAR</span>(<span class="number">15</span>), <span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">UNIQUE</span>(email));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改时添加 当字段中含有相同值时必须先修改值,否则失败</span></span><br><span class="line"><span class="comment">-- 方法1</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test1 MODIFY email <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">UNIQUE</span>;</span><br><span class="line"><span class="comment">-- 方法2</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test1 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">UNIQUE</span>(email);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复合型约束（多列约束）各约束列都一样才不能添加</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test3(id <span class="type">INT</span>,last_name <span class="type">varchar</span>(<span class="number">15</span>),`password` <span class="type">varChar</span>(<span class="number">25</span>) <span class="keyword">CONSTRAINT</span> constraint_name <span class="keyword">UNIQUE</span>(last_name,`password`));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除唯一性约束 通过删除唯一性索引（其名称与约束名称相同）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test1 <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> constraint_name;</span><br></pre></td></tr></table></figure>

<h3 id="主键约束-PRIMARY-KEY"><a href="#主键约束-PRIMARY-KEY" class="headerlink" title="主键约束 PRIMARY KEY"></a>主键约束 PRIMARY KEY</h3><p>非空且唯一，用来唯一标识表中的一行记录。</p>
<p><strong>特点</strong></p>
<ul>
<li>主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值。</li>
<li>一个表最多<strong>只能有一个</strong>主键约束，建立主键约束可以在列级别创建，也可以在表级别上创建。</li>
<li>主键约束对应着表中的一列或者多列（复合主键）</li>
<li>如果是多列组合的复合主键约束，那么这些列都不允许为空值，并且组合的值不允许重复。</li>
<li>MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用。</li>
<li>当创建主键约束时，系统默认会在所在的列或列组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高）。如果删除主键约束了，主键约束对应的索引就自动删除了。</li>
<li>需要注意的一点是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加主键约束</span></span><br><span class="line"><span class="comment">-- 列级约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,`name` <span class="type">VARCHAR</span>(<span class="number">10</span>));</span><br><span class="line"><span class="comment">-- 表级约束-重命名无作用，名字仍是PRIMARY，没必要命名</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1(id <span class="type">INT</span>,`name` <span class="type">VARCHAR</span>(<span class="number">10</span>),CONSTRAIN constrain_name <span class="keyword">PRIMARY</span> KEY(id));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改时添加主键约束 被约束列数据必须非空且唯一</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(id);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp5 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY(`NAME`,pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复合主键约束 各约束列都一样或有某一列为空才不能添加</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test1(id <span class="type">INT</span>,`name` <span class="type">VARCHAR</span>(<span class="number">10</span>),CONSTRAIN constrain_name <span class="keyword">PRIMARY</span> KEY(id,`name`));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除 删除主键约束，不需要指定主键名，因为一个表只有一个主键，删除主键约束后，非空还存</span></span><br><span class="line">在。 </span><br><span class="line"><span class="comment">-- !!实际开发中完全不会进行此操作</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>

<h3 id="自增列-AUTO-INCREMENT"><a href="#自增列-AUTO-INCREMENT" class="headerlink" title="自增列 AUTO_INCREMENT"></a>自增列 AUTO_INCREMENT</h3><p>某个字段的值自增,此字段必须已经是<code>UNIQUE</code> 或 <code>PRIMARY KEY</code><br>开发中一旦向主键作用字段添加自增列声明，在添加数据时就不要添加此列数据了</p>
<p><strong>特点(重要)</strong></p>
<ol>
<li>一个表最多只能有一个自增长列</li>
<li>自增列声明必须紧跟在字段后，不能使用表级约束</li>
<li>当需要产生唯一标识符或顺序值时，可设置自增长</li>
<li>自增长列约束的列必须是键列（主键列，唯一键列）</li>
<li>自增约束的列的数据类型必须是整数类型</li>
<li>如果自增列指定了 0 和 null，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表时添加，必须是字段有主键约束或唯一性约束</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test(id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,`name` <span class="type">VARCHAR</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改时添加，必须是字段有主键约束或唯一性约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test MODIFY id <span class="type">INT</span> AUTO_INCREMENT;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test MODIFY id <span class="type">INT</span>;</span><br></pre></td></tr></table></figure>


<p>MySQL 8.0新特性—自增变量的持久化<br>在MySQL 8.0之前，自增主键AUTO_INCREMENT的值如果大于max(primary key)+1，在MySQL重启后，会重置AUTO_INCREMENT&#x3D;max(primary key)+1，这种现象在某些情况下会导致业务主键冲突或者其他难以发现的问题。<br>在MySQL 5.7系统中，对于自增主键的分配规则，是由InnoDB数据字典内部一个 计数器 来决定的，而该计数器只在 内存中维护 ，并不会持久化到磁盘中。当数据库重启时，该计数器会被初始化。<br>MySQL 8.0将自增主键的计数器持久化到 重做日志 中。每次计数器发生改变，都会将其写入重做日志中。如果数据库重启，InnoDB会根据重做日志中的信息来初始化计数器的内存值</p>
<h3 id="外键约束-FOREIGN-KEY"><a href="#外键约束-FOREIGN-KEY" class="headerlink" title="外键约束 FOREIGN KEY"></a>外键约束 FOREIGN KEY</h3><p>阿里规范 –&gt; 不得使用外键与级联</p>
<p><strong>限定某个表的某个字段的引用完整性.</strong></p>
<ol>
<li>主表的修改和删除数据受约束，不能删除和修改被从表引用的数据</li>
<li>从表的添加和修改数据受约束，不能添加主表引用列没有的数据</li>
<li>在从表上建立外键，要求主表必须存在</li>
<li>删除主表时，要求从表从表先删除，或将从表中外键引用该主表的关系先删除</li>
</ol>
<p><strong>主表被引用列被参考数据不可进行删改操作，从表不可添加主表中被引用列没有的数据</strong><br>主表（父表）：被引用的表，被参考的表<br>从表（子表）：引用别人的表，参考别人的表</p>
<p><strong>特点</strong></p>
<ol>
<li>从表的外键列，必须引用&#x2F;参考主表的主键或唯一约束的列. 为什么？因为被依赖&#x2F;被参考的值必须是唯一的</li>
<li>在创建外键约束时，如果不给外键约束命名，<strong>默认名不是列名，而是自动产生一个外键名</strong>（例如student_ibfk_1;），也可以指定外键约束名。</li>
<li>创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表</li>
<li>删表时，先删从表（或先删除外键约束），再删除主表</li>
<li>当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据</li>
<li>在“从表”中指定外键约束，并且一个表可以建立多个外键约束</li>
<li>从表的外键列与主表被参照的列名字可以不相同，但是数据类型必须一样，逻辑意义一致。如果类型不一样，创建子表时，就会出现错误“ERROR 1005 (HY000): Can’t createtable’database.tablename’(errno: 150)”。例如：都是表示部门编号，都是int类型。</li>
<li>当创建外键约束时，系统默认会在所在的列上建立对应的普通索引。但是索引名是外键的约束名。（根据外键查询效率很高）</li>
<li>删除外键约束后，必须手动删除对应的索引</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建外键约束必须先创建主表</span></span><br><span class="line"><span class="comment">/*主表*/</span><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> departments(d_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,d_name <span class="type">VARCHAR</span>(<span class="number">15</span>));</span><br><span class="line"><span class="comment">/*从表*/</span><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employees(e_id <span class="keyword">IN</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,e_name <span class="type">VARCHAR</span>(<span class="number">15</span>),e_d_id <span class="type">INT</span></span><br><span class="line"><span class="comment">/*外键约束*/</span><span class="keyword">CONSTRAINT</span> con_emp_dep_d_id <span class="keyword">FOREIGN</span> KEY (e_d_id) <span class="keyword">REFERENCES</span> departments(d_id);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 也可在修改表时添加，修改从表</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employees <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> con_emp_dep_d_id <span class="keyword">FOREIGN</span> KEY (e_d_id) <span class="keyword">REFERENCES</span> departments(d_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="comment">-- 第一步先查看约束名和删除外键约束</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名称&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键约束名;</span><br><span class="line"><span class="comment">-- 第二步查看索引名和删除索引。（注意，只能手动删除）</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名称;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> INDEX 索引名;</span><br></pre></td></tr></table></figure>

<p><strong>约束等级</strong></p>
<ol>
<li><code>Cascade</code>：在父表上update&#x2F;delete记录时，同步update&#x2F;delete掉子表的匹配记录</li>
<li><code>Set null</code>：在父表上update&#x2F;delete记录时，将子表上匹配记录的列设为null，但是要注意子表的外键列不能为not null</li>
<li><code>No action</code>：如果子表中有匹配的记录，则不允许对父表对应候选键进行update&#x2F;delete操作</li>
<li><code>Restrict</code>：同no action， 都是立即检查外键约束</li>
<li><code>Set default</code>（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别<br>如果没有指定等级，就相当于Restrict方式。<br>对于外键约束，最好是采用:<code>ON UPDATE CASCADE ON DELETE RESTRICT</code>的方式。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">eid <span class="type">int</span> <span class="keyword">primary</span> key, </span><br><span class="line">ename <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">deptid <span class="type">int</span>, </span><br><span class="line"><span class="keyword">foreign</span> key (deptid) <span class="keyword">references</span> dept(did) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> restrict</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="开发建议"><a href="#开发建议" class="headerlink" title="开发建议"></a>开发建议</h4><p>问题1：如果两个表之间有关系（一对一、一对多），比如：员工表和部门表（一对多），它们之间是否<br>一定要建外键约束？<br>答：不是的</p>
<p>问题2：建和不建外键约束有什么区别？<br>答：建外键约束，你的操作（创建表、删除表、添加、修改、删除）会受到限制，从语法层面受到限制。例如：在员工表中不可能添加一个员工信息，它的部门的值在部门表中找不到。不建外键约束，你的操作（创建表、删除表、添加、修改、删除）不受限制，要保证数据的 引用完整性 ，只能依<code>靠程序员的自觉</code>，或者是<code>在Java程序中进行限定</code>。例如：在员工表中，可以添加一个员工的信息，它的部门指定为一个完全不存在的部门。</p>
<p>问题3：那么建和不建外键约束和查询有没有关系？<br>答：没有</p>
<p>在<code>MySQL</code>里，外键约束是<code>有成本</code>的，需要<code>消耗系统资源</code>。对于<code>大并发的 SQL 操作</code>，有可能会<code>不适合</code>。比如大型网站的中央数据库，可能会 因为外键约束的系统开销而变得非常慢 。所以， MySQL 允许你不使用系统自带的外键约束，在 应用层面 完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层面的附加逻辑，来实现外键约束的功能，确保数据的一致性。</p>
<p><strong>阿里开发规范</strong><br>【强制】<strong>不得使用外键与级联</strong>，一切外键概念必须在应用层解决。</p>
<blockquote>
<p>说明：（概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于 单机低并发 ，不适合 分布式 、高并发集群；级联更新是强阻塞，存在数据库 更新风暴 的风险；外键影响数据库的 插入速度 。</p>
</blockquote>
<h3 id="检查约束-CHECK"><a href="#检查约束-CHECK" class="headerlink" title="检查约束 CHECK"></a>检查约束 CHECK</h3><p>检查某个字段的值是否符号xx要求，一般指的是值的范围（MySQL5.7不支持，MySQL8.0支持）</p>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只能列级约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line">eid <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">ename <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">age <span class="type">int</span> <span class="keyword">check</span> (age<span class="operator">&gt;</span><span class="number">18</span>),</span><br><span class="line">gender <span class="type">char</span> <span class="keyword">check</span> (gender <span class="keyword">in</span> (<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;女&#x27;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="默认值约束-DEFAULT"><a href="#默认值约束-DEFAULT" class="headerlink" title="默认值约束 DEFAULT"></a>默认值约束 DEFAULT</h3><p>给某个字段&#x2F;某列指定默认值，一旦设置默认值，在插入数据时，如果此字段没有显式赋值，则赋值为默认值。<br>但<strong>默认值约束一般不在唯一键和主键列上加</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表时添加默认值约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">primary</span> key,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key,</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 修改时添加</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">default</span> 默认值;</span><br><span class="line"><span class="comment">--如果这个字段原来有非空约束，你还保留非空约束，那么在加默认值约束时，还得保留非空约束，否则非空约束就被删除了</span></span><br><span class="line"><span class="comment">--同理，在给某个字段加非空约束也一样，如果这个字段原来有默认值约束，你想保留，也要在modify语句中保留默认值约束，否则就删除了</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">default</span> 默认值 <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 ;#删除默认值约束，也不保留非空约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span>; #删除默认值约束，保留非空约束</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>为什么建表时，加 not null default ‘’ 或 default 0<br>答：不想让表中出现null值。</li>
<li>为什么不想要 null 的值<ol>
<li>不好比较。null是一种特殊值，比较时只能用专门的is null 和 is not null来比较。碰到运算符，通常返回null。</li>
<li>效率不高。影响提高索引效果。因此，我们往往在建表时 not null default ‘’ 或 default 0</li>
</ol>
</li>
<li>带AUTO_INCREMENT约束的字段值是从1开始的吗？<br>在MySQL中，默认AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT）的时候，还可以指定第一条插入记录的自增字段的值，这样新插入的记录的自增字段值从初始值开始递增，如在表中插入第一条记录，同时指定id值为5，则以后插入的记录的id值就会从6开始往上增加。添加主键约束时，往往需要设置字段自动增加属性。</li>
<li>并不是每个表都可以任意选择存储引擎？<br>外键约束（FOREIGN KEY）不能跨引擎使用。<br>MySQL支持多种存储引擎，每一个表都可以指定一个不同的存储引擎，需要注意的是：外键约束是用来保证数据的参照完整性的，如果表之间需要关联外键，却指定了不同的存储引擎，那么这些表之间是不能创建外键约束的。所以说，存储引擎的选择也不完全是随意的</li>
</ol>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><strong>视图</strong></p>
<ul>
<li>视图是一种<code>虚拟表</code>，本身是<code>不具有数据</code>的，占用很少的内存空间，它是<code>SQL</code>中的一个重要概念。实际每次都查看视图都会执行视图创建语句</li>
<li>视图建立在已有表的基础上,视图赖以建立的这些表称为基表。</li>
<li>视图的创建和删除只影响视图本身，不影响对应的基表。但是当对视图中的数据进行增加、删除和修改操作时，数据表中的数据会相应地发生变化，反之亦然。</li>
<li>向视图提供数据内容的语句为<code>SELECT</code>语句, 可以将视图理解为存储起来的<code>SELECT</code>语句</li>
<li>在数据库中，视图不会保存数据，数据真正保存在数据表中。</li>
<li>视图，是向用户提供基表数据的另一种表现形式。通常情况下，小型项目的数据库可以不使用视图，但是在大型项目中，以及数据表比较复杂的情况下，视图的价值就凸显出来了，它可以帮助我们把经常查询的结果集放到虚拟表中，提升使用效率。理解和使用起来都非常方便。</li>
</ul>
<p><strong>优点</strong><br>视图操作简单，可以减少数据冗余，从而简化查询；控制数据的访问，提高数据安全；适应灵活多变的需求；能够分解复杂的查询逻辑。<br><strong>不足</strong><br>如果我们在实际数据表的基础上创建了视图，那么，如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。因为创建视图的 SQL 查询可能会对字段重命名，也可能包含复杂的逻辑，这些都会增加维护的成本</p>
<h3 id="视图的创建、查看、修改和删除"><a href="#视图的创建、查看、修改和删除" class="headerlink" title="视图的创建、查看、修改和删除"></a>视图的创建、查看、修改和删除</h3><p><strong>视图的创建</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建视图-</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> <span class="keyword">select</span>查询语句</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建单表视图 </span></span><br><span class="line"><span class="comment">-- 方式一 视图字段名和基表字段名一致</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> <span class="keyword">SELECT</span> COLUMNS <span class="keyword">FROM</span> table_name (<span class="keyword">WHERE</span> ...);</span><br><span class="line"><span class="comment">-- 方式二 自定义的字段名,个数必须与select中字段数相同</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name(column_names) <span class="keyword">AS</span> <span class="keyword">SELECT</span> columns <span class="keyword">FROM</span> table_name (<span class="keyword">WHERE</span> ...);</span><br><span class="line"><span class="comment">-- 方式三 聚合函数等操作的结果转为视图字段，实际每次都查看视图都会执行视图创建语句，示例</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name(id,avg_sal) <span class="keyword">AS</span> <span class="keyword">SELECT</span> id <span class="built_in">avg</span>(salary) <span class="keyword">FROM</span> table_name (<span class="keyword">WHERE</span> ...);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 针对多表时即将select语句改为多表查询的语句</span></span><br><span class="line"><span class="comment">-- 同时还可以针对视图创建视图，将视图作为表代入select语句查询即可</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>查看视图</strong>和查看表一样</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看视图对象</span></span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="comment">-- 查看视图结构</span></span><br><span class="line"><span class="keyword">DESC</span> view_name;</span><br><span class="line"><span class="comment">-- 查看视图的属性信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;view_name&#x27;</span></span><br><span class="line"><span class="comment">-- 查看视图的详细定义信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name;</span><br></pre></td></tr></table></figure>

<p><strong>修改视图</strong>类似表的修改</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方法1 create or replace view</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> view_name(column_names`可省`)<span class="keyword">AS</span> `新`<span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="comment">-- 方法2 alter view</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span> <span class="keyword">SELECT</span> ...</span><br></pre></td></tr></table></figure>

<p><strong>删除视图</strong> 只是删除视图的定义，并不会删除基表的数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除视图必须先删除其子视图</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IF <span class="keyword">EXISTS</span> view_names;</span><br></pre></td></tr></table></figure>


<h3 id="视图数据的更新"><a href="#视图数据的更新" class="headerlink" title="视图数据的更新"></a>视图数据的更新</h3><p><strong>增删改视图数据都会影响基表，不建议在视图上进行此操作</strong><br>要使视图可更新，视图中的行和底层基本表中的行之间必须存在 一对一 的关系。更新方法同表的数据的更新</p>
<p><strong>不可更新视图</strong></p>
<ol>
<li>在定义视图的时候<code>指定了“ALGORITHM = TEMPTABLE”</code>，视图将<code>不支持INSERT和DELETE</code>操作；</li>
<li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图<code>将不支持INSERT</code>操作；</li>
<li>在定义视图的SELECT语句中<code>使用了JOIN联合查询</code> ，视图将<code>不支持INSERT和DELETE</code>操作；</li>
<li>在定义视图的SELECT语句后的字段列表中<code>使用了数学表达式</code>或<code>子查询</code> ，视图将<code>不支持INSERT</code>，也<code>不支持UPDATE</code>使用了数学表达式、子查询的字段值；</li>
<li>在定义视图的SELECT语句后的字段列表中<code>使用DISTINCT、聚合函数、GROUP BY、HAVING、UNION等</code>，视图将<code>不支持INSERT、UPDATE、DELETE</code>；</li>
<li>在定义视图的SELECT语句中<code>包含了子查询</code>，而子查询中引用了FROM后面的表，视图将<code>不支持INSERT、UPDATE、DELETE；</code></li>
<li>视图定义基于一个<code>不可更新视图</code> ；</li>
<li>常量视图。</li>
</ol>
<h2 id="存储过程和存储函数"><a href="#存储过程和存储函数" class="headerlink" title="存储过程和存储函数"></a>存储过程和存储函数</h2><p>存储函数和存储过程对比：</p>
<p>|名称|关键字|调用语法|返回值|应用场景<br>|—|————-|————–|—–|<br>|存储过程|PROCEDURE|CALL 存储过程()|理解为有0个或多个|一般用于更新|<br>|存储函数|FUNCTION|SELECT 函数()|只能是一个|一般用于查询结果为一个值并返回时|</p>
<p>此外，存储函数可以放在查询语句中使用，存储过程不行。反之，存储过程的功能更加强大，包括能够<br>执行对表的操作（比如创建表，删除表等）和事务操作，这些功能是存储函数不具备的</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>含义：存储过程的英文是<code>Stored Procedure</code>。它的思想很简单，就是一组经过<code>预先编译</code>的SQL语句的封装。</p>
<p>执行过程：存储过程预先存储在MySQL服务器上，需要执行的时候，客户端只需要向服务器端发出调用存储过程的命令，服务器端就可以把预先存储好的这一系列 SQL 语句全部执行。</p>
<p><strong>好处：</strong></p>
<ol>
<li>简化操作，提高了sql语句的重用性，减少了开发程序员的压力 </li>
<li>减少操作过程中的失误，提高效率</li>
<li>减少网络传输量（客户端不需要把所有的 SQL 语句通过网络发给服务器） </li>
<li>减少了 SQL 语句暴露在网上的风险，也提高了数据查询的安全性</li>
</ol>
<p><strong>和视图、函数的对比：</strong><br>它和视图有着同样的优点，清晰、安全，还可以减少网络传输量。不过它和视图不同，视图是 虚拟表 ，通常不对底层数据表直接操作，而存储过程是程序化的 SQL，可以 直接操作底层数据表 ，相比于面向集合的操作方式，能够实现一些更复杂的数据处理。一旦存储过程被创建出来，使用它就像使用函数一样简单，我们直接通过调用存储过程名即可。相较于函数，存储过程是 没有返回值 的。</p>
<p><strong>分类</strong><br>存储过程的参数类型可以是IN、OUT和INOUT。根据这点分类如下：<br>1、没有参数（无参数无返回）<br>2、仅仅带 IN 类型（有参数无返回）<br>3、仅仅带 OUT 类型（无参数有返回）<br>4、既带 IN 又带 OUT（有参数有返回）<br>5、带 INOUT（有参数有返回）<br>注意：IN、OUT、INOUT 都可以在一个存储过程中带多个</p>
<h3 id="存储过程的创建"><a href="#存储过程的创建" class="headerlink" title="存储过程的创建"></a>存储过程的创建</h3><p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">存储过程体</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p>说明：<br>说明：</p>
<ol>
<li>参数前面的符号的意思</li>
</ol>
<ul>
<li>IN：当前参数为输入参数，也就是表示入参；存储过程只是读取这个参数的值。如果没有定义参数种类，默认就是IN，表示输入参数。</li>
<li>OUT：当前参数为输出参数，也就是表示出参；执行完成之后，调用这个存储过程的客户端或者应用程序就可以读取这个参数返回的值了。</li>
<li>INOUT：当前参数既可以为输入参数，也可以为输出参数</li>
</ul>
<ol start="2">
<li>形参类型可以是 MySQL数据库中的任意类型。</li>
<li>characteristics 表示创建存储过程时指定的对存储过程的约束条件，其取值信息如下，含义使用时查询<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line"><span class="operator">|</span> [<span class="keyword">NOT</span>] <span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="operator">|</span> &#123; <span class="keyword">CONTAINS</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">NO</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="operator">|</span> <span class="keyword">MODIFIES</span> <span class="keyword">SQL</span> DATA &#125;</span><br><span class="line"><span class="operator">|</span> <span class="keyword">SQL</span> SECURITY &#123; DEFINER <span class="operator">|</span> INVOKER &#125;</span><br><span class="line"><span class="operator">|</span> COMMENT <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li>存储过程体中可以有多条 SQL 语句，如果仅仅一条SQL 语句，则可以省略 BEGIN 和 END</li>
<li>需要设置新的结束标记<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER 新的结束标记</span><br></pre></td></tr></table></figure></li>
</ol>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建过程查看employee表的所有数据</span></span><br><span class="line">DELIMITER $ <span class="comment">--使用$作为存储过程的结束符</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> select_data_emp()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ; <span class="comment">--恢复;作为结束符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建过程查看employee表某个人工资</span></span><br><span class="line">DELIMITER $ <span class="comment">--使用$作为存储过程的结束符</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> select_salary_emp(<span class="keyword">IN</span> i_name <span class="type">varchar</span>(<span class="number">20</span>),<span class="keyword">OUT</span> o_salary <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)) </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> o_salary <span class="keyword">FROM</span> employee <span class="keyword">where</span> last_name <span class="operator">=</span> i_name;</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line">DELIMITER ; <span class="comment">--恢复;作为结束符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--使用</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@i_name</span> <span class="operator">=</span> <span class="string">&#x27;abel&#x27;</span>;</span><br><span class="line"><span class="keyword">CALL</span> select_salary_emp(<span class="variable">@i_name</span>,<span class="variable">@o_salary</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@o_salary</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询领导姓名</span></span><br><span class="line">DELIMITER $ <span class="comment">--使用$作为存储过程的结束符</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> select_manager_emp(<span class="keyword">INOUT</span> m_name <span class="type">VARCHAR</span>(<span class="number">25</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">SELECT</span> last_name <span class="keyword">INTO</span> m_name <span class="keyword">FROM</span> employee <span class="keyword">where</span> employee_id <span class="operator">=</span> (</span><br><span class="line">      <span class="keyword">SELECT</span> manager_id <span class="keyword">From</span> employee <span class="keyword">WHERE</span> last_name <span class="operator">=</span> m_name;</span><br><span class="line">   );</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line">DELIMITER ; <span class="comment">--恢复;作为结束符</span></span><br></pre></td></tr></table></figure>

<h3 id="存储函数的使用"><a href="#存储函数的使用" class="headerlink" title="存储函数的使用"></a>存储函数的使用</h3><p><strong>语法格式</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> 函数名(参数名 参数类型,...)</span><br><span class="line"><span class="keyword">RETURNS</span> 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">函数体 #函数体中肯定有 <span class="keyword">RETURN</span> 语句</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ol>
<li>参数列表：指定参数为IN、OUT或INOUT只对PROCEDURE是合法的，FUNCTION中总是默认为IN参数。</li>
<li>RETURNS type 语句表示函数返回数据的类型；RETURNS子句只能对FUNCTION做指定，对函数而言这是<code>强制</code>的。它用来指定函数的返回类型，而且函数体必须包含一个 RETURN value 语句。</li>
<li>characteristic 创建函数时指定的对函数的约束。取值与创建存储过程时相同，这里不再赘述。</li>
<li>函数体也可以用BEGIN…END来表示SQL代码的开始和结束。如果函数体只有一条语句，也可以省略BEGIN…END</li>
</ol>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询id对应email</span></span><br><span class="line">DELIMITER $ <span class="comment">--使用$作为存储过程的结束符</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> email_by_id(emp_id <span class="type">INT</span>) <span class="keyword">RETURNS</span> <span class="type">VARCHAR</span>(<span class="number">25</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">RETURN</span> (<span class="keyword">SELECT</span> email <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id);</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line">DELIMITER ; <span class="comment">--恢复;作为结束符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--调用</span></span><br><span class="line"><span class="keyword">select</span> email_by_id(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><br>若在创建存储函数中报错“ you might want to use the less safelog_bin_trust_function_creators variable ”，有两种处理方法：</p>
<ul>
<li>方式1：<code>RETURNS 类型</code>后加上必要的函数特性<code>[NOT] DETERMINISTIC</code>和<code>&#123;CONTAINS SQL | NO SQL | READS SQL DATA |MODIFIES SQL DATA&#125;</code></li>
<li>方式2： <code>SET GLOBAL log_bin_trust_function_creators = 1</code>;</li>
</ul>
<h3 id="存储过程和存储函数的查看修改删除"><a href="#存储过程和存储函数的查看修改删除" class="headerlink" title="存储过程和存储函数的查看修改删除"></a>存储过程和存储函数的查看修改删除</h3><p><strong>查看</strong></p>
<ol>
<li>使用SHOW CREATE语句查看存储过程和函数的创建信息<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程名或函数名</span><br></pre></td></tr></table></figure></li>
<li>使用SHOW STATUS语句查看存储过程和函数的状态信息<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; STATUS [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>]</span><br><span class="line"><span class="comment">-- [LIKE &#x27;pattern&#x27;]：匹配存储过程或函数的名称，可以省略。当省略不写时，会列出MySQL数据库中存在的所有存储过程或函数的信息。</span></span><br></pre></td></tr></table></figure>
这个语句返回子程序的特征，如数据库、名字、类型、创建者及创建和修改日期。</li>
<li>从information_schema.Routines表中查看存储过程和函数的信息<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.Routines <span class="keyword">WHERE</span> ROUTINE_NAME<span class="operator">=</span><span class="string">&#x27;存储过程或函数的名&#x27;</span> [<span class="keyword">AND</span> ROUTINE_TYPE <span class="operator">=</span> &#123;<span class="string">&#x27;PROCEDURE|FUNCTION&#x27;</span>&#125;]</span><br><span class="line"><span class="comment">-- PROCEDURE|FUNCTION必须使用大写，存储过程和存储函数重名时必须有此</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>修改</strong><br>修改存储过程或函数，不影响存储过程或函数功能，只是修改相关特性。使用ALTER语句实现。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程或函数的名 [characteristic ...]</span><br><span class="line"><span class="comment">-- characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</span></span><br><span class="line">&#123; <span class="keyword">CONTAINS</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">NO</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="operator">|</span> <span class="keyword">MODIFIES</span> <span class="keyword">SQL</span> DATA &#125;</span><br><span class="line"><span class="operator">|</span> <span class="keyword">SQL</span> SECURITY &#123; DEFINER <span class="operator">|</span> INVOKER &#125;</span><br><span class="line"><span class="operator">|</span> COMMENT <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; [IF <span class="keyword">EXISTS</span>] 存储过程或函数的名</span><br></pre></td></tr></table></figure>

<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><p>对于存储过程和存储函数的使用，一直都存在着很多争议，比如有些公司对于大型项目要求使用存储过程和函数，而有些公司在手册中明确禁止使用存储过程和函数。</p>
<p><strong>阿里开发规范</strong></p>
<ul>
<li>【强制】禁止使用存储过程和函数，存储过程和函数难以调试和扩展，更没有移植性。</li>
</ul>
<p><strong>优点</strong></p>
<ol>
<li>存储过程和函数可以一次编译多次使用。存储过程和函数只在创建时进行编译，之后的使用都不需要重新编译，这就提升了 SQL 的执行效率。</li>
<li>可以减少开发工作量。将代码 封装 成模块，实际上是编程的核心思想之一，这样可以把复杂的问题拆解成不同的模块，然后模块之间可以 重复使用 ，在减少开发工作量的同时，还能保证代码的结构清晰。</li>
<li>存储过程和函数的安全性强。我们在设定存储过程和函数的时候可以 设置对用户的使用权限 ，这样就和视图一样具有较强的安全性。</li>
<li>可以减少网络传输量。因为代码封装到存储过程和函数中，每次使用只需要调用存储过程和函数即可，这样就减少了网络传输量。</li>
<li>良好的封装性。在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程和函数，只需要 连接一次即可 。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><code>可移植性差</code>。存储过程和函数不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</li>
<li><code>调试困难</code>。只有少数 DBMS 支持存储过程和函数的调试。对于复杂的存储过程和函数来说，开发和维护都不容易。虽然也有一些第三方工具可以对存储过程和函数进行调试，但要收费。</li>
<li>存储过程和函数的<code>版本管理很困难</code>。比如数据表索引发生变化了，可能会导致存储过程和函数失效。我们在开发软件的时候往往需要进行版本管理，但是存储过程和函数本身没有版本控制，版本迭代更新的时候很麻烦。</li>
<li>它<code>不适合高并发</code>的场景。高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程和函数会变得难以维护， 增加数据库的压力 ，显然就不适用了。。</li>
</ol>
<h2 id="变量、流程控制和游标"><a href="#变量、流程控制和游标" class="headerlink" title="变量、流程控制和游标"></a>变量、流程控制和游标</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p>系统变量由系统定义，不是用户定义，属于<code>服务器</code>层面。启动MySQL服务，生成MySQL服务实例期间，MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。这些系统变量的值要么是<code>编译MySQL时参数</code>的默认值，要么是<code>配置文件</code>（例如my.ini等）中的参数值。大家可以通过网址<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html">MySQL文档的系统变量</a>查看。<br>系统变量分为全局系统变量（需要添加<code>global</code>关键字）以及会话系统变量（需要添加<code>session</code>关键字），有时也把全局系统变量简称为全局变量，有时也把会话系统变量称为local变量。如果不写，默认会话级别。静态变量（在<code>MySQL</code>服务实例运行期间它们的值不能使用<code>set</code>动态修改）属于特殊的全局系统变量。<br>每一个MySQL客户机成功连接MySQL服务器后，都会产生与之对应的会话。会话期间，MySQL服务实例会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。如下图：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240807155020.png" alt="系统变量"></p>
<ul>
<li>全局系统变量针对于所有会话（连接）有效，但<code>不能跨重启</code></li>
<li>会话系统变量仅针对于当前会话（连接）有效。会话期间，当前会话对某个会话系统变量值的修改，不会影响其他会话同一个会话系统变量的值。</li>
<li>会话1对某个全局系统变量值的修改会导致会话2中同一个全局系统变量值的修改。</li>
</ul>
<p><strong>查看系统变量</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看系统变量</span></span><br><span class="line"><span class="comment">-- 查看所有全局变量</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES;</span><br><span class="line"><span class="comment">-- 查看所有会话变量</span></span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;</span><br><span class="line"><span class="comment">-- 查看满足条件的部分系统变量。</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看满足条件的部分会话变量</span></span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看指定系统变量 </span></span><br><span class="line"><span class="comment">/*MySQL 中的系统变量以 两个“@” 开头，其中“@@global”仅用于标记全局系统变量，“@@session”仅用于标记会话系统变量。“@@”首先标记会话系统变量，如果会话系统变量不存在，则标记全局系统变量。*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看指定的系统变量的值</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.变量名;</span><br><span class="line"><span class="comment">-- 查看指定的会话变量的值</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@session</span>.变量名;</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">SELECT</span> @@变量名</span><br></pre></td></tr></table></figure>

<p><strong>修改系统变量</strong></p>
<p>方式1：修改MySQL 配置文件 ，继而修改MySQL系统变量的值（该方法需要重启MySQL服务）<br>方式2：在MySQL服务运行期间，使用“set”命令重新设置系统变量的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 为某个系统变量赋值 两种方法 只针对当前数据库实例有效，一旦重启服务将会失效</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@global</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> 变量名<span class="operator">=</span>变量值;</span><br><span class="line"><span class="comment">-- MySQL8.0 下可以持久更改全局变量</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST <span class="keyword">global</span> 变量名 <span class="operator">=</span> 变量值</span><br><span class="line"><span class="comment">-- 配置保存到数据目录下的 mysqld-auto.cnf 文件中，下次启动时会读取该文件，用其中的配置来覆盖默认的配置文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 为某个会话变量赋值 两种方法 只针对当前会话有效，重新建立的会话还是默认值</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line"><span class="keyword">SET</span> SESSION 变量名<span class="operator">=</span>变量值;</span><br></pre></td></tr></table></figure>


<h4 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h4><p>用户变量是用户自己定义的，根据作用范围不同，又分为<code>会话用户变量</code>和<code>局部变量</code>。作为<code>MySQL</code>编码规范，MySQL中的会话用户变量以一个<code>@</code>开头。</p>
<ul>
<li>会话用户变量：作用域和会话变量一样，只对<code>当前连接</code>会话有效。</li>
<li>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在<code>存储过程和函数</code>中使用。</li>
</ul>
<p><strong>会话用户变量的定义和使用</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义</span></span><br><span class="line"><span class="comment">-- 方式1：“=”或“:=”</span></span><br><span class="line"><span class="keyword">SET</span> @用户变量 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> @用户变量 :<span class="operator">=</span> 值;</span><br><span class="line"><span class="comment">-- 方式2：“:=” 或 INTO关键字</span></span><br><span class="line"><span class="keyword">SELECT</span> @用户变量 :<span class="operator">=</span> 表达式 [<span class="keyword">FROM</span> 等子句]; <span class="comment">-- SELECT @count:= COUNT(*) FROM employees;</span></span><br><span class="line"><span class="keyword">SELECT</span> 表达式 <span class="keyword">INTO</span> @用户变量 [<span class="keyword">FROM</span> 等子句] <span class="comment">-- SELECT COUNT(*) into @count FROM employees;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看</span></span><br><span class="line"><span class="keyword">SELECT</span> @用户变量</span><br></pre></td></tr></table></figure>


<p><strong>局部变量的定义和使用</strong></p>
<p>定义：可以使用<code>DECLARE</code>语句定义一个局部变量<br>作用域：仅仅在定义它的<code>BEGIN...END</code>中有效，<code>只能在存储过程或存储函数中使用</code><br>位置：只能放在<code>BEGIN...END</code>中，而且只能放在第一句</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- 声明局部变量</span></span><br><span class="line"><span class="keyword">DECLARE</span> 变量名<span class="number">1</span> 变量数据类型 [<span class="keyword">DEFAULT</span> 变量默认值];</span><br><span class="line"><span class="keyword">DECLARE</span> 变量名<span class="number">2</span>,变量名<span class="number">3</span>,... 变量数据类型 [<span class="keyword">DEFAULT</span> 变量默认值];</span><br><span class="line"><span class="comment">-- 为局部变量赋值</span></span><br><span class="line"><span class="keyword">SET</span> 变量名<span class="number">1</span> <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> 变量名<span class="number">2</span>:<span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">SELECT</span> 值 <span class="keyword">INTO</span> 变量名<span class="number">3</span> [<span class="keyword">FROM</span> 子句];</span><br><span class="line"><span class="comment">-- 查看局部变量的值</span></span><br><span class="line"><span class="keyword">SELECT</span> 变量<span class="number">1</span>,变量<span class="number">2</span>,变量<span class="number">3</span>;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>

<p><strong>局部变量和会话用户变量</strong></p>
<table>
<thead>
<tr>
<th>作用域</th>
<th>定义位置</th>
<th>语法</th>
</tr>
</thead>
<tbody><tr>
<td>会话用户变量</td>
<td>当前会话</td>
<td>会话的任何地方，加@符号，不用指定类型</td>
</tr>
<tr>
<td>局部变量</td>
<td>定义它的BEGIN END中</td>
<td>BEGIN END的第一句话，一般不用加@，需要指定类型</td>
</tr>
</tbody></table>
<h3 id="定义条件与处理程序"><a href="#定义条件与处理程序" class="headerlink" title="定义条件与处理程序"></a>定义条件与处理程序</h3><p>(类似于异常处理，定义条件即异常，处理程序即异常的处理)</p>
<p><code>定义条件</code>是事先定义程序执行过程中可能遇到的问题，<code>处理程序</code>定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。这样可以增强存储程序处理问题的能力，避免程序异常停止运行。<br>说明：定义条件和处理程序在存储过程、存储函数中都是支持的。</p>
<h4 id="定义条件"><a href="#定义条件" class="headerlink" title="定义条件"></a>定义条件</h4><p>定义条件就是给MySQL中的错误码命名，这有助于存储的程序代码更清晰。它将一个<code>错误名字</code>和<code>指定的错误条件</code>关联起来。这个名字可以随后被用在定义处理程序的<code>DECLARE HANDLER</code>语句中</p>
<p>错误码的说明：<br><code>MySQL_error_code</code>和<code>sqlstate_value</code>都可以表示MySQL的错误。</p>
<ul>
<li><code>MySQL_error_code</code>是数值类型错误代码。</li>
<li><code>sqlstate_value</code>是长度为5的字符串类型错误代码。<br>例如，在ERROR 1418 (HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。</li>
</ul>
<p><strong>定义条件示例</strong>，使用<code>declare</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用MySQL_error_code</span></span><br><span class="line"><span class="keyword">DECLARE</span> Field_Not_Be_NULL <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="number">1048</span>;</span><br><span class="line"><span class="comment">-- 使用sqlstate_value</span></span><br><span class="line"><span class="keyword">DECLARE</span> Field_Not_Be_NULL <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;23000&#x27;</span>;</span><br></pre></td></tr></table></figure>


<h4 id="定义处理程序"><a href="#定义处理程序" class="headerlink" title="定义处理程序"></a>定义处理程序</h4><p><code>DECLARE 处理方式 HANDLER FOR 错误类型 处理语句</code></p>
<ul>
<li>处理方式：处理方式有3个取值：<code>CONTINUE、EXIT、UNDO</code>。<ul>
<li><code>CONTINUE</code>：表示遇到错误不处理，继续执行。主要在函数和过程中使用</li>
<li><code>EXIT</code>：表示遇到错误马上退出。</li>
<li><code>UNDO</code>：表示遇到错误后撤回之前的操作。MySQL中暂时不支持这样的操作。</li>
</ul>
</li>
<li>错误类型（即条件）可以有如下六种取值：<ul>
<li>针对单个错误<ul>
<li><code>SQLSTATE</code>‘字符串错误码’：表示长度为5的<code>sqlstate_value</code>类型的错误代码；</li>
<li><code>MySQL_error_code</code>：匹配数值类型错误代码；</li>
<li>错误名称：表示<code>DECLARE ... CONDITION</code>定义的错误条件名称。</li>
</ul>
</li>
<li>针对一类错误<ul>
<li><code>SQLWARNING</code>：匹配所有以01开头的<code>SQLSTATE</code>错误代码；</li>
<li><code>NOT FOUND</code>：匹配所有以02开头的<code>SQLSTATE</code>错误代码；</li>
<li><code>SQLEXCEPTION</code>：匹配所有没有被<code>SQLWARNING</code>或<code>NOT FOUND</code>捕获的SQLSTATE错误代码；</li>
</ul>
</li>
</ul>
</li>
<li>处理语句：如果出现上述条件之一，则采用对应的处理方式，并执行指定的处理语句。语句可以是像<code>SET 变量 = 值</code>这样的简单语句，也可以是使用<code>BEGIN ... END</code>编写的复合语句。</li>
</ul>
<p><strong>定义处理程序</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 法1：捕获sqlstate_value</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;42S02&#x27;</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"><span class="comment">-- 法2：捕获mysql_error_value</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="number">1146</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"><span class="comment">-- 法3：先定义条件，再调用</span></span><br><span class="line"><span class="keyword">DECLARE</span> no_such_table <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="number">1146</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> NO_SUCH_TABLE <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"><span class="comment">-- 法4：使用SQLWARNING</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLWARNING</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;ERROR&#x27;</span>;</span><br><span class="line"><span class="comment">-- 法5：使用NOT FOUND</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"><span class="comment">-- 法6：使用SQLEXCEPTION</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLEXCEPTION</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;ERROR&#x27;</span></span><br></pre></td></tr></table></figure>

<p>示例-针对存储过程使用</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> UpdateDataNoCondition()</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="comment">-- 定义处理程序</span></span><br><span class="line">      <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="number">1048</span> <span class="keyword">SET</span> <span class="variable">@proc_value</span> <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> email <span class="operator">=</span> <span class="keyword">NULL</span> <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>;</span><br><span class="line">      <span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> email <span class="operator">=</span> <span class="string">&#x27;aabbel&#x27;</span> <span class="keyword">WHERE</span> last_name <span class="operator">=</span> <span class="string">&#x27;Abel&#x27;</span>;</span><br><span class="line">      <span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>针对于MySQL的流程控制语句主要有 3 类。注意：<strong>（除case外）只能用于存储程序。</strong><br>存储程序：包括但不限于存储过程（Stored Procedures）、函数（Functions）、触发器（Triggers）和事件（Events）</p>
<ul>
<li>条件判断语句 ：IF 语句和 CASE 语句</li>
<li>循环语句 ：LOOP、WHILE 和 REPEAT 语句</li>
<li>跳转语句 ：ITERATE 和 LEAVE</li>
</ul>
<h4 id="分支结构之-IF"><a href="#分支结构之-IF" class="headerlink" title="分支结构之 IF"></a>分支结构之 IF</h4><p><code>IF</code> 语句只能在存储过程、函数、触发器和事件中使用，不能直接在普通的 SQL 查询中使用。</p>
<p>语法：<code>IF 表达式1 THEN 操作1 [ELSEIF 表达式2 THEN 操作2]…… [ELSE 操作N] END IF</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_by_eid3(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">DECLARE</span> emp_salary <span class="keyword">DOUBLE</span>;</span><br><span class="line">      <span class="keyword">DECLARE</span> bonus <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> emp_salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;</span><br><span class="line">      <span class="keyword">SELECT</span> commission_pct <span class="keyword">INTO</span> bonus <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;</span><br><span class="line"></span><br><span class="line">      IF emp_salary <span class="operator">&lt;</span> <span class="number">9000</span></span><br><span class="line">         <span class="keyword">THEN</span> <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> <span class="number">9000</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;</span><br><span class="line">      ELSEIF emp_salary <span class="operator">&lt;</span> <span class="number">10000</span> <span class="keyword">AND</span> bonus <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">THEN</span> <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> commission_pct <span class="operator">=</span> <span class="number">0.01</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span>emp_id;</span><br><span class="line">      <span class="keyword">ELSE</span></span><br><span class="line">         <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;</span><br><span class="line">      <span class="keyword">END</span> IF;</span><br><span class="line">   <span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<h4 id="分支结构之-CASE"><a href="#分支结构之-CASE" class="headerlink" title="分支结构之 CASE"></a>分支结构之 CASE</h4><p><code>CASE</code> 语句可以在 SQL 查询中使用，类似于其他数据库中的 <code>IF</code>，但只能出现在 <code>SELECT</code>、<code>WHERE</code>、<code>HAVING</code> 等 SQL 子句中。</p>
<p>语法：<br>情况一：类似于switch，针对值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> 表达式</span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span>或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span>或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>]（如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要）</span><br></pre></td></tr></table></figure>
<p>情况二：类似于多重if，针对范围</p>
<p>**case语句的when子句中可以使用子查询，如：when id in （select id from employee where salary &gt; 10) **</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> 条件<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span>或语句<span class="number">1</span>(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">WHEN</span> 条件<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span>或语句<span class="number">2</span>(如果是语句，需要加分号)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n(如果是语句，需要加分号)</span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>]（如果是放在<span class="keyword">begin</span> <span class="keyword">end</span>中需要加上<span class="keyword">case</span>，如果放在<span class="keyword">select</span>后面不需要`</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_by_eid3(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="comment">-- 演示1</span></span><br><span class="line">      <span class="keyword">DECLARE</span> var <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">CASE</span> var</span><br><span class="line">         <span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;var = 1&#x27;</span>;</span><br><span class="line">         <span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;var = 2&#x27;</span>;</span><br><span class="line">         <span class="keyword">ELSE</span> <span class="keyword">SELECT</span> <span class="string">&#x27;var &gt; 2 &#x27;</span>;</span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">CASE</span>;   </span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_by_eid4(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">   <span class="comment">-- 演示2</span></span><br><span class="line">      <span class="keyword">DECLARE</span> var1 <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">20</span>;</span><br><span class="line">      <span class="keyword">CASE</span> </span><br><span class="line">         <span class="keyword">WHEN</span> var1 <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;三位数&#x27;</span>;</span><br><span class="line">         <span class="keyword">WHEN</span> var1 <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;两位数&#x27;</span>;</span><br><span class="line">         <span class="keyword">ELSE</span> <span class="keyword">SELECT</span> <span class="string">&#x27;个位数&#x27;</span>;</span><br><span class="line">      <span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>





<h4 id="循环结构之-LOOP"><a href="#循环结构之-LOOP" class="headerlink" title="循环结构之 LOOP"></a>循环结构之 LOOP</h4><p>LOOP内的语句一直重复执行直到循环被退出，可以在循环内部使用 <code>LEAVE</code> 语句来中止循环。<br>语法：其中，loop_label表示LOOP语句的标注名称，每个 <code>LOOP</code> 必须有一个标签，用于在 <code>LEAVE</code> 语句中指定退出。（只有一个loop是或可省略）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[loop_label:] LOOP</span><br><span class="line">循环执行的语句</span><br><span class="line"><span class="keyword">END</span> LOOP [loop_label]</span><br></pre></td></tr></table></figure>

<p>示例代码：循环给大家涨薪，薪资涨为原来的1.1倍。直到全公司的平均薪资达到12000结束</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_loop(<span class="keyword">OUT</span> num <span class="type">INT</span>)</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">DECLARE</span> avg_salary <span class="keyword">DOUBLE</span>;</span><br><span class="line">      <span class="keyword">DECLARE</span> loop_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_salary <span class="keyword">FROM</span> employees;</span><br><span class="line">      label_loop:LOOP</span><br><span class="line">         IF avg_salary <span class="operator">&gt;=</span> <span class="number">12000</span> <span class="keyword">THEN</span> LEAVE label_loop;</span><br><span class="line">         <span class="keyword">END</span> IF;</span><br><span class="line">         <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.1</span>;</span><br><span class="line">         <span class="keyword">SET</span> loop_count <span class="operator">=</span> loop_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_salary <span class="keyword">FROM</span> employees;</span><br><span class="line">      <span class="keyword">END</span> LOOP label_loop;</span><br><span class="line">      <span class="keyword">SET</span> num <span class="operator">=</span> loop_count;</span><br><span class="line">   <span class="keyword">END</span> $</span><br></pre></td></tr></table></figure>

<h4 id="循环结构之-WHILE"><a href="#循环结构之-WHILE" class="headerlink" title="循环结构之 WHILE"></a>循环结构之 WHILE</h4><p>WHILE在执行语句执行时，先对指定的表达式进行判断，如果为真，就执行循环内的语句，否则退出循环。（可以在循环内部使用 <code>LEAVE</code> 语句来中止循环。）<br>语法:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[while_label:] WHILE 循环条件 DO</span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">END</span> WHILE [while_label];</span><br></pre></td></tr></table></figure>

<p>示例：循环给大家降薪，薪资降为原来的90%。直到全公司的平均薪资达到5000结束</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_while(<span class="keyword">OUT</span> num <span class="type">INT</span>)</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">DECLARE</span> avg_sal <span class="keyword">DOUBLE</span> ;</span><br><span class="line">      <span class="keyword">DECLARE</span> while_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_sal <span class="keyword">FROM</span> employees;</span><br><span class="line">      WHILE avg_sal <span class="operator">&gt;</span> <span class="number">5000</span> DO</span><br><span class="line">         <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">0.9</span>;</span><br><span class="line">         <span class="keyword">SET</span> while_count <span class="operator">=</span> while_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_sal <span class="keyword">FROM</span> employees;</span><br><span class="line">      <span class="keyword">END</span> WHILE;</span><br><span class="line">      <span class="keyword">SET</span> num <span class="operator">=</span> while_count;</span><br><span class="line">   <span class="keyword">END</span> $</span><br></pre></td></tr></table></figure>


<h4 id="循环结构之-REPEAT"><a href="#循环结构之-REPEAT" class="headerlink" title="循环结构之 REPEAT"></a>循环结构之 REPEAT</h4><p>类似do-while<br>REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出，即 END REPEAT；如果条件不满足，则会就继续执行循环，直到满足退出条件为止。<br>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[repeat_label:] REPEAT</span><br><span class="line">循环体的语句</span><br><span class="line">UNTIL 结束循环的条件表达式</span><br><span class="line"><span class="keyword">END</span> REPEAT [repeat_label]</span><br></pre></td></tr></table></figure>

<p>示例：循环给大家涨薪，薪资涨为原来的1.15倍。直到全公司的平均薪资达到13000结束</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_repeat(<span class="keyword">OUT</span> num <span class="type">INT</span>)</span><br><span class="line">   <span class="keyword">BEGIN</span></span><br><span class="line">      <span class="keyword">DECLARE</span> avg_sal <span class="keyword">DOUBLE</span> ;</span><br><span class="line">      <span class="keyword">DECLARE</span> repeat_count <span class="type">INT</span> DEFAULT1;</span><br><span class="line">      <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_sal <span class="keyword">FROM</span> employees;</span><br><span class="line">      repeat_sal: REPEAT</span><br><span class="line">         <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.15</span>;</span><br><span class="line">         <span class="keyword">SET</span> repeat_count <span class="operator">=</span> repeat_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_sal <span class="keyword">FROM</span> employees;</span><br><span class="line">         UNTIL avg_sal <span class="operator">&gt;=</span> <span class="number">13000</span>;</span><br><span class="line">      <span class="keyword">END</span> REPEAT repeat_sal;</span><br><span class="line">      <span class="keyword">SET</span> num <span class="operator">=</span> repeat_count;</span><br><span class="line">   <span class="keyword">END</span> $</span><br></pre></td></tr></table></figure>

<p><strong>三种循环结构对比</strong>：<br>1、这三种循环都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称。<br>2、 LOOP：一般用于实现简单的”死”循环 WHILE：先判断后执行 REPEAT：先执行后判断，无条件至少执行一次</p>
<h4 id="跳转语句之-LEAVE"><a href="#跳转语句之-LEAVE" class="headerlink" title="跳转语句之 LEAVE"></a>跳转语句之 LEAVE</h4><p>可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出程序体的操作,可以理解为 break。</p>
<p>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEAVE 标记名</span><br></pre></td></tr></table></figure>
<p>使用方法见上文LOOP部分</p>
<h4 id="跳转语句之-ITERATE"><a href="#跳转语句之-ITERATE" class="headerlink" title="跳转语句之 ITERATE"></a>跳转语句之 ITERATE</h4><p>只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处，可以理解为 continue，意<br>思为“再次循环”。<br>语法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITERATE label</span><br></pre></td></tr></table></figure>

<h3 id="游标的使用"><a href="#游标的使用" class="headerlink" title="游标的使用"></a>游标的使用</h3><p>虽然我们也可以通过筛选条件 WHERE 和 HAVING，或者是限定返回记录的关键字 LIMIT 返回一条记录，但是，却无法在结果集中像指针一样，向前定位一条记录、向后定位一条记录，或者是 随意定位到某一条记录 ，并对记录的数据进行处理。这个时候，就可以用到游标。<br>游标提供了一种灵活的操作方式，让我们能够对结果集中的每一条记录进行定位，并对指向的记录中的数据进行操作的数据结构。游标让 SQL 这种面向集合的语言有了面向过程开发的能力。<br>在 SQL 中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。这里游标 充当了指针的作用 ，我们可以通过操作游标来对数据行进行操作。<br>MySQL中游标<code>可以在存储过程和函数中</code>使用。</p>
<p><strong>游标的使用步骤</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.游标的声明 </span></span><br><span class="line"><span class="comment">/*select_statement 代表的是 SELECT 语句，返回一个用于创建游标的结果集。*/</span></span><br><span class="line"><span class="comment">-- 在 MySQL，SQL Server，DB2 和 MariaDB</span></span><br><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement;</span><br><span class="line"><span class="comment">-- 在 Oracle 或者 PostgreSQL</span></span><br><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">IS</span> select_statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.打开游标：定义后想要使用必须打开游标</span></span><br><span class="line"><span class="comment">/*打开游标的时候 SELECT 语句的查询结果集就会送到游标工作区，为后面游标的 逐条读取 结果集中的记录做准备。*/</span></span><br><span class="line"><span class="keyword">OPEN</span> cursor_name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 使用游标（从游标中取得数据）</span></span><br><span class="line"><span class="comment">/*如果游标读取的数据行有多个列名，则在 INTO 关键字后面赋值给多个变量名即可；游标的查询结果集中的字段数，必须跟 INTO 后面的变量数一致；var_name必须在声明游标之前就定义好*/</span></span><br><span class="line"><span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> var_name [, var_name] ...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4.关闭游标，避免资源浪费</span></span><br><span class="line"><span class="comment">/*使用完游标后需要关闭掉该游标。因为游标会占用系统资源 ，如果不及时关闭，游标会一直保持到存储过程结束，影响系统运行的效率。*/</span></span><br><span class="line"><span class="keyword">CLOSE</span> cursor_name</span><br></pre></td></tr></table></figure>

<p>使用实例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_count_by_limit_total_salary(<span class="keyword">IN</span> l_t_salary <span class="type">DECIMAL</span>,<span class="keyword">OUT</span> t_count <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">DECLARE</span> sum_sal <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0.0</span>; <span class="comment">-- 先声明局部变量</span></span><br><span class="line">   <span class="keyword">DECLARE</span> emp_sal <span class="keyword">DOUBLE</span>;</span><br><span class="line">   <span class="keyword">DECLARE</span> emp_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">   <span class="comment">-- 声明</span></span><br><span class="line">   <span class="keyword">DECLARE</span> emp_cu <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br><span class="line">   <span class="comment">-- 打开</span></span><br><span class="line">   <span class="keyword">OPEN</span> emp_cu;</span><br><span class="line">   REPEAT</span><br><span class="line">      <span class="comment">--使用</span></span><br><span class="line">      <span class="keyword">FETCH</span> emp_cu <span class="keyword">INTO</span> emp_sal;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">SET</span> sum_sal <span class="operator">=</span> sum_sal <span class="operator">+</span> emp_sal;</span><br><span class="line">      <span class="keyword">SET</span> emp_count <span class="operator">=</span> emp_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">      UNTIL sum_sal <span class="operator">&gt;=</span> l_t_salary;</span><br><span class="line">   <span class="keyword">END</span> REPEAT;</span><br><span class="line">   <span class="keyword">SET</span> t_count <span class="operator">=</span> emp_count;</span><br><span class="line">   <span class="comment">--关闭</span></span><br><span class="line">   <span class="keyword">CLOSE</span> emp_cu;</span><br><span class="line"><span class="keyword">END</span> $</span><br></pre></td></tr></table></figure>


<p>游标的优点和不足</p>
<ol>
<li>为 逐条读取 结果集中的数据，提供了完美的解决方案。</li>
<li>在使用游标的过程中，会对数据行进行 加锁 ，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会 消耗系统资源 ，造成内存不足</li>
</ol>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是由<code>事件来触发</code>某个操作，这些事件包括<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>事件。所谓事件就是指用户的动作或者触发某项行为。如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生了，就会<code>自动</code>激发触发器执行相应的操作。<br>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来实现。<br><strong>触发器是针对某一特定的表的特定操作的</strong></p>
<h3 id="触发器的创建"><a href="#触发器的创建" class="headerlink" title="触发器的创建"></a>触发器的创建</h3><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称</span><br><span class="line">&#123;BEFORE<span class="operator">|</span>AFTER&#125; &#123;<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">触发器执行的语句块;</span><br></pre></td></tr></table></figure>

<p><strong>格式说明：</strong></p>
<ol>
<li>表名：表示触发器监控的对象。</li>
<li>BEFORE|AFTER：表示触发的时间。<code>BEFORE</code>表示在事件之前触发；<code>AFTER</code>表示在事件之后触发。</li>
<li>INSERT|UPDATE|DELETE ：表示触发的事件。<ul>
<li>INSERT 表示插入记录时触发；</li>
<li>UPDATE 表示更新记录时触发；</li>
<li>DELETE 表示删除记录时触发。</li>
</ul>
</li>
<li>触发器执行的语句块：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块</li>
</ol>
<p>示例：创建名称为before_insert的触发器，向test_trigger数据表插入数据之前，向test_trigger_log数据表中插入before_insert的日志信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> before_insert</span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> test_trigger</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test_trigger_log(t_log) <span class="keyword">values</span>(<span class="string">&#x27;before_insert&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>在插入操作触发器中可以用new表示新插入的数据；在删除操作触发器中可以用old表示刚删除的数据</strong><br>同一表同一操作可以绑定多个触发器，均会执行。</p>
<h3 id="查看和删除触发器"><a href="#查看和删除触发器" class="headerlink" title="查看和删除触发器"></a>查看和删除触发器</h3><p>查看触发器是查看数据库中已经存在的触发器的定义、状态和语法信息等。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 方式1：查看当前数据库的所有触发器的定义</span></span><br><span class="line"><span class="keyword">SHOW</span> TRIGGERS\G</span><br><span class="line"><span class="comment">-- 方式2：查看当前数据库中某个触发器的定义</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器</span><br><span class="line"><span class="comment">-- 方式3：从系统库information_schema的TRIGGERS表中查询“salary_check_trigger”触发器的信息。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure>

<p><strong>删除触发器</strong><br>触发器也是数据库对象，删除触发器也用DROP语句，语法格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> 触发器名称;</span><br></pre></td></tr></table></figure>

<h3 id="触发器的优缺点"><a href="#触发器的优缺点" class="headerlink" title="触发器的优缺点"></a>触发器的优缺点</h3><p><strong>优点</strong></p>
<ol>
<li>触发器可以确保数据的完整性。</li>
<li>触发器可以帮助我们记录操作日志</li>
<li>触发器还可以用在操作数据前，对数据进行合法性检查。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>触发器最大的一个问题就是可读性差</li>
<li>相关数据的变更，可能会导致触发器出错，如数据表结构的变化等。由于触发器本身的隐蔽性，影响到应用中错误原因排查的效率。</li>
</ol>
<p><strong>注意点</strong><br>如果在子表中定义了外键约束，并且外键指定了<code>ON UPDATE/DELETE CASCADE/SET NULL</code>子句，此时修改父表被引用的键值或删除父表被引用的记录行时，也会引起子表的修改和删除操作，此时基于子表的UPDATE和DELETE语句定义的触发器并不会被激活。</p>
<p>例如：基于子表员工表（t_employee）的DELETE语句定义了触发器t1，而子表的部门编号（did）字段定义了外键约束引用了父表部门表（t_department）的主键列部门编号（did），并且该外键加了“ONDELETE SET NULL”子句，那么如果此时删除父表部门表（t_department）在子表员工表（t_employee）有匹配记录的部门记录时，会引起子表员工表（t_employee）匹配记录的部门编号（did）修改为NULL但是此时不会激活触发器t1。只有直接对子表员工表（t_employee）执行DELETE语句时才会激活触发器<br>t1。</p>
<h2 id="8-0其他新特性"><a href="#8-0其他新特性" class="headerlink" title="8.0其他新特性"></a>8.0其他新特性</h2><p>新增特性：<br>更简便的NoSQL支持、更好的索引、更完善的JSON支持、安全和账户管理、InnoDB的变化、数据字典、原子数据定义语句、资源管理、字符集支持、优化器增强、公用表表达式、窗口函数、正则表达式支持、内部临时表、日志记录、备份锁、增强的MySQL复制</p>
<p>删除特性的领域：<br>查询缓存、部分加密操作、部分空间函数、\N视为NULL、mysql_install_db、通用分区处理程序、通用分区处理程序、mysql_plugin工具</p>
<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。<br>窗口函数可以分为<code>静态窗口函数</code>和<code>动态窗口函数</code>。</p>
<ul>
<li>静态窗口函数的窗口大小是固定的，不会因为记录的不同而不同；</li>
<li>动态窗口函数的窗口大小会随着记录的不同而变化。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number">MySQL窗口函数官方参考网页</a></p>
<p>窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数，如下表：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240808212056.png" alt="窗口函数"></p>
<h4 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h4><p><code>函数 OVER（[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）</code><br>或<br><code>函数 OVER 窗口名 … WINDOW 窗口名 AS （[PARTITION BY 字段名 ORDER BY 字段名 ASC|DESC]）</code></p>
<p>说明：</p>
<ul>
<li>OVER关键字指定函数窗口的范围。<ul>
<li>如果省略后面括号中的内容，则窗口会包含满足WHERE条件的所有记录，窗口函数会基于所有满足WHERE条件的记录进行计算。</li>
<li>如果OVER关键字后面的括号不为空，则可以使用如下语法设置窗口。</li>
</ul>
</li>
<li>窗口名：为窗口设置一个别名，用来标识窗口。</li>
<li>PARTITION BY子句：指定窗口函数按照哪些字段进行分组。分组后，窗口函数可以在每个分组中分别执行。</li>
<li>ORDER BY子句：指定窗口函数按照哪些字段进行排序。执行排序操作使窗口函数按照排序后的数据记录的顺序进行编号。</li>
<li>FRAME子句：为分区中的某个子集定义规则，可以用来作为滑动窗口使用</li>
</ul>
<h4 id="序号函数"><a href="#序号函数" class="headerlink" title="序号函数"></a>序号函数</h4><p><strong>ROW_NUMBER()</strong></p>
<p>ROW_NUMBER()函数能够对数据中的序号进行顺序显示。</p>
<p>示例：查询 goods 数据表中每个商品分类下价格降序排列的各个商品信息。(此时价格一致但序号仍有大小)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> row_num,id, category_id, category, NAME, price, stock <span class="keyword">FROM</span> goods;</span><br></pre></td></tr></table></figure>


<p><strong>RANK()函数</strong></p>
<p>使用RANK()函数能够对序号进行并列排序，并且会跳过重复的序号，比如序号为1、1、3。</p>
<p>举例：使用RANK()函数获取goods数据表中各类别的价格从高到低排序的各商品信息。(此时价格一致则序号相同)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank_num ,id, category_id,category, NAME, price, stock <span class="keyword">FROM</span> goods;</span><br><span class="line"><span class="comment">-- 当两价格相同，则其序号相同，更低价格的为当前相同价格的商品序号+相同价格商品数</span></span><br></pre></td></tr></table></figure>


<p><strong>DENSE_RANK()函数</strong></p>
<p>DENSE_RANK()函数对序号进行并列排序，并且不会跳过重复的序号，比如序号为1、1、2。</p>
<p>举例：使用DENSE_RANK()函数获取 goods 数据表中各类别的价格从高到低排序的各商品信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank_num ,id, category_id,category, NAME, price, stock <span class="keyword">FROM</span> goods;</span><br><span class="line"><span class="comment">-- 当两价格相同，则其序号相同，更低价格的为当前相同价格的商品序号 + 1</span></span><br></pre></td></tr></table></figure>

<h4 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h4><p><strong>PERCENT_RANK()函数</strong></p>
<p>PERCENT_RANK()函数是等级值百分比函数。按照如下方式进行计算。<br><code>(rank - 1) / (rows - 1)</code><br>其中，rank的值为使用RANK()函数产生的序号，rows的值为当前窗口的总记录数。</p>
<p>举例：计算 goods 数据表中名称为“女装&#x2F;女士精品”的类别下的商品的PERCENT_RANK值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">RANK</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> r, <span class="built_in">PERCENT_RANK</span>() <span class="keyword">OVER</span> w <span class="keyword">AS</span> pr, id, category_id, category, NAME, price, stock</span><br><span class="line"><span class="keyword">FROM</span> goods <span class="keyword">WHERE</span> category_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>);</span><br><span class="line"><span class="comment">-- 适合用于计算成绩分布</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>函数类别</th>
<th>函数名</th>
<th>函数功能</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>分布函数</td>
<td>CUME_DIST()</td>
<td>主要用于查询小于或等于某个值的比例。</td>
<td></td>
</tr>
<tr>
<td>前后函数</td>
<td>LAG(expr,n)</td>
<td>返回当前行的前n行的expr的值</td>
<td></td>
</tr>
<tr>
<td>前后函数</td>
<td>LEAD(expr,n)</td>
<td>返回当前行的后n行的expr的值。</td>
<td></td>
</tr>
<tr>
<td>首尾函数</td>
<td>FIRST_VALUE(expr)</td>
<td>返回第一个expr的值。</td>
<td></td>
</tr>
<tr>
<td>首尾函数</td>
<td>LAST_VALUE(expr)</td>
<td>返回最后一个expr的值</td>
<td></td>
</tr>
<tr>
<td>其他函数</td>
<td>NTH_VALUE(expr,n)</td>
<td>返回第n个expr的值。</td>
<td></td>
</tr>
<tr>
<td>其他函数</td>
<td>NTILE(n)</td>
<td>将分区中的有序数据分为n堆，记录堆编号。</td>
<td></td>
</tr>
</tbody></table>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- CUME_DIST() 查询goods数据表中小于或等于当前价格的比例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CUME_DIST</span>() <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">ASC</span>) <span class="keyword">AS</span> cd,</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> id, category, NAME, price</span><br><span class="line"><span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">FROM</span> goods</span><br><span class="line"><span class="comment">-- LAG(expr,n) 查询goods数据表中前一个商品价格与当前商品价格的差值</span></span><br><span class="line"><span class="comment">-- LEAD(expr,n) 查询goods数据表中后一个商品价格与当前商品价格的差值。</span></span><br><span class="line"><span class="keyword">SELECT</span> id, category, NAME, behind_price, price,behind_price <span class="operator">-</span> price <span class="keyword">AS</span> diff_price</span><br><span class="line"><span class="keyword">FROM</span>( <span class="keyword">SELECT</span> id, category, NAME, price,<span class="built_in">LEAD</span>(price, <span class="number">1</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> behind_price <span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price)) t;</span><br><span class="line"><span class="comment">-- FIRST_VALUE(expr) 按照价格排序，查询第1个商品的价格信息。</span></span><br><span class="line"><span class="keyword">SELECT</span> id, category, NAME, price, stock,<span class="built_in">FIRST_VALUE</span>(price) <span class="keyword">OVER</span> w <span class="keyword">AS</span> first_price <span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price);</span><br><span class="line"><span class="comment">-- LAST_VALUE(expr) 按照价格排序，查询最后一个商品的价格信息。</span></span><br><span class="line"><span class="keyword">SELECT</span> id, category, NAME, price, stock,<span class="built_in">LAST_VALUE</span>(price) <span class="keyword">OVER</span> w <span class="keyword">AS</span> last_price <span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price)</span><br><span class="line"><span class="comment">-- NTH_VALUE(expr,n) 查询goods数据表中排名第2和第3的价格信息</span></span><br><span class="line"><span class="keyword">SELECT</span> id, category, NAME, price,<span class="built_in">NTH_VALUE</span>(price,<span class="number">2</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> second_price,<span class="built_in">NTH_VALUE</span>(price,<span class="number">3</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> third_price <span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price)</span><br><span class="line"><span class="comment">-- NTILE(n) 将goods表中的商品按照价格分为3组</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">NTILE</span>(<span class="number">3</span>) <span class="keyword">OVER</span> w <span class="keyword">AS</span> nt,id, category, NAME, price <span class="keyword">FROM</span> goods <span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> category_id <span class="keyword">ORDER</span> <span class="keyword">BY</span> price);</span><br></pre></td></tr></table></figure>

<h3 id="公用表表达式"><a href="#公用表表达式" class="headerlink" title="公用表表达式"></a>公用表表达式</h3><p>公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结果集，作用范围是当前语句。CTE可以理解成一个可以复用的子查询，当然跟子查询还是有点区别的，CTE可以引用其他CTE，但子查询不能引用其他子查询。所以，可以考虑代替子查询。<br>依据语法结构和执行方式的不同，公用表表达式分为<code>普通公用表表达式</code>和 递归公用表表达式&#96;2 种</p>
<h4 id="普通公用表表达式"><a href="#普通公用表表达式" class="headerlink" title="普通公用表表达式"></a>普通公用表表达式</h4><p>语法结构:<br>   <code>WITH CTE名称 AS （子查询）SELECT|DELETE|UPDATE 语</code></p>
<p>普通公用表表达式类似于子查询，不过，跟子查询不同的是，它可以被多次引用，而且可以被其他的普通公用表表达式所引用。<br>举例：查询员工所在的部门的详细信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees);</span><br><span class="line"><span class="comment">--等价于公用表表达式：</span></span><br><span class="line"><span class="keyword">WITH</span> emp_dept_id <span class="keyword">AS</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees) <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> departments d <span class="keyword">JOIN</span> emp_dept_id e <span class="keyword">ON</span> d.department_id <span class="operator">=</span> e.department_id</span><br></pre></td></tr></table></figure>

<h4 id="递归公用表表达式"><a href="#递归公用表表达式" class="headerlink" title="递归公用表表达式"></a>递归公用表表达式</h4><p>递归公用表表达式可以调用自己<br>语法结构：<br>   <code>WITH RECURSIVE CTE名称 AS （子查询）SELECT|DELETE|UPDATE 语句;</code><br>递归公用表表达式由 2 部分组成，分别是种子查询和递归查询，中间通过关键字 UNION [ALL]进行连接。<br>这里的种子查询，意思就是获得递归的初始值。这个查询只会运行一次，以创建初始数据集，之后递归查询会一直执行，直到没有任何新的查询数据产生，递归返回</p>
<p>示例：employees表包含employee_id，last_name和manager_id三个字段。如果a是b的管理者，那么，我们可以把b叫做a的下属，如果同时b又是c的管理者，那么c就是b的下属，是a的下下属。用查询语句列出所有具有下下属身份的人员信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> <span class="keyword">RECURSIVE</span> cte</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line">(</span><br><span class="line">   <span class="keyword">SELECT</span> employee_id,last_name,manager_id,<span class="number">1</span> <span class="keyword">AS</span> n <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">100</span></span><br><span class="line"><span class="comment">-- 种子查询，找到第一代领导</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="comment">-- 递归查询，找出以递归公用表表达式的人为领导的人</span></span><br><span class="line"><span class="keyword">SELECT</span> a.employee_id,a.last_name,a.manager_id,n<span class="operator">+</span><span class="number">1</span> <span class="keyword">FROM</span> employees <span class="keyword">AS</span> a <span class="keyword">JOIN</span> cte <span class="keyword">ON</span> (a.manager_id <span class="operator">=</span> cte.employee_id) </span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name <span class="keyword">FROM</span> cte <span class="keyword">WHERE</span> n <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="关键字及其含义"><a href="#关键字及其含义" class="headerlink" title="关键字及其含义"></a>关键字及其含义</h2><p><code>SELECT</code> - 用于从数据库表中选取数据。它允许你指定你想从表中检索的列。<br><code>FROM</code> - 指定了SELECT语句中要查询的表名。<br><code>WHERE</code> - 用于指定过滤条件，以限制SELECT语句返回的行。<br><code>INSERT INTO</code> - 用于向数据库表中插入新的行。<br><code>UPDATE</code> - 用于修改表中的数据。它必须配合SET子句来指定要修改的列和新值，以及WHERE子句来指定哪些行需要被更新。<br><code>DELETE</code>- 用于从数据库表中删除行。它可以与WHERE子句结合使用，以限制删除哪些行。<br><code>CREATE TABLE</code> - 用于创建一个新表，并定义其列和每列的数据类型。<br><code>ALTER TABLE</code> - 用于修改已存在的表的结构，如添加、删除或修改列。<br><code>DROP TABLE</code> - 用于删除整个表及其所有数据。<br><code>TRUNCATE TABLE</code> - 用于删除表中的所有行，但不删除表本身。与DELETE相比，它通常更快，因为它不记录个别行删除的日志。<br><code>JOIN</code> - 用于根据两个或多个表中的列之间的关系，结合这些表的数据。常见的JOIN类型有INNER JOIN、LEFT JOIN、RIGHT JOIN和FULL JOIN。<br><code>GROUP BY</code> - 通常与聚合函数（如COUNT、MAX、MIN、SUM、AVG）一起使用，用于将结果集中的行分组。<br><code>HAVING</code> - 用于对GROUP BY的结果进行过滤，类似于WHERE子句，但它是用于聚合后的结果。<br><code>ORDER BY</code> - 用于对结果集进行排序。可以指定一个或多个列进行升序（ASC）或降序（DESC）排序。<br><code>DISTINCT</code> - 用于返回唯一不同的值。<br><code>UNION</code> - 用于合并两个或多个SELECT语句的结果集，并删除重复的行。<br><code>UNION ALL</code> - 类似于UNION，但它不删除重复的行。<br><code>COUNT()、MAX()、MIN()、SUM()、AVG()</code> - 这些是聚合函数，用于在SELECT语句中对一组值执行计算并返回单个值。<br><code>LIKE</code> - 在WHERE子句中用于在模糊匹配中搜索列中的指定模式。<br><code>IN</code> - 在WHERE子句中用于指定多个可能的值，以便从中选择。<br><code>IFNULL</code> - </p>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用于存储过程和函数、触发器 45000可换为其他错误码</span></span><br><span class="line">SIGNAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;45000&#x27;</span> <span class="keyword">SET</span> MESSAGE_TEXT <span class="operator">=</span> <span class="string">&#x27;自定义错误消息&#x27;</span>;  </span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"><i class="fa fa-tag"></i> MySQL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/08/30/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="prev" title="算法-动态规划">
                  <i class="fa fa-angle-left"></i> 算法-动态规划
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/09/07/MySQL-Note2-%E6%9E%B6%E6%9E%84%E7%B4%A2%E5%BC%95%E8%B0%83%E4%BC%98/" rel="next" title="MySQL-Note2-架构索引调优">
                  MySQL-Note2-架构索引调优 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments giscus-container">
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Shearington</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">449k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">24:56</span>
  </span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"Fushiye/Fushiye.github.io","repo_id":"R_kgDOLyiTvA","category":"Announcements","category_id":"DIC_kwDOLyiTvM4CteAo","mapping":"title","strict":0,"reactions_enabled":1,"emit_metadata":0,"theme":"light","lang":"zh-CN","crossorigin":"anonymous","input_position":"top","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
