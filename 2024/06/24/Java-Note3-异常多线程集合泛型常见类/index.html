<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon_apple-touch-icon-human.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_human_32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_human_16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"fushiye.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.23.2","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism-darcula","dark":"prism-darcula"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"giscus","storage":true,"lazyload":false,"nav":null,"activeClass":"giscus"},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":3,"unescape":false,"preload":true}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="java异常、多线程、常见类、集合、泛型等知识学习过程中记录的笔记，仅供参考，如有错漏，敬请指正!">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-Note3-异常多线程集合泛型常见类">
<meta property="og:url" content="https://fushiye.github.io/2024/06/24/Java-Note3-%E5%BC%82%E5%B8%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9B%86%E5%90%88%E6%B3%9B%E5%9E%8B%E5%B8%B8%E8%A7%81%E7%B1%BB/index.html">
<meta property="og:site_name" content="星海拾贝">
<meta property="og:description" content="java异常、多线程、常见类、集合、泛型等知识学习过程中记录的笔记，仅供参考，如有错漏，敬请指正!">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240709164203.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240711161020.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240711162142.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240711201627.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240711215500.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712133305.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712133441.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712134227.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712134802.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712210402.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240713170651.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240713170738.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240713170456.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240714004243.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240715101443.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719001310.png">
<meta property="og:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719002242.png">
<meta property="article:published_time" content="2024-06-24T08:11:29.000Z">
<meta property="article:modified_time" content="2025-02-07T14:45:59.097Z">
<meta property="article:author" content="Shearington">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240709164203.png">


<link rel="canonical" href="https://fushiye.github.io/2024/06/24/Java-Note3-%E5%BC%82%E5%B8%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9B%86%E5%90%88%E6%B3%9B%E5%9E%8B%E5%B8%B8%E8%A7%81%E7%B1%BB/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://fushiye.github.io/2024/06/24/Java-Note3-%E5%BC%82%E5%B8%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9B%86%E5%90%88%E6%B3%9B%E5%9E%8B%E5%B8%B8%E8%A7%81%E7%B1%BB/","path":"2024/06/24/Java-Note3-异常多线程集合泛型常见类/","title":"Java-Note3-异常多线程集合泛型常见类"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java-Note3-异常多线程集合泛型常见类 | 星海拾贝</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">星海拾贝</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">探索永无止境</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC3%E9%98%B6%E6%AE%B5%EF%BC%9A%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">第3阶段：高级应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC09%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="nav-number">1.1.</span> <span class="nav-text">第09章_异常处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB"><span class="nav-number">1.1.1.</span> <span class="nav-text">Java异常体系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F1-try-catch-finally"><span class="nav-number">1.1.2.</span> <span class="nav-text">异常处理方式1 try-catch-finally</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#finally"><span class="nav-number">1.1.3.</span> <span class="nav-text">finally</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F2-throws"><span class="nav-number">1.1.4.</span> <span class="nav-text">异常处理方式2 throws</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.1.5.</span> <span class="nav-text">手动抛出异常对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="nav-number">1.1.6.</span> <span class="nav-text">自定义异常类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC10%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">第10章_多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F1-%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="nav-number">1.2.1.</span> <span class="nav-text">线程的创建方式1:继承Thread类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F2-%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.2.2.</span> <span class="nav-text">线程的创建方式2:实现Runnable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.3.</span> <span class="nav-text">Thread中常用的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.4.</span> <span class="nav-text">线程优先级和相关方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A"><span class="nav-number">1.2.5.</span> <span class="nav-text">线程的生命周期：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%92%8C%E5%A4%84%E7%90%86"><span class="nav-number">1.2.6.</span> <span class="nav-text">线程的安全问题和处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%92%8CLock-%E9%94%81"><span class="nav-number">1.2.7.</span> <span class="nav-text">死锁和Lock(锁)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1-%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.8.</span> <span class="nav-text">线程通信-等待唤醒机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="nav-number">1.2.9.</span> <span class="nav-text">生产者消费者问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B9%8BCallable-%E4%BA%86%E8%A7%A3"><span class="nav-number">1.2.10.</span> <span class="nav-text">线程创建方式之Callable(了解)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.2.11.</span> <span class="nav-text">线程创建方式之线程池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%A1%80API"><span class="nav-number">1.3.</span> <span class="nav-text">第11章_常用类和基础API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%B1%BB"><span class="nav-number">1.3.1.</span> <span class="nav-text">String类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E5%A3%B0%E6%98%8E"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">相关声明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#String%E4%B8%8E%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">String与其他类型之间的转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#String-%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">String 中的常用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#StringBuffer-StringBuilder"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">StringBuffer StringBuilder</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%B1%BB"><span class="nav-number">1.3.2.</span> <span class="nav-text">日期时间类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">jdk&lt;8 API</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jdk-8-API"><span class="nav-number">1.3.3.</span> <span class="nav-text">jdk&gt;8 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">比较器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Comparable-%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">Comparable 自然排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Comparator-%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">Comparator 定制排序</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%B1%BB"><span class="nav-number">1.3.5.</span> <span class="nav-text">其他常见类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#System"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">System</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Runtime"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">Runtime</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Math"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">Math</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#BigInteger%E3%80%81BigDecimal"><span class="nav-number">1.3.5.4.</span> <span class="nav-text">BigInteger、BigDecimal</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Random"><span class="nav-number">1.3.5.5.</span> <span class="nav-text">Random</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC12%E7%AB%A0-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="nav-number">1.4.</span> <span class="nav-text">第12章_集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.1.</span> <span class="nav-text">Collection接口常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#List%E5%AD%90%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">List子接口常用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Set%E5%AD%90%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">Set子接口常用方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.2.</span> <span class="nav-text">Map接口常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E5%85%83%E7%B4%A0"><span class="nav-number">1.4.3.</span> <span class="nav-text">Iterator迭代器遍历元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">1.4.4.</span> <span class="nav-text">Collections工具类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97-Queue"><span class="nav-number">1.4.5.</span> <span class="nav-text">队列 Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-Deque"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">双端队列 Deque</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">1.4.6.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC13%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.5.</span> <span class="nav-text">第13章_泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="nav-number">1.5.1.</span> <span class="nav-text">自定义泛型结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">1.5.2.</span> <span class="nav-text">泛型的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.3.</span> <span class="nav-text">通配符?的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC14%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81"><span class="nav-number">1.6.</span> <span class="nav-text">第14章_数据结构与集合源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90"><span class="nav-number">1.6.1.</span> <span class="nav-text">List接口分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90"><span class="nav-number">1.6.2.</span> <span class="nav-text">Map接口分析</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shearington"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Shearington</p>
  <div class="site-description" itemprop="description">诗酒趁年华</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Fushiye/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Fushiye&#x2F;" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:shearington@foxmail.com" title="E-Mail → mailto:shearington@foxmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fushiye.github.io/2024/06/24/Java-Note3-%E5%BC%82%E5%B8%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9B%86%E5%90%88%E6%B3%9B%E5%9E%8B%E5%B8%B8%E8%A7%81%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Shearington">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="星海拾贝">
      <meta itemprop="description" content="诗酒趁年华">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java-Note3-异常多线程集合泛型常见类 | 星海拾贝">
      <meta itemprop="description" content="java异常、多线程、常见类、集合、泛型等知识学习过程中记录的笔记，仅供参考，如有错漏，敬请指正!">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java-Note3-异常多线程集合泛型常见类
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-24 16:11:29" itemprop="dateCreated datePublished" datetime="2024-06-24T16:11:29+08:00">2024-06-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-02-07 22:45:59" itemprop="dateModified" datetime="2025-02-07T22:45:59+08:00">2025-02-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">基础</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>25k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:24</span>
    </span>
</div>

            <div class="post-description">java异常、多线程、常见类、集合、泛型等知识学习过程中记录的笔记，仅供参考，如有错漏，敬请指正!</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>Java异常处理 多线程 常用类与基础API 集合框架 泛型 数据结构和集合源码 </p>
<span id="more"></span>

<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1PY411e7J6/?p=15&spm_id_from=pageDriver&vd_source=20530c92c1be8bd70e37346e3a5c037a">尚硅谷-java基础教程</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-tutorial.html">菜鸟教程-java</a><br><a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/index.html">Java API 参考文档</a><br>参考书籍:《java核心技术》《Effective Java》 《java编程思想》</p>
<h2 id="第3阶段：高级应用"><a href="#第3阶段：高级应用" class="headerlink" title="第3阶段：高级应用"></a>第3阶段：高级应用</h2><h3 id="第09章-异常处理"><a href="#第09章-异常处理" class="headerlink" title="第09章_异常处理"></a>第09章_异常处理</h3><p>异常：指出现在执行过程中出现的非正常情况，如果不处理最终将会导致JVM的非正常停止</p>
<p>异常的抛出机制：Java中把不同的异常用不同的类表示，一旦发生某种异常，就<code>创建该异常类型的对象</code>，并且抛出（throw）。然后程序员可以捕获(catch)到这个异常对象，并处理；如果没有捕获(catch)这个异常对象，那么这个异常对象将会导致程序终止。</p>
<p>异常的处理：对于程序出现的异常，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是程序员在编写程序时，就充分考虑到各种可能发生的异常和错误，极力预防和避免。实在无法避免的，要编写相应的代码进行异常的检测、以及<code>异常的处理</code>，保证代码的<code>健壮性</code>。</p>
<p><strong>开发中异常处理方式的选择</strong><br>前提：对于异常，使用相应的处理方式。此时的异常，主要指的是编译时异常。</p>
<ul>
<li>如果程序代码中，涉及到资源的调用（流、数据库连接、网络连接等），则必须考虑使用try-catch-finally来处理，保证不出现内存泄漏。</li>
<li>如果父类被重写的方法没有throws异常类型，则子类重写的方法中如果出现异常，只能考虑使用try-catch-finally进行处理，不能throws。</li>
<li>开发中，方法a中依次调用了方法b,c,d等方法，方法b,c,d之间是递进关系。此时，如果方法b,c,d中有异常，我们通常选择使用throws，而方法a中通常选择使用try-catch-finally。</li>
</ul>
<h4 id="Java异常体系"><a href="#Java异常体系" class="headerlink" title="Java异常体系"></a>Java异常体系</h4><p>1 Throwable<br><code>java.lang.Throwable</code> 类是Java程序执行过程中发生的异常事件对应的类的根父类。</p>
<p>2 Error 和 Exception<br>Throwable可分为两类：Error和Exception。分别对应着<code>java.lang.Error</code>与<code>java.lang.Exception</code>两个类。</p>
<p><strong>Error：</strong>Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。一般不编写针对性的代码进行处理。</p>
<ul>
<li>例如：StackOverflowError（栈内存溢出）和OutOfMemoryError（堆内存溢出，简称OOM）。</li>
</ul>
<p><strong>Exception:</strong> 其它因编程错误或偶然的外在因素导致的一般性问题，需要<strong>使用针对性的代码进行处理</strong>，使程序继续运行。否则一旦发生异常，程序也会挂掉。可以分为编译时异常（受检异常）和运行时异常（非受检异常）</p>
<p>例如：</p>
<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ul>
<blockquote>
<p>说明： </p>
<ol>
<li>无论是Error还是Exception，还有很多子类，异常的类型非常丰富。当代码运行出现异常时，特别是我们不熟悉的异常时，不要紧张，把异常的简单类名，拷贝到API中去查去认识它即可。</li>
<li>我们本章讲的异常处理，其实针对的就是Exception。</li>
</ol>
</blockquote>
<p>常见异常：<br>运行时异常：</p>
<ul>
<li>数组角标越界：<code>ArrayIndexOutOfBoundsException</code> 如<code>int[] array = new int[10]; array[10] = 1;</code></li>
<li>空指针访问：<code>NullPointerException</code> </li>
<li>类型间转换不兼容：<code>ClassCastException</code> 如<code>obj-&gt;Date</code></li>
<li>数字格式异常：<code>NumberFormatException</code> 如<code>Integer.parseInt(&quot;abc&quot;)</code></li>
<li>输入不匹配异常：<code>InputMIsmatchException</code> 如输入<code>abc-&gt;int num = scanner.nextInt();</code></li>
<li>算术错误异常：<code>ArithmeticException</code> 如<code>10/0</code><br>编译时异常：</li>
<li>类无法找到异常：<code>ClassNoFoundException</code> </li>
<li>文件无法找到异常：<code>FileNoFoundException</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file)<span class="comment">//可能出现FileNoFoundException</span></span><br></pre></td></tr></table></figure></li>
<li>输入输出异常：<code>IOException</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fis.close();<span class="comment">//可能出现IOException</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="异常处理方式1-try-catch-finally"><a href="#异常处理方式1-try-catch-finally" class="headerlink" title="异常处理方式1 try-catch-finally"></a>异常处理方式1 try-catch-finally</h4><p>抓抛模型：try-catch-finally<br>1 抛：程序在执行过程中，一旦出现异常，即在出现异常的代码处生成对应异常类的对象，并将此异常抛出，一旦抛出，此程序不再执行其后代码<br>2 抓：针对过程中抛出的异常对象进行捕获处理。一旦将异常进行了处理，代码就可以继续执行（执行的是try-catch-finally结构结束后的语句而不是try的剩余语句）<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240709164203.png" alt="抓-抛"></p>
<p>基本结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    .....<span class="comment">//可能产生异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> e)&#123;</span><br><span class="line">    .....<span class="comment">//产生异常类型1时的处置措施</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> e)&#123;</span><br><span class="line">    .....<span class="comment">//产生异常类型2时的处置措施</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    .....<span class="comment">//无论是否发生异常都无条件执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将可能出现异常的代码声明在try语句中，针对try中抛出的异常类的对象，使用之后的catch语句进行匹配，一旦匹配进入其语句块进行处理，处理结束代码可继续向下执行。如果声明多个catch结构，不同的异常类型在不存在子父类关系的情况下，为并列关系；若满足子分类关系，必须将子类声明在父类上，否则会报错。 </p>
<p>catch中常见的异常处理方式：</p>
<ol>
<li>自己编写输出的语句</li>
<li>(推荐！)printStackTrace()，打印异常的详细信息（也是一种异常处理的方法，但实际没有处理）</li>
<li>getMessage()，获取发生异常的原因</li>
</ol>
<p>运行时异常的处理：开发中通常不进行显示处理，一旦程序出现此类隐藏，保存日志，根据异常提示信息修改代码即可<br>编译时异常的处理：必须处理，否则无法编译通过</p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>即使catch语句块中出现异常，也会执行finally中的语句<br>&#x3D;&#x3D;》将一定要执行的代码声明在finally结构中<br>&#x3D;&#x3D;》无论try或catch中是否存在仍未被处理的异常，无论try或catch中是否存在return语句(这种情况下先执行finally最后再执行return)等(除system.exit(0)外)，finally中声明的语句也一定会被执行<br>&#x3D;&#x3D;》finally语句是可选的，但不能单独存在，catch也是</p>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test(<span class="number">10</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (NumberFormatException e)&#123;</span><br><span class="line">        <span class="keyword">return</span> num--;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test结束&quot;</span>);</span><br><span class="line">        <span class="comment">// return ++num; //若为此句，则上文输出11</span></span><br><span class="line">        <span class="comment">//++num;          //若为此句，则上文输出10 --》这里的num和try中的return的num在内存中不是同一个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>必须声明在finally中的代码</strong>：在开发中一些资源（如输入输出流，数据库连接，Socket连接等），在使用结束后，必须显示地进行关闭操作，垃圾回收器不会自动回收这些资源，进而可能导致内存泄漏。</p>
<p>示例：实际开发中的finally应用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    FileInputStream fileInputStream;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// try中声明的变量只有try中可见--代码块&#123;&#125;</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">        fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);<span class="comment">//可能FileNotFoundException</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fileInputStream.read();<span class="comment">//可能IOException</span></span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>)data);</span><br><span class="line">            data = fileInputStream.read();<span class="comment">//可能IOException</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fileInputStream.close();//可能IOException</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (FileNotFoundException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;<span class="comment">//流资源的关闭操作必须放在finall</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fileInputStream!=<span class="literal">null</span>)</span><br><span class="line">                fileInputStream.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异常处理方式2-throws"><a href="#异常处理方式2-throws" class="headerlink" title="异常处理方式2 throws"></a>异常处理方式2 throws</h4><p>格式：在方法的声明处，使用”throws 异常类型1,异常类型2,…”<br>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException&#123;</span><br><span class="line">    FileInputStream fileInputStream;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">    fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);<span class="comment">//可能FileNotFoundException</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> fileInputStream.read();<span class="comment">//可能IOException</span></span><br><span class="line">    <span class="keyword">while</span> (data != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println((<span class="type">char</span>)data);</span><br><span class="line">        data = fileInputStream.read();<span class="comment">//可能IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用机制：</p>
<ol>
<li>向调用者抛出异常，实际本身没有处理，</li>
<li>如调用者仍没有解决异常，继续像其调用者抛出异常</li>
<li>直到某上级调用者使用try-catch-finally处理</li>
<li>至少在main()一层必须解决上抛的异常，不能再添加throws</li>
</ol>
<p>说明：</p>
<ul>
<li>(针对编译时异常)子类重写的方法可以抛出父类被重写方法同样的异常或是父类方法异常的子类，但不能抛父类没有的，可以用try-catch-finally直接解决</li>
</ul>
<h4 id="手动抛出异常对象"><a href="#手动抛出异常对象" class="headerlink" title="手动抛出异常对象"></a>手动抛出异常对象</h4><p>Java 中异常对象的生成有两种方式：</p>
<ul>
<li>由虚拟机<strong>自动生成</strong>：程序运行过程中，虚拟机检测到程序发生了问题，那么针对当前代码，就会在后台自动创建一个对应异常类的实例对象并抛出。</li>
<li>由开发人员<strong>手动创建</strong>：<code>new 异常类型([实参列表]);</code>，如果创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样，但是一旦throw抛出，就会对程序运行产生影响了。</li>
</ul>
<p>格式：<code>throw new 异常类名(参数);</code></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.register(<span class="number">10</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">        student.register(-<span class="number">11</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的id非法&quot;</span>);<span class="comment">//抛出的异常也要处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出如下：</span></span><br><span class="line"><span class="comment">Student&#123;id=10&#125;</span></span><br><span class="line"><span class="comment">Exception in thread &quot;main&quot; java.lang.RuntimeException: 输入的id非法</span></span><br><span class="line"><span class="comment">	at com.atguigu01.throwable.Student.register(ErrorTest.java:28)</span></span><br><span class="line"><span class="comment">	at com.atguigu01.throwable.ErrorTest.main(ErrorTest.java:17)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><br><br><br>throw语句抛出的异常对象，和JVM自动创建和抛出的异常对象一样。</p>
<ul>
<li>如果是编译时异常类型的对象，同样需要使用throws或者try…catch处理，否则编译不通过。</li>
<li>如果是运行时异常类型的对象，编译器不提示。</li>
<li>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误：</li>
</ul>
<p>使用注意：<br>无论是编译时异常类型的对象，还是运行时异常类型的对象，如果没有被try..catch合理的处理，都会导致程序崩溃。<br>throw语句会导致程序执行流程被改变，throw语句是明确抛出一个异常对象，因此它<code>下面的代码将不会执行</code>。<br>如果当前方法没有try…catch处理这个异常对象，throw语句就会<code>代替return语句</code>提前终止当前方法的执行，并返回一个异常对象给调用者。</p>
<h4 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h4><p>Java中不同的异常类，分别表示着某一种具体的异常情况。那么在开发中总是有些异常情况是核心类库中没有定义好的，此时我们需要根据自己业务的异常情况来定义异常类。例如年龄负数问题，考试成绩负数问题，某员工已在团队中等。为了达到<strong>见名知义</strong>的目的，可以自定义异常类</p>
<p>自定义异常方法：</p>
<ol>
<li>继承一个异常类型<ul>
<li>自定义一个编译时异常类型：自定义类继承<code>java.lang.Exception</code>。</li>
<li>自定义一个运行时异常类型：自定义类继承<code>java.lang.RuntimeException</code>。</li>
</ul>
</li>
<li>建议大家提供至少两个构造器，一个是无参构造，一个是(String message)构造器。</li>
<li>自定义异常需要提供<code>serialVersionUID</code></li>
</ol>
<p>示例：仿造异常类的设计</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">23423423435L</span>;<span class="comment">//待后续io流解释，不写自动分配，但会变</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> idnumber;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message, <span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.idnumber = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> idnumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意点：</p>
<ol>
<li>自定义的异常只能通过throw抛出。</li>
<li>自定义异常最重要的是异常类的名字和message属性。当异常出现时，可以根据名字判断异常类型。比如：<code>TeamException(&quot;成员已满，无法添加&quot;); </code>、 <code>TeamException(&quot;该员工已是某团队成员&quot;);</code></li>
<li>自定义异常对象只能手动抛出。抛出后由try..catch处理，也可以甩锅throws给调用者处理。</li>
</ol>
<h3 id="第10章-多线程"><a href="#第10章-多线程" class="headerlink" title="第10章_多线程"></a>第10章_多线程</h3><p>程序：为完成特定任务，用某种语言编写的<code>一组指令的集合</code>。即指<code>一段静态的代码</code>，静态对象。<br>进程：程序的一次执行过程，或是正在内存中运行的应用程序。如：运行中的QQ，运行中的网易音乐播放器。</p>
<ul>
<li>每个进程都有一个独立的内存空间，系统运行一个程序即是一个进程从创建、运行到消亡的过程。（生命周期）</li>
<li>程序是静态的，进程是动态的</li>
<li>不同的进程之间是不共享内存的。进程之间的数据交换和通信的成本很高。</li>
<li>进程作为<code>操作系统调度和分配资源的最小单位</code>（亦是系统运行程序的基本单位），系统在运行时会为每个进程分配不同的内存区域。</li>
<li>现代的操作系统，大都是支持多进程的，支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。</li>
</ul>
<p>线程：进程可进一步细化为线程，是程序内部的<code>一条执行路径</code>。一个进程中至少有一个线程。</p>
<ul>
<li>一个进程同一时间若<code>并行</code>执行多个线程，就是支持多线程的。</li>
<li>线程作为<code>CPU调度和执行的最小单位</code>。</li>
<li>一个进程中的多个线程共享相同的内存单元，它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来<code>安全的隐患</code>。</li>
<li>下图中，红框的蓝色区域为线程独享，黄色区域为线程共享。</li>
</ul>
<p>多线程的优点：</p>
<ol>
<li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li>
<li>提高计算机系统CPU的利用率</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li>
</ol>
<p>并行：指两个或多个事件在<code>同一时刻</code>发生（同时发生）。指在同一时刻，有<code>多条指令</code>在<code>多个CPU</code>上<code>同时</code>执行。比如：多个人同时做不同的事。<br>并发：指两个或多个事件在<code>同一个时间段内</code>发生。即在一段时间内，有<code>多条指令</code>在<code>单个CPU</code>上<code>快速轮换、交替</code>执行，使得在宏观上具有多个进程同时执行的效果。</p>
<p>Thread类的特性</p>
<ul>
<li>每个线程都是通过某个特定Thread对象的run()方法来完成操作的，因此把run()方法体称为<code>线程执行体</code>。</li>
<li>通过该Thread对象的start()方法来启动这个线程，而非直接调用run()</li>
<li>要想实现多线程，必须在主线程中创建新的线程对象。</li>
</ul>
<h4 id="线程的创建方式1-继承Thread类"><a href="#线程的创建方式1-继承Thread类" class="headerlink" title="线程的创建方式1:继承Thread类"></a>线程的创建方式1:继承Thread类</h4><p>步骤：</p>
<ol>
<li>定义Thread类的子类</li>
<li>重写Thread类的run()方法，该run()方法的方法体就代表了线程需要完成的任务</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<p>注意：</p>
<ol>
<li>此方法会导致线程类不能再继承其他类（类的单继承性）</li>
<li>必须使用对象.start()才是调用线程，对象.run()方法启动的不是多线程</li>
<li>已经执行start()方法的调用不能在使用对象.start()启动新进程，必须声明新的对象</li>
</ol>
<p>示例：两个线程，分别遍历100以内奇偶数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EvenNumberPrint</span> <span class="variable">evenNumberPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EvenNumberPrint</span>();</span><br><span class="line">        <span class="type">OddNumberPrint</span> <span class="variable">oddNumberPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OddNumberPrint</span>();</span><br><span class="line">        evenNumberPrint.start();</span><br><span class="line">        oddNumberPrint.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvenNumberPrint</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OddNumberPrint</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名子类的写法(简单但不符合阿里语法规范)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程的创建方式2-实现Runnable接口"><a href="#线程的创建方式2-实现Runnable接口" class="headerlink" title="线程的创建方式2:实现Runnable接口"></a>线程的创建方式2:实现Runnable接口</h4><p>步骤如下：</p>
<ol>
<li>定义Runnable接口的实现类</li>
<li>重写Runnable接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li>
<li>创建Runnable实现类的实例</li>
<li>将此实例作为Thread类构造器中的target参数来创建Thread对象，该Thread对象才是真正<br>的线程对象。</li>
<li>调用线程对象的start()方法，启动线程。调用Runnable接口实现类的run方法。</li>
</ol>
<p>示例：两个线程，分别遍历100以内奇偶数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">EvenNumberPrint</span> <span class="variable">evenNumberPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EvenNumberPrint</span>();</span><br><span class="line">        <span class="type">OddNumberPrint</span> <span class="variable">oddNumberPrint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OddNumberPrint</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(evenNumberPrint);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(oddNumberPrint);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EvenNumberPrint</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OddNumberPrint</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名类的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种创建线程的方式对比：<br>共同点：</p>
<ul>
<li>Thread类实际上也是实现了Runnable接口的类。即：    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br></pre></td></tr></table></figure></li>
<li>启动线程，使用的都是Thread类中定义的start()，创建的线程对象都是Thread类或其子类的实例。</li>
</ul>
<p>不同点：</p>
<ul>
<li>继承Thread：线程代码存放Thread子类run方法中。</li>
<li>实现Runnable：线程代码存在接口的子类的run方法。</li>
</ul>
<p><strong>实现Runnable接口比继承Thread类所具有的优势</strong></p>
<ul>
<li>避免了单继承的局限性</li>
<li>多个线程可以<strong>共享同一个接口实现类的对象</strong>，非常适合多个相同线程来处理同一份资源。</li>
<li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li>
</ul>
<h4 id="Thread中常用的方法"><a href="#Thread中常用的方法" class="headerlink" title="Thread中常用的方法"></a>Thread中常用的方法</h4><ol>
<li>构造器<ul>
<li>public Thread() :分配一个新的线程对象。</li>
<li>public Thread(String name) :分配一个指定名字的新的线程对象。</li>
<li>public Thread(Runnable target) :指定创建线程的目标对象，它实现了Runnable接口中的run方法</li>
<li>public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。</li>
</ul>
</li>
<li>常用方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> :此线程要执行的任务在此处定义代码。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> :导致此线程开始执行; Java虚拟机调用此线程的run方法。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> :获取当前线程名称。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>：设置该线程名称。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title function_">currentThread</span><span class="params">()</span> :返回对当前正在执行的线程对象的引用。在Thread子类中就是<span class="built_in">this</span>，通常用于主线程和Runnable实现类</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>：<span class="keyword">yield</span>只是让当前线程暂停一下，让系统的线程调度器重新调度一次，希望优先级与当前线程相同或更高的其他线程能够获得执行机会，但是这个不能保证，完全有可能的情况是，当某个线程调用了<span class="keyword">yield</span>方法暂停之后，线程调度器又将其调度出来重新执行。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isAlive</span><span class="params">()</span>：测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。 </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">join</span><span class="params">()</span> ：等待该线程终止。 </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span> ：等待该线程终止的时间最长为 millis 毫秒。如果millis时间到，将不再等待。 </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span> ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>：`已过时`，不建议使用。强行结束一个线程的执行，直接进入死亡状态。run()即刻停止，可能会导致一些清理性的工作得不到完成，如文件，数据库等的关闭。同时，会立即释放该线程所持有的所有的锁，导致数据得不到同步的处理，出现数据不一致的问题。</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">suspend</span><span class="params">()</span> / <span class="keyword">void</span> <span class="title function_">resume</span><span class="params">()</span> : 这两个操作就好比播放器的暂停和恢复。二者必须成对出现，否则非常容易发生死锁。suspend()调用会导致线程暂停，但不会释放任何锁资源，导致其它线程都无法访问被它占用的锁，直到调用resume()。`已过时`，不建议使用。</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="线程优先级和相关方法"><a href="#线程优先级和相关方法" class="headerlink" title="线程优先级和相关方法"></a>线程优先级和相关方法</h4><p>每个线程都有一定的优先级，同优先级线程组成先进先出队列（先到先服务），使用分时调度策略。优先级高的线程采用抢占式策略，获得较多的执行机会。每个线程默认的优先级都与创建它的父线程具有相同的优先级。</p>
<p>Thread类的三个优先级常量：</p>
<ul>
<li>MAX_PRIORITY（10）：最高优先级 </li>
<li>MIN _PRIORITY （1）：最低优先级</li>
<li>NORM_PRIORITY （5）：普通优先级，默认情况下main线程具有普通优先级。</li>
</ul>
<p>常用方法：</p>
<ul>
<li>public final int getPriority() ：返回线程优先级 </li>
<li>public final void setPriority(int newPriority) ：改变线程的优先级，范围在[1,10]之间。</li>
</ul>
<h4 id="线程的生命周期："><a href="#线程的生命周期：" class="headerlink" title="线程的生命周期："></a>线程的生命周期：</h4><p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240711161020.png" alt="JDK&lt;1.5进程生命周期示意图"></p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240711162142.png" alt="JDK&gt;=1.5进程生命周期示意图"><br>jdk1.5后把阻塞状态细分</p>
<h4 id="线程的安全问题和处理"><a href="#线程的安全问题和处理" class="headerlink" title="线程的安全问题和处理"></a>线程的安全问题和处理</h4><p>示例：售票</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindowTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SaleTicket</span> <span class="variable">saleTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SaleTicket</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(saleTicket,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(saleTicket,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(saleTicket,<span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">        thread.start();thread1.start();thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SaleTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售票，票号为&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出如下：三个窗口都卖出了100号的票(重票错票：多线程同时使用同一个资源或使用不存在的资源)</span></span><br><span class="line"><span class="comment">线程1售票，票号为100</span></span><br><span class="line"><span class="comment">线程2售票，票号为100</span></span><br><span class="line"><span class="comment">线程2售票，票号为98</span></span><br><span class="line"><span class="comment">线程3售票，票号为100</span></span><br><span class="line"><span class="comment">....</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure>
<p>synchronized解决了线程的安全问题，但导致在操作共享数据时实际上串行处理的，降低了性能</p>
<p>解决方案：使用线程的同步机制<br>同步代码块方案</p>
<ul>
<li>格式：synchronized(同步监视器){需要被同步的代码（即多线程操作的共享数据）}</li>
<li>需要被同步的代码在被某个线程执行过程中其他线程不能执行。</li>
<li>同步监视器即锁，可以使用<strong>任何一个类</strong>的对象存档，但多线程必须使用同一个同步监视器</li>
<li>在实现Runnable接口的方式中，同步监视器可以考虑使用this</li>
<li>在继承Thread类的方式中，同步监视器应当慎用this(指定的对象可能不一样)，可以考虑使用<code>当前类.class</code></li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SaleTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//任何一个类都行，也可以自己声明一个类</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="comment">//常用 synchronized (this)，这里的this是saleTicket</span></span><br><span class="line">                <span class="comment">//使用继承Thread类的方法实现多线程时，就不能使用this，因为this指定的对象不一样</span></span><br><span class="line">                <span class="comment">//   ==》 需要static 修饰上文的Obj对象</span></span><br><span class="line">                <span class="comment">//   ==》 或使用当前类.class即Window.class</span></span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售票，票号为&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步方法方案：若操作共享数据的代码完整地声明在一个方法中，我们就能将此方法直接声明为同步方法</p>
<ul>
<li>在这种方案中，非静态的同步方法，同步监视器默认是this</li>
<li>静态的同步方法，同步监视器默认是当前类本身</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SaleTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(isFlag)&#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售票，票号为&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                isFlag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="死锁和Lock-锁"><a href="#死锁和Lock-锁" class="headerlink" title="死锁和Lock(锁)"></a>死锁和Lock(锁)</h4><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就会形成线程的死锁<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240711201627.png" alt="死锁的概念"></p>
<p>死锁的四个条件：</p>
<ol>
<li>互斥</li>
<li>占用且等待</li>
<li>不可剥夺</li>
<li>循环等待</li>
</ol>
<p>死锁的解决：破环上诉四条件，一般是破坏2，3，4</p>
<ol>
<li>针对条件2 可以考虑一次性申请所有所需的资源，这样就不存在等待的问题。</li>
<li>针对条件3：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。</li>
<li>针对条件4：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。</li>
</ol>
<p>lock的使用</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//1. 必须保证多个线程共用一个lock实例，可以将此对象声明为static final</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">//2. 执行lock方法，锁定对共享资源的调用</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售票，票号为&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//3. 执行unlock方法，解锁对共享资源的调用</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized与Lock的对比</strong></p>
<ol>
<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域、遇到异常等自动解锁</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类），更体现面向对象。</li>
<li>（了解）Lock锁可以对读不加锁，对写加锁，synchronized不可以</li>
<li>（了解）Lock锁可以有多种获取锁的方式，可以从sleep的线程中抢到锁，synchronized不可以</li>
</ol>
<p>因此：开发建议中处理线程安全问题优先使用顺序为：Lock —-&gt; 同步代码块 —-&gt; 同步方法</p>
<h4 id="线程通信-等待唤醒机制"><a href="#线程通信-等待唤醒机制" class="headerlink" title="线程通信-等待唤醒机制"></a>线程通信-等待唤醒机制</h4><p>在一个线程满足某个条件时，就进入等待状态（<code>wait() / wait(time)</code>）， 等待其他线程执行完他们的指定代码过后再将其唤醒（<code>notify()</code>）;或可以指定wait的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果需要，可以使用 <code>notifyAll()</code>来唤醒所有的等待线程。wait&#x2F;notify 就是线程间的一种协作机制。</p>
<ol>
<li>wait：线程不再活动，不再参与调度，进入 <code>wait set</code>（等待状态） 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态是 WAITING 或 TIMED_WAITING。它还要等着别的线程执行一个<code>特别的动作</code>，也即“<code>通知（notify）</code>”或者等待时间到，在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（<code>ready queue</code>）中</li>
<li>notify：则选取所通知对象的 wait set 中的一个优先级最高的线程释放；如果多个优先级相同，随机释放一个</li>
<li>notifyAll：则释放所通知对象的 wait set 上的全部线程。</li>
</ol>
<p>注意：</p>
<ol>
<li>此三个方法必须使用在同步方法或同步代码块中，因为：必须要<code>通过锁对象</code>调用这2个方法。否则会报java.lang.IllegalMonitorStateException异常。lock需要配合Condition实现进程通信</li>
<li>此方法的<strong>调用者必须是同步监视器</strong>！！！</li>
<li>此三方法均定义在Object类中</li>
</ol>
<p>示例：打印1-100，两线程交替打印。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNumberTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNumber</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNumber</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(p,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        t1.start();t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintNumber</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line"></span><br><span class="line">                notify();<span class="comment">//唤醒，相当于this.notify()</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                        <span class="comment">//不会释放对同步监视器的调用</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + number);</span><br><span class="line">                    number++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                        <span class="comment">//线程一旦执行此方法，进入等待状态，同时会释放对同步监视器的调用</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerCustomerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line">        <span class="type">Producer</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Producer</span>(clerk);</span><br><span class="line"></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk);</span><br><span class="line"></span><br><span class="line">        p1.setName(<span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line">        c1.setName(<span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line">        c2.setName(<span class="string">&quot;消费者2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(Clerk clerk)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=========生产者开始生产产品========&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//要求clerk去增加产品</span></span><br><span class="line">            clerk.addProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=========消费者开始消费产品========&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">50</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//要求clerk去减少产品</span></span><br><span class="line">            clerk.minusProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">productNum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//产品数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_PRODUCT</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_PRODUCT</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(productNum &gt;= MAX_PRODUCT)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            productNum++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">&quot;生产了第&quot;</span> + productNum + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            <span class="comment">//唤醒消费者</span></span><br><span class="line">            <span class="built_in">this</span>.notifyAll();        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">minusProduct</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(productNum &lt; MIN_PRODUCT)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">&quot;消费了第&quot;</span> + productNum + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            productNum--;</span><br><span class="line">            notify();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程创建方式之Callable-了解"><a href="#线程创建方式之Callable-了解" class="headerlink" title="线程创建方式之Callable(了解)"></a>线程创建方式之Callable(了解)</h4><p><strong>Callable</strong></p>
<p>与使用Runnable相比， Callable功能更强大些</p>
<ul>
<li>相比run()方法，call()方法可以有返回值</li>
<li>方法可以使用throw的方式抛出异常</li>
<li>支持泛型的返回值（需要借助FutureTask类，获取返回结果）</li>
<li>缺点：在获取分线程执行结果的时候，当前线程（或是主线程）受阻塞，效率较低。</li>
</ul>
<p>Future接口（了解）</p>
<ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。</li>
<li>FutureTask是Futrue接口的唯一的实现类</li>
<li>FutureTask 同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
<p>代码举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//      接收返回值</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="线程创建方式之线程池"><a href="#线程创建方式之线程池" class="headerlink" title="线程创建方式之线程池"></a>线程创建方式之线程池</h4><p>如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。那么有没有一种办法使得线程可以复用，即执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p>
<p><strong>思路：</strong>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240711215500.png" alt="线程池的理解"></p>
<p><strong>好处：</strong></p>
<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>线程池相关API</strong></p>
<p>JDK5.0之前，我们必须手动自定义线程池。从JDK5.0开始，Java内置线程池相关的API。在java.util.concurrent包下提供了线程池相关API：<code>ExecutorService</code> 和 <code>Executors</code>。</p>
<ul>
<li><code>ExecutorService</code>：真正的线程池接口。常见子类ThreadPoolExecutor<ul>
<li><code>void execute(Runnable command)</code> ：执行任务&#x2F;命令，没有返回值，一般用来执行Runnable</li>
<li><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>：执行任务，有返回值，一般又来执行Callable</li>
<li><code>void shutdown()</code> ：关闭连接池</li>
</ul>
</li>
<li><code>Executors</code>：一个线程池的工厂类，通过此类的静态工厂方法可以创建多种类型的线程池对象。<ul>
<li><code>Executors.newCachedThreadPool()</code>：创建一个可根据需要创建新线程的线程池</li>
<li><code>Executors.newFixedThreadPool(int nThreads)</code>; 创建一个可重用固定线程数的线程池</li>
<li><code>Executors.newSingleThreadExecutor()</code> ：创建一个只有一个线程的线程池</li>
<li><code>Executors.newScheduledThreadPool(int corePoolSize)</code>：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</li>
</ul>
</li>
</ul>
<p><strong>代码举例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread2</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">evenSum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录偶数的和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                evenSum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> evenSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line"><span class="comment">//        //设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());//ThreadPoolExecutor</span></span><br><span class="line">        service1.setMaximumPoolSize(<span class="number">50</span>); <span class="comment">//设置线程池中线程数的上限</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Future</span> <span class="variable">future</span> <span class="operator">=</span> service.submit(<span class="keyword">new</span> <span class="title class_">NumberThread2</span>());<span class="comment">//适合使用于Callable</span></span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + future.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="第11章-常用类和基础API"><a href="#第11章-常用类和基础API" class="headerlink" title="第11章_常用类和基础API"></a>第11章_常用类和基础API</h3><h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><h5 id="相关声明"><a href="#相关声明" class="headerlink" title="相关声明"></a>相关声明</h5><p><strong>String类的声明</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence,</span><br><span class="line">               Constable, ConstantDesc</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>private意味着外面无法直接获取字符数组，而且String没有提供value的get和set方法。</li>
<li>final意味着字符数组的引用不可改变，而且String也没有提供方法来修改value数组某个元素值<br>因此字符串的字符数组内容也不可变的，即String代表着不可变的字符序列。即，一旦对字符串进行修改，就会产生新对象。</li>
<li>Serializable:可序列化的接口，凡是实现此接口的类的对象就可以通过网络或本地流进行数据传输</li>
<li>Comparable：凡是实现此接口的类，其对象都可以比较大小</li>
</ul>
<p><strong>String类的属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><strong>final</strong>：说明此数组一旦初始化，其地址就不可改变</li>
</ul>
<p>字符串常量的<strong>存储位置</strong></p>
<ul>
<li>字符串常量存储在字符串常量池(StringTable)中</li>
<li>字符串常量池不允许存放两个相同的字符串<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true，两个字符串的地址相同</span></span><br></pre></td></tr></table></figure></li>
<li>字符串常量池在不同jdk版本，存放位置不同<br>jdk&lt;7  存放在方法区<br>jdk&gt;&#x3D;7 存放在堆空间（为方便JC回收，方法区回收频率低）</li>
</ul>
<p><strong>String不可变性的理解</strong></p>
<ol>
<li>当对字符串变量重新赋值时，需要重新指定一个字符串常量的位置进行赋值，不能在原有位置修改</li>
<li>当对现有字符串进行拼接操作时，需要重新开辟空间保存拼接后的字符串，不能在原有位置修改</li>
<li>当调用字符串的replace()替换现有某个字符时，需要重新开辟空间保存修改以后的字符串，不能在原有位置修改</li>
<li>上述操作都是类中源码自主完成的，不需要使用String的程序员自主实现</li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712133305.png" alt="String不可变性的理解2"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712133441.png" alt="String不可变性的理解3"><br>(实际上上图中的0x1122是value数组的位置，value数组再指向字符串hello)   </p>
<p><strong>String实例化的两种方式</strong></p>
<ol>
<li><code>String s = new String(&quot;hello&quot;);</code> 创建了2个对象，一个是堆空间中new分配的，一个是字符串常量池中生成的字符串常量</li>
<li><code>String s = &quot;hello&quot;</code></li>
</ol>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712134227.png" alt="两种创建方式的不同地址"><br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712134802.png" alt="类中字符串的地址"></p>
<p><strong>String的连接操作+</strong></p>
<ol>
<li>常量 + 常量：转为字节码时会直接视为一个字符串，结果仍然存储在字符串常量池中(常量包括普通常量和final修饰的变量)</li>
<li>变量 + 变量;变量 + 常量: 都会通过new的方式创建一个新的字符串，返回堆空间中此字符串对象的地址</li>
<li>调用字符串的intern(): 返回字符串常量池中字面量的地址（存在返回已有，不存在新建再返回）</li>
<li>concat():不管常量还是变量调用此方法，参数不论是常量变量，都返回一个新new的对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;HelloWorld!&quot;</span>; <span class="comment">//直接在字符串常量池中创建一个字面量为&quot;HelloWorld!&quot;的字符串。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;World!&quot;</span>; <span class="comment">//s4指向字符串常量池中已经创建的&quot;HelloWorld!&quot;的字符串。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;World!&quot;</span>; <span class="comment">//字符串内容也是HelloWorld!，s1是常量，常量+ 常量 结果在常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s1 + s2; <span class="comment">//字符串内容也是HelloWorld!，s1和s2都是常量，常量+ 常量 结果在常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1.concat(s2);</span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s3.intern(); <span class="comment">// 堆空间的s3对象在调用intern()之后，会将常量池中已经存在的&quot;HelloWorld!&quot;字符串赋值给s8</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s9</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">s9 = s9 + <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"><span class="comment">// 实际上原来的“Hello”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s9+&quot;World!&quot;（也就是&quot;HelloWorld!&quot;)。</span></span><br><span class="line"><span class="comment">// 如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。</span></span><br><span class="line"><span class="comment">// 如果这样的操作放到循环中，会极大影响程序的性能。</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5); <span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s6); <span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s7); <span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s8); <span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s9); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>


<p><strong>String的构造器</strong></p>
<ul>
<li><code>public String() </code> ：初始化新创建的 String对象，以使其表示空字符序列。</li>
<li><code> String(String original)</code>： 初始化一个新创建的 <code>String</code> 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。</li>
<li><code>public String(char[] value) </code> ：通过当前参数中的字符数组来构造新的String。</li>
<li><code>public String(char[] value,int offset, int count) </code> ：通过字符数组的一部分来构造新的String。</li>
<li><code>public String(byte[] bytes) </code> ：通过使用平台的<strong>默认字符集</strong>解码当前参数中的字节数组来构造新的String。</li>
<li><code>public String(byte[] bytes,String charsetName) </code> ：通过使用指定的字符集解码当前参数中的字节数组来构造新的String。</li>
</ul>
<h5 id="String与其他类型之间的转换"><a href="#String与其他类型之间的转换" class="headerlink" title="String与其他类型之间的转换"></a>String与其他类型之间的转换</h5><p>String与包装类的转换（详见包装类章节）</p>
<p>String与char[]之间的转换</p>
<ol>
<li>String –&gt; char[]: <code>arr = str.toCharArray();</code></li>
<li>char[] –&gt; String: <code>str = new String(arr);</code></li>
</ol>
<p>String与byte[]之间的转换</p>
<ol>
<li>String –&gt; byte[]: <code>arr = str.getBytes();</code> &#x2F;&#x2F; 使用默认字符集转换<br>String –&gt; byte[]: <code>arr = str.getBytes(&quot;gbk&quot;);</code> &#x2F;&#x2F; 使用gbk字符集<br>UTF-8中兼容了ASCII码，一个字母占一个字节，一个汉字占3字节<br>gbk中兼容了ASCII码，一个字母占一个字节，一个汉字占2字节</li>
<li>byte[] –&gt; String: <code>str = new String(arr);</code><br>               <code>str = new String(arr,&quot;gbk&quot;);</code></li>
<li>解码和编码时使用的字符集必须一致，否则会报错</li>
</ol>
<h5 id="String-中的常用方法"><a href="#String-中的常用方法" class="headerlink" title="String 中的常用方法"></a>String 中的常用方法</h5><p><strong>比较，转换，拼接，空格</strong></p>
<ol>
<li>boolean isEmpty()：字符串是否为空</li>
<li>int length()：返回字符串的长度</li>
<li>String concat(xx)：拼接</li>
<li>boolean equals(Object obj)：比较字符串是否相等，区分大小写</li>
<li>boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写</li>
<li>int compareTo(String other)：比较字符串大小，区分大小写，<strong>按照Unicode编码值</strong>比较大小</li>
<li>int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写</li>
<li>String toLowerCase()：将字符串中大写字母转为小写</li>
<li>String toUpperCase()：将字符串中小写字母转为大写</li>
<li>String trim()：去掉字符串前后空白符</li>
<li>public String intern()：结果在常量池中共享</li>
</ol>
<p><strong>查找</strong></p>
<ol>
<li>boolean contains(xx)：是否包含x</li>
<li>int indexOf(xx)：从前往后找当前字符串中xx，即如果有返回第一次出现的下标，要是没有返回-1</li>
<li>int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</li>
<li>int lastIndexOf(xx)：从后往前找当前字符串中xx，即如果有返回最后一次出现的下标，要是没有返回-1</li>
<li>int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</li>
</ol>
<p><strong>字符串截取</strong></p>
<ol>
<li>String substring(int beginIndex) ：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符</li>
<li>String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</li>
</ol>
<p><strong>字符&#x2F;字符数组相关</strong></p>
<ol>
<li>char charAt(index)：返回[index]位置的字符</li>
<li>char[] toCharArray()： 将此字符串转换为一个新的字符数组返回</li>
<li>static String valueOf(char[] data)  ：返回指定数组中表示该字符序列的 String</li>
<li>static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String</li>
<li>static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String</li>
<li>static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的 String</li>
</ol>
<p><strong>开头与结尾</strong></p>
<ol>
<li>boolean startsWith(xx)：测试此字符串是否以指定的前缀开始 </li>
<li>boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</li>
<li>boolean endsWith(xx)：测试此字符串是否以指定的后缀结束</li>
</ol>
<p><strong>替换</strong></p>
<ol>
<li>String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 不支持正则。</li>
<li>String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 </li>
<li>String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 </li>
<li>String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</li>
</ol>
<h5 id="StringBuffer-StringBuilder"><a href="#StringBuffer-StringBuilder" class="headerlink" title="StringBuffer StringBuilder"></a>StringBuffer StringBuilder</h5><p>三者比较</p>
<ol>
<li>String: 不可变的字符序列; </li>
<li>StringBuffer: 可变字符序列; 线程安全; 效率低; </li>
<li>StringBuilder: 可变字符序列; 线程不安全; 效率高; </li>
<li>jdk&lt;8, 底层均使用char[]; jdk&gt;&#x3D;8 底层均使用byte[]</li>
<li>效率比较(尤其增删改)：StringBuilder &gt; StringBuffer &gt; String</li>
</ol>
<p>StringBuilder(jdk&lt;8)内部属性和方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>[] value; <span class="comment">//存储字符序列 没有final修饰！</span></span><br><span class="line"><span class="type">int</span> count; <span class="comment">//实际存储的字符个数</span></span><br></pre></td></tr></table></figure>

<p>StringBuilder使用<strong>可变性分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 底层实现char[] value = new char[16];</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(); <span class="comment">// 底层实现char[] value = new char[16 + &quot;abc&quot;.length];</span></span><br></pre></td></tr></table></figure>
<p>使用.append()方法添加字符串时，当添加超过16个字符时(count&gt;value.length)，需要扩容，重新创建一个数组，默认容量为原有容量的2倍+2，并将原value数组中的元素复制到新的数组中</p>
<p><strong>开发使用建议</strong></p>
<ol>
<li>如果开发中需要频繁针对字符串进行<strong>增删改</strong>操作，建议使用<strong>StringBuilder和StringBuffer</strong>取代String，避免频繁创建新对象降低效率</li>
<li>如果开发中<strong>不涉及线程安全</strong>问题，建议使用<strong>StringBuilder</strong>替换StringBuffer，效率更高</li>
<li>如果开发中大体<strong>确认要操作的字符的个数</strong>，建议<strong>使用带int capacity参数的构造器</strong>，可以避免底层多层扩容操作降低效率</li>
</ol>
<p><strong>常用方法</strong><br>增、删、改、查、插入、长度、反转<br>（1）StringBuffer append(xx)：提供了很多的append()方法，用于进行字符串追加的方式拼接<br>（2）StringBuffer delete(int start, int end)：删除[start,end)之间字符<br>（3）StringBuffer deleteCharAt(int index)：删除[index]位置字符<br>（4）StringBuffer replace(int start, int end, String str)：替换[start,end)范围的字符序列为str<br>（5）void setCharAt(int index, char c)：替换[index]位置字符<br>（6）char charAt(int index)：查找指定index位置上的字符<br>（7）StringBuffer insert(int index, xx)：在[index]位置插入xx<br>（8）int length()：返回存储的字符数据的长度<br>（9）StringBuffer reverse()：反转<br>查、截取<br>（1）int indexOf(String str)：在当前字符序列中查询str的第一次出现下标<br>（2）int indexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的第一次出现下标<br>（3）int lastIndexOf(String str)：在当前字符序列中查询str的最后一次出现下标<br>（4）int lastIndexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的最后一次出现下标<br>（5）String substring(int start)：截取当前字符序列[start,最后]<br>（6）String substring(int start, int end)：截取当前字符序列[start,end]<br>（7）String toString()：返回此序列中数据的字符串表示形式<br>（8）void setLength(int newLength) ：设置当前字符序列长度为newLength，多出部分忽略，少的以’\0’填充，</p>
<p>多看题！！<br>new会分配新地址，String改会new!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(str);<span class="comment">// 源码上处理机制就是如果是null之间按字符串处理</span></span><br><span class="line">System.out,println(sb.length());<span class="comment">//4</span></span><br><span class="line">System.out,println(sb)<span class="comment">//&quot;null&quot; </span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(sb);<span class="comment">//报错</span></span><br><span class="line">System.out,println(sb1);<span class="comment">//空指针异常</span></span><br></pre></td></tr></table></figure>

<h4 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h4><h5 id="jdk"><a href="#jdk" class="headerlink" title="jdk&lt;8 API"></a>jdk&lt;8 API</h5><p>System类提供的<code>public static long currentTimeMillis()</code>：</p>
<ul>
<li>用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</li>
<li>此方法适于计算时间差。</li>
</ul>
<p><strong>util.Date</strong><br>同样相对于1970年1月1日0时0分0秒</p>
<ul>
<li>构造器：</li>
</ul>
<ul>
<li>Date()：使用无参构造器创建的对象可以获取本地当前时间。</li>
<li>Date(long 毫秒数)：把该毫秒值换算成日期时间对象</li>
</ul>
<ul>
<li>常用方法</li>
</ul>
<ul>
<li>getTime(): 返回自 1970 年 1 月 1 日 00:00:00 GMT 以来此 Date 对象表示的毫秒数。</li>
<li>toString(): 把此 Date 对象转换为以下形式的 String： dow mon dd hh:mm:ss zzz yyyy 其中： dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准。</li>
<li>其它很多方法都过时了。</li>
</ul>
<p><strong>sql.Date</strong></p>
<ul>
<li>对应数据库中的date类型数据</li>
<li><code>java.sql.Date date1 = new java.sql.Date(1370020020220L);</code></li>
<li>util.Date-&gt;sql.Date:<br>Date date1 &#x3D; new Date();<br>java.sql.Date date &#x3D; new java.sql.Date(date1.getTime());</li>
</ul>
<p><strong>text.SimpleDateFormat</strong><br>用于日期时间的格式化(日期-&gt;字符串)和解析(字符串-&gt;日期)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();<span class="comment">// 默认格式2024/7/12 下午6:48</span></span><br><span class="line"><span class="comment">// 也可使用以下构造器格式化，日期将按指定的格式显示，字母含义可见其具体说明文档（点击可见）</span></span><br><span class="line"><span class="comment">// SimpleDateFormat sdf = new SimpleDateFormat(&quot;EEE, d MMM yyyy HH:mm:ss Z&quot;);</span></span><br><span class="line"><span class="comment">// 周五, 12 7月 2024 18:52:40 +0800</span></span><br><span class="line"><span class="comment">// 常用SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">strDate</span> <span class="operator">=</span> sdf.format(date1);</span><br><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    date2 = sdf.parse(<span class="string">&quot;22/12/4 下午3:22&quot;</span>);</span><br><span class="line">    <span class="comment">// 默认必须按此格式，必须使用try-catch包围</span></span><br><span class="line">    <span class="comment">// 如上文采用第二种方式，则应按指定格式输入</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(strDate);</span><br><span class="line">System.out.println(date2);</span><br></pre></td></tr></table></figure>


<p><strong>util.Calendar</strong><br>jdk8后大部分Date的方法都被calendar中方法替代<br>使用步骤：</p>
<ol>
<li>实例化：由于Calendar是抽象类，需要创建其子类实例，通过Calendar.getInstance()获取</li>
<li>一个Calendar的实例是系统时间的抽象表示，可以修改或获取 YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND等 <code>日历字段</code>对应的时间值。</li>
</ol>
<ul>
<li>public int get(int field)：返回给定日历字段的值</li>
<li>public void set(int field,int value) ：将给定的日历字段设置为指定的值</li>
<li>public void add(int field,int amount)：根据日历的规则，为给定的日历字段添加或者减去指定的时间量</li>
<li>public final Date getTime()：将Calendar转成Date对象</li>
<li>public final void setTime(Date date)：使用指定的Date对象重置Calendar的时间</li>
</ul>
<h4 id="jdk-8-API"><a href="#jdk-8-API" class="headerlink" title="jdk&gt;8 API"></a>jdk&gt;8 API</h4><p>以往时间API的缺点：</p>
<ol>
<li>可变性：日期时间应当是不可变的，修改应当生成新对象</li>
<li>偏移性：年是从1970年开始，月份是从0开始，表示2022需要设置2022-1970&#x3D;52</li>
<li>格式化：格式化只对Date有用，Calendar不行</li>
<li>线程不安全，不能处理闰秒</li>
</ol>
<p>新的日期时间API包括：</p>
<ul>
<li><code>java.time</code> – 包含值对象的基础包</li>
<li><code>java.time.chrono</code> – 提供对不同的日历系统的访问。</li>
<li><code>java.time.format</code> – 格式化和解析时间和日期</li>
<li><code>java.time.temporal</code> – 包括底层框架和扩展特性</li>
<li><code>java.time.zone</code> – 包含时区支持的类</li>
</ul>
<p>新的 java.time 中包含了所有关于时钟（Clock），本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。</p>
<p><strong>本地日期时间：LocalDate、LocalTime、LocalDateTime</strong><br>类似Calendar</p>
<table>
<thead>
<tr>
<th>方法</th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>now() </code>&#x2F; now(ZoneId zone)</td>
<td>静态方法，根据当前时间创建对象&#x2F;指定时区的对象</td>
</tr>
<tr>
<td><code>of(xx,xx,xx,xx,xx,xxx)</code></td>
<td>静态方法，根据指定日期&#x2F;时间创建对象，无需相对1970偏移，输入什么时间就是什么时间</td>
</tr>
<tr>
<td>getDayOfMonth()&#x2F;getDayOfYear()</td>
<td>获得月份天数(1-31) &#x2F;获得年份天数(1-366)</td>
</tr>
<tr>
<td>getDayOfWeek()</td>
<td>获得星期几(返回一个 DayOfWeek 枚举值)</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获得月份, 返回一个 Month 枚举值</td>
</tr>
<tr>
<td>getMonthValue() &#x2F; getYear()</td>
<td>获得月份(1-12) &#x2F;获得年份</td>
</tr>
<tr>
<td>getHours()&#x2F;getMinute()&#x2F;getSecond()</td>
<td>获得当前对象对应的小时、分钟、秒</td>
</tr>
<tr>
<td>withDayOfMonth()&#x2F;withDayOfYear()&#x2F;withMonth()&#x2F;withYear()</td>
<td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td>
</tr>
<tr>
<td>with(TemporalAdjuster  t)</td>
<td>将当前日期时间设置为校对器指定的日期时间</td>
</tr>
<tr>
<td>plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</td>
<td>向当前对象添加几天、几周、几个月、几年、几小时</td>
</tr>
<tr>
<td>minusMonths() &#x2F; minusWeeks()&#x2F;minusDays()&#x2F;minusYears()&#x2F;minusHours()</td>
<td>从当前对象减去几月、几周、几天、几年、几小时</td>
</tr>
<tr>
<td>plus(TemporalAmount t)&#x2F;minus(TemporalAmount t)</td>
<td>添加或减少一个 Duration 或 Period</td>
</tr>
<tr>
<td>isBefore()&#x2F;isAfter()</td>
<td>比较两个 LocalDate</td>
</tr>
<tr>
<td>isLeapYear()</td>
<td>判断是否是闰年（在LocalDate类中声明）</td>
</tr>
<tr>
<td>format(DateTimeFormatter  t)</td>
<td>格式化本地日期、时间，返回一个字符串</td>
</tr>
<tr>
<td>parse(Charsequence text)</td>
<td>将指定格式的字符串解析为日期、时间</td>
</tr>
</tbody></table>
<p><strong>Instant</strong>类似Date<br>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间戳。时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</p>
<ul>
<li><code>java.time.Instant</code>表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，<code>它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。</code></li>
</ul>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>now()</code></td>
<td>静态方法，返回默认UTC时区的Instant类的对象</td>
</tr>
<tr>
<td><code>ofEpochMilli(long epochMilli)</code></td>
<td>静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象</td>
</tr>
<tr>
<td>atOffset(ZoneOffset offset)</td>
<td>结合即时的偏移来创建一个 OffsetDateTime</td>
</tr>
<tr>
<td><code>toEpochMilli()</code></td>
<td>返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳</td>
</tr>
</tbody></table>
<p><strong>DateTimeFormatter</strong></p>
<p>该类提供了三种格式化方法：</p>
<ul>
<li>(了解)预定义的标准格式。如：ISO_LOCAL_DATE_TIME、ISO_LOCAL_DATE、ISO_LOCAL_TIME</li>
<li>(了解)本地化相关的格式。如：ofLocalizedDate(FormatStyle.LONG)</li>
<li>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</li>
</ul>
<table>
<thead>
<tr>
<th><strong>方</strong>   <strong>法</strong></th>
<th><strong>描</strong>   <strong>述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>ofPattern(String</strong>  <strong>pattern)</strong></td>
<td>静态方法，返回一个指定字符串格式的DateTimeFormatter</td>
</tr>
<tr>
<td><strong>format(TemporalAccessor</strong> <strong>t)</strong></td>
<td>格式化一个日期、时间，返回字符串</td>
</tr>
<tr>
<td><strong>parse(CharSequence</strong>  <strong>text)</strong></td>
<td>将指定格式的字符序列解析为一个日期、时间</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//方式三：自定义的方式（关注、重点）</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy/MM/dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line"><span class="type">String</span> <span class="variable">strDateTime</span> <span class="operator">=</span> dateTimeFormatter.format(LocalDateTime.now());</span><br><span class="line">System.out.println(strDateTime); <span class="comment">//2022/12/04 21:05:42</span></span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> dateTimeFormatter.parse(<span class="string">&quot;2022/12/04 21:05:42&quot;</span>);</span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.from(accessor);</span><br><span class="line">System.out.println(localDateTime); <span class="comment">//2022-12-04T21:05:42</span></span><br></pre></td></tr></table></figure>

<h4 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h4><h5 id="Comparable-自然排序"><a href="#Comparable-自然排序" class="headerlink" title="Comparable 自然排序"></a>Comparable 自然排序</h5><p>实现Comparable接口中的compareTo方法：<br>实现步骤：</p>
<ol>
<li>具体的类A实现Comparable接口</li>
<li>重写Comparable接口中的compareTo()方法，此方法指明比较类A的对象的大小的标准(可以用.compare()方法)</li>
<li>创建类A的多个实例，进行比较或排序</li>
<li>(此后使用sort()方法排序时默认即会按上述标准，也可调用compareTo比较二者)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照价格，比较商品的大小</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">other</span> <span class="operator">=</span> (Goods) o;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(<span class="built_in">this</span>.price,other.price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造器、getter、setter、toString()方法略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComparableTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Goods[] all = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">4</span>];</span><br><span class="line">        all[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;War and Peace&quot;</span>, <span class="number">100</span>);</span><br><span class="line">        all[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Childhood&quot;</span>, <span class="number">80</span>);</span><br><span class="line">        all[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Scarlet and Black&quot;</span>, <span class="number">140</span>);</span><br><span class="line">        all[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Notre Dame de Paris&quot;</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(all);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(all));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Comparator-定制排序"><a href="#Comparator-定制排序" class="headerlink" title="Comparator 定制排序"></a>Comparator 定制排序</h5><p>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码（例如：一些第三方的类，你只有.class文件，没有源文件）<br>如果一个类，实现了Comparable接口，也指定了两个对象的比较大小的规则，但是此时此刻我不想按照它预定义的方法比较大小，但是我又不能随意修改，因为会影响其他地方的使用，怎么办？</p>
<p>java.util.Comparator接口，强行对多个对象进行整体排序的比较。</p>
<ul>
<li>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li>
<li>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort），从而允许在排序顺序上实现精确控制。</li>
</ul>
<p>实现步骤：</p>
<ol>
<li>创建一个实现Comparator接口的实现类A</li>
<li>实现类A要求重写重写Comparator接口中的compare()方法，此方法指明要比较的对象的大小的标准</li>
<li>创建此实现类A的对象，并将此对象传入到相关方法的参数位置即可（如Array.sort(..,类A的实例)）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Goods[] all = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">4</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;War and Peace&quot;</span>, <span class="number">100</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Childhood&quot;</span>, <span class="number">80</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Scarlet and Black&quot;</span>, <span class="number">140</span>);</span><br><span class="line">all[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;Notre Dame de Paris&quot;</span>, <span class="number">120</span>);</span><br><span class="line"></span><br><span class="line">Arrays.sort(all, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;<span class="comment">//匿名实现类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods) o1;</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods) o2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(all));</span><br></pre></td></tr></table></figure>

<h4 id="其他常见类"><a href="#其他常见类" class="headerlink" title="其他常见类"></a>其他常见类</h4><h5 id="System"><a href="#System" class="headerlink" title="System"></a>System</h5><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于<code>java.lang包</code>。<br>由于该类的构造器是private的，所以无法创建该类的对象。其内部的成员变量和成员方法都是<code>static的</code>，所以也可以很方便的进行调用。</p>
<p>成员变量<br>System类内部包含<code>in</code>、<code>out</code>和<code>err</code>三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</p>
<p>成员方法</p>
<ul>
<li><code>native long currentTimeMillis()</code>：<br>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</li>
<li><code>void exit(int status)</code>：<br>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</li>
<li><code>void gc()</code>：<br>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</li>
<li><code>String getProperty(String key)</code>：<br>该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240712210402.png" alt="系统属性值表"></li>
<li><code>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：<br>从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。常用于数组的插入和删除</li>
</ul>
<h5 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h5><p>每个 Java 应用程序都有一个 <code>Runtime</code> 类实例，使应用程序能够与其运行的环境相连接。</p>
<p><code>public static Runtime getRuntime()</code>： 返回与当前 Java 应用程序相关的运行时对象。应用程序不能创建自己的 Runtime 类实例。<br><code>public long totalMemory()</code>：返回 Java 虚拟机中初始化时的内存总量。此方法返回的值可能随时间的推移而变化，这取决于主机环境。默认为物理电脑内存的1&#x2F;64。<br><code>public long maxMemory()</code>：返回 Java 虚拟机中最大程度能使用的内存总量。默认为物理电脑内存的1&#x2F;4。<br><code>public long freeMemory()</code>：回 Java 虚拟机中的空闲内存量。调用 gc 方法可能导致 freeMemory 返回值的增加。</p>
<h5 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h5><p><code>java.lang.Math</code> 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。类似这样的工具类，其所有方法均为静态方法，并且不会创建对象，调用起来非常简单。</p>
<p><code>public static double abs(double a) </code> ：返回 double 值的绝对值。<br><code>public static double ceil(double a)</code> ：返回大于等于参数的最小的整数。<br><code>public static double floor(double a) </code> ：返回小于等于参数最大的整数。<br><code>public static long round(double a)</code> ：返回最接近参数的 long，.5向大数取。(相当于四舍五入方法)<br> 注意round(-12.5)&#x3D;-12 round(-12.6)&#x3D;-13 round(12.5)&#x3D;13<br><code>public static double random()</code>：返回[0,1]的随机值<br>public static double pow(double a,double b)：返回a的b幂次方法<br>public static double sqrt(double a)：返回a的平方根<br>public static final double PI：返回圆周率<br>public static double max(double x, double y)：返回x,y中的最大值<br>public static double min(double x, double y)：返回x,y中的最小值<br>其它：acos,asin,atan,cos,sin,tan 三角函数</p>
<h5 id="BigInteger、BigDecimal"><a href="#BigInteger、BigDecimal" class="headerlink" title="BigInteger、BigDecimal"></a>BigInteger、BigDecimal</h5><p>Integer类作为int的包装类，能存储的最大整型值为2^31-1，Long类也是有限的，最大为2^63-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。<br>任意精度的整数和浮点数<br>java.math.BigInteger<br>java.math.BigDecimal</p>
<p><strong>BigInteger</strong><br>java.math包的BigInteger可以表示<code>不可变的任意精度的整数</code>。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。 </p>
<p>构造器<br>BigInteger(String val)：根据字符串构建BigInteger对象</p>
<p>方法</p>
<ul>
<li>public BigInteger <code>abs</code>()：返回此 BigInteger 的绝对值的 BigInteger。</li>
<li>BigInteger <code>add</code>(BigInteger val) ：返回其值为 (this + val) 的 BigInteger</li>
<li>BigInteger <code>subtract</code>(BigInteger val) ：返回其值为 (this - val) 的 BigInteger</li>
<li>BigInteger <code>multiply</code>(BigInteger val) ：返回其值为 (this * val) 的 BigInteger</li>
<li>BigInteger <code>divide</code>(BigInteger val) ：返回其值为 (this &#x2F; val) 的 BigInteger。整数相除只保留整数部分。</li>
<li>BigInteger <code>remainder</code>(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。</li>
<li>BigInteger[] <code>divideAndRemainder</code>(BigInteger val)：返回包含 (this &#x2F; val) 后跟 (this % val) 的两个 BigInteger 的数组。</li>
<li>BigInteger <code>pow</code>(int exponent) ：返回其值为 (this^exponent) 的 BigInteger。</li>
</ul>
<p><strong>BigDecimal</strong><br>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p>
<p>构造器</p>
<ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal(String val) –&gt; 推荐</li>
</ul>
<p>常用方法</p>
<ul>
<li>public BigDecimal <code>add</code>(BigDecimal augend)</li>
<li>public BigDecimal <code>subtract</code>(BigDecimal subtrahend)</li>
<li>public BigDecimal <code>multiply</code>(BigDecimal multiplicand)</li>
<li>public BigDecimal <code>divide</code>(BigDecimal divisor, int scale, int roundingMode)：divisor是除数，scale指明保留几位小数，roundingMode指明舍入模式（ROUND_UP :向上加1、ROUND_DOWN :直接舍去、ROUND_HALF_UP:四舍五入）</li>
</ul>
<h5 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h5><p>用于产生随机数</p>
<ul>
<li><code>boolean nextBoolean()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean 值。 </li>
<li><code>void nextBytes(byte[] bytes)</code>:生成随机字节并将其置于用户提供的 byte 数组中。 </li>
<li><code>double nextDouble()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 double 值。 </li>
<li><code>float nextFloat()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 float 值。 </li>
<li><code>double nextGaussian()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的、呈高斯（“正态”）分布的 double 值，其平均值是 0.0，标准差是 1.0。 </li>
<li><code>int nextInt()</code>:返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。 </li>
<li><code>int nextInt(int n)</code>:返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值。 </li>
<li><code>long nextLong()</code>:返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。</li>
</ul>
<hr>
<h3 id="第12章-集合框架"><a href="#第12章-集合框架" class="headerlink" title="第12章_集合框架"></a>第12章_集合框架</h3><p>数组的特点及其弊端：</p>
<ol>
<li>数组一旦初始化，长度即确定，不可更改</li>
<li>数组的多个元素是依次紧密排序的，有序，可重复的，无法存储无序不可重复数据</li>
<li>数组可用的方法属性较少</li>
<li>（优点）数组一旦初始化完成，其元素类型即确定，不是此类不可添加（可以声明Object数组存放多种数据类型数据）</li>
<li>插入，删除操作性能差</li>
</ol>
<p>Java集合框架</p>
<p>java.util.Collection存储一个一个的数据<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240713170651.png" alt="Collection接口继承树"></p>
<ul>
<li>子接口List：存储有序可重复的数据(动态数组，可自动扩容)<ul>
<li>ArrayList：主要实现类，线程不安全但效率高；底层使用<strong>object[]数组</strong>存储，利于<strong>查询尾部添加和删除</strong></li>
<li>LinkedList：底层使用<strong>双向链表</strong>的方式进行存储，有利于<strong>随机插入，删除，修改</strong></li>
<li>Vector：过时实现类，线程安全效率低；底层使用<strong>object[]数组</strong>存储</li>
</ul>
</li>
<li>子接口Set:存储无序的不可重复的数据(集合)<ul>
<li>HashSet：主要实现类；不能保证元素的排列顺序，线程不安全，元素可以是null，底层使用HashMap，即使用数组+单向链表+红黑树结构存储(jdk&gt;&#x3D;8)<ul>
<li>LinkedHashSet：HashSet的子类，在HashSet的基础上添加了一组双向链表以记录添加元素的先后顺序，即可以按照添加元素的顺序遍历</li>
</ul>
</li>
<li>TreeSet：底层使用红黑树存储，可以按照添加元素的指定的属性的大小顺序进行遍历，需要考虑使用自然排序和定制排序，添加的key元素必须是同一类型</li>
</ul>
</li>
</ul>
<p>java.util.Map:存储一对一对的数据(key-value键值对)<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240713170738.png" alt="Map接口继承树"></p>
<ul>
<li>HashMap：主要实现类，线程不安全，效率高，可以添加null的key&#x2F;value值，使用数组+单向链表+红黑树结构存储(jdk&gt;&#x3D;8)<ul>
<li>LinkedHashMap：HashMap的子类，在HashMap的基础上添加了一组双向链表以记录添加元素的先后顺序，即可以按照添加元素的顺序遍历，频繁遍历建议使用此类</li>
</ul>
</li>
<li>Hashtable：过时实现类，线程安全，效率低，不可添加null的key&#x2F;value值，使用数组+单向链表结构存储<ul>
<li>Properties：其key和value都是String类型，常用于处理属性文件</li>
</ul>
</li>
<li>TreeMap：底层使用红黑树存储，可以按照添加key-value中的key元素的指定的属性的大小顺序进行遍历，需要考虑使用自然排序和定制排序，添加的元素必须是同一类型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240713170456.png" alt="学习目标"></p>
<h4 id="Collection接口常用方法"><a href="#Collection接口常用方法" class="headerlink" title="Collection接口常用方法"></a>Collection接口常用方法</h4><p>JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List）去实现，该接口里定义的方法既可用于操作 Set 集合，也可用于操作 List 集合。方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    collection.add(p1);</span><br><span class="line">    collection.add(<span class="number">11</span>);<span class="comment">//操作基本数据类型时存在自动装箱</span></span><br><span class="line">    collection1.add(collection);</span><br><span class="line"></span><br><span class="line">    System.out.println(collection.isEmpty());</span><br><span class="line">    System.out.println(collection.contains(<span class="string">&quot;aa&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><strong>添加</strong><br>（1）<code>add(E obj)</code>：添加元素对象到当前集合中<br>（2）addAll(Collection other)：添加other集合中的所有元素对象到当前集合中，即this &#x3D; this ∪ other<br>注意：使用add(Collection other)将把other集合作为一个整体元素添加到当前集合中</p>
<p><strong>判断</strong><br>（3）int size()：获取当前集合中实际存储的元素个数<br>（4）boolean isEmpty()：判断当前集合是否为空集合<br>（5）<code>boolean contains(Object obj)</code>：判断当前集合中是否存在一个obj对象equals返回true的元素，对于内置数据类型，比较的是实际内容而不是地址，对于自定义类的对象，需要重写equals()方法，否则比较地址<br>（6）boolean containsAll(Collection coll)：判断coll集合中的元素是否在当前集合中都存在。即coll集合是否是当前集合的“子集”<br>（7）boolean equals(Object obj)：判断当前集合与obj是否相等（很少用）</p>
<p><strong>删除</strong><br>（8）void clear()：清空集合元素（逐个置为null）<br>（9） <code>boolean remove(Object obj)</code> ：从当前集合中删除第一个找到的与obj对象equals返回true的元素。底层调用了equals()方法，因此自定义类删除需要重写equals()方法<br>（10）boolean removeAll(Collection coll)：从当前集合中删除所有与coll集合中相同的元素。即this &#x3D; this - this ∩ coll<br>（11）boolean retainAll(Collection coll)：从当前集合中删除两个集合中不同的元素，使得当前集合仅保留与coll集合中的元素相同的元素，即当前集合中仅保留两个集合的交集，即this  &#x3D; this ∩ coll；</p>
<p><strong>其它</strong><br>（12）<code>Object[] toArray()</code>：返回包含当前集合中所有元素的数组 集合 –&gt; 数组<br>（13）hashCode()：获取集合对象的哈希值<br>（14）iterator()：返回迭代器对象，用于集合遍历<br>相关方法：数组 –&gt; 集合 数组中asList()方法，返回List型对象<br>Arrays.asList(…) 方法返回的 List 集合，既不是 ArrayList 实例，也不是 Vector 实例。 Arrays.asList(…) 返回值是一个固定长度的 List 集合<br>需要注意：asList()方法参数是对象，不能传入基本数据类型，因此：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Arrays.asList(arr1);<span class="comment">// 存入数组的起始地址</span></span><br><span class="line">System.out.println(list1.size());<span class="comment">//1，</span></span><br><span class="line"></span><br><span class="line">Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr);<span class="comment">//自动装箱</span></span><br><span class="line">System.out.println(list.size());<span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p><strong>Collection使用要求</strong><br>向Collection中添加元素时必须重写其中的equals()方法，因为其中许多方法隐式调用了equals()方法</p>
<h5 id="List子接口常用方法"><a href="#List子接口常用方法" class="headerlink" title="List子接口常用方法"></a>List子接口常用方法</h5><p>存储有序的可以重复的数据</p>
<p><strong>插入元素</strong></p>
<ul>
<li><code>void add(int index, Object ele)</code>:在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来<br><strong>获取元素</strong></li>
<li><code>Object get(int index)</code>:获取指定index位置的元素</li>
<li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合<br><strong>获取元素索引</strong></li>
<li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置<br><strong>删除和替换元素</strong></li>
<li><code>Object remove(int index)</code>:移除指定index位置的元素，并返回此元素</li>
<li><code>Object set(int index, Object ele)</code>:设置指定index位置的元素为ele</li>
</ul>
<p>注意：使用<code>.add();</code>方法操作基本数据类型时存在自动装箱，因此欲使用其父接口Collection的remove()方法直接删除元素时需要使用包装类的.valueOf(方法)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">List.add(<span class="number">1</span>);</span><br><span class="line">List.add(<span class="number">3</span>);</span><br><span class="line">List.add(<span class="number">4</span>);</span><br><span class="line">list.remove(Integer.valueOf(<span class="number">3</span>));<span class="comment">//删除的是值为3即索引为2的元素</span></span><br><span class="line">list.remove(<span class="number">3</span>);<span class="comment">//删除的是索引为3的元素即4</span></span><br></pre></td></tr></table></figure>

<p><strong>LinkedList</strong>实现类的特有方法</p>
<ul>
<li>void addFirst(Object obj)</li>
<li>void addLast(Object obj)	</li>
<li>Object getFirst()</li>
<li>Object getLast()</li>
<li>Object removeFirst()</li>
<li>Object removeLast()</li>
</ul>
<h5 id="Set子接口常用方法"><a href="#Set子接口常用方法" class="headerlink" title="Set子接口常用方法"></a>Set子接口常用方法</h5><p>存储无序的不可重复的数据，用于过滤重复数据<br>Set接口是Collection的子接口，Set接口相较于Collection接口<em>没有提供额外的方法</em><br>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。<br>Set集合支持的遍历方式和Collection集合一样：foreach和Iterator。<br>Set的常用实现类有：</p>
<ul>
<li>HashSet<br>遍历时不一定按输入顺序，但也是按固定顺序</li>
<li>LinkedHashSet<br>遍历时按输入顺序</li>
<li>TreeSet</li>
</ul>
<p><strong>Set的无序性</strong><br>不是随机性！也不是指添加顺序和遍历顺序不同。<br>通过哈希算法计算元素的哈希值，根据哈希值计算其在数组中的存储位置，因此元素在存储时不是依次排列的，表现出无序性<br><del>存储时顺序：计算哈希值-&gt;在哈希表中判断是否存在相同哈希值元素-&gt;存在，使用equals对比，不存在直接存入-&gt;相同，不录入</del></p>
<p><strong>Set的不可重复性</strong><br>比较的标准，需要判断hashCode()得到的哈希值以及equals()得到的Boolean型的结果，哈希值相同且equals()返回true则认为元素是相同的，不能添加。</p>
<p><strong>添加元素到HashSet&#x2F;LinkedHashSet的要求</strong><br>因此使用Set添加自定义类对象时**必须重写hashCode()和equals()**方法！！！且两个方法要保持一致性<br>利用idea自动生成，尽可能不要自己重写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(name,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>TreeSet</strong>的使用</p>
<ol>
<li>判断元素是否相等或其大小的标准：和上文HashSet不同，使用的是自然排序和定制排序，根据compareTo()和compare()方法的返回值</li>
<li>添加到TreeSet中的元素<strong>必须是同一类型</strong>的对象，否则出现ClassCastException</li>
<li>因此需要重写compareTo()或compare方法</li>
</ol>
<p>去除List中重复数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>(originList);</span><br><span class="line"><span class="type">List</span> <span class="variable">newList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(set);</span><br></pre></td></tr></table></figure>

<p>面试题-下列操作均可成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line"></span><br><span class="line">set.add(p1);</span><br><span class="line">set.add(p2);</span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">set.remove(p1);<span class="comment">//不可删除，hashCode不一致</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>));<span class="comment">//可以添加，hashCode不一致</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>));<span class="comment">//可以添加，equals不一致</span></span><br><span class="line">System.out.println(set);</span><br><span class="line"><span class="comment">//其中Person类中重写了hashCode()和equal()方法</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Map接口常用方法"><a href="#Map接口常用方法" class="headerlink" title="Map接口常用方法"></a>Map接口常用方法</h4><p>Map 中的 key 和  value 都可以是任何引用类型的数据。但常用String类作为Map的“键”。<br>以HashMap为例：<br><strong>特点</strong></p>
<ol>
<li>Map 中的 <code>key用Set来存放</code>，<code>不允许重复</code>,无序，即同一个 Map 对象所对应的类，**须重写hashCode()和equals()**方法<br>value值可以重复</li>
<li>key 和 value 之间存在单向一对一关系，即通过指定的 key 总能找到唯一的、确定的 value，不同key对应的<code>value可以重复</code>。value所在的类要重写equals()方法。</li>
<li>key和value构成一个entry。所有的entry彼此之间是<code>无序的</code>、<code>不可重复的</code>，构成一个<code>Set</code>。</li>
</ol>
<p>常用方法<br><strong>添加、修改操作：</strong><br>-<code> Object put(Object key,Object value)</code>：将指定key-value添加到(或<code>修改</code>)当前map对象中</p>
<ul>
<li>void putAll(Map m):将m中的所有key-value对存放到当前map中<br><strong>删除操作：</strong></li>
<li><code>Object remove(Object key)</code>：移除指定key的key-value对，并返回value</li>
<li>void clear()：清空当前map中的所有数据<br><strong>元素查询的操作：</strong></li>
<li><code>Object get(Object key)</code>：获取指定key对应的value</li>
<li>Objext getOrDefault(Object key，defaultValue): 获取指定key对应的value，若不存在此key，返回默认值defaultValue</li>
<li><code>boolean containsKey(Object key)</code>：是否包含指定的key</li>
<li><code>boolean containsValue(Object value)</code>：是否包含指定的value</li>
<li><code>int size()</code>：返回map中key-value对的个数</li>
<li>boolean isEmpty()：判断当前map是否为空</li>
<li>boolean equals(Object obj)：判断当前map和参数对象obj是否相等<br><strong>元视图操作的方法：</strong></li>
<li>Set keySet()：返回所有key构成的Set集合</li>
<li>Collection values()：返回所有value构成的Collection集合</li>
<li>Set entrySet()：返回所有key-value对构成的Set集合</li>
</ul>
<p>HashMap概述</p>
<ul>
<li>HashMap是 Map 接口<code>使用频率最高</code>的实现类。</li>
<li>HashMap是线程不安全的。允许添加 null 键和 null 值。</li>
<li>存储数据采用的哈希表结构，底层使用<code>一维数组</code>+<code>单向链表</code>+<code>红黑树</code>进行key-value数据的存储。与HashSet一样，元素的存取顺序不能保证一致。</li>
<li>HashMap <code>判断两个key相等的标准</code>是：两个 key 的hashCode值相等，通过 equals() 方法返回 true。</li>
<li>HashMap <code>判断两个value相等的标准</code>是：两个 value 通过 equals() 方法返回 true。</li>
</ul>
<p>LinkedHashMap 是 HashMap 的子类</p>
<ul>
<li>存储数据采用的哈希表结构+链表结构，在HashMap存储结构的基础上，使用了一对<code>双向链表</code>来<code>记录添加元素的先后顺序</code>，可以保证遍历元素时，与添加的顺序一致。</li>
<li>通过哈希表结构可以保证键的唯一、不重复，需要键所在类重写hashCode()方法、equals()方法。</li>
</ul>
<p>TreeMap</p>
<ul>
<li>TreeMap存储 key-value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 key-value 对处于<code>有序状态</code>。</li>
<li>TreeSet底层使用<code>红黑树</code>结构存储数据</li>
<li>TreeMap 的 Key 的排序：<ul>
<li><code>自然排序</code>：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException</li>
<li><code>定制排序</code>：创建 TreeMap 时，构造器传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口</li>
</ul>
</li>
<li>TreeMap判断<code>两个key相等的标准</code>：两个key通过compareTo()方法或者compare()方法返回0。</li>
</ul>
<p>Hashtable</p>
<ul>
<li>Hashtable是Map接口的<code>古老实现类</code>，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。</li>
<li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构（数组+单向链表），查询速度快。</li>
<li>与HashMap一样，Hashtable 也不能保证其中 Key-Value 对的顺序</li>
<li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li>
<li>与HashMap不同，Hashtable 不允许使用 null 作为 key 或 value。</li>
</ul>
<p>Properties</p>
<ul>
<li>Properties 类是 Hashtable 的子类，该对象用于处理属性文件</li>
<li>由于属性文件里的 key、value 都是字符串类型，所以 Properties 中要求 key 和 value 都是字符串类型</li>
<li>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法</li>
</ul>
<p>面试题：Hashtable和HashMap的区别</p>
<blockquote>
<p>HashMap:底层是一个哈希表（jdk7:数组+链表;jdk8:数组+链表+红黑树）,是一个线程不安全的集合,执行效率高<br>Hashtable:底层也是一个哈希表（数组+链表）,是一个线程安全的集合,执行效率低<br>HashMap集合:可以存储null的键、null的值<br>Hashtable集合,不能存储null的键、null的值<br>Hashtable和Vector集合一样,在jdk1.2版本之后被更先进的集合(HashMap,ArrayList)取代了。所以HashMap是Map的主要实现类，Hashtable是Map的古老实现类。<br>Hashtable的子类Properties（配置文件）依然活跃在历史舞台<br>Properties集合是一个唯一和IO流相结合</p>
</blockquote>
<p>实例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">singers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">singer1</span> <span class="operator">=</span> <span class="string">&quot;周杰伦&quot;</span>;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">songs1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    songs1.add(<span class="string">&quot;晴天&quot;</span>);</span><br><span class="line">    songs1.add(<span class="string">&quot;青花瓷&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">singer2</span> <span class="operator">=</span> <span class="string">&quot;林俊杰&quot;</span>;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">songs2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    songs2.add(<span class="string">&quot;江南&quot;</span>);</span><br><span class="line">    songs2.add(<span class="string">&quot;曹操&quot;</span>);</span><br><span class="line"></span><br><span class="line">    singers.put(singer1, songs1);</span><br><span class="line">    singers.put(singer2, songs2);</span><br><span class="line"></span><br><span class="line">    <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> singers.entrySet();</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) iterator.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;歌手：&quot;</span> + entry.getKey());</span><br><span class="line">        System.out.println(<span class="string">&quot;歌曲：&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="Iterator迭代器遍历元素"><a href="#Iterator迭代器遍历元素" class="headerlink" title="Iterator迭代器遍历元素"></a>Iterator迭代器遍历元素</h4><p>集合遍历的四种方式<br>一般for循环  迭代器  增强for循环  Stream中forEach()</p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    collection.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    collection.add(<span class="number">11</span>);</span><br><span class="line">    collection.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line">    <span class="comment">//如果有下一个</span></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;       </span><br><span class="line">        <span class="comment">//输出下一个 ：指针下移，如有下一个，返回</span></span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240714004243.png" alt="迭代器执行原理"></p>
<p><strong>增强for循环</strong>底层实际上就是调用了迭代器<br>注意：增强for循环执行过程中，将集合或数组中元素依次赋值给临时变量，如果在增强for循环中更改元素，可能无法修改（假如传入的是类，改类中属性可能可以）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合内部元素类型 临时变量 容器名</span></span><br><span class="line"><span class="keyword">for</span>(Object obj : collection)&#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h4><p>一个操作 Set、List 和 Map 等集合的工具类。</p>
<p><strong>排序操作：</strong></p>
<ul>
<li>reverse(List)：反转 List 中元素的顺序</li>
<li>shuffle(List)：对 List 集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序，元素所在类需要重写compareTo方法</li>
<li>sort(List，Comparator)：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li>swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
</ul>
<p><strong>查找</strong></p>
<ul>
<li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素，元素所在类需要重写compareTo方法</li>
<li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li>
<li>Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素，元素所在类需要重写compareTo方法</li>
<li>Object min(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最小元素</li>
<li>int binarySearch(List list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。<em>采用二分法</em></li>
<li>int binarySearch(List list,T key,Comparator c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。</li>
<li>int frequency(Collection c，Object o)：返回指定集合中指定元素的出现次数</li>
</ul>
<p><strong>复制、替换</strong></p>
<ul>
<li>void copy(List dest,List src)：将src中的内容复制到dest中,src的size()必须不大于dest的size();<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">src</span> <span class="operator">=</span> Array.asList(<span class="number">45</span>,<span class="number">22</span>,<span class="number">31</span>,<span class="number">234</span>,<span class="number">43</span>,<span class="number">435</span>,<span class="number">4</span>);</span><br><span class="line"><span class="type">List</span> <span class="variable">dest</span> <span class="operator">=</span> Array.asList(<span class="keyword">new</span> <span class="title class_">Object</span>[src.size()]);</span><br><span class="line">Collections.copy(dest,src);</span><br></pre></td></tr></table></figure></li>
<li>boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</li>
<li>提供了多个unmodifiableXxx()方法，该方法返回指定 Xxx的<em>不可修改</em>的视图。</li>
</ul>
<p><strong>添加</strong></p>
<ul>
<li>boolean addAll(Collection  c,T… elements)将所有指定元素添加到指定 collection 中。</li>
</ul>
<p><strong>同步</strong></p>
<ul>
<li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题：<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240715101443.png"></li>
</ul>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><p>Java 中的 <code>Queue</code> 接口是一个扩展了 <code>Collection</code> 接口的子接口，通常用于代表一个先进先出的（FIFO）数据结构。<code>Queue</code> 接口常被用作队列数据结构的接口定义，像 <code>LinkedList</code> 和 <code>PriorityQueue</code> 等类都实现了该接口。以下是 <code>Queue</code> 接口中常用的几种方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>当队列为空时的行为</th>
<th>当队列已满时的行为</th>
</tr>
</thead>
<tbody><tr>
<td><code>add(E e)</code></td>
<td>将元素插入队列尾部，插入成功返回 <code>true</code></td>
<td>抛出 <code>NoSuchElementException</code></td>
<td>抛出 <code>IllegalStateException</code></td>
</tr>
<tr>
<td><code>offer(E e)</code></td>
<td>将元素插入队列尾部，插入成功返回 <code>true</code>，失败返回 <code>false</code></td>
<td>返回 <code>false</code></td>
<td>返回 <code>false</code></td>
</tr>
<tr>
<td><code>remove()</code></td>
<td>移除并返回队列头部元素</td>
<td>抛出 <code>NoSuchElementException</code></td>
<td>不适用</td>
</tr>
<tr>
<td><code>poll()</code></td>
<td>移除并返回队列头部元素，失败时返回 <code>null</code></td>
<td>返回 <code>null</code></td>
<td>不适用</td>
</tr>
<tr>
<td><code>element()</code></td>
<td>返回队列头部元素，但不移除</td>
<td>抛出 <code>NoSuchElementException</code></td>
<td>不适用</td>
</tr>
<tr>
<td><code>peek()</code></td>
<td>返回队列头部元素，但不移除，失败时返回 <code>null</code></td>
<td>返回 <code>null</code></td>
<td>不适用</td>
</tr>
</tbody></table>
<h5 id="双端队列-Deque"><a href="#双端队列-Deque" class="headerlink" title="双端队列 Deque"></a>双端队列 Deque</h5><p>Deque（双端队列）是一个接口，它继承自Queue接口，并且提供了在队列的两端进行插入和删除操作的方法。Deque的实现类如ArrayDeque和LinkedList（后者也实现了List接口）都是非常常用的。</p>
<p><strong>插入操作</strong></p>
<ul>
<li><code>addFirst(E e)</code>: 在双端队列的开头添加指定的元素。</li>
<li><code>push(E e)</code>:将元素推送到此双端队列表示的堆栈上。 </li>
<li><code>addLast(E e)</code>: 在双端队列的末尾添加指定的元素。这两个方法等价于offerFirst(E e)和offerLast(E e)，但它们在无法添加元素时会抛出异常。</li>
<li>offerFirst(E e): 在双端队列的开头插入指定的元素（如果可能），并返回true（如果队列没有满），或者false（如果队列已满）。</li>
<li>offerLast(E e): 在双端队列的末尾插入指定的元素（如果可能），并返回true（如果队列没有满），或者false（如果队列已满）。</li>
</ul>
<p><strong>删除操作</strong></p>
<ul>
<li><code>removeFirst()</code>: 移除并返回双端队列的开头元素。如果队列为空，则抛出NoSuchElementException。</li>
<li><code>removeLast()</code>: 移除并返回双端队列的末尾元素。如果队列为空，则抛出NoSuchElementException。</li>
<li><code>pollFirst()</code>: 移除并返回双端队列的开头元素，如果队列为空，则返回null。</li>
<li><code>pollLast()</code>: 移除并返回双端队列的末尾元素，如果队列为空，则返回null。</li>
</ul>
<p><strong>访问操作</strong></p>
<ul>
<li><code>getFirst()</code>: 返回双端队列的开头元素但不移除它。如果队列为空，则抛出NoSuchElementException。</li>
<li><code>getLast()</code>: 返回双端队列的末尾元素但不移除它。如果队列为空，则抛出NoSuchElementException。</li>
<li><code>peekFirst()</code>: 返回双端队列的开头元素，如果队列为空，则返回null。</li>
<li><code>peekLast()</code>: 返回双端队列的末尾元素，如果队列为空，则返回null。</li>
<li><code>pop():</code> 从此双端队列表示的堆栈中弹出一个元素。</li>
</ul>
<p><strong>检查操作</strong></p>
<ul>
<li>isEmpty(): 检查双端队列是否为空。如果队列为空，则返回true；否则返回false。</li>
</ul>
<p><strong>其他操作</strong></p>
<ul>
<li><code>size()</code>: 返回双端队列中的元素数量。</li>
<li>descendingIterator(): 返回在此双端队列元素上按逆序进行迭代的Iterator。</li>
<li>iterator(): 返回在此双端队列元素上进行迭代的Iterator。迭代器提供的是弱一致性的视图，这反映了某一时间点或者迭代开始时的集合状态，它们反映的是弱一致性的视图。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>企业真题</p>
<ol>
<li>List，Set，Map是否继承自collection接口？（Map不是。）</li>
<li>说说List,Set,Map三者的区别(集合框架处)</li>
<li>写出list、map、set接口的实现类，并说出其特点（）</li>
<li>常见集合类的区别和适用场景（）</li>
<li>集合的父类是谁？哪些安全的？（不安全：ArrayList、HashMap、HashSet ； 安全：Vector、Hashtable）</li>
<li>集合说一下哪些是线程不安全的（）</li>
<li>遍历集合的方式有哪些？（）<ul>
<li>迭代器Iterator用来遍历Collection，不能用来遍历Map！</li>
<li>增强for</li>
<li>一般的for：可以用来遍历List</li>
</ul>
</li>
<li>List下面有哪些实现（）</li>
<li>ArrayList与LinkedList区别？()</li>
<li>ArrayList与Vector区别呢？为什么要用ArrayList取代Vector呢？(Vector效率低。)</li>
<li>Java.util.ArrayList常用的方法有哪些？（）</li>
<li>Arraylist 是有序还是无序？为什么？（有序；底层使用数组：Object[]）</li>
<li>Set集合有哪些实现类，分别有什么特点？（）</li>
<li>List集合和Set集合的区别？（）</li>
<li>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用&#x3D;&#x3D;还是equals()? 它们有何区别?（）</li>
<li>TreeSet两种排序方式在使用的时候怎么起作用？（在添加新的元素时，需要调用compareTo() 或 compare()）</li>
<li>TreeSet的数据结构（红黑树）</li>
<li>说一下Java的集合Map有哪些Map？（）</li>
<li>final怎么用，修饰Map可以继续添加数据吗？（可以！final HashMap map &#x3D; new HashMap();map.put(“AA”,123);）</li>
<li>Set和Map的比较（）<br>HashSet底层就是HashMap<br>LinkedHashSet底层就是LinkedHashMap<br>TreeSet底层就是TreeMap</li>
<li>HashMap说一下，线程安全吗？（不安全）</li>
<li>HashMap和Hashbable的区别？()</li>
<li>Hashtable是怎么实现的，为什么线程安全？（数组+单向链表；底层方法使用synchronized修饰）</li>
<li>HashMap和LinkedHashMap的区别（）</li>
<li>HashMap 和 TreeMap 的区别（底层的数据结构截然不同）</li>
<li>HashMap里面实际装的是什么？<br>JDK7：HashMap内部声明了Entry，实现了Map中的Entry接口。（key，value作为Entry的两个属性出现）<br>JDK8：HashMap内部声明了Node，实现了Map中的Entry接口。（key，value作为Node的两个属性出现）</li>
<li>HashMap的key存储在哪里？和value存储在一起吗？那么value存储在哪里？说具体点？（数组+链表+红黑树。 key、value作为Node的属性出现）</li>
<li>自定义类型可以作为Key么？（可以！ 要重写hashCode() 和equals()）</li>
<li>集合类的工具类是谁？用过工具类哪些方法？（Collections）</li>
<li>Collection 和 Collections的区别？（）</li>
<li>ArrayList 如何实现排序（Collections.sort(list) 或 Collections.sort(list,comparator)）</li>
<li>HashMap是否线程安全，怎样解决HashMap的线程不安全（）</li>
</ol>
<hr>
<h3 id="第13章-泛型"><a href="#第13章-泛型" class="headerlink" title="第13章_泛型"></a>第13章_泛型</h3><p>我们在声明方法时，当在完成方法功能时如果有<code>未知的数据</code>需要参与，这些未知的数据需要在调用方法时才能确定，那么我们把这样的数据通过<code>形参</code>表示。在方法体中，用这个形参名来代表那个未知的数据，而调用者在调用时，对应的传入<code>实参</code>就可以了泛型即为“<code>类型参数</code>”，这个类型参数在声明它的类、接口或方法中，代表未知的某种通用类型。</p>
<p>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。即，把不安全的因素在编译期间就排除了，而不是运行期；既然通过了编译，那么类型一定是符合要求的，就避免了类型转换。同时，代码更加简洁、健壮。<br><strong>把一个集合中的内容限制为一个特定的数据类型，这就是generic背后的核心思想。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型在List中的使用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//举例：将学生成绩保存在ArrayList中</span></span><br><span class="line">    <span class="comment">//标准写法：</span></span><br><span class="line">    <span class="comment">//ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">    <span class="comment">//jdk7的新特性：类型推断</span></span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//实例化时指明类的泛型参数的类型</span></span><br><span class="line"></span><br><span class="line">    list.add(<span class="number">56</span>); <span class="comment">//自动装箱</span></span><br><span class="line">    list.add(<span class="number">89</span>);</span><br><span class="line">    <span class="comment">//当添加非Integer类型数据时，编译不通过，没有规定泛型时会编译通过，运行时强转报错</span></span><br><span class="line">    <span class="comment">//list.add(&quot;Tom&quot;);//编译报错</span></span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">//不需要强转，直接可以获取添加时的元素的数据类型</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">score</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator1 = entrySet.iterator();</span><br></pre></td></tr></table></figure>

<p><strong>使用说明</strong></p>
<ol>
<li>集合框架在声明接口和其实现类时，使用了泛型，在实例化集合对象时，如果没有使用泛型，则认为操作的是Object类型的数据，如果使用了泛型，则需要指定泛型的具体类型，此后凡是使用类的泛型的位置，都(自动)替换为具体的泛型类型</li>
<li>泛型参数只能被指明为引用数据类型，基本数据类型需要使用包装类替代</li>
<li>如果在创建自定义泛型类的对象时，没有指明泛型参数类型，那么泛型将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。<strong>泛型要使用一路都用。要不用，一路都不要用</strong></li>
<li>除创建泛型类对象外，子类继承泛型类时、实现类实现泛型接口时，也可以确定泛型结构中的泛型参数。</li>
</ol>
<p><strong>注意</strong></p>
<ol>
<li>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</li>
<li>JDK7.0 开始，泛型的简化操作：ArrayList<Fruit> flist &#x3D; new ArrayList&lt;&gt;();</li>
<li>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。（接口和抽象类不能实例化）</li>
<li>不能使用new E[]。但是可以：E[] elements &#x3D; (E[])new Object[capacity];<br>参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</li>
<li>在类&#x2F;接口上声明的泛型，在本类或本接口中即代表某种类型，但不可以在静态方法中使用类的泛型。</li>
<li>异常类不能是带泛型的。</li>
</ol>
<hr>
<h4 id="自定义泛型结构"><a href="#自定义泛型结构" class="headerlink" title="自定义泛型结构"></a>自定义泛型结构</h4><p>自定义类如果没有在声明时声明为泛型类，就不能使用泛型。</p>
<p><strong>自定义泛型类&#x2F;接口</strong></p>
<p>格式：<code>class A&lt;T&gt;&#123;&#125;</code></p>
<ol>
<li>声明类的泛型参数后即可在类内部使用此泛型参数，用以声明属性、方法、构造器等</li>
<li>泛型类在使用时也可以不指明泛型类型，默认为Object(向下兼容)<br>但不等价与指定泛型参数为Object的操作</li>
<li>泛型参数只能被指明为引用数据类型，基本数据类型需要使用包装类替代</li>
<li>泛型类被继承时，如果子类没有<code>&lt;&gt;</code>符，默认指定父类的泛型参数类型为<code>Object</code>;</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Order&lt;Integer&gt; order = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//泛型类在使用时也可以不指明泛型类型，默认为Object(向下兼容)</span></span><br><span class="line">        <span class="comment">//泛型参数只能被指明为引用数据类型，基本数据类型需要使用包装类替代</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(Integer.valueOf(<span class="number">1</span>),<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&lt;T&gt;&#123;</span><br><span class="line">    T t;</span><br><span class="line">    <span class="type">int</span> orderId;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(T t, <span class="type">int</span> orderId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setT</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二者均不是泛型方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderSon</span> <span class="keyword">extends</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">    <span class="comment">//默认指定父类Order的泛型参数类型为Object，此子类不是泛型类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderSon1</span> <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="comment">//指定父类Order的泛型参数类型为Integer，此子类不是泛型类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderSon2</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">//此子类也是泛型类，父类的泛型参数未被指定</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderSon3</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;Integer&gt;&#123;</span><br><span class="line">    <span class="comment">//此子类也是泛型类，指定父类Order的泛型参数类型为Integer,自身还有一个泛型参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderSon4</span>&lt;T,E&gt; <span class="keyword">extends</span> <span class="title class_">Order</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">//此子类也是泛型类，父类的泛型参数未被指定,自身还有一个泛型参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>自定义泛型方法</strong></p>
<p>格式：<code>权限修饰符 &lt;T&gt; 返回值类型 方法名(形参列表)&#123;&#125;</code></p>
<p>说明：</p>
<ul>
<li>方法，也可以被泛型化，与其所在的类是否是泛型类没有关系。</li>
<li>泛型方法中的泛型参数在方法被调用时确定。</li>
<li>泛型方法可以根据需要，声明为static的。</li>
</ul>
<p>示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写一个泛型方法，接收一个任意引用类型的数组，并反转数组中的所有元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">( E[] arr)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>,max = arr.length - <span class="number">1</span>;min &lt; max; min++,max--)&#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">temp</span> <span class="operator">=</span> arr[min];</span><br><span class="line">        arr[min] = arr[max];</span><br><span class="line">        arr[max] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="泛型的继承"><a href="#泛型的继承" class="headerlink" title="泛型的继承"></a>泛型的继承</h4><p>如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的类或接口，<code>G&lt;B&gt;</code>并不是<code>G&lt;A&gt;</code>的子类型！<br>如果superA是A的父类型，superA<code>&lt;G&gt;</code> 与 A<code>&lt;G&gt;</code>有继承或实现的关系，即A<code>&lt;G&gt;</code>的实例可以通过多态赋值给superA<code>&lt;G&gt;</code>的实例<br>比如：String是Object的子类，但是List<code>&lt;String&gt;</code>并不是List<code>&lt;Object&gt;</code>的子类。<br>&#x3D;&#x3D;》否则出现语言逻辑冲突</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;aa&quot;</span>;</span><br><span class="line"></span><br><span class="line">    obj = str;</span><br><span class="line">    <span class="comment">// String是Object的子类，由于多态，此语句无报错</span></span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//以下语句会报错</span></span><br><span class="line">    <span class="comment">//list1 = list2</span></span><br><span class="line"></span><br><span class="line">    Person&lt;String&gt; perS = <span class="literal">null</span>;</span><br><span class="line">    Person&lt;Object&gt; perO = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//以下语句同样报错</span></span><br><span class="line">    <span class="comment">//perO = perS;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    T t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="通配符-的使用"><a href="#通配符-的使用" class="headerlink" title="通配符?的使用"></a>通配符<code>?</code>的使用</h4><p>当我们声明一个变量&#x2F;形参时，这个变量&#x2F;形参的类型是一个泛型类或泛型接口，例如：Comparator<T>类型，但是我们仍然无法确定这个泛型类或泛型接口的类型变量<T>的具体类型，此时我们考虑使用类型通配符 ? 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list2.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    list = list2;</span><br><span class="line">    <span class="comment">//list = list1;//均可正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//String str = list.get(0);</span></span><br><span class="line">    <span class="comment">// 不可编译通过，返回值类型为E,，而我们没有确定泛型指定的数据类型</span></span><br><span class="line">    <span class="comment">// 因此，返回值为默认类型即Object</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//list.add(&quot;BB&quot;);</span></span><br><span class="line">    <span class="comment">//不可编译通过，因为不确定集合的类型（？），但添加null可以通过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mothod</span><span class="params">(List&lt;?&gt; list)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写操作：</strong><br>将任意元素加入到其中不是类型安全的：因为我们不知道元素类型，我们不能向其中添加对象。add方法有类型参数E作为集合的元素类型。我们传给add的任何参数都必须是一个未知类型的子类。因为我们不知道那是什么类型，所以我们无法传任何东西进去。唯一可以插入的元素是null，因为它是所有引用类型的默认值。</p>
<p><strong>读操作：</strong><br>另一方面，读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管 list 的真实类型是什么，它包含的都是Object。</p>
<p><strong>注意</strong></p>
<ol>
<li>编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用?<br><code>public static &lt;?&gt; void test(ArrayList&lt;?&gt; list)&#123;&#125;</code></li>
<li>编译错误：不能用在泛型类的声明上<br><code>class GenericTypeClass&lt;?&gt;&#123;&#125;</code></li>
<li>编译错误：不能用在创建对象上，右边属于创建集合对象<br><code>ArrayList&lt;?&gt; list2 = new ArrayList&lt;?&gt;();</code></li>
</ol>
<p><strong>有限制的通配符</strong></p>
<ul>
<li><code>&lt;?&gt;</code><ul>
<li>允许所有泛型的引用调用</li>
</ul>
</li>
<li>通配符指定上限：<code>&lt;? extends 类/接口 &gt;</code><ul>
<li>使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;&#x3D;</li>
</ul>
</li>
<li>通配符指定下限：<code>&lt;? super 类/接口 &gt;</code><ul>
<li>使用时指定的类型必须是操作的类或接口，或者是操作的类的父类或接口的父接口，即&gt;&#x3D;</li>
</ul>
</li>
</ul>
<p><strong>说明：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;     <span class="comment">//(无穷小 , Number]</span></span><br><span class="line"><span class="comment">// 具体的类型可以是此区间中任意,因此写入不可，因为具体类型可能是写入类型更小的类</span></span><br><span class="line"><span class="comment">// 可读不可写（除null外），读的类型为Number</span></span><br><span class="line"><span class="comment">//只允许泛型为Number及Number子类的引用调用</span></span><br><span class="line">&lt;? <span class="built_in">super</span> Number&gt;      <span class="comment">//[Number , 无穷大)</span></span><br><span class="line"><span class="comment">// 可读亦可写，读的类型为Object，写不可写Object</span></span><br><span class="line"><span class="comment">//只允许泛型为Number及Number父类的引用调用</span></span><br><span class="line">&lt;? <span class="keyword">extends</span> <span class="title class_">Comparable</span>&gt;</span><br><span class="line"><span class="comment">//只允许泛型为实现Comparable接口的实现类的引用调用</span></span><br></pre></td></tr></table></figure>


<hr>
<h3 id="第14章-数据结构与集合源码"><a href="#第14章-数据结构与集合源码" class="headerlink" title="第14章_数据结构与集合源码"></a>第14章_数据结构与集合源码</h3><p>一、数据间逻辑关系<br>数据的逻辑结构指反映数据元素之间的逻辑关系，而与数据的存储无关，是独立于计算机的。</p>
<ul>
<li><strong>集合结构</strong>：数据结构中的元素之间除了“<code>同属一个集合</code>” 的相互关系外，别无其他关系。集合元素之间没有逻辑关系。</li>
<li><strong>线性结构</strong>：数据结构中的元素存在<code>一对一</code>的相互关系。比如：排队。结构中必须存在唯一的首元素和唯一的尾元素。体现为：一维数组、链表、栈、队列</li>
<li><strong>树形结构</strong>：数据结构中的元素存在<code>一对多</code>的相互关系。比如：家谱、文件系统、组织架构</li>
<li><strong>图形结构</strong>：数据结构中的元素存在<code>多对多</code>的相互关系。比如：全国铁路网、地铁图</li>
</ul>
<p>二、数据的存储结构（或物理结构）<br>数据的物理结构&#x2F;存储结构：包括<code>数据元素的表示</code>和<code>关系的表示</code>。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。</p>
<p><strong>结构1：顺序结构</strong></p>
<ul>
<li>顺序结构就是使用一组连续的存储单元依次存储逻辑上相邻的各个元素。</li>
<li>优点： 只需要申请存放数据本身的内存空间即可，支持下标访问，也可以实现随机访问。</li>
<li>缺点： 必须静态分配连续空间，内存空间的利用率比较低。插入或删除可能需要移动大量元素，效率比较低</li>
</ul>
<p><strong>结构2：链式结构</strong></p>
<ul>
<li>不使用连续的存储空间存放结构的元素，而是为每一个元素构造一个节点。节点中除了存放数据本身以外，还需要存放指向下一个节点的指针。</li>
<li>优点：不采用连续的存储空间导致内存空间利用率比较高，克服顺序存储结构中预知元素个数的缺点。插入或删除元素时，不需要移动大量的元素。</li>
<li>缺点：需要额外的空间来表达数据之间的逻辑关系，不支持下标访问和随机访问。</li>
</ul>
<p><strong>结构3：索引结构</strong></p>
<ul>
<li>除建立存储节点信息外，还建立附加的<code>索引表</code>来记录每个元素节点的地址。索引表由若干索引项组成。索引项的一般形式是：（关键字，地址）。</li>
<li>优点：用节点的索引号来确定结点存储地址，检索速度快。</li>
<li>缺点： 增加了附加的索引表，会占用较多的存储空间。在增加和删除数据时要修改索引表，因而会花费较多的时间。</li>
</ul>
<p><strong>结构4：散列结构</strong></p>
<ul>
<li>根据元素的关键字直接计算出该元素的存储地址，又称为Hash存储。</li>
<li>优点：检索、增加和删除结点的操作都很快。</li>
<li>缺点：不支持排序，一般比用线性表存储需要更多的空间，并且记录的关键字不能重复。</li>
</ul>
<p>三、运算结构</p>
<p>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</p>
<ul>
<li>分配资源，建立结构，释放资源</li>
<li>插入和删除</li>
<li>获取和遍历</li>
<li>修改和排序</li>
</ul>
<hr>
<h4 id="List接口分析"><a href="#List接口分析" class="headerlink" title="List接口分析"></a>List接口分析</h4><p><strong>ArrayList</strong></p>
<p>JDK&lt;&#x3D;7和JDK&gt;&#x3D;8对比</p>
<ol>
<li>JDK7: 两个构造器，一个无参构造器默认初始化容量为10的数组，一个有1参构造器默认初始化容量为参数（不能&lt;0）的数组<br>JDK8: 两个构造器，一个无参构造器初始化长度为0数组；在添加(add)第一个元素时重新初始化为容量为10的数组</li>
<li>当添加第11个元素时，需要扩容，默认扩容为原来容量的1.5倍</li>
</ol>
<p><strong>Vector</strong></p>
<ol>
<li>两个构造器，一个无参构造器默认初始化容量为10的数组，一个有1参构造器默认初始化容量为参数（不能&lt;0）的数组。当添加第11个元素时，需要扩容，默认扩容为原来容量的2倍（jdk&#x3D;8(1.8.0_271)）</li>
</ol>
<p><strong>LinkedList</strong></p>
<p>底层为链表，不需要扩容，构造器基本没有工作</p>
<p><strong>开发建议</strong></p>
<ol>
<li>ArrayList底层使用数组结构，查找，尾部添加操作效率高，时间复杂度是O(1); 删除和插入操作效率低，为O(n);<br>LinkedList底层使用双向链表结构，查找，尾部添加操作效率低，时间复杂度是O(n); 删除和插入操作效率高，为O(1);</li>
<li>选择ArrayList时，若已知集合大小，应当有参构造器ArrayList(initialCapacity)</li>
</ol>
<hr>
<h4 id="Map接口分析"><a href="#Map接口分析" class="headerlink" title="Map接口分析"></a>Map接口分析</h4><p><strong>HashMap</strong></p>
<p><strong>JDK7</strong></p>
<ol>
<li>创建对象的过程中，底层会初始化Entry(jdk8是Node)类数组Entry[] table，默认容量为16;<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="type">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>(重点)添加&#x2F;修改过程：<ul>
<li>（过程）将(key1,value1)添加到当前map中，过程如下<ol>
<li>调用key1所在类的hashCode()方法，计算key1对应的哈希值1</li>
<li>此哈希值1经过某种算法(hash())之后，得到哈希值2</li>
<li>哈希值2再经过某种算法(indexFor())之后，确定了(key1,value1)在数组table中的索引位置i</li>
<li>如果数组索引为i的位置上没有元素，则(key1,value1)添加成功  <strong>情况1</strong><br>如果数组索引为i的位置上有元素(key2,value2)，则继续比较key1和key2的哈希值2  —-&gt; 哈希冲突</li>
<li>如果key1的哈希值2和key2的哈希值2不相同，则(key1,value1)添加成功  <strong>情况2</strong><br>如果key1的哈希值2和key2的哈希值2相同，则调用key1的equals()方法，执行key1.equals(key2);</li>
<li>如果方法返回false，则(key1,value1)添加成功  <strong>情况3</strong><br>如果方法返回true，则认为key1和key2相同，<strong>默认使用value1替换value2</strong></li>
</ol>
</li>
<li>（存储）情况2，3下，Java会使(key1,value1)和现有(key2,value2)构成单向链表结构，(key1,value1)指向(key2,value2)（头插法）</li>
<li>（扩容）当元素的个数达到临界值(默认12)(数组长度16*加载因子0.75)且当前添加的元素必须添加到链表而非数组中时（即满足(size &gt;&#x3D; threshold)&amp;&amp;(null !&#x3D; table[i])）时，会扩容，默认扩容为原来的2倍</li>
<li>null默认添加到角标为0的数组位置。</li>
</ul>
</li>
</ol>
<p><strong>jdk7与jdk8对比</strong></p>
<ol>
<li>JDK8中，当我们创建了HashMap实例后，底层不会初始化table数组，当首次添加(key1,value1)时，如果发现table尚未初始化，则进行初始化</li>
<li>JDK8中，HashMap底层定义了Node内部类，替换jdk7中的Entry内部类，因此是Node数组</li>
<li>JDK8中，如果当前的(key,value)可以添加到下标为i的数组位置而此位置已经有元素，则旧的元素指向新的元素（jdk7是新指向旧(尾插法)）</li>
<li>jdk7: 数组+单向链表  jdk8:数组+单向链表+红黑树<ul>
<li>如果数组索引为i的位置上的元素个数达到8个且数组长度大于64，会将此位置上的多个元素改为使用红黑树存储，提高增删查找效率</li>
<li>当使用红黑树的索引为i的位置上的元素个数低于6个时，退化为单向链表，减少存储空间占用<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719001310.png" alt="结构示例"></li>
</ul>
</li>
</ol>
<p><strong>LinkedHashMap</strong></p>
<p>构造器直接调用父类HashMap的构造器，put()方法是父类的方法，但重写了newNode()方法，此为put方法内调用的<br><img src="https://raw.githubusercontent.com/Fushiye/Alldocuments/main/img_blog/20240719002242.png" alt="LinkedHashMap"></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag"><i class="fa fa-tag"></i> Java基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/06/24/Java-Note2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="prev" title="Java-Note2-面向对象">
                  <i class="fa fa-angle-left"></i> Java-Note2-面向对象
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/07/15/Java-Note4-IO%E7%BD%91%E7%BB%9C%E5%8F%8D%E5%B0%84/" rel="next" title="Java-Note4-IO网络反射">
                  Java-Note4-IO网络反射 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  
  <div class="comments giscus-container">
  </div>
  
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Shearington</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">442k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">24:34</span>
  </span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="giscus" type="application/json">{"enable":true,"repo":"Fushiye/Fushiye.github.io","repo_id":"R_kgDOLyiTvA","category":"Announcements","category_id":"DIC_kwDOLyiTvM4CteAo","mapping":"title","strict":0,"reactions_enabled":1,"emit_metadata":0,"theme":"light","lang":"zh-CN","crossorigin":"anonymous","input_position":"top","loading":"lazy"}</script>

<script>
document.addEventListener('page:loaded', () => {
  if (!CONFIG.page.comments) return;

  NexT.utils.loadComments('.giscus-container')
    .then(() => NexT.utils.getScript('https://giscus.app/client.js', {
      attributes: {
        async                   : true,
        crossOrigin             : 'anonymous',
        'data-repo'             : CONFIG.giscus.repo,
        'data-repo-id'          : CONFIG.giscus.repo_id,
        'data-category'         : CONFIG.giscus.category,
        'data-category-id'      : CONFIG.giscus.category_id,
        'data-mapping'          : CONFIG.giscus.mapping,
        'data-strict'           : CONFIG.giscus.strict,
        'data-reactions-enabled': CONFIG.giscus.reactions_enabled,
        'data-emit-metadata'    : CONFIG.giscus.emit_metadata,
        'data-theme'            : CONFIG.giscus.theme,
        'data-lang'             : CONFIG.giscus.lang,
        'data-input-position'   : CONFIG.giscus.input_position,
        'data-loading'          : CONFIG.giscus.loading
      },
      parentNode: document.querySelector('.giscus-container')
    }));
});
</script>

</body>
</html>
